[
    {
        "func": "function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }",
        "@dev": "Returns `true` if `account` has been granted `role`.",
        "@notice": "",
        "@gnotice": "Check if an account has a specific role",
        "@gparam1": "role The bytes32 identifier of the role",
        "@gparam2": "account The address of the account to check",
        "@greturn1": "Whether or not the account has the specified role",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\n        // Check caller is admin\n    \trequire(msg.sender == admin, \"only admin can set close factor\");\n\n        uint oldCloseFactorMantissa = closeFactorMantissa;\n        closeFactorMantissa = newCloseFactorMantissa;\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }",
        "@notice": "",
        "@dev": "set closeFactor",
        "@param1": "newCloseFactorMantissa New close factor, scaled by 1e18",
        "@return1": "uint 0=success, otherwise a failure",
        "@gnotice": "Sets the `closeFactorMantissa` to `newCloseFactorMantissa`",
        "@gparam1": "newCloseFactorMantissa The new close factor mantissa value to set",
        "@greturn1": "An unsigned integer representing the error code associated with the function execution.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function totalSupplyAt(uint256 _specificTransfersAndMintsIndex) public view returns(uint256) {\n        return supply.totalSupplyAt(_specificTransfersAndMintsIndex);\n    }",
        "@notice": "Total amount of tokens at `_specificTransfersAndMintsIndex`.",
        "@param1": "_specificTransfersAndMintsIndex The totalSupply at index",
        "@return1": "The total amount of tokens at `_specificTransfersAndMintsIndex`",
        "@gnotice": "Returns the total supply of tokens at a specific index of transfers and mints",
        "@gparam1": "_specificTransfersAndMintsIndex The specific index of transfers and mints to check the total supply at",
        "@greturn1": "The total supply of tokens at the specified index of transfers and mints",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function burnTokens(uint256 _amount) external onlyDisputeManager {\n        if (_amount > 0) {\n            _updateAvailableBalanceOf(BURN_ACCOUNT, _amount, true);\n            emit JurorTokensBurned(_amount);\n        }\n    }",
        "@notice": "Burn `@tokenAmount(self.token(), _amount)`",
        "@param1": "_amount Amount of tokens to be burned",
        "@gnotice": "Burn `_amount` tokens for dispute resolution purposes",
        "@gparam1": "_amount The number of tokens to burn",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function setAffiliateFeeFrac(address affiliate, uint256 feeFrac)\n        public\n        onlySystemParamsAdmin\n    {\n        require(\n            feeFrac < MAX_AFFILIATE_FEE,\n            \"AFFILIATE_FEE_TOO_HIGH\"\n        );\n\n        affiliateFeeFrac[affiliate] = feeFrac;\n    }",
        "@notice": "Sets the affiliate fee fraction for an address.",
        "@param1": "affiliate The affiliate whose fee fraction should be changed.",
        "@param2": "feeFrac The new fee fraction for this affiliate.",
        "@gnotice": "Set the fee fraction for a specific affiliate address",
        "@gparam1": "affiliate The address of the affiliate account",
        "@gparam2": "feeFrac The new fee fraction for the affiliate",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 1,
        "@tparam2": 0
    },
    {
        "func": "function batch(\n        bytes[] memory batchDataEncoded\n    ) external {\n        unchecked {\n            for (uint256 i; i < batchDataEncoded.length; i++) {\n\n                // Decode this transaction.\n                BatchData memory batchData = abi.decode(batchDataEncoded[i], (BatchData));\n\n                // Determine function and transact.\n                if (batchData.category == 0) {\n                    // Transfer the CryptoBlob if the sender has access to it.\n                    transferFrom(batchData.account1, batchData.account2, batchData.tokenId);\n                } else if (batchData.category == 1) {\n                    // Approve or revoke an account operator.\n                    setApprovalForAll(batchData.account1, batchData.approved);\n                } else if (batchData.category == 2) {\n                    // Approve or revoke a token operator.\n                    approve(batchData.account1, batchData.tokenId);\n                } else if (batchData.category == 3) {\n                    // Cancel a trade or lock/unlock trades for an account you have access to.\n                    manageTrades(batchData.account1, batchData.hash);\n                } else if (batchData.category == 4) {\n                    // Optimize CryptoBlobs.\n                    optimize(batchData.tokenIds);\n                } else if (batchData.category == 5) {\n                    // Sacrifice CryptoBlobs.\n                    sacrifice(batchData.tokenId, batchData.tokenIds);\n                }\n            }\n        }\n    }",
        "@notice": "make multiple transactions in a single transaction",
        "@dev": "Categories: 0 {transferFrom}, 1 {setApprovalForAll}, 2 {approve}, 3 {manageTrades}, 4 {optimize}, 5 {sacrifice}. * Each transaction is separately encoded and processed in the order of the array.",
        "@param1": "batchDataEncoded The encoded batch data.",
        "@gnotice": "Executes a batch of transactions encoded in `batchDataEncoded`",
        "@gparam1": "batchDataEncoded An array of encoded transactions",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }",
        "@notice": "",
        "@dev": "Gets the balance of the specified address.",
        "@param1": "_owner The address to query the the balance of.",
        "@return1": "the amount owned by the passed address.",
        "@gnotice": "Get the token balance of `_owner`",
        "@gparam1": "_owner The address of the account to check",
        "@greturn1": "The balance of tokens held by `_owner`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function canPerform(address _sender, bytes32 _role, uint256[] _params) public view returns (bool) {\n        if (!hasInitialized()) {\n            return false;\n        }\n\n        IKernel linkedKernel = kernel();\n        if (address(linkedKernel) == address(0)) {\n            return false;\n        }\n\n        return linkedKernel.hasPermission(\n            _sender,\n            address(this),\n            _role,\n            ConversionHelpers.dangerouslyCastUintArrayToBytes(_params)\n        );\n    }",
        "@dev": "Check whether an action can be performed by a sender for a particular role on this app",
        "@param1": "_sender Sender of the call",
        "@param2": "_role Role on this app",
        "@param3": "_params Permission params for the role",
        "@return1": "Boolean indicating whether the sender has the permissions to perform the action. * Always returns false if the app hasn't been initialized yet.",
        "@notice": "",
        "@gnotice": "Checks if `_sender` has permission for `_role` with given `_params`",
        "@gparam1": "_sender The address of the account to check permissions for",
        "@gparam2": "_role The role to check for",
        "@gparam3": "_params An array of parameters required to execute the role",
        "@greturn1": "Whether or not `_sender` has permission for the given `_role` and `_params`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1,
        "@tparam2": 0,
        "@tparam3": 0,
        "@treturn1": 0,
        "@gtparam3": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function abort() onlyHouse public {\n        require(stage == Stages.InitialOffer);\n\n        stage = Stages.Aborted;\n        abortTime = now;\n    }",
        "@dev": "Allows House to terminate ICO as an emergency measure",
        "@notice": "",
        "@gnotice": "Aborts the contract at the InitialOffer stage, setting the stage to Aborted",
        "@tnotice": 0,
        "@tdev": 1
    },
    {
        "func": "function registerUser(address contributor, uint c1, uint c2, uint c3, uint c4)\n        public\n        onlyOwner\n    {\n        require(contributor != address(0));\n        // if the user was already registered ensure that the new caps do not contradict their current contributions\n        if(hasPreviouslyRegistered(contributor)){\n            require(validateUpdatedRegistration(contributor, c1, c2, c3, c4));\n        }\n        require(c1.add(c2).add(c3).add(c4) >= minContribution);\n        registry[contributor] = true;\n        cap1[contributor] = c1;\n        cap2[contributor] = c2;\n        cap3[contributor] = c3;\n        cap4[contributor] = c4;\n        RegistrationStatusChanged(contributor, true, c1, c2, c3, c4);\n    }",
        "@dev": "Sets registration status of an address for participation.",
        "@param1": "contributor Address that will be registered/deregistered.",
        "@param2": "c1 The maximum amount of wei that the user can contribute in tier 1.",
        "@param3": "c2 The maximum amount of wei that the user can contribute in tier 2.",
        "@param4": "c3 The maximum amount of wei that the user can contribute in tier 3.",
        "@param5": "c4 The maximum amount of wei that the user can contribute in tier 4.",
        "@notice": "",
        "@gnotice": "Register a user in the system with given contribution caps",
        "@gparam1": "contributor The address of the user being registered",
        "@gparam2": "c1 The cap for contribution type 1 for the registered user",
        "@gparam3": "c2 The cap for contribution type 2 for the registered user",
        "@gparam4": "c3 The cap for contribution type 3 for the registered user",
        "@gparam5": "c4 The cap for contribution type 4 for the registered user",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0,
        "@tparam5": 0,
        "@gtparam3": 0,
        "@gtparam4": 0,
        "@gtparam5": 0
    },
    {
        "func": "function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }",
        "@notice": "",
        "@dev": "transfer control of the contract to a newOwner.",
        "@param1": "_newOwner The address to transfer ownership to.",
        "@gnotice": "Transfers ownership of the contract to a new account (`_newOwner`)",
        "@gparam1": "_newOwner The address of the new owner",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function queryExit(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external override returns (uint256 bptIn, uint256[] memory amountsOut) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onExitPool,\n            _downscaleDownArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptIn, amountsOut);\n    }",
        "@notice": "\"Dry run\" `onExitPool`.",
        "@dev": "Returns the amount of BPT that would be burned from `sender` if the `onExitPool` hook were called by the * Vault with the same arguments, along with the number of tokens `recipient` would receive. * * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault * data, such as the protocol swap fee percentage and Pool balances. * * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must * explicitly use eth_call instead of eth_sendTransaction.",
        "@gnotice": "Queries the amount of output tokens `amountsOut` that a user would receive and the corresponding amount of pool tokens `bptIn` required to exit the pool with given `poolId`, `sender`, `recipient` and `balances`, taking into account fees and other parameters",
        "@gparam1": "poolId The ID of the pool",
        "@gparam2": "sender The address of the user exiting the pool",
        "@gparam3": "recipient The address that will receive the output tokens",
        "@gparam4": "balances An array of token balances in the pool ordered according to the token address",
        "@gparam5": "lastChangeBlock The last block number that modified the pool state",
        "@gparam6": "protocolSwapFeePercentage The protocol swap fee percentage applied to the swap",
        "@gparam7": "userData User-specified data",
        "@greturn1": "bptIn The number of pool tokens required to exit the pool",
        "@greturn2": "amountsOut An array of output token amounts",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0,
        "@tparam5": 0,
        "@tparam6": 0,
        "@tparam7": 0,
        "@treturn1": 0,
        "@treturn2": 0,
        "@gtparam3": 0,
        "@gtparam4": 0,
        "@gtparam5": 0,
        "@gtparam6": 0,
        "@gtparam7": 0,
        "@gtreturn1": 0,
        "@gtreturn2": 0
    },
    {
        "func": "function severelyUndercollateralizedThresholdPercent() external view returns (uint16) {\n        return self.severelyUndercollateralizedThresholdPercent;\n    }",
        "@notice": "Get the severe undercollateralization level for this Deposit.",
        "@dev": "This collateralization level is critical. If the collateralization /// level falls below this percentage the Deposit can get liquidated. /// This value represents the percentage of the backing BTC value the /// signers must hold as bond in order to not be severely /// undercollateralized. It is set at creation time. Note that the /// value for new deposits in TBTCSystem can be changed by governance, /// but the value for a particular deposit is static once the deposit /// is created.",
        "@return1": "The severely undercollateralized level for this deposit.",
        "@gnotice": "Get the percentage threshold for when an account is considered severely undercollateralized",
        "@greturn1": "The percentage threshold for severe under-collateralization",
        "@tnotice": 0,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function peakReferralRedeemCommissionForCycle(uint256 _cycle) public {\n        (bool success, ) = peakdefiLogic3.delegatecall(\n            abi.encodeWithSelector(\n                this.peakReferralRedeemCommissionForCycle.selector,\n                _cycle\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "@notice": "Redeems commission for a particular cycle.",
        "@param1": "_cycle the cycle for which the commission will be redeemed. * Commissions for a cycle will be redeemed during the Intermission phase of the next cycle, so _cycle must < cycleNumber.",
        "@gnotice": "Retrieve the total referral commission earned during a specific `_cycle` and redeem it for the calling account",
        "@gparam1": "_cycle The cycle for which the referral commission is being redeemed",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function requestCreateOrderTKNETH(\n        address _tokenPriceAddress,\n        uint256[] calldata _metadata\n    )\n    external\n    payable\n    override\n    nonReentrant\n    {\n        requestCreateOrderTKNETHInternal(_tokenPriceAddress, _metadata);\n    }",
        "@notice": "Issuer/Seller offers promise as supply token and needs to escrow the deposit. A supply token is * also known as a voucher set. Price is specified in tokens and the deposits are specified in ETH. * Since the price, which is specified in tokens, is not collected when a voucher set is created, there is no need to call * permit or transferFrom on the token at this time. The address of the price token is only recorded.",
        "@param1": "_tokenPriceAddress address of the token to be used for the deposits",
        "@param2": "_metadata metadata which is required for creation of a voucher set * Metadata array is used for consistency across the permutations of similar functions. * Some functions require other parameters, and the number of parameters causes stack too deep error. * The use of the matadata array mitigates the stack too deep error. * * uint256 _validFrom = _metadata[0]; * uint256 _validTo = _metadata[1]; * uint256 _price = _metadata[2]; * uint256 _depositSe = _metadata[3]; * uint256 _depositBu = _metadata[4]; * uint256 _quantity = _metadata[5];",
        "@gnotice": "Requests creation of a new order for TKN-ETH trading pair",
        "@gparam1": "_tokenPriceAddress The address of the PriceAggregator contract for TKN-ETH trading pair",
        "@gparam2": "_metadata An array of metadata related to the order",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 1
    },
    {
        "func": "function transferAdmin(address newAdmin) external virtual onlyOwner {\n        require(newAdmin != address(0), \"Accessible: zero address\");\n        require(msg.sender != newAdmin, \"Accessible: same admin\");\n\n        grantRole(PROJECT_ADMIN_ROLE, newAdmin);\n        renounceRole(PROJECT_ADMIN_ROLE, msg.sender);\n    }",
        "@notice": "",
        "@dev": "transfer admin",
        "@param1": "newAdmin new admin address",
        "@gnotice": "Transfer the project ownership to `newAdmin`",
        "@gparam1": "newAdmin The address of the new project owner. Must not be the zero address and not the current owner of the project.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function revertMonitor() public onlyOwner {\n        require(lastMonitor != address(0));\n\n        monitor = lastMonitor;\n\n        emit MonitorChangeReverted(monitor);\n    }",
        "@notice": "Its possible to revert monitor to last used monitor",
        "@gnotice": "Revert the last monitor change and reset the `monitor` address to the previous value",
        "@tnotice": 0,
        "@tdev": 0
    },
    {
        "func": "function execute(\n    uint positionId,\n    address spell,\n    bytes memory data\n  ) external payable lock returns (uint) {\n    if (positionId == 0) {\n      positionId = nextPositionId++;\n      positions[positionId].owner = msg.sender;\n    } else {\n      require(positionId < nextPositionId, 'position id not exists');\n      require(msg.sender == positions[positionId].owner, 'not position owner');\n    }\n    POSITION_ID = positionId;\n    SPELL = spell;\n    HomoraCaster(caster).cast{value: msg.value}(spell, data);\n    uint collateralValue = getCollateralETHValue(positionId);\n    uint borrowValue = getBorrowETHValue(positionId);\n    require(collateralValue >= borrowValue, 'insufficient collateral');\n    POSITION_ID = _NO_ID;\n    SPELL = _NO_ADDRESS;\n    return positionId;\n  }",
        "@dev": "Execute the action via HomoraCaster, calling its function with the supplied data.",
        "@param1": "positionId The position ID to execute the action, or zero for new position.",
        "@param2": "spell The target spell to invoke the execution via HomoraCaster.",
        "@param3": "data data to pass to the target for the execution.",
        "@notice": "",
        "@gnotice": "Executes the specified `spell` with `data`. If `positionId` is 0, creates a new position with `msg.sender` as the owner. If `positionId` is nonzero, executes the spell on the position owned by `msg.sender` with that ID.",
        "@gparam1": "positionId The ID of the position to execute the spell on",
        "@gparam2": "spell The address of the spell contract to execute",
        "@gparam3": "data The data to pass to the spell contract",
        "@greturn1": "The ID of the position that was executed on",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 1,
        "@tparam3": 0,
        "@treturn1": 0,
        "@gtparam3": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function mint(\n    address _to,\n    uint256 _amount\n  )\n    public\n    returns (bool)\n  {\n    require(totalSupply_.add(_amount) <= cap);\n\n    return super.mint(_to, _amount);\n  }",
        "@notice": "",
        "@dev": "mint tokens",
        "@param1": "_to The address that will receive the minted tokens.",
        "@param2": "_amount The amount of tokens to mint.",
        "@return1": "A boolean that indicates if the operation was successful.",
        "@gnotice": "Create `_amount` new tokens and assign them to `_to`, but require that the total number of tokens does not exceed the `cap`",
        "@gparam1": "_to The address that will receive the minted tokens",
        "@gparam2": "_amount The amount of tokens to mint",
        "@greturn1": "Whether or not the minting was successful",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function accountDataByCategory(address[] memory accounts, uint256 category)\n        external\n        view\n        returns (uint256[] memory data)\n    {\n        unchecked {\n\n            // The following categories can be queried from logs.\n            // tokensMinted\n            // mintedFree\n            // mintedHourlyDrops\n            // mintedSacrifices\n            // mintedReferrals\n            // mintedGiveaway\n            // mintedBogos\n            // mintedSpecial\n            // referralPurchases\n            // timestampHourlyDropLastClaimed\n            // timestampReferralLinkUsed\n\n            // Use {accountData} for claimable specifics.\n            // claimableHourlyDrops\n            // claimableSacrifices\n            // claimableReferrals\n            // claimableGiveaway\n\n            uint256 accountsAmount = accounts.length;\n            if (category == 0) {\n                // Owned, burned, optimized, purchased.\n                // Data for the leaderboards.\n                uint256 amount = 4;\n                data = new uint256[](accountsAmount * amount);\n                for (uint256 i; i < accountsAmount; i++) {\n                    data[i * amount] = balanceOf(accounts[i]);\n                    data[i * amount + 1] = _account[accounts[i]].tokensBurned;\n                    data[i * amount + 2] = _account[accounts[i]].tokensOptimized;\n                    data[i * amount + 3] = _account[accounts[i]].mintedPurchase;\n                }\n            } else if (category == 1) {\n                // Owned, burned, optimized.\n                // Alternative for category 0 because purchases can be retrieved from past logs.\n                uint256 amount = 3;\n                data = new uint256[](accountsAmount * amount);\n                for (uint256 i; i < accountsAmount; i++) {\n                    data[i * amount] = balanceOf(accounts[i]);\n                    data[i * amount + 1] = _account[accounts[i]].tokensBurned;\n                    data[i * amount + 2] = _account[accounts[i]].tokensOptimized;\n                }\n            } else if (category == 2) {\n                // Total claimable.\n                data = new uint256[](accountsAmount);\n                for (uint256 i; i < accountsAmount; i++) {\n                    (\n                        ,\n                        uint256 claimableHourlyDrops, \n                        uint256 claimableSacrifices, \n                        uint256 claimableReferrals, \n                        uint256 claimableGiveaway\n                    ) = _accountToClaimable(accounts[i]);\n                    data[i] = claimableHourlyDrops + claimableSacrifices + claimableReferrals + claimableGiveaway;\n                }\n            } else if (category == 3) {\n                // Timestamp trades locked.\n                data = new uint256[](accountsAmount);\n                for (uint256 i; i < accountsAmount; i++) {\n                    data[i] = _account[accounts[i]].timestampTradesLocked;\n                }\n            } else {\n                // Wallet balance and is contract.\n                uint256 amount = 2;\n                data = new uint256[](accountsAmount * amount);\n                for (uint256 i; i < accountsAmount; i++) {\n                    data[i * amount] = address(accounts[i]).balance;\n                    if (_isContractPastConstruction(accounts[i])) data[i * amount + 1] = 1;\n                }\n            }\n            return data;\n        }\n    }",
        "@notice": "Account data for multiple accounts by categor",
        "@dev": "See past event logs for more data. Use {addressesToENS} for ENS names. * The zero address cannot have an account and returns from it should be ignored. This is not checked to optimize calls.",
        "@param1": "accounts The addresses of the accounts.",
        "@param2": "category (0: owned, burned, optimized, purchased), (1: owned, burned, optimized), 2 total claimable, 3 trades locked, (4: wallet balance, is contract)",
        "@return1": "data The uint data of all accounts, based on the category.",
        "@gnotice": "Get account data by category for given accounts",
        "@gparam1": "accounts An array of account addresses to get data for",
        "@gparam2": "category The category of data to retrieve (0, 1, 2, 3 or 4)",
        "@greturn1": "An array of uint256 values representing the requested account data by category",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 1,
        "@treturn1": 0
    },
    {
        "func": "function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0), \"SPENDER_INVALID\");\n\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }",
        "@dev": "Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729",
        "@param1": "spender The address which will spend the funds.",
        "@param2": "value The amount of tokens to be spent.",
        "@notice": "",
        "@gnotice": "Approve `spender` to spend `value` tokens on behalf of `msg.sender`",
        "@gparam1": "spender The address of the account authorized to spend the tokens",
        "@gparam2": "value The maximum amount of tokens that can be spent",
        "@greturn1": "Whether or not the approval succeeded",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function sacrifice(\n        uint256 tokenIdUpgrading,\n        uint256[] memory tokenIdsSacrificing\n    ) public {\n        unchecked {\n\n            // Check if sacrificing is paused.\n            if (_sacrificingPaused) revert SACRIFICING_IS_CURRENTLY_DISABLED();\n\n            // Check if upgrading ID exists.\n            _revertIfTokenIsInvalid(tokenIdUpgrading);\n\n            uint16 totalSouls;\n            uint256 amount = tokenIdsSacrificing.length;\n            uint32 safeBlockTimestamp = _safeBlockTimestamp();\n\n            for (uint256 i; i < amount; i++) {\n\n                // Get sacrificing ID.\n                uint256 tokenIdSacrificing = tokenIdsSacrificing[i];\n\n                // Revert if sacrificing ID matches upgrading.\n                if (tokenIdSacrificing == tokenIdUpgrading) revert INVALID_CRYPTOBLOB_ID();\n\n                // Revert if the caller does not have access and get the owner.\n                address owner = _revertIfNoAccess(msg.sender, tokenIdSacrificing);\n\n                // Update owner's stats. Cannot underflow because ownership is checked.\n                _account[owner].tokensOwned--;\n                _account[owner].tokensBurned++;\n\n                // Implicitly clear approvals.\n                delete _token[tokenIdSacrificing].approval;\n\n                // ERC721 standards says to not emit an Approval event when transferring. https://eips.ethereum.org/EIPS/eip-721\n                // \"When a Transfer event emits, this also indicates that the approved address for that NFT (if any) is reset to none.\"\n\n                // Save the token ID burned to.\n                _token[tokenIdSacrificing].burnTo = uint16(tokenIdUpgrading);\n\n                // Update souls to now say how many were transferred. +1 for own soul.\n                _token[tokenIdSacrificing].souls++;\n\n                // Add to total.\n                totalSouls += _token[tokenIdSacrificing].souls; \n\n                // '_token[].account' now stores the address of the last owner.\n                if (_token[tokenIdSacrificing].account != owner) _token[tokenIdSacrificing].account = owner;\n\n                // Save the timestamp when it was burned.\n                _token[tokenIdSacrificing].burnTimestamp = safeBlockTimestamp;\n\n                // Burn event.\n                emit Transfer(              // 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n                    owner,                  // address indexed from\n                    address(0),             // address indexed to\n                    tokenIdSacrificing      // uint256 indexed tokenId\n                );\n\n            }\n            _token[tokenIdUpgrading].souls += totalSouls; // Transfer souls.\n            _tokensBurned += uint32(amount); // Update total burned.\n\n            // A 'Sacrifice' event is not emitted. Refer to 'Transfer' logs instead or data saved to the contract.\n        }\n    }",
        "@notice": "Sacrifice and upgrade CryptoBlobs",
        "@dev": "Sacrificing permanently removes CryptoBlobs from the circulating supply and * rewards a meta-collectible called souls via a soul transferring system. * The more souls a CryptoBlob possess, the higher its rarity, rank, and value. * The earlier your CryptoBlobs harnesses souls, the easier it will be to collect them. * Only 25,000 souls exist, one for each CryptoBlob. Souls cannot be created or destroyed. * You also earn 1 free CryptoBlob for every 10 sacrificed during the limited-time promotion. * You must have access to a CryptoBlob to sacrifice it but not upgrade it.",
        "@param1": "tokenIdUpgrading The CryptoBlob ID that will harness the souls of `tokenIdsSacrificing`.",
        "@param2": "tokenIdsSacrificing The CryptoBlob IDs being sacrificed.",
        "@gnotice": "Allows the caller to burn a list of token IDs as a sacrifice to upgrade another token ID.",
        "@gparam1": "tokenIdUpgrading The ID of the token to be upgraded by burning other tokens",
        "@gparam2": "tokenIdsSacrificing The list of token IDs to be burnt as a sacrifice",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 1,
        "@tparam2": 0
    },
    {
        "func": "function currentState() external view returns (uint256) {\n        return uint256(self.currentState);\n    }",
        "@notice": "Get the integer representing the current state.",
        "@dev": "We implement this because contracts don't handle foreign enums /// well. See `DepositStates` for more info on states.",
        "@return1": "The 0-indexed state from the DepositStates enum.",
        "@gnotice": "Get the current state of the contract",
        "@greturn1": "The current state of the contract as a `uint256` value",
        "@tnotice": 0,
        "@tdev": 0,
        "@treturn1": 1,
        "@gtreturn1": 0
    },
    {
        "func": "function revertMonitor() public onlyAllowed {\n        require(lastMonitor != address(0));\n\n        monitor = lastMonitor;\n\n        emit MonitorChangeReverted(monitor);\n    }",
        "@notice": "Its possible to revert monitor to last used monitor",
        "@gnotice": "Reverts to the last saved monitor address",
        "@tnotice": 0,
        "@tdev": 0
    },
    {
        "func": "function transferAdmin(address newAdmin) external virtual onlyOwner {\n        require(newAdmin != address(0), \"Accessible: zero address\");\n        require(msg.sender != newAdmin, \"Accessible: same admin\");\n\n        grantRole(ADMIN_ROLE, newAdmin);\n        renounceRole(ADMIN_ROLE, msg.sender);\n    }",
        "@notice": "",
        "@dev": "transfer admin",
        "@param1": "newAdmin new admin address",
        "@gnotice": "Transfers the ownership of the contract administrator",
        "@gparam1": "newAdmin The address of the new administrator to be assigned",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function _setPendingAdmin(address payable newPendingAdmin) external override returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }",
        "@notice": "begin change of admin.",
        "@dev": "The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.",
        "@param1": "newPendingAdmin New pending admin.",
        "@return1": "uint 0=success, otherwise a failure",
        "@gnotice": "Sets a new address as the pending admin",
        "@gparam1": "newPendingAdmin The address of the new pending admin",
        "@greturn1": "An error code (0 if successful)",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function isTokenExemptFromYieldProtocolFee(IERC20 token) external view returns (bool) {\n        return _isTokenExemptFromYieldProtocolFee(_getTokenIndex(token));\n    }",
        "@dev": "Returns whether the token is exempt from protocol fees on the yield. * If the BPT token is passed in (which doesn't make much sense, but shouldn't fail, * since it is a valid pool token), the corresponding flag will be false.",
        "@notice": "",
        "@gnotice": "Check if `token` is exempt from yield protocol fee",
        "@gparam1": "token The token to check",
        "@greturn1": "Returns true if the token is exempt, otherwise returns false",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }",
        "@dev": "Destroys `amount` tokens from the caller. * * See {ERC20-_burn}.",
        "@notice": "",
        "@gnotice": "Burn `amount` tokens from the caller's balance",
        "@gparam1": "amount The number of tokens to burn",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function withdrawEth() public onlyOwner {\n        uint balance = address(this).balance;\n        msg.sender.transfer(balance);\n    }",
        "@notice": "In case something is left in contract, owner is able to withdraw it",
        "@gnotice": "Withdraws the ETH balance held in the contract to the `msg.sender`",
        "@tnotice": 1,
        "@tdev": 0
    },
    {
        "func": "function deployStableSwapPool(\n        address _curveFactory,\n        address _crvBasePool,\n        address _crv3PoolTokenAddress,\n        uint256 _amplificationCoefficient,\n        uint256 _fee\n    ) external onlyAdmin {\n        // Create new StableSwap meta pool (uAD <-> 3Crv)\n        address metaPool =\n            ICurveFactory(_curveFactory).deploy_metapool(\n                _crvBasePool,\n                ERC20(dollarTokenAddress).name(),\n                ERC20(dollarTokenAddress).symbol(),\n                dollarTokenAddress,\n                _amplificationCoefficient,\n                _fee\n            );\n        stableSwapMetaPoolAddress = metaPool;\n\n        // Approve the newly-deployed meta pool to transfer this contract's funds\n        uint256 crv3PoolTokenAmount =\n            IERC20(_crv3PoolTokenAddress).balanceOf(address(this));\n        uint256 uADTokenAmount =\n            IERC20(dollarTokenAddress).balanceOf(address(this));\n\n        // safe approve revert if approve from non-zero to non-zero allowance\n        IERC20(_crv3PoolTokenAddress).safeApprove(metaPool, 0);\n        IERC20(_crv3PoolTokenAddress).safeApprove(\n            metaPool,\n            crv3PoolTokenAmount\n        );\n\n        IERC20(dollarTokenAddress).safeApprove(metaPool, 0);\n        IERC20(dollarTokenAddress).safeApprove(metaPool, uADTokenAmount);\n\n        // coin at index 0 is uAD and index 1 is 3CRV\n        require(\n            IMetaPool(metaPool).coins(0) == dollarTokenAddress &&\n                IMetaPool(metaPool).coins(1) == _crv3PoolTokenAddress,\n            \"uADMGR: COIN_ORDER_MISMATCH\"\n        );\n        // Add the initial liquidity to the StableSwap meta pool\n        uint256[2] memory amounts =\n            [\n                IERC20(dollarTokenAddress).balanceOf(address(this)),\n                IERC20(_crv3PoolTokenAddress).balanceOf(address(this))\n            ];\n\n        // set curve 3Pool address\n        curve3PoolTokenAddress = _crv3PoolTokenAddress;\n        IMetaPool(metaPool).add_liquidity(amounts, 0, msg.sender);\n    }",
        "@notice": "deploy a new Curve metapools for uAD Token uAD/3Pool",
        "@dev": "From the curve documentation for uncollateralized algorithmic stablecoins amplification should be 5-10",
        "@param1": "_curveFactory MetaPool factory address",
        "@param2": "_crvBasePool Address of the base pool",
        "@param3": "_crv3PoolTokenAddress curve 3Pool token Address",
        "@param4": "_amplificationCoefficient amplification coefficient. The smaller it is the closer to a constant product we are.",
        "@param5": "_fee Trade fee",
        "@gnotice": "Deploys a new StableSwap meta pool for exchanging between uAD and 3CRV tokens and adds initial liquidity to it",
        "@gparam1": "_curveFactory The address of the Curve Factory contract",
        "@gparam2": "_crvBasePool The address of the base pool contract",
        "@gparam3": "_crv3PoolTokenAddress The address of the 3CRV token contract",
        "@gparam4": "_amplificationCoefficient The amplification coefficient to use for the new StableSwap pool",
        "@gparam5": "_fee The fee to be charged for exchanges on the new StableSwap pool",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0,
        "@tparam5": 0
    },
    {
        "func": "function extendInsuranceMining(uint256 _insuranceMiningExtension)\n        external\n        onlyAdmin\n        insuranceMiningOngoing\n        isNotPaused\n    {\n        LibDiamondStorageInsuranceFund.DiamondStorageInsuranceFund storage dsInsuranceFund =\n            LibDiamondStorageInsuranceFund.diamondStorageInsuranceFund();\n\n        require(_insuranceMiningExtension != 0, \"IFund: invalid extension.\");\n        // Extend the mining final block number\n        dsInsuranceFund.miningFinalBlockNumber = dsInsuranceFund.miningFinalBlockNumber.add(_insuranceMiningExtension);\n\n        emit InsuranceMiningExtended(dsInsuranceFund.miningFinalBlockNumber);\n    }",
        "@notice": "This function extends insurance mining.",
        "@param1": "_insuranceMiningExtension Insurance mining extension * (blocks).",
        "@gnotice": "Extend the insurance mining duration by `_insuranceMiningExtension` number of blocks",
        "@gparam1": "_insuranceMiningExtension The number of blocks to extend the mining duration by. Cannot be zero.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function blockchainExchange(\n    uint256 _amount, \n    uint256 _network, \n    bytes32 _adr\n  ) public \n  {\n    burn(_amount);\n    cap.sub(_amount);\n    emit BlockchainExchange(\n      msg.sender, \n      _amount, \n      _network, \n      _adr\n    );\n  }",
        "@notice": "",
        "@dev": "burn tokens and rise event for burn tokens in another network",
        "@param1": "_amount The amount of tokens that will burn",
        "@param2": "_network The index of target network.",
        "@param3": "_adr The address in new network",
        "@gnotice": "Exchange tokens for another blockchain asset",
        "@gparam1": "_amount The amount of tokens to exchange",
        "@gparam2": "_network The blockchain network for the asset to receive",
        "@gparam3": "_adr The address of the asset to receive",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0
    },
    {
        "func": "function buy(address _srcAddr, address _destAddr, uint _destAmount) external override payable returns(uint) {\n        address uniswapExchangeAddr;\n        uint srcAmount;\n\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n         // if we are buying ether\n        if (_destAddr == WETH_ADDRESS) {\n            uniswapExchangeAddr = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\n\n            ERC20(_srcAddr).safeApprove(uniswapExchangeAddr, uint(-1));\n\n            srcAmount = UniswapExchangeInterface(uniswapExchangeAddr).\n                tokenToEthTransferOutput(_destAmount, uint(-1), block.timestamp + 1, msg.sender);\n        }\n        // if we are buying token to token\n        else {\n            uniswapExchangeAddr = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\n\n            ERC20(_srcAddr).safeApprove(uniswapExchangeAddr, uint(-1));\n\n            srcAmount = UniswapExchangeInterface(uniswapExchangeAddr).\n                tokenToTokenTransferOutput(_destAmount, uint(-1), uint(-1), block.timestamp + 1, msg.sender, _destAddr);\n        }\n\n        // Send the leftover from the source token back\n        sendLeftOver(_srcAddr);\n\n        return srcAmount;\n    }",
        "@notice": "Buys a _destAmount of tokens at Uniswap",
        "@param1": "_srcAddr From token",
        "@param2": "_destAddr To token",
        "@param3": "_destAmount To amount",
        "@return1": "uint srcAmount",
        "@gnotice": "Buy `_destAmount` of `_destAddr` by sending ether or token from `_srcAddr` to this contract",
        "@gparam1": "_srcAddr The address of the token or ether being sold",
        "@gparam2": "_destAddr The address of the token being bought",
        "@gparam3": "_destAmount The amount of tokens to buy",
        "@greturn1": "The amount of tokens bought after conversion",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@treturn1": 1,
        "@gtparam3": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function balanceOfUnderlying(address owner) external override returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n        return balance;\n    }",
        "@notice": "Get the underlying balance of the `owner`",
        "@dev": "This also accrues interest in a transaction",
        "@param1": "owner The address of the account to query",
        "@return1": "The amount of underlying owned by `owner`",
        "@gnotice": "Get the current balance of `owner` in underlying tokens",
        "@gparam1": "owner The address of the account to query",
        "@greturn1": "The number of underlying tokens owned by `owner`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function requestCreateOrderTKNETHConditional(\n        address _tokenPriceAddress,\n        uint256[] calldata _metadata,\n        ConditionalCommitInfo calldata _conditionalCommitInfo\n    )\n    external\n    payable\n    override\n    nonReentrant\n    onlyApprovedGate(_conditionalCommitInfo.gateAddress)\n    {\n        uint256 tokenIdSupply = requestCreateOrderTKNETHInternal(_tokenPriceAddress, _metadata);\n        finalizeConditionalOrder(tokenIdSupply, _conditionalCommitInfo);\n    }",
        "@notice": "Issuer/Seller offers promise as supply token and needs to escrow the deposit.",
        "@param1": "_tokenPriceAddress address of the token to be used for the deposits",
        "@param2": "_metadata metadata which is required for creation of a voucher set",
        "@param3": "_conditionalCommitInfo struct that contains data pertaining to conditional commit",
        "@gnotice": "Requests the creation of a new token-ETH order with a conditional commitment",
        "@gparam1": "_tokenPriceAddress The address of the ERC20 token used for the order price",
        "@gparam2": "_metadata Array of metadata related to the order",
        "@gparam3": "_conditionalCommitInfo Struct containing information about the conditional commitment",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 1,
        "@tparam3": 0,
        "@gtparam3": 0
    },
    {
        "func": "function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        unchecked {\n            if (_getTokenIndex(tokenId) >= _tokensMinted()) revert INVALID_CRYPTOBLOB_ID();\n\n            uint256 souls;\n            if (!_isTokenSacrificed(tokenId)) souls = _token[tokenId].souls + 1; // Get souls harnessed and +1 for self.\n            if (souls > _URIMaxSoulsLimit) souls = _URIMaxSoulsLimit; // Limit souls.\n\n            if (bytes(_tokenURIPrefix).length > 0) {\n                // Single URI with an extension.\n                return string(abi.encodePacked(_tokenURIPrefix, _toPaddedString(souls), \"/\", _toPaddedString(tokenId)));\n            } else if (bytes(_tokenURIPrefixes[souls]).length > 0) {\n                // Multi URI with no extension.\n                return string(abi.encodePacked(_tokenURIPrefixes[souls], _toPaddedString(tokenId)));\n            } else {\n                // If no token URI.\n                return \"\";\n            }\n        }\n    }",
        "@notice": "",
        "@dev": "Unminted CryptoBlobs revert with an error. * Sacrificed CryptoBlobs still have metadata.",
        "@param1": "tokenId The token ID of the CryptoBlob.",
        "@return1": "The token URI of `tokenId`.",
        "@gnotice": "Get the URI for a specific token ID",
        "@gparam1": "tokenId The ID of the token to get the URI for",
        "@greturn1": "The URI associated with the given token ID",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        // The interface IDs are constants representing the first 4 bytes\n        // of the XOR of all function selectors in the interface.\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\n    }",
        "@dev": "Returns true if this contract implements the interface defined by * `interfaceId`. See the corresponding * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified) * to learn more about how these ids are created. * * This function call must use less than 30000 gas.",
        "@notice": "",
        "@gnotice": "Checks whether a contract implements a given interface ID.",
        "@gparam1": "interfaceId The interface ID to check for implementation",
        "@greturn1": "`true` if the contract implements `interfaceId`, `false` otherwise",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function manageTrades(\n        address account,\n        bytes32 hash\n    ) public {\n        unchecked {\n            // Check if the caller has access.\n            if (msg.sender != account && !isApprovedForAll(account, msg.sender)) revert RESTRICTED_ACCESS();\n\n            if (hash == 0x0000000000000000000000000000000000000000000000000000000000000000) { // Unlock trades.\n                delete _account[account].timestampTradesLocked;\n            } else if (hash == 0x0000000000000000000000000000000000000000000000000000000000000001) { // Lock trades.\n                _account[account].timestampTradesLocked = _safeBlockTimestamp();\n            } else if (_account[account].timestampTradeHashUsed[hash] == 0) { // Cancel trade if not cancelled.\n                // The block timestamp is multiplied by 10 to store a binary number. 0 means cancelled. 1 means completed.\n                _account[account].timestampTradeHashUsed[hash] = block.timestamp * 10;\n            } else {\n                revert RESTRICTED_ACCESS();\n            }\n\n            uint256[] memory empty = new uint256[](0); // Empty array.\n\n            // msg.sender is `taker` when isTrade is false, which can be an account operator.\n            emit Trade(             // 0x10d92c47650ef2b2a841f26c951f4391ccbb731e57d36a67665a0d138e08ef09\n                hash,               // address indexed hash\n                account,            // address indexed maker\n                msg.sender,         // address indexed taker\n                empty,              // uint256[] makerIds\n                empty,              // uint256[] takerIds\n                0,                  // uint256 price\n                0,                  // uint256 expiry\n                block.timestamp,    // uint256 timestamp\n                false               // bool isTrade\n            );\n        }\n    }",
        "@notice": "Cancel a trade or lock/unlock your trades",
        "@dev": "This has no effect on third-party NFT marketplaces. * Locking your trades prevents others from completing them. * Trades that auto-expire will continue to countdown when they're locked.",
        "@param1": "account The account to manage the trades of.",
        "@param2": "hash The hash of the trade to cancel. 0 bytes to unlock trades. 1 byte to lock trades.",
        "@gnotice": "Manage trades by locking or unlocking them, cancelling existing trades, or restricting caller access",
        "@gparam1": "account The address of the account to manage trades for",
        "@gparam2": "hash The hash of the trade to manage",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function getPriorVotes(address account, uint blockNumber)\n    external\n    view\n    returns (uint256)\n    {\n        require(blockNumber < block.number, \"getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }",
        "@notice": "",
        "@dev": "Block number must be a finalized block or else this function will revert to prevent misinformation.",
        "@param1": "account The address of the account to check",
        "@param2": "blockNumber The block number to get the vote balance at",
        "@return1": "The number of votes the account had as of the given block",
        "@gnotice": "Get the prior voting power of `account` at `blockNumber`",
        "@gparam1": "account The address of the account to check",
        "@gparam2": "blockNumber The block number to get the voting power at",
        "@greturn1": "The voting number of `account` at `blockNumber`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function emergencyBurn(uint id, uint amount) external nonReentrant returns (uint) {\n    (uint pid, ) = decodeId(id);\n    _burn(msg.sender, id, amount);\n    chef.withdraw(pid, amount);\n    (address lpToken, , , ) = chef.poolInfo(pid);\n    IERC20(lpToken).safeTransfer(msg.sender, amount);\n    return pid;\n  }",
        "@dev": "Burn ERC1155 token to redeem LP ERC20 token back without taking SUSHI rewards.",
        "@return1": "The pool id that that you received LP token back.",
        "@notice": "",
        "@gnotice": "Burn `amount` tokens with ID `id` from `msg.sender`, withdraw corresponding tokens from the Chef contract for the same `id` and transfer them to `msg.sender`",
        "@gparam1": "id The ID of the token to burn and withdraw",
        "@gparam2": "amount The amount of tokens to burn and withdraw",
        "@greturn1": "The pool ID from the Chef contract",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function removeAdmin(address account) public virtual onlyOwner {\n        renounceRole(ADMIN_ROLE, account);\n    }",
        "@notice": "",
        "@dev": "remove admin",
        "@param1": "account address to remove",
        "@gnotice": "Removes the `ADMIN_ROLE` from the specified account",
        "@gparam1": "account The address from which to remove the `ADMIN_ROLE`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function approve(address spender, uint256 amount) external override returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }",
        "@notice": "Approve `spender` to transfer up to `amount` from `src`",
        "@dev": "This will overwrite the approval amount for `spender` * and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)",
        "@param1": "spender The address of the account which may transfer tokens",
        "@param2": "amount The number of tokens that are approved",
        "@return1": "Whether or not the approval succeeded",
        "@gnotice": "Approve the `spender` to transfer up to `amount` tokens from the `msg.sender` account",
        "@gparam1": "spender The address authorized to spend the funds",
        "@gparam2": "amount The maximum amount of tokens the `spender` can transfer",
        "@greturn1": "Whether or not the approval succeeded",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function claimTokens(address payable _token) public onlyOwner {\n    if (_token == address(0)) {\n      address(uint160(owner())).transfer(address(this).balance);\n      return;\n    }\n\n    MiniMeToken token = MiniMeToken(_token);\n    uint balance = token.balanceOf(address(this));\n    require(token.transfer(owner(), balance));\n    emit ClaimedTokens(_token, owner(), balance);\n  }",
        "@notice": "This method can be used by the owner to extract mistakenly /// sent tokens to this contract.",
        "@param1": "_token The address of the token contract that you want to recover /// set to 0 in case you want to extract ether.",
        "@gnotice": "Claim tokens held by this contract and transfer them to the owner",
        "@gparam1": "_token The address of the token to claim. If set to 0, will claim Ether.",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@greturn1": "N/A (function does not return a value)"
    },
    {
        "func": "function withdrawUnsoldTokens(uint256 roundId, address recipient)\n        external\n        onlyOwner\n    {\n        if (roundId > roundsCounter) {\n            revert RoundNotFound(\"TokenSale: Round not found\");\n        }\n        TokenSaleRound storage tokenSaleRound = rounds[roundId];\n        if (tokenSaleRound.endTime > block.timestamp) {\n            revert RoundNotEnd(\"TokenSale: Round not end\");\n        }\n        if (tokenSaleRound.totalPurchaseAmount > tokenSaleRound.tokensSold) {\n            uint256 unsoldTokens = tokenSaleRound.totalPurchaseAmount -\n                tokenSaleRound.tokensSold;\n            tokenSaleRound.tokensSold = tokenSaleRound.totalPurchaseAmount;\n            userBalance[recipient][roundId] += unsoldTokens;\n            emit WithdrawUnsoldTokens(roundId, recipient, unsoldTokens);\n        } else {\n            revert TokensNotEnough(\"TokenSale: Sold out\");\n        }\n\n        tokenSaleRound.isEnded = true;\n    }",
        "@notice": "withdraws tokens that were not sold and writes them to the balance of the specified wallet.",
        "@dev": "Only owner can call it. Only if round is end.",
        "@param1": "roundId tokeSale round id.",
        "@param2": "recipient recipient wallet address",
        "@gnotice": "Withdraws unsold tokens from a specific `roundId` and transfers them to the `recipient` account",
        "@gparam1": "roundId The ID of the sale round to withdraw unsold tokens from",
        "@gparam2": "recipient The address of the account to receive the unsold tokens",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function votingDelay() public pure returns (uint) { return 1; }",
        "@notice": "The delay before voting on a proposal may take place, once proposed // This also helps protect against flash loan attacks because only the vote balance at the proposal start block is considered",
        "@gnotice": "Get the delay period required for a vote to be counted",
        "@greturn1": "The delay period in blocks",
        "@tnotice": 1,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function removeAddressesFromWhitelist(address[] memory addrs)\n        public\n        onlyOwner\n        returns (bool success)\n    {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (removeAddressFromWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }",
        "@notice": "",
        "@dev": "remove addresses from the whitelist",
        "@param1": "addrs addresses",
        "@return1": "success if at least one address was removed from the whitelist, * false if all addresses weren't in the whitelist in the first place",
        "@gnotice": "Removes a list of addresses from the whitelist",
        "@gparam1": "addrs An array of addresses to be removed from the whitelist",
        "@greturn1": "success A boolean indicating whether or not the removal was successful",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function setTreasuryAddress(address _treasuryAddress) external onlyAdmin {\n        treasuryAddress = _treasuryAddress;\n    }",
        "@notice": "set the treasury address",
        "@dev": "the treasury fund is used to maintain the protocol",
        "@param1": "_treasuryAddress treasury fund address",
        "@gnotice": "Sets the treasury address for the contract",
        "@gparam1": "_treasuryAddress The address to set as the new treasury address.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function name() public view returns (string memory) {\n        return _name;\n    }",
        "@dev": "Returns the name of the token.",
        "@notice": "",
        "@gnotice": "Get the name of the token",
        "@greturn1": "The name of the token as a string",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable virtual override {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\n\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\n\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\n\n        // The nested ifs save around 20+ gas over a compound boolean condition.\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\n\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        _beforeTokenTransfers(from, to, tokenId, 1);\n\n        // Clear approvals from the previous owner.\n        assembly {\n            if approvedAddress {\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\n                sstore(approvedAddressSlot, 0)\n            }\n        }\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\n        unchecked {\n            // We can directly increment and decrement the balances.\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\n\n            // Updates:\n            // - `address` to the next owner.\n            // - `startTimestamp` to the timestamp of transfering.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `true`.\n            _packedOwnerships[tokenId] = _packOwnershipData(\n                to,\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\n            );\n\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\n                if (_packedOwnerships[nextTokenId] == 0) {\n                    // If the next slot is within bounds.\n                    if (nextTokenId != _currentIndex) {\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfers(from, to, tokenId, 1);\n    }",
        "@dev": "Transfers `tokenId` from `from` to `to`. * * Requirements: * * - `from` cannot be the zero address. * - `to` cannot be the zero address. * - `tokenId` token must be owned by `from`. * - If the caller is not `from`, it must be approved to move this token * by either {approve} or {setApprovalForAll}. * * Emits a {Transfer} event.",
        "@notice": "",
        "@gnotice": "Transfers `tokenId` token from `from` to `to`, checking first that `msg.sender` is authorized to do so",
        "@gparam1": "from The address of the current owner of the token",
        "@gparam2": "to The address of the new owner of the token",
        "@gparam3": "tokenId The ID of the token to be transferred",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@gtparam3": 0
    },
    {
        "func": "function votingDelay() public pure returns (uint) { return 1; }",
        "@notice": "The delay before voting on a proposal may take place, once proposed // This also helps protect against flash loan attacks because only the vote balance at the proposal start block is considered",
        "@gnotice": "Returns the number of blocks a voter must wait before being able to withdraw a previously delegated vote",
        "@greturn1": "The voting delay in blocks",
        "@tnotice": 1,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function blockchainExchangeFrom(\n    address _from,\n    uint256 _amount, \n    uint256 _network, \n    bytes32 _adr\n  ) public \n  {\n    require(_amount <= allowed[_from][msg.sender], \"Used didn't allow sender to interact with balance\");\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n    _burn(_from, _amount);\n    emit BlockchainExchange(\n      msg.sender, \n      _amount, \n      _network,\n      _adr\n    );\n  }",
        "@notice": "",
        "@dev": "burn allowed tokens from special address and rise event for burn tokens in another network",
        "@param1": "_from The address of holder",
        "@param2": "_amount The amount of tokens that will burn",
        "@param3": "_network The index of target network.",
        "@param4": "_adr The address in new network",
        "@gnotice": "Move tokens from the `_from` address to the contract to represent an exchange action on a different blockchain",
        "@gparam1": "_from The address to take the tokens from",
        "@gparam2": "_amount The amount of tokens to exchange",
        "@gparam3": "_network The integer representing a specific blockchain network",
        "@gparam4": "_adr The address on the specific blockchain network",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0
    },
    {
        "func": "function burn(uint id, uint amount) external nonReentrant returns (uint) {\n    if (amount == uint(-1)) {\n      amount = balanceOf(msg.sender, id);\n    }\n    (uint pid, uint stSushiPerShare) = decodeId(id);\n    _burn(msg.sender, id, amount);\n    chef.withdraw(pid, amount);\n    (address lpToken, , , uint enSushiPerShare) = chef.poolInfo(pid);\n    IERC20(lpToken).safeTransfer(msg.sender, amount);\n    uint stSushi = stSushiPerShare.mul(amount).divCeil(1e12);\n    uint enSushi = enSushiPerShare.mul(amount).div(1e12);\n    if (enSushi > stSushi) {\n      sushi.safeTransfer(msg.sender, enSushi.sub(stSushi));\n    }\n    return pid;\n  }",
        "@dev": "Burn ERC1155 token to redeem LP ERC20 token back plus SUSHI rewards.",
        "@return1": "The pool id that that you received LP token back.",
        "@notice": "",
        "@gnotice": "Burn `amount` tokens with ID `id` from the `msg.sender` account and receive underlying LP tokens and/or SUSHI rewards",
        "@gparam1": "id The ID of the tokens to burn",
        "@gparam2": "amount The amount of tokens to burn. If set to -1, all tokens will be burned",
        "@greturn1": "The ID of the pool from which LP tokens were withdrawn",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function updateStartTime(uint256 roundId, uint256 newStartTime)\n        external\n        onlyOwner\n    {\n        if (roundId > roundsCounter) {\n            revert RoundNotFound(\"TokenSale: Round not found\");\n        }\n        TokenSaleRound storage tokenSaleRound = rounds[roundId];\n        if (tokenSaleRound.startTime < block.timestamp) {\n            revert RoundIsStarted(\"TokenSale: Round is started\");\n        }\n\n        tokenSaleRound.startTime = newStartTime;\n        tokenSaleRound.endTime = newStartTime + tokenSaleRound.duration;\n        emit UpdateRoundStartTime(\n            roundId,\n            tokenSaleRound.startTime,\n            tokenSaleRound.endTime\n        );\n    }",
        "@notice": "update token sale round start time.",
        "@dev": "Only owner can call it. Only if round is not started.",
        "@param1": "roundId tokeSale round id.",
        "@param2": "newStartTime new start time timestamp",
        "@gnotice": "Update the start time and end time of a token sale round",
        "@gparam1": "roundId The ID of the token sale round to be updated",
        "@gparam2": "newStartTime The new start time for the token sale round",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function mint(address _to, uint256 _tokenId) external onlyFactory {\n        _mint(_to, _tokenId);\n    }",
        "@dev": "Mints a new token. /// Reverts if the given token ID already exists.",
        "@param1": "_to The address that will own the minted token",
        "@param2": "_tokenId uint256 ID of the token to be minted",
        "@notice": "",
        "@gnotice": "Mint a new token with ID `_tokenId` and assign it to the address `_to`",
        "@gparam1": "_to The address that will be assigned the newly minted token",
        "@gparam2": "_tokenId The ID of the newly minted token",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function claim() external {\n        // Transfer the entire balance to owner.\n        (bool success, ) = owner().call{value: address(this).balance}(\"\");\n        require(success, \"!transfer\");\n    }",
        "@notice": "Transfers the entire native token balance to the owner of the contract.",
        "@dev": "The owner must be able to receive native tokens.",
        "@gnotice": "Claim the balance of the contract and transfer it to the owner of the contract.",
        "@tnotice": 0,
        "@tdev": 0
    },
    {
        "func": "function batchTradeHashUsedAndHasAccess(\n        address[] memory accounts,\n        uint256[] memory numbers\n    ) \n        external\n        view\n        returns (\n            uint256[] memory data\n        )\n    {\n        uint256 maxSupply = _maxSupply; // Get max supply.\n        uint256 accountsAmount = accounts.length; // Get return length.\n        data = new uint256[](accountsAmount); // Create array.\n        for (uint256 i; i < accountsAmount; i++) {\n            if (numbers[i] > maxSupply) { // If checking hash.\n                data[i] = _account[accounts[i]].timestampTradeHashUsed[bytes32(numbers[i])]; // Convert to bytes32 and check if used.\n            } else {\n                bool hasAccess;\n                (hasAccess,) = _hasAccess(accounts[i], numbers[i]);\n                if (hasAccess) data[i] = 1; // Return 1 if account has access.\n            }\n        }\n        return data;\n    }",
        "@notice": "Check if trade hashes have been used and if an account can access token IDs",
        "@dev": "Token ID is checked if number is <= 25000, else the hash is checked. * Hashes must be converted to uint.",
        "@param1": "accounts The addresses of the accounts.",
        "@param2": "numbers The hashes to check.",
        "@return1": "data Data returned.",
        "@gnotice": "Returns an array of data indicating if the account at the corresponding index in the `accounts` array has used the trade hash if `numbers[i]` is greater than `_maxSupply`, or if the account at the corresponding index in `accounts` has access to the trade if `numbers[i]` is less than or equal to `_maxSupply`.",
        "@gparam1": "accounts An array of account addresses to check for trade hash usage or trade access",
        "@gparam2": "numbers An array of numbers to check for trade hash usage or trade access",
        "@greturn1": "An array of uint256 values indicating if each account has used the trade hash or has access to the trade. A value of 1 indicates the corresponding account has access or the trade hash has been used. A value of 0 indicates the corresponding account does not have access or the trade hash has not been used.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 1
    },
    {
        "func": "function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }",
        "@notice": "",
        "@dev": "check the amount of tokens that `_owner` allowed to `spender`.",
        "@param1": "_owner address The address which owns the funds.",
        "@param2": "_spender address The address which will spend the funds.",
        "@return1": "the amount of tokens still available for the spender.",
        "@gnotice": "Get the allowance amount `_spender` can spend on behalf of `_owner`",
        "@gparam1": "_owner The address of the owner account",
        "@gparam2": "_spender The address of the spender account",
        "@greturn1": "The number of tokens `_spender` is allowed to spend on behalf of `_owner`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function getETHPx(address lp) external view override returns (uint) {\n    address pool = poolOf[lp];\n    require(pool != address(0), 'lp is not registered');\n    UnderlyingToken[] memory tokens = ulTokens[lp];\n    uint minPx = uint(-1);\n    uint n = tokens.length;\n    for (uint idx = 0; idx < n; idx++) {\n      UnderlyingToken memory ulToken = tokens[idx];\n      uint tokenPx = base.getETHPx(ulToken.token);\n      if (ulToken.decimals < 18) tokenPx = tokenPx.div(10**(18 - uint(ulToken.decimals)));\n      if (ulToken.decimals > 18) tokenPx = tokenPx.mul(10**(uint(ulToken.decimals) - 18));\n      if (tokenPx < minPx) minPx = tokenPx;\n    }\n    require(minPx != uint(-1), 'no min px');\n    return minPx.mul(ICurvePool(pool).get_virtual_price()).div(1e18);\n  }",
        "@dev": "Return the value of the given input as ETH per unit, multiplied by 2**112.",
        "@param1": "lp The ERC-20 LP token to check the value.",
        "@notice": "",
        "@gnotice": "Returns the ETH price of the LP token `lp`",
        "@gparam1": "lp The address of the LP token",
        "@greturn1": "The ETH price of the LP token `lp`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function hasPrice(bytes32 identifier, uint256 time) external override view onlyRegisteredContract() returns (bool) {\n        (bool _hasPrice, , ) = _getPriceOrError(identifier, time);\n        return _hasPrice;\n    }",
        "@notice": "Whether the price for `identifier` and `time` is available.",
        "@dev": "Time must be in the past and the identifier must be supported.",
        "@param1": "identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.",
        "@param2": "time unix timestamp of for the price request.",
        "@return1": "bool if the DVM has resolved to a price for the given identifier and timestamp.",
        "@gnotice": "Check if there is a price available for the specified `identifier` and `time`",
        "@gparam1": "identifier The identifier of the price to check",
        "@gparam2": "time The timestamp for which to check the price availability",
        "@greturn1": "True if the price is available, false otherwise",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 1,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function queryJoin(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external override returns (uint256 bptOut, uint256[] memory amountsIn) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onJoinPool,\n            _downscaleUpArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptOut, amountsIn);\n    }",
        "@notice": "\"Dry run\" `onJoinPool`.",
        "@dev": "Returns the amount of BPT that would be granted to `recipient` if the `onJoinPool` hook were called by the * Vault with the same arguments, along with the number of tokens `sender` would have to supply. * * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault * data, such as the protocol swap fee percentage and Pool balances. * * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must * explicitly use eth_call instead of eth_sendTransaction.",
        "@gnotice": "Calculates join pool amounts",
        "@gparam1": "poolId The id of the pool",
        "@gparam2": "sender The address of the user depositing funds",
        "@gparam3": "recipient The address where the BPTs will be sent",
        "@gparam4": "balances An array of the current balances of each token in the pool",
        "@gparam5": "lastChangeBlock The block at which the balances were last updated",
        "@gparam6": "protocolSwapFeePercentage The protocol's swap fee percentage",
        "@gparam7": "userData Arbitrary data that can be passed through to onJoinPool",
        "@greturn1": "The amount of BPTs received and an array of the amounts of tokens to deposit",
        "@greturn2": "",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0,
        "@tparam5": 0,
        "@tparam6": 0,
        "@tparam7": 0,
        "@treturn1": 0,
        "@treturn2": 0,
        "@gtparam3": 0,
        "@gtparam4": 0,
        "@gtparam5": 0,
        "@gtparam6": 0,
        "@gtparam7": 0,
        "@gtreturn1": 0,
        "@gtreturn2": 0
    },
    {
        "func": "function _setInterestRateModel(InterestRateModel newInterestRateModel) public override returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n        }\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }",
        "@notice": "",
        "@dev": "accrue interest and update the interest rate model",
        "@param1": "newInterestRateModel the new interest rate model to use",
        "@return1": "uint 0=success, otherwise a failure (see ErrorReporter.sol for details)",
        "@gnotice": "Set a new interest rate model for the market",
        "@gparam1": "newInterestRateModel The new interest rate model to be set",
        "@greturn1": "uint representing success or failure of the transaction",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n\n        // Preapproved services:\n        // OpenSea, X2Y2, LooksRare, Rarible, 0x Protocol v4, Element, SudoSwap, NFTX, and NFTTrader.\n        // You can manage these services like usual with {setApprovalForAll} or {batch}.\n\n        uint256 status = _account[owner].approvals[operator];\n        return (\n                    status == 2 || // If approved.\n                    (\n                        status == 0 && // If default value (never approved or revoked by the owner).\n                        _account[operator].preapprovedStatus == 2 && // If preapproved service.\n                        owner != operator // If not self.\n                    )\n                );\n    }",
        "@notice": "Returns if `operator` is an approved account operator of `owner`",
        "@dev": "Account operators can do everything the owner can do expect sign messages and manage their account operators. * Preapproved services: OpenSea, X2Y2, LooksRare, Rarible, 0x Protocol v4, Element, SudoSwap, NFTX, and NFTTrader. * You can revoke these services using {setApprovalForAll} or visit CryptoBlobs.com for a batch tx to revoke all at once. * SuperCollectiv will permanently disable preapproved services if any issues are discovered with these contracts. * Services that list your account operators will not detect that these addresses have * been approved unless you reapprove each service with {setApprovalForAll} or {batch}.",
        "@param1": "owner The address of the account that owns the CryptoBlobs.",
        "@param2": "operator The address of the account to the check the status of.",
        "@return1": "If `operator` is an account operator of `owner`.",
        "@gnotice": "Checks whether a given `operator` is approved by `owner` to manage all of its assets",
        "@gparam1": "owner The address of the owner",
        "@gparam2": "operator The address of the operator to check",
        "@greturn1": "Whether or not `operator` is approved to manage all of `owner`'s assets",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function farm(bytes[] calldata data)\n        external\n        payable\n        returns (bytes[] memory results)\n    {\n        return _farm(data);\n    }",
        "@notice": "Execute multiple function calls in Depot",
        "@param1": "data list of encoded function calls to be executed",
        "@return1": "results list of return data from each function call",
        "@dev": "Implementation from https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/Multicall.sol.",
        "@gnotice": "Allows users to farm by calling multiple functions in a single transaction",
        "@gparam1": "data An array of function call data in the form of bytes",
        "@greturn1": "An array of return values for each function called in the same order as `data`",
        "@tnotice": 0,
        "@tparam1": 0,
        "@treturn1": 0,
        "@tdev": 0
    },
    {
        "func": "function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) public override view returns (uint rate) {\n        (rate, ) = KyberNetworkProxyInterface(KYBER_INTERFACE)\n            .getExpectedRate(ERC20(_srcAddr), ERC20(_destAddr), _srcAmount);\n\n        // multiply with decimal difference in src token\n        rate = rate * (10**(18 - getDecimals(_srcAddr)));\n        // divide with decimal difference in dest token\n        rate = rate / (10**(18 - getDecimals(_destAddr)));\n    }",
        "@notice": "Return a rate for which we can sell an amount of tokens",
        "@param1": "_srcAddr From token",
        "@param2": "_destAddr To token",
        "@param3": "_srcAmount From amount",
        "@return1": "rate Rate",
        "@gnotice": "Get the sell rate for converting `srcAmount` of `srcAddr` token to `destAddr` token",
        "@gparam1": "_srcAddr The address of the source token",
        "@gparam2": "_destAddr The address of the destination token",
        "@gparam3": "_srcAmount The amount of source tokens to sell",
        "@greturn1": "The sell rate for converting `srcAmount` of `srcAddr` token to `destAddr` token, adjusted for decimals difference between the tokens.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@treturn1": 0,
        "@gtparam3": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function buyForErc20(uint256 roundId, uint256 amount)\n        external\n        isEnded(roundId)\n    {\n        TokenSaleRound storage tokenSaleRound = rounds[roundId];\n\n        if (!tokenSaleRound.isPublic) {\n            if (!whitelist[msg.sender]) {\n                revert NotInTheWhitelist(\"TokenSale: Not in the whitelist\");\n            }\n        }\n\n        if (!isRoundStared(roundId)) {\n            revert RoundNotStarted(\"TokenSale: Round is not started\");\n        }\n\n        if (amount < tokenSaleRound.minAmount) {\n            revert MinMaxPurchase(\"TokenSale: Amount not allowed\");\n        }\n\n        uint256 tokenAmount = _calcPurchaseAmount(\n            amount,\n            tokenSaleRound.purchasePrice\n        );\n\n        if (\n            tokenSaleRound.tokensSold + tokenAmount >\n            tokenSaleRound.totalPurchaseAmount\n        ) {\n            revert TokensNotEnough(\"TokenSale: Tokens not enough\");\n        }\n\n        tokenSaleRound.tokensSold += tokenAmount;\n        userSpentFunds[msg.sender][roundId] += amount;\n\n        IERC20(usdtToken).safeTransferFrom(msg.sender, treasury, amount);\n\n        userBalance[msg.sender][roundId] += tokenAmount;\n\n        _endSoldOutRound(roundId);\n        emit PurchasePlanetexToken(msg.sender, amount, tokenAmount);\n    }",
        "@notice": "",
        "@dev": "buy tokens for usdt or busd tokens",
        "@param1": "roundId tokeSale round id.",
        "@param2": "amount usdt or busd amount.",
        "@gnotice": "Buy Planetex token with ERC20 tokens for the specified round",
        "@gparam1": "roundId The ID of the token sale round",
        "@gparam2": "amount The amount of ERC20 tokens to be used for the purchase",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function votingDelay() public pure returns (uint) { return 1; }",
        "@notice": "The delay before voting on a proposal may take place, once proposed // This also helps protect against flash loan attacks because only the vote balance at the proposal start block is considered",
        "@gnotice": "Returns the number of blocks a voter has to wait before being able to vote after a transaction is executed",
        "@greturn1": "The voting delay in blocks",
        "@tnotice": 1,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }",
        "@dev": "Atomically decreases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address. * - `spender` must have allowance for the caller of at least * `subtractedValue`.",
        "@notice": "",
        "@gnotice": "Decrease the allowance granted to `spender` by `subtractedValue`",
        "@gparam1": "spender The address which is allowed to spend the `msg.sender`'s tokens",
        "@gparam2": "subtractedValue The amount of allowance to be removed from `spender`",
        "@greturn1": "Whether or not the decrease succeeded",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function setAffiliateFeeFrac(address affiliate, uint256 feeFrac)\n        public\n        onlySystemParamsAdmin\n    {\n        require(\n            feeFrac < MAX_AFFILIATE_FEE,\n            \"AFFILIATE_FEE_TOO_HIGH\"\n        );\n\n        affiliateFeeFrac[affiliate] = feeFrac;\n    }",
        "@notice": "Sets the affiliate fee fraction for an address.",
        "@param1": "affiliate The affiliate whose fee fraction should be changed.",
        "@param2": "feeFrac The new fee fraction for this affiliate.",
        "@gnotice": "Sets the affiliate fee fraction `feeFrac` for the `affiliate` address",
        "@gparam1": "affiliate The affiliate account to set the fee for",
        "@gparam2": "feeFrac The fee fraction to be set for the affiliate",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return interfaceId == type(IERC165).interfaceId ||          // 0x01ffc9a7\n            interfaceId == type(IERC721).interfaceId ||             // 0x80ac58cd\n            interfaceId == type(IERC721Metadata).interfaceId ||     // 0x5b5e139f\n            interfaceId == type(IERC721Enumerable).interfaceId;     // 0x780e9d63\n    }",
        "@notice": "If an interface ID is supported",
        "@dev": "Supported interfaces: IERC165 (0x01ffc9a7), IERC721 (0x80ac58cd), IERC721Metadata (0x5b5e139f), IERC721Enumerable (0x780e9d63).",
        "@param1": "interfaceId Interface ID to check.",
        "@return1": "If `interfaceId` is supported.",
        "@gnotice": "if `interfaceId` is supported by the contract",
        "@gparam1": "interfaceId The interface ID to check for support",
        "@greturn1": "`true` if the contract supports `interfaceId`, otherwise `false`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function votingDelay() public pure returns (uint) { return 1; }",
        "@notice": "The delay before voting on a proposal may take place, once proposed // This also helps protect against flash loan attacks because only the vote balance at the proposal start block is considered",
        "@gnotice": "Get the voting delay",
        "@greturn1": "The voting delay in number of blocks",
        "@tnotice": 1,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function setApprovalForAll(address to, bool approved) public {\n        require(to != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][to] = approved;\n        emit ApprovalForAll(_msgSender(), to, approved);\n    }",
        "@dev": "Sets or unsets the approval of a given operator * An operator is allowed to transfer all tokens of the sender on their behalf.",
        "@param1": "to address to set the approval",
        "@param2": "approved the status of the approval to be set",
        "@notice": "",
        "@gnotice": "Sets or revokes permission for `to` to manage all the assets in the caller's account",
        "@gparam1": "to The address to grant management permission",
        "@gparam2": "approved Whether the permission is granted or revoked",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function addressesToENS(address[] memory accounts) public view returns (string[] memory ensNames) {\n        return IReverseRecords(_reverseRecordsAddress).getNames(accounts);\n    }",
        "@notice": "Reverse records for the primary ENS name of accounts",
        "@dev": "_reverseRecordsAddress Can be updated to support additional features.",
        "@param1": "accounts The addresses of the accounts.",
        "@return1": "ensNames ENS names of `accounts`.",
        "@gnotice": "Returns the ENS names associated with the provided `accounts`",
        "@gparam1": "accounts An array of addresses",
        "@greturn1": "An array of ENS names (as strings) corresponding to the provided `accounts`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function burn(uint256 _value) public {\n    _burn(msg.sender, _value);\n  }",
        "@notice": "",
        "@dev": "Burns a specific amount of tokens.",
        "@param1": "_value The amount of token to be burned.",
        "@gnotice": "Burn `_value` tokens from `msg.sender`",
        "@gparam1": "_value The number of tokens to burn",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function setApprovalForAll(address operator, bool approved)\n        public\n        virtual\n        override\n    {\n        unchecked {\n            if (msg.sender == operator) revert CANNOT_APPROVE_THIS_ADDRESS();\n\n            // Numbers are used to enable the preapproved services feature. Works similarly to an enum.\n            // Values:\n            // 0 = default\n            // 1 = revoked\n            // 2 = approved\n\n            if (approved) {\n                _account[msg.sender].approvals[operator] = 2; // Approve.\n            } else {\n                _account[msg.sender].approvals[operator] = 1; // Revoked.\n            }\n\n            emit ApprovalForAll(    // 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31\n                msg.sender,         // address indexed owner\n                operator,           // address indexed operator\n                approved            // bool approved\n            );\n        }\n    }",
        "@notice": "Approves `to` to be an account operator of your account",
        "@dev": "Account operators can do everything the owner can do expect sign messages and manage their account operators. * Preapproved services: OpenSea, X2Y2, LooksRare, Rarible, 0x Protocol v4, Element, SudoSwap, NFTX, and NFTTrader. * You can revoke these services using {setApprovalForAll} or visit CryptoBlobs.com for a batch tx to revoke all at once. * SuperCollectiv will permanently disable preapproved services if any issues are discovered with these contracts. * Services that list your account operators will not detect that these addresses have * been approved unless you reapprove each service with {setApprovalForAll} or {batch}.",
        "@param1": "operator The address of the account to update the operator status of.",
        "@param2": "approved The approval status to set `operator` to.",
        "@gnotice": "Approves `operator` to operate on behalf of the `msg.sender`",
        "@gparam1": "operator The address which will act on behalf of `msg.sender`",
        "@gparam2": "approved Whether or not the `operator` is approved",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function exitMarket(address cTokenAddress) external override returns (uint) {\n        CToken cToken = CToken(cTokenAddress);\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n        /* Fail if the sender has a borrow balance */\n        if (amountOwed != 0) {\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n        }\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n        uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n        if (allowed != 0) {\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n        }\n\n        Market storage marketToExit = markets[address(cToken)];\n\n        /* Return true if the sender is not already \u2018in\u2019 the market */\n        if (!marketToExit.accountMembership[msg.sender]) {\n            return uint(Error.NO_ERROR);\n        }\n\n        /* Set cToken account membership to false */\n        delete marketToExit.accountMembership[msg.sender];\n\n        /* Delete cToken from the account\u2019s list of assets */\n        // load into memory for faster iteration\n        CToken[] memory userAssetList = accountAssets[msg.sender];\n        uint len = userAssetList.length;\n        uint assetIndex = len;\n        for (uint i = 0; i < len; i++) {\n            if (userAssetList[i] == cToken) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        CToken[] storage storedList = accountAssets[msg.sender];\n        storedList[assetIndex] = storedList[storedList.length - 1];\n        storedList.pop();\n\n        emit MarketExited(cToken, msg.sender);\n\n        return uint(Error.NO_ERROR);\n    }",
        "@notice": "Removes asset from sender's account liquidity calculation",
        "@dev": "Sender must not have an outstanding borrow balance in the asset, * or be providing necessary collateral for an outstanding borrow.",
        "@param1": "cTokenAddress The address of the asset to be removed",
        "@return1": "Whether or not the account successfully exited the market",
        "@gnotice": "Allows a user to exit a given market by redeeming all underlying tokens",
        "@gparam1": "cTokenAddress The address of the Compound token to exit",
        "@greturn1": "an error code, 0 if successful",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }",
        "@dev": "Returns the symbol of the token, usually a shorter version of the * name.",
        "@notice": "",
        "@gnotice": "Gets the token symbol",
        "@greturn1": "The symbol of the token",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function getApproved(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (address)\n    {\n        _revertIfTokenIsInvalid(tokenId);\n        return _token[tokenId].approval;\n    }",
        "@notice": "",
        "@dev": "Get all approved token operators with {tokenDataByCategory} category 1.",
        "@param1": "tokenId The token ID of the CryptoBlob.",
        "@return1": "The address of the account that can manage `tokenId`.",
        "@gnotice": "Get the approved address for a specific token",
        "@gparam1": "tokenId The ID of the token",
        "@greturn1": "The address approved to transfer the token, or zero address if no approval is set",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function getPrices(address[] memory _cTokens) public view returns (uint[] memory prices) {\n        prices = new uint[](_cTokens.length);\n        address oracleAddr = comp.oracle();\n\n        for (uint i = 0; i < _cTokens.length; ++i) {\n            prices[i] = CompoundOracleInterface(oracleAddr).getUnderlyingPrice(_cTokens[i]);\n        }\n    }",
        "@notice": "Fetches cream prices for tokens",
        "@param1": "_cTokens Arr. of cTokens for which to get the prices",
        "@return1": "prices Array of prices",
        "@gnotice": "Fetches the underlying asset price for each Compound market corresponding to the given `_cTokens`",
        "@gparam1": "_cTokens An array of Compound market addresses for which underlying asset prices are to be fetched",
        "@greturn1": "An array of underlying asset prices corresponding to each `_cTokens` market",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ownerOf(tokenId);\n\n        if (_msgSenderERC721A() != owner)\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\n                revert ApprovalCallerNotOwnerNorApproved();\n            }\n\n        _tokenApprovals[tokenId].value = to;\n        emit Approval(owner, to, tokenId);\n    }",
        "@dev": "Gives permission to `to` to transfer `tokenId` token to another account. * The approval is cleared when the token is transferred. * * Only a single account can be approved at a time, so approving the * zero address clears previous approvals. * * Requirements: * * - The caller must own the token or be an approved operator. * - `tokenId` must exist. * * Emits an {Approval} event.",
        "@notice": "",
        "@gnotice": "Approve the address `to` to transfer `tokenId`",
        "@gparam1": "to The address that will be allowed to transfer the token",
        "@gparam2": "tokenId The ID of the token to be approved for transfer",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function totalSupply() public view virtual override returns (uint256) {\n        // Counter underflow is impossible as _burnCounter cannot be incremented\n        // more than `_currentIndex - _startTokenId()` times.\n        unchecked {\n            return _currentIndex - _burnCounter - _startTokenId();\n        }\n    }",
        "@dev": "Returns the total number of tokens in existence. * Burned tokens will reduce the count. * To get the total number of tokens minted, please see {_totalMinted}.",
        "@notice": "",
        "@gnotice": "Get the total number of tokens in circulation",
        "@greturn1": "The total number of tokens in circulation",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function tbtcToTdt(uint256 _tdtId) external {\n        require(tbtcDepositToken.exists(_tdtId), \"tBTC Deposit Token does not exist\");\n        require(isQualified(address(_tdtId)), \"Deposit must be qualified\");\n\n        uint256 depositValue = Deposit(address(uint160(_tdtId))).lotSizeTbtc();\n        require(tbtcToken.balanceOf(msg.sender) >= depositValue, \"Not enough TBTC for TDT exchange\");\n        tbtcToken.burnFrom(msg.sender, depositValue);\n\n        // TODO do we need the owner check below? transferFrom can be approved for a user, which might be an interesting use case.\n        require(tbtcDepositToken.ownerOf(_tdtId) == address(this), \"Deposit is locked\");\n        tbtcDepositToken.transferFrom(address(this), msg.sender, _tdtId);\n    }",
        "@notice": "Burns TBTC and transfers the tBTC Deposit Token to the caller /// as long as it is qualified.",
        "@dev": "We burn the lotSize of the Deposit in order to maintain /// the TBTC supply peg in the Vending Machine. VendingMachine must be approved /// by the caller to burn the required amount.",
        "@param1": "_tdtId ID of tBTC Deposit Token to buy.",
        "@gnotice": "Exchange `tBTC` for `TDT` token and transfer to `msg.sender`",
        "@gparam1": "_tdtId The ID of the `tBTC` Deposit Token",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function optimize(\n        uint256[] memory tokenIds\n    ) public {\n        unchecked {\n            uint256 amount = tokenIds.length;\n            for (uint256 i; i < amount; i++) {\n                if (_token[tokenIds[i]].account != address(0)) revert CRYPTOBLOB_DOES_NOT_REQUIRE_OPTIMIZATION();\n                _token[tokenIds[i]].account = ownerOf(tokenIds[i]);\n            }\n            _account[msg.sender].tokensOptimized += uint16(amount);\n\n            emit Optimize(              // 0xff06b6e7e3b7963958aa44cc1dff152337abfc3ef2d0ecd54bdcd8fb9694e0eb\n                msg.sender,             // address indexed account\n                tokenIds,               // uint256[] tokenIds\n                block.timestamp         // uint256 timestamp\n            );\n        }\n    }",
        "@notice": "Optimize CryptoBlobs to lower future transaction fees with it",
        "@dev": "You can optimize any CryptoBlob, even if you do not own it. * You earn one account level per CryptoBlob you optimize.",
        "@param1": "tokenIds The token IDs of the CryptoBlobs.",
        "@gnotice": "Optimize the storage of tokens with the given token IDs",
        "@gparam1": "tokenIds Array of token IDs to optimize storage for",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function buyForEth(uint256 roundId) external payable isEnded(roundId) {\n        if (msg.value == 0) {\n            revert ZeroMsgValue(\"TokenSale: Zero msg.value\");\n        }\n\n        TokenSaleRound storage tokenSaleRound = rounds[roundId];\n\n        if (!tokenSaleRound.isPublic) {\n            if (!whitelist[msg.sender]) {\n                revert NotInTheWhitelist(\"TokenSale: Not in the whitelist\");\n            }\n        }\n\n        if (!isRoundStared(roundId)) {\n            revert RoundNotStarted(\"TokenSale: Round is not started\");\n        }\n\n        uint256[] memory amounts = swapRouter.getAmountsOut(msg.value, path);\n\n        if (amounts[1] < tokenSaleRound.minAmount) {\n            revert MinMaxPurchase(\"TokenSale: Amount not allowed\");\n        }\n\n        uint256 tokenAmount = _calcPurchaseAmount(\n            amounts[1],\n            tokenSaleRound.purchasePrice\n        );\n\n        if (\n            tokenSaleRound.tokensSold + tokenAmount >\n            tokenSaleRound.totalPurchaseAmount\n        ) {\n            revert TokensNotEnough(\"TokenSale: Tokens not enough\");\n        }\n\n        tokenSaleRound.tokensSold += tokenAmount;\n        userSpentFunds[msg.sender][roundId] += amounts[1];\n\n        userBalance[msg.sender][roundId] += tokenAmount;\n\n        _endSoldOutRound(roundId);\n\n        (bool sent, ) = treasury.call{value: msg.value}(\"\");\n        require(sent, \"Failed to send Ether\");\n        emit PurchasePlanetexToken(msg.sender, amounts[1], tokenAmount);\n    }",
        "@notice": "",
        "@dev": "buy tokens for eth or bnb tokens",
        "@param1": "roundId tokeSale round id.",
        "@gnotice": "Buy Planetex tokens for ETH in a token sale round",
        "@gparam1": "roundId The ID of the token sale round",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function preapprovedServiceStatus(address account) external view returns (uint256 status) {\n        return _account[account].preapprovedStatus;\n    }",
        "@notice": "Returns the status for a preapproved service",
        "@dev": "SuperCollectiv can only manage services preapproved in the constructor. * 0x1E0049783F008A0085193E00003D00cd54003c71 (OpenSea). * 0xF849de01B080aDC3A814FaBE1E2087475cF2E354 (X2Y2). * 0xf42aa99F011A1fA7CDA90E5E98b277E306BcA83e (LooksRare). * 0x4feE7B061C97C9c496b01DbcE9CDb10c02f0a0Be (Rarible). * 0xDef1C0ded9bec7F1a1670819833240f027b25EfF (0x Protocol, Coinbase NFT, and more). * 0x20F780A973856B93f63670377900C1d2a50a77c4 (Element). * 0x2B2e8cDA09bBA9660dCA5cB6233787738Ad68329 (SudoSwap). * 0x0fc584529a2AEfA997697FAfAcbA5831faC0c22d (NFTX). * 0x657E383EdB9A7407E468acBCc9Fe4C9730c7C275 (NFTTrader).",
        "@param1": "account The address of the account.",
        "@return1": "status 0 = service is permanently disabled, 1 = service is temporarily disabled, 2 = service is enabled.",
        "@gnotice": "Get the pre-approved service status of an account",
        "@gparam1": "account The address of the account to query",
        "@greturn1": "The pre-approved service status of the account.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 1
    },
    {
        "func": "function cancelOrder(LibOrder.Order memory order) public {\n        assertCancelValid(order, msg.sender);\n        fills.cancel(order);\n\n        emit OrderCancel(\n            order.maker,\n            order.getOrderHash(),\n            order\n        );\n    }",
        "@notice": "Cancels an order and prevents and further filling. /// Uses the order hash to uniquely ID the order.",
        "@param1": "order The order to cancel.",
        "@gnotice": "Cancel an order given by its parameters",
        "@gparam1": "order The order to be canceled",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }",
        "@dev": "Atomically decreases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address. * - `spender` must have allowance for the caller of at least * `subtractedValue`.",
        "@notice": "",
        "@gnotice": "Decrease the allowance of `spender` by `subtractedValue`",
        "@gparam1": "spender The address which is allowed to spend tokens on behalf of `msg.sender`",
        "@gparam2": "subtractedValue The amount by which to decrease the allowance",
        "@greturn1": "Whether or not the decrease in allowance succeeded.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function addAddressToWhitelist(address addr)\n        public\n        onlyOwner\n        returns (bool success)\n    {\n        if (!whitelist[addr]) {\n            whitelist[addr] = true;\n            emit WhitelistedAddressAdded(addr);\n            success = true;\n        }\n    }",
        "@notice": "",
        "@dev": "add an address to the whitelist",
        "@param1": "addr address",
        "@return1": "success if the address was added to the whitelist, false if the address was already in the whitelist",
        "@gnotice": "Adds `addr` to the whitelist",
        "@gparam1": "addr The address to be added to the whitelist",
        "@greturn1": "`success` Whether or not the address was successfully added to the whitelist",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function addAdmin(address account) public virtual onlyOwner {\n        grantRole(ADMIN_ROLE, account);\n    }",
        "@notice": "",
        "@dev": "add admin",
        "@param1": "account address to add",
        "@gnotice": "Adds `account` as an admin",
        "@gparam1": "account The address to be added as an admin. Must not be null.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function setFundsRecipient(\n    address payable newRecipientAddress\n  ) external onlyRoleOrAdmin(SALES_MANAGER_ROLE) {\n    config.fundsRecipient = newRecipientAddress;\n    emit FundsRecipientChanged(newRecipientAddress, _msgSender());\n  }",
        "@notice": "Set a different funds recipient",
        "@param1": "newRecipientAddress new funds recipient address",
        "@gnotice": "Set the new funds recipient address",
        "@gparam1": "newRecipientAddress The address of the new funds recipient account, must be payable",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function seize(address liquidator, address borrower, uint seizeTokens) external override nonReentrant returns (uint) {\n        return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\n    }",
        "@notice": "Transfers collateral tokens to the liquidator",
        "@dev": "Will fail unless called by another cToken during the process of liquidation. * Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.",
        "@param1": "liquidator The account receiving seized collateral",
        "@param2": "borrower The account having collateral seized",
        "@param3": "seizeTokens The number of cTokens to seize",
        "@return1": "uint 0=success, otherwise a failure",
        "@gnotice": "Seizes `seizeTokens` tokens from `borrower` to be transferred to `liquidator` account",
        "@gparam1": "liquidator The account that will receive the seized tokens",
        "@gparam2": "borrower The account that borrowed the tokens to be seized",
        "@gparam3": "seizeTokens The number of tokens to be seized",
        "@greturn1": "The actual amount of tokens seized",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@treturn1": 1
    },
    {
        "func": "function trade(\n        address maker,\n        address taker,\n        uint256[] memory makerIds,\n        uint256[] memory takerIds,\n        uint256 price,\n        uint256 expiry,\n        uint256 salt,\n        bytes memory signature\n    ) external payable nonReentrant {\n        unchecked {\n\n            // Check if trading is paused.\n            if (_tradingPaused) revert TRADING_IS_CURRENTLY_DISABLED();\n\n            // Revert if the trade is private and if the sender is not the taker.\n            if (taker != address(0) && msg.sender != taker) revert TRADE_IS_NOT_FOR_YOU();\n\n            // Revert if the amount sent is insufficient.\n            if (msg.value < price) revert INSUFFICIENT_FUNDS_SENT();\n\n            // Get the hash and errors for the trade.\n            (bytes32 hash, uint256[8] memory errors) = isTradeApprovedAndValid(\n                maker,\n                taker,\n                makerIds,\n                takerIds,\n                price,\n                expiry,\n                salt,\n                signature, \n                false\n            );\n\n            // Revert if the trade contains errors.\n            for (uint256 i; i < errors.length; i++) if (errors[i] != 0) revert INVALID_TRADE();\n\n            // Transfer sale price to the maker.\n            if (price > 0) _transferEther(maker, price);\n\n            // Transfer CryptoBlobs.\n            // Third-party NFT marketplaces require an approval to use {transferFrom}, but this trading platform uses {_transfer}, \n            // an internal function, to bypass approvals. This allows takers to complete trades on the maker's behalf using a signature.\n            // Note that {_revertIfNoAccess} returns the owner's address because makers and takers can be approved accounts.\n\n            // Transfer maker IDs. Reverts if the maker does not have access to transfer a maker ID.\n            for (uint256 i; i < makerIds.length; i++) _transfer(_revertIfNoAccess(maker, makerIds[i]), msg.sender, makerIds[i]);\n\n            // Transfer taker IDs. Reverts if the sender does not have access to transfer a taker ID.\n            for (uint256 i; i < takerIds.length; i++) _transfer(_revertIfNoAccess(msg.sender, takerIds[i]), maker, takerIds[i]);\n\n            // Use the trade hash.\n            // The block timestamp is multiplied by 10 to store a binary number. 0 means cancelled. 1 means completed.\n            _account[maker].timestampTradeHashUsed[hash] = (block.timestamp * 10) + 1;\n\n            emit Trade(             // 0x10d92c47650ef2b2a841f26c951f4391ccbb731e57d36a67665a0d138e08ef09\n                hash,               // bytes32 hash\n                maker,              // address indexed maker\n                msg.sender,         // address indexed taker\n                makerIds,           // uint256[] makerIds\n                takerIds,           // uint256[] takerIds\n                price,              // uint256 price\n                expiry,             // uint256 expiry\n                block.timestamp,    // uint256 timestamp\n                true                // bool isTrade\n            );\n        }\n    }",
        "@notice": "Confirm a trade on the integrated trading platform",
        "@dev": "Buy, sell, and trade multiple CryptoBlobs at a time. * Makers and takers can trade CryptoBlobs that they have access to. * Approve accounts with {approve} or {setApprovalForAll}. * Makers do not need to approve this contract to trade. * Only takers can transfer ETH in a trade. Makers can't deposit ETH. * Use {manageTrades} to cancel a trade or lock/unlock your trades. * The trading platform does not currently support EIP-712.",
        "@param1": "maker The address of the maker.",
        "@param2": "taker The address of the taker.",
        "@param3": "makerIds The CryptoBlob IDs `maker` has access to trade.",
        "@param4": "takerIds The CryptoBlob IDs `taker` has access to trade.",
        "@param5": "price The price (in WEI) the `taker` must pay to `maker` to complete the trade.",
        "@param6": "expiry The timestamp the trade auto-expires, or 0 for never expires.",
        "@param7": "salt Salt allows the same trade parameters to be used again, resulting in a different hash.",
        "@param8": "signature The signature is the hash of the trade signed by the maker.",
        "@gnotice": "trade CryptoBlobs IDs for a specific price",
        "@gparam1": "maker The address of the maker account",
        "@gparam2": "taker The address of the taker account",
        "@gparam3": "makerIds An array of IDs representing the CryptoBlobs owned by maker",
        "@gparam4": "takerIds An array of IDs representing the CryptoBlobs owned by taker",
        "@gparam5": "price The price of the trade in wei",
        "@gparam6": "expiry The time at which the trade will expire",
        "@gparam7": "salt A unique number to generate a unique hash for the trade",
        "@gparam8": "signature The signature of the trade hash signed by the maker",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0,
        "@tparam5": 0,
        "@tparam6": 0,
        "@tparam7": 1,
        "@tparam8": 0
    },
    {
        "func": "function setBondingContractAddress(address _bondingContractAddress)\n        external\n        onlyAdmin\n    {\n        bondingContractAddress = _bondingContractAddress;\n    }",
        "@notice": "set the bonding bontract smart contract address",
        "@dev": "bonding contract participants deposit curve LP token for a certain duration to earn uGOV and more curve LP token",
        "@param1": "_bondingContractAddress bonding contract address",
        "@gnotice": "Sets the address of the bonding contract to `_bondingContractAddress`",
        "@gparam1": "_bondingContractAddress The new address of the bonding contract.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function burnDeadman(address _deadman)\n        public\n        nonReentrant\n        during(CyclePhase.Intermission)\n    {\n        require(_deadman != address(this));\n        require(\n            cycleNumber.sub(lastActiveCycle(_deadman)) > INACTIVE_THRESHOLD\n        );\n        uint256 balance = cToken.balanceOf(_deadman);\n        require(cToken.destroyTokens(_deadman, balance));\n        emit BurnDeadman(_deadman, balance);\n    }",
        "@notice": "Burns the RepToken balance of a manager who has been inactive for a certain number of cycles",
        "@param1": "_deadman the manager whose RepToken balance will be burned",
        "@gnotice": "Burn all of the tokens held by an inactive `_deadman` account during the Intermission phase of the cycle",
        "@gparam1": "_deadman The address of the account to burn tokens from",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 1
    },
    {
        "func": "function tokenDataByCategory(uint256 category, uint256 index, uint256 amount)\n        external\n        view\n        returns (uint256[] memory data)\n    {\n        unchecked {\n            uint256 tokensMinted = _tokensMinted();\n            uint256 toIndex;\n            uint256 fromIndex;\n            if (amount == 0) { // Getting all data.\n                amount = _maxSupply;\n                toIndex = tokensMinted;\n            } else { // Getting range.\n                // Precheck for accurate data. \n                if (category == 0 || category == 3 || category == 8) {\n                    // toIndex temporarily holds precheck amount.\n                    uint maxPrecheck = _purchaseLimit + _maxFreePerAccount;\n                    if (index > maxPrecheck) {\n                        toIndex = maxPrecheck;\n                    } else if (index != 0) {\n                        toIndex = index % (maxPrecheck);\n                    }\n                }\n                fromIndex = index - toIndex; // Cannot underflow because index > toIndex (precheck).\n                toIndex += fromIndex + amount; // toIndex is calculated here.\n                // Limit amount.\n                if (toIndex > tokensMinted) {\n                    toIndex = tokensMinted;\n                    amount = toIndex - index; // Cannot underflow because toIndex always > index.\n                }\n            }\n            data = new uint256[](amount); // Create uint array.\n            uint256 holdNumber;\n            if (category != 8) {\n                while (fromIndex < toIndex) {\n                    // Check all minted CryptoBlobs.\n                    uint256 tokenId = _getTokenId(fromIndex); // Get token ID.\n                    bool sacrificed = _isTokenSacrificed(tokenId);\n                    uint256 dataRetrieved;\n                    if (category == 0) {\n                        // Update account of token.\n                        if (_token[tokenId].account != address(0)) {\n                            holdNumber = uint160(_token[tokenId].account);\n                        }\n                        // Add address if not sacrificed.\n                        if (!sacrificed) {\n                            dataRetrieved = holdNumber;\n                        }\n                    } else if (category == 1) {\n                        // Add approval.\n                        dataRetrieved = uint160(_token[tokenId].approval);\n                    } else if (category == 2) {\n                        // Update account of token.\n                        if (_token[tokenId].account != address(0)) {\n                            holdNumber = uint160(_token[tokenId].account);\n                        }\n                        // Add address if sacrificed.\n                        if (sacrificed) {\n                            dataRetrieved = holdNumber;\n                        }\n                    } else if (category == 3) {\n                        // Update latest mint timestamp.\n                        if (_token[tokenId].mintTimestamp != 0) {\n                            holdNumber = _token[tokenId].mintTimestamp;\n                        }\n                        // Add mint timestamp.\n                        dataRetrieved = holdNumber;\n                    } else if (category == 4) {\n                        // Add burn timestamp.\n                        dataRetrieved = _token[tokenId].burnTimestamp;\n                    } else if (category == 5 && !sacrificed) {\n                        // Add souls if not sacrificed.\n                        dataRetrieved = _token[tokenId].souls + 1;\n                    } else if (category == 6 && sacrificed) {\n                        // Add souls transferred if sacrificed.\n                        dataRetrieved = _token[tokenId].souls;\n                    } else if (category == 7 && sacrificed) {\n                        // Add token ID upgraded.\n                        dataRetrieved = _token[tokenId].burnTo;\n                    }\n                    // Add data to array.\n                    if (amount == _maxSupply) {\n                        if (dataRetrieved != 0) {\n                            data[tokenId - 1] = dataRetrieved;\n                        }\n                    } else if (fromIndex >= index) {\n                        if (dataRetrieved != 0) {\n                            data[fromIndex - index] = dataRetrieved;\n                        }\n                    }\n                    fromIndex++;\n                }\n            } else if (category == 8) {\n                uint256 tokensChecked;\n                while (fromIndex < toIndex) {\n                    if (_token[_getTokenId(toIndex - tokensChecked - 1)].account == address(0)) {\n                        holdNumber++;\n                    } else if (holdNumber > 0) {\n                        for (uint256 j; j < holdNumber + 1; j++) {\n                            if (amount == _maxSupply) {\n                                data[_getTokenId(toIndex - tokensChecked - 1 + j) - 1] = j;\n                            } else if (toIndex - tokensChecked - 1 + j >= index) {\n                                data[toIndex - tokensChecked - 1 + j - index] = j;\n                            }\n                        }\n                        delete holdNumber;\n                    }\n                    tokensChecked++;\n                    fromIndex++;\n                }\n            }\n            return data;\n        }\n    }",
        "@notice": "Information about all tokens.",
        "@dev": "Most providers will successfully call this function. * Data can be split by specifying an index and an amount, which uses token indices.",
        "@param1": "category 0 owners, 1 approvals, 2 burners, 3 mintTimestamps, 4 burnTimestamps, 5 ownedSouls, 6 burnSouls, 7 burnTos, 8 distance.",
        "@param2": "index Index to start from when splitting data.",
        "@param3": "amount Amount to query when splitting data.",
        "@return1": "data The number data of all tokens, based on the category.",
        "@gnotice": "Get token data based on `category`, `index`, and `amount`",
        "@gparam1": "category The category of data to retrieve (0-8)",
        "@gparam2": "index The starting index of the range of tokens to retrieve data for",
        "@gparam3": "amount The number of tokens to retrieve data for",
        "@greturn1": "An array of uint256 values containing the requested data for the specified tokens",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 1,
        "@tparam2": 0,
        "@tparam3": 0,
        "@treturn1": 1
    },
    {
        "func": "function addAddressesToWhitelist(address[] memory addrs)\n        public\n        onlyOwner\n        returns (bool success)\n    {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (addAddressToWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }",
        "@notice": "",
        "@dev": "add addresses to the whitelist",
        "@param1": "addrs addresses",
        "@return1": "success if at least one address was added to the whitelist",
        "@gnotice": "Add multiple addresses to the whitelist",
        "@gparam1": "addrs Array of addresses to add to the whitelist",
        "@greturn1": "Whether or not the additions were successful",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function approve(address to, uint256 tokenId) public virtual override {\n        // Get the owner of `tokenId`.\n        address owner = ownerOf(tokenId);\n\n        // Cannot approve the current owner.\n        if (to == owner) revert CANNOT_APPROVE_THIS_ADDRESS();\n\n        // Revert if not the owner and not approved for all.\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) revert RESTRICTED_ACCESS();\n\n        // Approve `to` to manage `tokenId`.\n        _token[tokenId].approval = to;\n\n        emit Approval(  // 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925\n            owner,      // address indexed owner\n            to,         // address indexed approved\n            tokenId     // uint256 indexed tokenId\n        );\n    }",
        "@notice": "Approves `to` to be a token operator of `tokenId`",
        "@dev": "You must be the owner of `tokenId` or an account operator of the owner. * Only a single account can be approved at a time. * Approve the zero address to clear the current approval. * The approval is cleared when the token is transferred.",
        "@param1": "to The address of the account to approve.",
        "@gnotice": "Approves `to` to operate with `tokenId`",
        "@gparam1": "to The approved address",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function mint(\n    address _to,\n    uint256 _amount\n  )\n    public\n    hasMintPermission\n    canMint\n    returns (bool)\n  {\n    totalSupply_ = totalSupply_.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    emit Mint(_to, _amount);\n    emit Transfer(address(0), _to, _amount);\n    return true;\n  }",
        "@notice": "",
        "@dev": "mint tokens",
        "@param1": "_to The address that will receive the minted tokens.",
        "@param2": "_amount The amount of tokens to mint.",
        "@return1": "A boolean that indicates if the operation was successful.",
        "@gnotice": "Mint `_amount` tokens and assign them to `_to` address",
        "@gparam1": "_to The address to mint tokens to",
        "@gparam2": "_amount The amount of tokens to mint",
        "@greturn1": "A boolean indicating whether or not the minting was successful",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function removeAddressFromWhitelist(address addr)\n        public\n        onlyOwner\n        returns (bool success)\n    {\n        if (whitelist[addr]) {\n            whitelist[addr] = false;\n            emit WhitelistedAddressRemoved(addr);\n            success = true;\n        }\n    }",
        "@notice": "",
        "@dev": "remove an address from the whitelist",
        "@param1": "addr address",
        "@return1": "success if the address was removed from the whitelist",
        "@gnotice": "Removes `addr` from the whitelist",
        "@gparam1": "addr The address to remove",
        "@greturn1": "Whether or not the removal succeeded",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    }
]