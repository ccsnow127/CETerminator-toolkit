[
    {
        "func": "function refund(bytes32 _contractId)\n        external\n        contractExists(_contractId)\n        refundable(_contractId)\n        returns (bool)\n    {\n        LockContract storage c = contracts[_contractId];\n        c.refunded = true;\n        c.sender.transfer(c.amount);\n        emit LogHTLCRefund(_contractId);\n        return true;\n    }",
        "@notice": "",
        "@dev": "Called by the sender if there was no withdraw AND the time lock has * expired. This will refund the contract amount.",
        "@param1": "_contractId Id of HTLC to refund from.",
        "@return1": "bool true on success",
        "@gnotice": "Refunds the amount deposited in the LockContract with `_contractId` back to the sender's account",
        "@gparam1": "_contractId The identifier for the LockContract",
        "@greturn1": "Whether or not the refund was successful",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 1,
        "@treturn1": 0
    },
    {
        "func": "function iWantXKeys(uint256 _keys)\n        public\n        view\n        returns(uint256)\n    {\n        // setup local rID\n        uint256 _rID = rID_;\n\n        // grab time\n        uint256 _now = now;\n\n        // are we in a round?\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );\n        else // rounds over.  need price for new round\n            return ( (_keys).eth() );\n    }",
        "@notice": "returns current eth price for X keys. ",
        "@dev": "* -functionhash- 0xcf808000",
        "@param1": "_keys number of keys desired (in 18 decimal format)",
        "@return1": "amount of eth needed to send",
        "@gnotice": "Calculates the amount of Ether required to buy `_keys` number of keys based on the current game round's price",
        "@gparam1": "_keys Number of keys to buy",
        "@greturn1": "The amount of Ether required to buy `_keys` number of keys in the current game round. If the current round is not active, returns the Ether required for the next round's price.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function pendingRequestExists(uint64 subId) public view returns (bool) {\n    SubscriptionConfig memory subConfig = s_subscriptionConfigs[subId];\n    for (uint256 i = 0; i < subConfig.consumers.length; i++) {\n      for (uint256 j = 0; j < s_provingKeyHashes.length; j++) {\n        (uint256 reqId, ) = computeRequestId(\n          s_provingKeyHashes[j],\n          subConfig.consumers[i],\n          subId,\n          s_consumers[subConfig.consumers[i]][subId]\n        );\n        if (s_requestCommitments[reqId] != 0) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }",
        "@noticeCheck": "to see if there exists a request commitment consumers * for all consumers and keyhashes for a given sub.",
        "@param1": "subId where to send the funds",
        "@return1": "true if outstanding requests",
        "@dev": "Looping is bounded to MAX_CONSUMERS*(number of keyhashes). * Used to disable subscription canceling while outstanding request are present.",
        "@notice": "",
        "@gnotice": "Check if there is a pending request for the given subscription ID",
        "@gparam1": "subId The subscription ID to check for",
        "@greturn1": "A boolean indicating whether or not there is a pending request for the given subscription ID",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function tokenURI(\n    uint256 _tokenId\n  )\n    external\n    override\n    view\n    validNFToken(_tokenId)\n    returns (string memory)\n  {\n    return _tokenURI(_tokenId);\n  }",
        "@notice": "",
        "@dev": "A distinct URI (RFC 3986) for a given NFT.",
        "@param1": "_tokenId Id for which we want uri.",
        "@return1": "URI of _tokenId.",
        "@gnotice": "Returns the Uniform Resource Identifier (URI) for the given token",
        "@gparam1": "_tokenId The ID of the token to retrieve the URI for",
        "@greturn1": "The URI of the given token",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function setMinter(address newMinter) external onlyOwner {\n        minter = newMinter;\n        emit NewMinter(newMinter);\n    }",
        "@notice": "change the contract minter.",
        "@dev": " Allowed only for owner * * Emits a { NewMinter } event",
        "@param1": "newMinter The address of the new minter",
        "@gnotice": "Set a new address to act as the minter of the tokens",
        "@gparam1": "newMinter The address to set as the new minter. This address must have the necessary permissions to mint new tokens.",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }",
        "@dev": "Returns the number of accounts that have `role`. ",
        "@notice": "",
        "@gnotice": "Get the number of members assigned to the `role`",
        "@gparam1": "role The identifier for the role being queried",
        "@greturn1": "The number of members assigned to the `role`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public override allowedDelegate {\n        super.permit(owner, spender, value, deadline, v, r, s);\n    }",
        "@notice": "Update allowance with a signed permit.",
        "@dev": "Allowed only if * the sender is whitelisted, or the delegateMode is set to true",
        "@param1": "owner Token owner's address (Authorizer)",
        "@param2": "spender Spender's address",
        "@param3": "value Amount of allowance",
        "@param4": "deadline Expiration time, seconds since the epoch",
        "@param5": "v v part of the signature",
        "@param6": "r r part of the signature",
        "@param7": "s s part of the signature",
        "@gnotice": "Allows `spender` to spend up to `value` tokens on behalf of `owner` via `delegate`",
        "@gparam1": "owner The address giving permission to `spender` to spend tokens",
        "@gparam2": "spender The address receiving permission to spend tokens",
        "@gparam3": "value The amount of tokens the spender is granted permission to spend",
        "@gparam4": "deadline Time after which the permit is no longer valid",
        "@gparam5": "v Component of the ECDSA signature",
        "@gparam6": "r Component of the ECDSA signature",
        "@gparam7": "s Component of the ECDSA signature",
        "@greturn1": "None",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 1,
        "@tparam5": 0,
        "@tparam6": 0,
        "@tparam7": 0
    },
    {
        "func": "function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }",
        "@dev": "Destroys `amount` tokens from the caller.",
        "@notice": "",
        "@gnotice": "Burn `amount` tokens from the caller's account",
        "@gparam1": "amount The number of tokens to burn",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override returns (bool) {\n        return\n            // ERC165 Interface ID for ERC721TokenReceiver.\n            interfaceId == this.onERC721Received.selector ||\n            // ERC165 Interface ID for ERC1155TokenReceiver.\n            interfaceId == type(ERC1155TokenReceiver).interfaceId ||\n            // ERC165 interface ID for ERC1155MetadataURI.\n            interfaceId == this.uri.selector ||\n            // ERC165 Interface IDs for ERC1155.\n            super.supportsInterface(interfaceId);\n    }",
        "@notice": "If an interface ID is supported",
        "@dev": "ERC165 interface detection.",
        "@param1": "interfaceId ID to check.",
        "@return1": "Fetch detection success.",
        "@gnotice": "Check if the contract implements the specified interface ID `interfaceId`",
        "@gparam1": "interfaceId The interface ID to check for support",
        "@greturn1": "Whether or not the contract implements the specified interface ID. True if the contract implements the interface ID, false otherwise.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 1
    },
    {
        "func": "function supportsInterface(\n    bytes4 _interfaceID\n  )\n    external\n    override\n    view\n    returns (bool)\n  {\n    return supportedInterfaces[_interfaceID];\n  }",
        "@notice": "",
        "@dev": "check which interfaces are suported by this contract.",
        "@param1": "_interfaceID Id of the interface.",
        "@return1": "True if _interfaceID is supported, false otherwise.",
        "@gnotice": "Check if a contract implements an interface",
        "@gparam1": "_interfaceID The interface identifier to check",
        "@greturn1": "Whether or not the contract implements the given interface",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n    external\n    override\n  {\n    _safeTransferFrom(_from, _to, _tokenId, \"\");\n  }",
        "@notice": "Transfers the ownership of an NFT from `_from` to `_to`. ",
        "@dev": "This function can * be changed to payable.",
        "@param1": "_from The current owner of the NFT.",
        "@param2": "_to The new owner.",
        "@param3": "_tokenId The NFT to transfer.",
        "@gnotice": "Safely transfer token with identifier `_tokenId` from `_from` to `_to`.",
        "@gparam1": "_from The address of the current owner of the token",
        "@gparam2": "_to The address of the new owner of the token",
        "@gparam3": "_tokenId The identifier of the token being transferred",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0
    },
    {
        "func": "function reportOutcomes(\n        bytes32[] memory marketHashes,\n        LibOutcome.Outcome[] memory outcomes\n    ) public {\n        uint256 marketHashesLength = marketHashes.length;\n        for (uint256 i = 0; i < marketHashesLength; i++) {\n            reportOutcome(marketHashes[i], outcomes[i]);\n        }\n    }",
        "@notice": "Reports the outcome for several markets.",
        "@param1": "marketHashes The market hashes to report.",
        "@param2": "outcomes The outcomes to report.",
        "@gnotice": "Reports the outcomes for multiple markets",
        "@gparam1": "marketHashes An array of hashed market IDs",
        "@gparam2": "outcomes An array of outcomes for each respective market",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 1
    },
    {
        "func": "function balanceOf(\n    address _owner\n  )\n    external\n    override\n    view\n    returns (uint256)\n  {\n    require(_owner != address(0), ZERO_ADDRESS);\n    return _getOwnerNFTCount(_owner);\n  }",
        "@notice": "Returns the number of NFTs owned by `_owner`.",
        "@dev": "NFTs assigned to the zero address are * considered invalid, and this function throws for queries about the zero address.",
        "@param1": "_owner Address for whom to query the balance.",
        "@return1": "Balance of _owner.",
        "@gnotice": "Gets the balance of the specified address",
        "@gparam1": "_owner The address to query for the balance",
        "@greturn1": "The balance of the specified address",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"ArbitrumCrossDomainForwarder 0.1.0\";\n  }",
        "@notice": "versions: * * - ArbitrumCrossDomainForwarder 0.1.0: initial release",
        "@inheritdoc": "TypeAndVersionInterface",
        "@gnotice": "Get the current version of the contract",
        "@greturn1": "The current version of the contract as a string",
        "@tnotice": 1,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function burn(address account, uint256 amount) external {\n        require(_msgSender() == burner, \"BackedToken: Only burner\");\n        require(account == _msgSender() || account == address(this), \"BackedToken: Cannot burn account\");\n        _burn(account, amount);\n    }",
        "@notice": "burn tokens",
        "@dev": "Allowed only for burner. The burned tokens * must be from the burner (msg.sender), or from the contract itself",
        "@param1": "account The account from which the tokens will be burned",
        "@param2": "amount The amount of tokens to be burned",
        "@gnotice": "Burn `amount` tokens from the `account` address",
        "@gparam1": "account The address from which tokens will be burned",
        "@gparam2": "amount The number of tokens to burn",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function owner() public view returns (address) {\n        return _owner;\n    }",
        "@dev": "Returns the address of the current owner.",
        "@notice": "",
        "@gnotice": "Get the address of the contract owner",
        "@greturn1": "The address of the contract owner",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function conditionalTransitions() public {\n\n        bytes32 next = states[currentStateId].nextStateId;\n        bool stateChanged;\n\n        while (next != 0) {\n            // If one of the next state's conditions is met, go to this state and continue\n            stateChanged = false;\n            for (uint256 i = 0; i < states[next].startConditions.length; i++) {\n                if (states[next].startConditions[i](next)) {\n                    goToNextState();\n                    next = states[next].nextStateId;\n                    stateChanged = true;\n                    break;\n                }\n            }\n            // If none of the next state's conditions are met, then we are in the right current state\n            if (!stateChanged) break;\n        }\n    }",
        "@dev": "transitions the state machine into the state it should currently be in * by taking into account the current conditions and how many further transitions can occur",
        "@notice": "",
        "@gnotice": "This function is used to transition between states based on predefined conditions.",
        "@tnotice": 0,
        "@tdev": 0
    },
    {
        "func": "function setUserPermission(\n        address to,\n        uint256 id,\n        bool on\n    ) public payable virtual {\n        _authorized();\n\n        _setUserPermission(to, id, on);\n    }",
        "@notice": "ID transfer permission setting",
        "@param1": "to Account to set permission for.",
        "@param2": "id ID to set permission for.",
        "@param3": "on Permission setting.",
        "@dev": "This sets account-based ID restriction specifically.",
        "@gnotice": "Sets permission `on` for address `to` on permit `id`",
        "@gparam1": "to The address of the account for which permission is being set",
        "@gparam2": "id The id of the permit being set",
        "@gparam3": "on If `true`, permission is granted. If `false`, permission is revoked.",
        "@tnotice": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tdev": 0
    },
    {
        "func": "function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata _data\n  )\n    external\n    override\n  {\n    _safeTransferFrom(_from, _to, _tokenId, _data);\n  }",
        "@notice": "Transfers the ownership of an NFT from one address to another address. ",
        "@dev": "This function can * be changed to payable.",
        "@param1": "_from The current owner of the NFT.",
        "@param2": "_to The new owner.",
        "@param3": "_tokenId The NFT to transfer.",
        "@param4": "_data Additional data with no specified format, sent in call to `_to`.",
        "@gnotice": "Transfers ownership of the ERC721 token with ID `_tokenId` from `_from` to `_to` performing a safe check to determine if `_to` is a contract and if it is, if it can receive ERC721 tokens. `_data` is additional data that can be sent alongside the transfer.",
        "@gparam1": "_from The address of the current owner of the token",
        "@gparam2": "_to The address of the new owner of the token",
        "@gparam3": "_tokenId The ID of the token being transferred",
        "@gparam4": "_data Additional data that can be sent alongside the transfer",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0
    },
    {
        "func": "function remargin() external override isInitialized() nonReentrant() {\n        return;\n    }",
        "@notice": "Same comment as `emergencyShutdown`. For the sake of simplicity, this will simply exit silently.",
        "@gnotice": "Trigger a remargin event to update the oracle price for the margin trading contract.",
        "@tnotice": 1,
        "@tdev": 0
    },
    {
        "func": "function destroyTokens(address _owner, uint _amount\n    ) onlyController public returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        Transfer(_owner, 0, _amount);\n        return true;\n    }",
        "@notice": "Burns `_amount` tokens from `_owner`",
        "@param1": "_owner The address that will lose the tokens",
        "@param2": "_amount The quantity of tokens to burn",
        "@return1": "True if the tokens are burned correctly",
        "@gnotice": "Destroy `_amount` tokens from the `_owner` account",
        "@gparam1": "_owner The address of the account owning the tokens to be destroyed",
        "@gparam2": "_amount The number of tokens to destroy",
        "@greturn1": "Whether or not the tokens were successfully destroyed",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }",
        "@dev": "total number of tokens in existence",
        "@notice": "",
        "@gnotice": "Get the total supply of tokens",
        "@greturn1": "The total supply of tokens currently in circulation",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function getPlayerInfoByAddress(address _addr)\n        public\n        view\n        returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)\n    {\n        // setup local rID\n        uint256 _rID = rID_;\n\n        if (_addr == address(0))\n        {\n            _addr == msg.sender;\n        }\n        uint256 _pID = pIDxAddr_[_addr];\n\n        return\n        (\n            _pID,                               //0\n            plyr_[_pID].name,                   //1\n            plyrRnds_[_pID][_rID].keys,         //2\n            plyr_[_pID].win,                    //3\n            (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),       //4\n            plyr_[_pID].aff,                    //5\n            plyrRnds_[_pID][_rID].eth           //6\n        );\n    }",
        "@notice": "returns player info based on address.",
        "@dev": "if no address is given, it will * use msg.sender * -functionhash- 0xee0b5d8b",
        "@param1": "_addr address of the player you want to lookup",
        "@return1": "_pID player ID",
        "@return2": "plyr_[_pID].name player name",
        "@return3": "plyrRnds_[_pID][_rID].keys keys owned (current round)",
        "@return4": "plyr_[_pID].win winnings vault",
        "@return5": "general vault",
        "@return6": "plyr_[_pID].aff affiliate vault",
        "@return7": "plyrRnds_[_pID][_rID].eth player round eth",
        "@gnotice": "Get player info based on player address `_addr`",
        "@gparam1": "_addr The address of the player",
        "@greturn1": "_pID The unique player ID",
        "@greturn2": "plyr_[_pID].name The player's name",
        "@greturn3": "plyrRnds_[_pID][_rID].keys The number of keys the player has in the current round",
        "@greturn4": "plyr_[_pID].win The amount of winnings the player has earned",
        "@greturn5": "The sum of the player's general vault and the unmasked earnings up to the last payout round",
        "@greturn6": "plyr_[_pID].aff The ID of the player's referrer",
        "@greturn7": "plyrRnds_[_pID][_rID].eth The amount of Ether contributed by the player to the current round",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0,
        "@treturn2": 0,
        "@treturn3": 0,
        "@treturn4": 0,
        "@treturn5": 0,
        "@treturn6": 0,
        "@treturn7": 0
    },
    {
        "func": "function votingDelay() public pure returns (uint) { return 1; }",
        "@notice": "The delay before voting on a proposal may take place, once proposed // This also helps protect against flash loan attacks because only the vote balance at the proposal start block is considered",
        "@gnotice": "Returns the current voting delay",
        "@greturn1": "The current voting delay value, which is an unsigned integer",
        "@tnotice": 1,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function _grantComp(address recipient, uint amount) public {\n        require(adminOrInitializing(), \"only admin can grant comp\");\n        uint amountLeft = grantCompInternal(recipient, amount);\n        require(amountLeft == 0, \"insufficient comp for grant\");\n        emit CompGranted(recipient, amount);\n    }",
        "@notice": "Transfer COMP to the recipient",
        "@dev": "Note: If there is not enough COMP, we do not perform the transfer all.",
        "@param1": "recipient The address of the recipient to transfer COMP to",
        "@param2": "amount The amount of COMP to (possibly) transfer",
        "@gnotice": "Grants `amount` Comp tokens to `recipient`",
        "@gparam1": "recipient The address of the account receiving the grant",
        "@gparam2": "amount The number of Comp tokens being granted",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function balanceOfUnderlying(address owner)\n        external\n        view\n        returns (uint256)\n    {\n        owner; // Shh\n        delegateToViewAndReturn();\n    }",
        "@notice": "Currently unused. For future compatability",
        "@param1": "owner The address of the account to query",
        "@return1": "The number of underlying tokens owned by `owner`",
        "@gnotice": "Get the balance of underlying asset of the `owner` account",
        "@gparam1": "owner The address of the account to query",
        "@greturn1": "The balance of underlying asset owned by the account.",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }",
        "@dev": "Returns the symbol of the token",
        "@notice": "",
        "@gnotice": "Get the token symbol",
        "@greturn1": "The symbol of the token",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function getSkipRemainingVotingThresholdCount() public view returns (uint96) {\n        LibDiamondStorageDerivaDEX.DiamondStorageDerivaDEX storage dsDerivaDEX =\n            LibDiamondStorageDerivaDEX.diamondStorageDerivaDEX();\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n\n        uint96 totalSupply = dsDerivaDEX.ddxToken.totalSupply().safe96(\"Governance: amount exceeds 96 bits\");\n        return totalSupply.proportion96(dsGovernance.skipRemainingVotingThreshold, 100);\n    }",
        "@notice": "gets the quorum vote count given the * quorum vote percentage relative to the total DDX supply.",
        "@return1": "Quorum vote count.",
        "@gnotice": "Returns the count of voters who can skip the remaining voting threshold",
        "@greturn1": "The count of voters who can skip the remaining voting threshold",
        "@tnotice": 0,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function Whitelistable(address _admin) public validAdmin(_admin) {\n        whitelistAdmin = _admin;        \n    }",
        "@dev": "Constructor for Whitelistable contract",
        "@param1": "_admin the address of the admin that will generate the signatures",
        "@notice": "",
        "@gnotice": "Constructor for Whitelistable contract, sets `whitelistAdmin` to `_admin`",
        "@gparam1": "_admin The address of the admin account to set as `whitelistAdmin`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function updateRate(string _symbol, uint _rate) public onlyOwner {\n    rates[sha3(_symbol)] = _rate;\n    RateUpdated(now, sha3(_symbol), _rate);\n  }",
        "@notice": "",
        "@dev": "update a single rate.",
        "@param1": "_symbol The symbol to be updated.",
        "@param2": "_rate the rate for the symbol.",
        "@gnotice": "Update the exchange rate for a given symbol",
        "@gparam1": "_symbol The symbol whose exchange rate is being updated",
        "@gparam2": "_rate The new exchange rate for the given symbol",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }",
        "@dev": "Upgrade the implementation of the proxy.",
        "@notice": "",
        "@gnotice": "Upgrade the implementation contract to a new address",
        "@gparam1": "newImplementation The address of the new implementation contract",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function cancelWager(uint256 _wagerId) external nonReentrant {\n        Wager memory wager = wagers[_wagerId];\n        if (wager.isClosed) revert WagerAlreadyClosed();\n        if (msg.sender != wager.userA && msg.sender != wager.userB)\n            revert UnauthorizedSender();\n        if (wager.isFilled) revert WagerAlreadyFilled();\n\n        wagers[_wagerId].isClosed = true;\n\n        if (\n            wager.paymentToken ==\n            address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n        ) {\n            _transfer(payable(wager.userA), wager.amountUserA);\n        } else {\n            IERC20(wager.paymentToken).safeTransfer(\n                wager.userA,\n                wager.amountUserA\n            );\n        }\n        emit WagerCancelled(_wagerId, msg.sender);\n    }",
        "@notice": "Cancels a wager that has not been filled",
        "@dev": "Fee is not refunded if wager was created as p2m",
        "@param1": "_wagerId id of the wager",
        "@gnotice": "Cancel a specified wager",
        "@gparam1": "_wagerId The ID of the wager to be cancelled",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function setDelegateMode(bool _delegateMode) external onlyOwner {\n        delegateMode = _delegateMode;\n\n        emit DelegateModeChange(_delegateMode);\n    }",
        "@notice": "",
        "@dev": "EIP-712 Function to change the contract delegate mode. Allowed * only for owner * * Emits a { DelegateModeChange } event",
        "@param1": "_delegateMode The new delegate mode for the contract",
        "@gnotice": "Sets the delegate mode to `_delegateMode`",
        "@gparam1": "_delegateMode Whether or not to enable delegate mode",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function burnFor(address from, uint256 amount) external override {\n        if (msg.sender != from && !_superOperators[msg.sender]) {\n            uint256 currentAllowance = _allowances[from][msg.sender];\n            if (currentAllowance != ~uint256(0)) {\n                require(currentAllowance >= amount, \"NOT_AUTHOIZED_ALLOWANCE\");\n                _allowances[from][msg.sender] = currentAllowance - amount;\n            }\n        }\n        _burn(from, amount);\n    }",
        "@notice": "burn `amount` tokens from `owner`.",
        "@param1": "from address whose token is to burn.",
        "@param2": "amount the number of token to burn.",
        "@gnotice": "Burn `amount` tokens from the `from` account",
        "@gparam1": "from The address of the account to burn tokens from",
        "@gparam2": "amount The number of tokens to burn",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function setDAIEnabled(bool enabled) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _daiEnabled = enabled;\n    }",
        "@notice": "Enable / disable DAI payment for StarterPacks",
        "@param1": "enabled Whether to enable or disable",
        "@gnotice": "Enables or disables the use of DAI token in the platform",
        "@gparam1": "enabled A boolean indicating whether to enable or disable the use of DAI token",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function _supportMarket(CToken cToken) external returns (uint) {\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n        }\n\n        if (markets[address(cToken)].isListed) {\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n        }\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n        // Note that isComped is not in active use anymore\n        markets[address(cToken)] = Market({isListed: true, isComped: false, collateralFactorMantissa: 0});\n\n        _addMarketInternal(address(cToken));\n\n        emit MarketListed(cToken);\n\n        return uint(Error.NO_ERROR);\n    }",
        "@notice": "Add the market to the markets mapping and set it as listed",
        "@dev": "Admin function to set isListed and add support for the market",
        "@param1": "cToken The address of the market (token) to list",
        "@return1": "uint 0=success, otherwise a failure. (See enum Error for details)",
        "@gnotice": "Adds a new market corresponding to `cToken`",
        "@gparam1": "cToken The address of the cToken contract to list",
        "@greturn1": "An error code indicating success or failure",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function raiseFlag(address subject) external override {\n    require(_allowedToRaiseFlags(), \"Not allowed to raise flags\");\n\n    _tryToRaiseFlag(subject);\n  }",
        "@notice": "enable the warning flag for an address.",
        "@param1": "subject The contract address whose flag is being raised",
        "@gnotice": "raise a flag for the given `subject`",
        "@gparam1": "subject The address of the subject for whom flag needs to be raised",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"OptimismCrossDomainForwarder 0.1.0\";\n  }",
        "@notice": "versions: * * - OptimismCrossDomainForwarder 0.1.0: initial release",
        "@inheritdoc": "TypeAndVersionInterface",
        "@gnotice": "Returns the type and version of the contract",
        "@greturn1": "A string indicating the type and version",
        "@tnotice": 1,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function votingDelay() public pure returns (uint) { return 1; }",
        "@notice": "The delay before voting on a proposal may take place, once proposed // This also helps protect against flash loan attacks because only the vote balance at the proposal start block is considered",
        "@gnotice": "Returns the delay (in block numbers) required for a newly created proposal to be voted on",
        "@greturn1": "The delay (in block numbers)",
        "@tnotice": 1,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        // Convert amount to uint96\n        uint96 amount;\n        if (_amount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_amount, \"DDX: amount exceeds 96 bits.\");\n        }\n\n        // Transfer tokens from sender to recipient\n        _transferTokens(msg.sender, _recipient, amount);\n        return true;\n    }",
        "@notice": "Transfer `amount` tokens from `msg.sender` to `dst`",
        "@param1": "_recipient The address of the destination account",
        "@param2": "_amount The number of tokens to transfer",
        "@return1": "Whether or not the transfer succeeded",
        "@gnotice": "Transfer `_amount` tokens from `msg.sender` to `_recipient`",
        "@gparam1": "_recipient The address of the destination account",
        "@gparam2": "_amount The number of tokens to transfer, which cannot exceed 96 bits",
        "@greturn1": "Whether or not the transfer succeeded",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function _setMarketBorrowCaps(CToken[] calldata cTokens, uint[] calldata newBorrowCaps) external {\n    \trequire(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\"); \n\n        uint numMarkets = cTokens.length;\n        uint numBorrowCaps = newBorrowCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n        for(uint i = 0; i < numMarkets; i++) {\n            borrowCaps[address(cTokens[i])] = newBorrowCaps[i];\n            emit NewBorrowCap(cTokens[i], newBorrowCaps[i]);\n        }\n    }",
        "@notice": "set the borrow caps.",
        "@dev": "A borrow cap of 0 corresponds to unlimited borrowing.",
        "@param1": "cTokens The addresses of the markets to change the borrow caps for",
        "@param2": "newBorrowCaps The new borrow cap values in underlying to be set.",
        "@gnotice": "Sets borrow caps for multiple markets",
        "@gparam1": "cTokens An array of `CToken` addresses to set the borrow caps for",
        "@gparam2": "newBorrowCaps An array of new borrow caps for the corresponding `cTokens`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function getOrderStatus(\n        LibOrder.Order memory order,\n        bytes memory makerSig\n    )\n        public\n        view\n        returns (string memory)\n    {\n        string memory baseMakerOrderStatus = getBaseOrderStatus(\n            order,\n            makerSig\n        );\n        if (!baseMakerOrderStatus.equals(\"OK\")) {return baseMakerOrderStatus;}\n        uint256 remainingSpace = fills.remainingSpace(order);\n        if (remainingSpace == 0) {\n            return \"FULLY_FILLED\";\n        }\n        LibOrderAmounts.OrderAmounts memory orderAmounts = LibOrderAmounts.computeOrderAmounts(\n            order,\n            remainingSpace\n        );\n        string memory allowanceBalanceValidity = getMakerAllowanceAndBalanceStatus(\n            orderAmounts,\n            order.baseToken,\n            order.maker\n        );\n        return allowanceBalanceValidity;\n    }",
        "@notice": "Gets the current status of an order without considering /// any individual taker.",
        "@param1": "order The order to examine.",
        "@param2": "makerSig The signature of maker on this order.",
        "@return1": "representing the status.",
        "@gnotice": "Get the status of an order",
        "@gparam1": "order The order information",
        "@gparam2": "makerSig The signature provided by the maker of the order",
        "@greturn1": "The status of the order. Possible statuses include \"OK\", \"MAKER_SIGNATURE_INVALID\", \"FULLY_FILLED\", and messages related to allowance and balance of the maker account.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function isApprovedForAll(\n    address _owner,\n    address _operator\n  )\n    external\n    override\n    view\n    returns (bool)\n  {\n    return ownerToOperators[_owner][_operator];\n  }",
        "@notice": "",
        "@dev": "Checks if `_operator` is an approved operator for `_owner`.",
        "@param1": "_owner The address that owns the NFTs.",
        "@param2": "_operator The address that acts on behalf of the owner.",
        "@return1": "True if approved for all, false otherwise.",
        "@gnotice": "Check if `_operator` is approved to manage all assets of `_owner`",
        "@gparam1": "_owner The address of the owner of the assets",
        "@gparam2": "_operator The address of the operator",
        "@greturn1": "Whether or not `_operator` is approved to manage all assets of `_owner`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function withdrawFundsTo(address payable recipient) external onlyOwner {\n    uint256 amount = address(this).balance;\n    Address.sendValue(recipient, amount);\n  }",
        "@notice": "withdraws all funds available in this contract to the address specified",
        "@dev": "only owner can call this",
        "@param1": "recipient address where to send the funds",
        "@gnotice": "Withdraws the entire contract balance and sends it to `recipient`",
        "@gparam1": "recipient The address that will receive the contract balance",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function newContract(address payable _receiver, bytes32 _hashlock, uint _timelock)\n        external\n        payable\n        fundsSent\n        futureTimelock(_timelock)\n        returns (bytes32 contractId)\n    {\n        contractId = sha256(\n            abi.encodePacked(\n                msg.sender,\n                _receiver,\n                msg.value,\n                _hashlock,\n                _timelock\n            )\n        );\n\n        // Reject if a contract already exists with the same parameters. The\n        // sender must change one of these parameters to create a new distinct\n        // contract.\n        if (haveContract(contractId))\n            revert(\"Contract already exists\");\n\n        contracts[contractId] = LockContract(\n            msg.sender,\n            _receiver,\n            msg.value,\n            _hashlock,\n            _timelock,\n            false,\n            false,\n            0x0\n        );\n\n        emit LogHTLCNew(\n            contractId,\n            msg.sender,\n            _receiver,\n            msg.value,\n            _hashlock,\n            _timelock\n        );\n    }",
        "@notice": "",
        "@dev": "Sender sets up a new hash time lock contract depositing the ETH and * providing the reciever lock terms.",
        "@param1": "_receiver Receiver of the ETH.",
        "@param2": "_hashlock A sha-2 sha256 hash hashlock.",
        "@param3": "_timelock UNIX epoch seconds time that the lock expires at.",
        "@return1": "contractId Id of the new HTLC.",
        "@gnotice": "Creates a new Hashed TimeLock Contract with the specified parameters",
        "@gparam1": "_receiver The address of the destination account for the contract",
        "@gparam2": "_hashlock The hash of the preimage that releases the funds",
        "@gparam3": "_timelock The UNIX timestamp for when the contract can be executed",
        "@greturn1": "The unique identifier for the new Contract",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 1,
        "@tparam2": 1,
        "@tparam3": 1,
        "@treturn1": 0
    },
    {
        "func": "function getPriorVotes(address account, uint256 blockNumber)\n        public\n        view\n        returns (uint96)\n    {\n        require(\n            blockNumber < block.number,\n            \"Comp::getPriorVotes: not yet determined\"\n        );\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }",
        "@notice": "Determine the prior number of votes for an account as of a block number",
        "@dev": "Block number must be a finalized block or else this function will revert to prevent misinformation.",
        "@param1": "account The address of the account to check",
        "@param2": "blockNumber The block number to get the vote balance at",
        "@return1": "The number of votes the account had as of the given block",
        "@gnotice": "Gets the prior voting power of `account` at a specific `block Number`",
        "@gparam1": "account The address of the voter",
        "@gparam2": "blockNumber The block number for which to get the voting power",
        "@greturn1": "The prior voting power of `account` at `blockNumber`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function setSanctionsList(address newSanctionsList) external onlyOwner {\n        // Check the proposed sanctions list contract has the right interface:\n        require(!SanctionsList(newSanctionsList).isSanctioned(address(this)), \"BackedToken: Wrong List interface\");\n\n        sanctionsList = SanctionsList(newSanctionsList);\n        emit NewSanctionsList(newSanctionsList);\n    }",
        "@notice": "change the contract Senctions List",
        "@dev": "Allowed only for owner * * Emits a { NewSanctionsList } event",
        "@param1": "newSanctionsList The address of the new Senctions List following the Chainalysis standard",
        "@gnotice": "Set a new Sanctions List contract address",
        "@gparam1": "newSanctionsList The address of the new SanctionsList contract",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function addAuthorized(address _addr) external onlyAuthorized {\n    authorizerIndex[_addr] = authorizers.length;\n    authorizers.length++;\n    authorizers[authorizers.length - 1] = _addr;\n  }",
        "@notice": "",
        "@dev": "add a new authorizer",
        "@param1": "_addr the address to add as a new authorizer.",
        "@gnotice": "Adds `_addr` to the list of authorized addresses",
        "@gparam1": "_addr The address to add to the list of authorized addresses",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\n        require(blockNumber < block.number, \"FXS::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }",
        "@notice": "Determine the prior number of votes for an account as of a block number",
        "@dev": "Block number must be a finalized block or else this function will revert to prevent misinformation.",
        "@param1": "account The address of the account to check",
        "@param2": "blockNumber The block number to get the vote balance at",
        "@return1": "The number of votes the account had as of the given block",
        "@gnotice": "Get the prior number of votes for `account` as of a given `blockNumber`",
        "@gparam1": "account The address to get the vote balance of",
        "@gparam2": "blockNumber The block number to get the vote balance at",
        "@greturn1": "The number of votes the account had as of the given block number",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n        }\n\n        // Save current value for use in log\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n        // Set liquidation incentive to new incentive\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n        // Emit event with old incentive, new incentive\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n        return uint(Error.NO_ERROR);\n    }",
        "@notice": "Sets liquidationIncentive",
        "@dev": "Admin function to set liquidationIncentive",
        "@param1": "newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18",
        "@return1": "uint 0=success, otherwise a failure. (See ErrorReporter for details)",
        "@gnotice": "Sets the liquidation incentive (`newLiquidationIncentiveMantissa`) for the contract",
        "@gparam1": "newLiquidationIncentiveMantissa The new value for the liquidation incentive",
        "@greturn1": "An unsigned integer representing an error code (0 on success)",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 1
    },
    {
        "func": "function setPauser(address newPauser) external onlyOwner {\n        pauser = newPauser;\n        emit NewPauser(newPauser);\n    }",
        "@notice": "change the contract pauser",
        "@dev": "Allowed only for owner * * Emits a { NewPauser } event",
        "@param1": "newPauser The address of the new pauser",
        "@gnotice": "Set the address of the Pauser to `newPauser`",
        "@gparam1": "newPauser The new address of the Pauser contract or account. The caller must have the `owner` role.",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function addAddressToWhitelist(address operator)\n        public\n        onlySuperAdmin(msg.sender)\n    {\n        whitelisted[operator] = true;\n    }",
        "@notice": "Adds an operator to the whitelist /// Only callable by the SuperAdmin role.",
        "@param1": "operator The operator to add.",
        "@gnotice": "Adds `operator` address to the whitelist, which allows them to perform certain actions.",
        "@gparam1": "operator The address to be added to the whitelist. Only a super admin can add an operator to the whitelist.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function requestTransferPosition() public onlyPreExpiration() nonReentrant() {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.transferPositionRequestPassTimestamp == 0);\n\n        // Make sure the proposed expiration of this request is not post-expiry.\n        uint256 requestPassTime = getCurrentTime().add(withdrawalLiveness);\n        require(requestPassTime < expirationTimestamp);\n\n        // Update the position object for the user.\n        positionData.transferPositionRequestPassTimestamp = requestPassTime;\n\n        emit RequestTransferPosition(msg.sender);\n    }",
        "@notice": "Requests to transfer ownership of the caller's current position to a new sponsor address. * Once the request liveness is passed, the sponsor can execute the transfer and specify the new sponsor.",
        "@dev": "The liveness length is the same as the withdrawal liveness.",
        "@gnotice": "request to transfer their position to a new owner before expiration.",
        "@tnotice": 0,
        "@tdev": 0
    },
    {
        "func": "function setApprovalForAll(\n    address _operator,\n    bool _approved\n  )\n    external\n    override\n  {\n    ownerToOperators[msg.sender][_operator] = _approved;\n    emit ApprovalForAll(msg.sender, _operator, _approved);\n  }",
        "@notice": "This works even if sender doesn't own any tokens at the time",
        "@dev": "Enables or disables approval for a third party (\"operator\") to manage all of * `msg.sender`'s assets. It also emits the ApprovalForAll event.",
        "@param1": "_operator Address to add to the set of authorized operators.",
        "@param2": "_approved True if the operators is approved, false to revoke approval.",
        "@gnotice": "Set approval for `_operator` to operate on all tokens of the `msg.sender`",
        "@gparam1": "_operator The operator address that `msg.sender` wants to give approval to",
        "@gparam2": "_approved Whether or not the operator is approved",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function calculateLastTick(string memory cronString) external view returns (uint256) {\n    return CronInternal.lastTick(CronInternal.toSpec(cronString));\n  }",
        "@notice": "calculates the last time a cron job \"ticked\". * This should only be called off-chain, as it is gas expensive!",
        "@param1": "cronString the cron string to consider",
        "@return1": "the timestamp in UTC of the last \"tick\"",
        "@gnotice": "Calculate the last tick time for the given cron string",
        "@gparam1": "cronString The cron string to calculate the last tick for",
        "@greturn1": "The timestamp of the last tick",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function getApproved(\n    uint256 _tokenId\n  )\n    external\n    override\n    view\n    validNFToken(_tokenId)\n    returns (address)\n  {\n    return idToApproval[_tokenId];\n  }",
        "@notice": "",
        "@dev": "Get the approved address for a single NFT.",
        "@param1": "_tokenId ID of the NFT to query the approval of.",
        "@return1": "Address that _tokenId is approved for.",
        "@gnotice": "Returns the approved address for a specific NFT",
        "@gparam1": "_tokenId uint256 ID of the NFT",
        "@greturn1": "The approved address for the specified NFT",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, allowance[_msgSender()][spender] - subtractedValue);\n        return true;\n    }",
        "@dev": "decreases the allowance granted to `spender` by the caller.",
        "@notice": "",
        "@gnotice": "Decreases the allowance granted to `spender` by the caller's own account by `subtractedValue`",
        "@gparam1": "spender The address of the account to which the allowance is being granted",
        "@gparam2": "subtractedValue The amount by which the allowance will be decreased",
        "@greturn1": "Whether or not the operation was successful",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function paused() public view virtual returns (bool) {\n        return _paused;\n    }",
        "@dev": "Returns true if the contract is paused, and false otherwise.",
        "@notice": "",
        "@gnotice": "Returns whether the contract is paused or not",
        "@greturn1": "`true` if the contract is paused, `false` otherwise",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }",
        "@dev": "Destroys `amount` tokens from `account`",
        "@notice": "",
        "@gnotice": "Burn `amount` tokens from `account` after checking the allowance",
        "@gparam1": "account The address of the account to burn tokens from",
        "@gparam2": "amount The number of tokens to burn",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function approve(address spender, uint256 rawAmount)\n        external\n        returns (bool)\n    {\n        uint96 amount;\n        if (rawAmount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(rawAmount, \"Comp::approve: amount exceeds 96 bits\");\n        }\n\n        allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }",
        "@notice": "Approve `spender` to transfer up to `amount` from `src`",
        "@dev": "This will overwrite the approval amount for `spender` * and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)",
        "@param1": "spender The address of the account which may transfer tokens",
        "@param2": "rawAmount The number of tokens that are approved",
        "@return1": "Whether or not the approval succeeded",
        "@gnotice": "Approve the `spender` to transfer up to `rawAmount` tokens from the `msg.sender` account",
        "@gparam1": "spender The address authorized to spend the tokens",
        "@gparam2": "rawAmount The maximum number of tokens that can be spent",
        "@greturn1": "Whether or not the approval succeeded",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"Flags 1.1.0\";\n  }",
        "@notice": "versions: * * - Flags 1.1.0: upgraded to solc 0.8, added lowering access controller * - Flags 1.0.0: initial release",
        "@inheritdoc": "TypeAndVersionInterface",
        "@gnotice": "Get the type and version of the contract",
        "@greturn1": "A string representing the type and version of the contract",
        "@tnotice": 1,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function stakeToInsuranceFund(bytes32 _collateralName, uint96 _amount) external insuranceMiningOngoing isNotPaused {\n        LibDiamondStorageInsuranceFund.DiamondStorageInsuranceFund storage dsInsuranceFund =\n            LibDiamondStorageInsuranceFund.diamondStorageInsuranceFund();\n\n        // Obtain the collateral struct for the collateral type\n        // participant is staking\n        InsuranceFundDefs.StakeCollateral storage stakeCollateral = dsInsuranceFund.stakeCollaterals[_collateralName];\n\n        // Ensure this is a supported collateral type and that the user\n        // has approved the proxy contract for transfer\n        require(stakeCollateral.collateralToken != address(0), \"IFund: invalid collateral.\");\n\n        // Ensure non-zero stake amount\n        require(_amount > 0, \"IFund: non-zero amount.\");\n\n        // Claim DDX for staking user. We do this prior to the stake\n        // taking effect, thereby preventing someone from being rewarded\n        // instantly for the stake.\n        claimDDXFromInsuranceMining(msg.sender);\n\n        // Increment the underlying capitalization\n        stakeCollateral.cap = stakeCollateral.cap.add96(_amount);\n\n        // Transfer collateral amount from user to proxy contract\n        IERC20(stakeCollateral.collateralToken).safeTransferFrom(msg.sender, address(this), _amount);\n\n        // Mint DIFund tokens to user\n        stakeCollateral.diFundToken.mint(msg.sender, _amount);\n\n        emit StakedToInsuranceFund(msg.sender, _amount, _collateralName);\n    }",
        "@notice": "This function allows participants to stake a supported * collateral type to the insurance fund.",
        "@param1": "_collateralName Name of collateral.",
        "@param2": "_amount Amount to stake.",
        "@gnotice": "Stake `_amount` collateral tokens of type `_collateralName` to the insurance fund",
        "@gparam1": "_collateralName The name of the collateral token being staked",
        "@gparam2": "_amount The amount of collateral tokens being staked",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function remargin() external override isInitialized() nonReentrant() {\n        return;\n    }",
        "@notice": "Same comment as `emergencyShutdown`. For the sake of simplicity, this will simply exit silently.",
        "@gnotice": "Adjusts the margin of the current position based on the current market conditions",
        "@tnotice": 1,
        "@tdev": 0
    },
    {
        "func": "function changeAdmin(address newAdmin) external ifAdmin {\n        require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n        emit AdminChanged(_admin(), newAdmin);\n        _setAdmin(newAdmin);\n    }",
        "@dev": "Changes the admin of the proxy.",
        "@param1": "newAdmin Address to transfer proxy administration to.",
        "@notice": "",
        "@gnotice": "Change the admin of the contract to `newAdmin`",
        "@gparam1": "newAdmin The address of the new admin account",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function holdsRole(uint256 roleId, address memberToCheck) public view returns (bool) {\n        Role storage role = roles[roleId];\n        if (role.roleType == RoleType.Exclusive) {\n            return role.exclusiveRoleMembership.isMember(memberToCheck);\n        } else if (role.roleType == RoleType.Shared) {\n            return role.sharedRoleMembership.isMember(memberToCheck);\n        }\n        revert(\"Invalid roleId\");\n    }",
        "@notice": "Whether `memberToCheck` is a member of roleId.",
        "@dev": "Reverts if roleId does not correspond to an initialized role.",
        "@param1": "roleId the Role to check.",
        "@param2": "memberToCheck the address to check.",
        "@return1": "True if `memberToCheck` is a member of `roleId`.",
        "@gnotice": "Check if `memberToCheck` is a member of the role `roleId`",
        "@gparam1": "roleId The ID of the role to check membership for",
        "@gparam2": "memberToCheck The address of the account to check membership for",
        "@greturn1": "`true` if `memberToCheck` is a member of the role `roleId`, `false` otherwise",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function upgradeToAndCall(address newImplementation, bytes calldata data)\n    external\n    payable\n    ifAdmin\n  {\n    _upgradeTo(newImplementation);\n    (bool success, ) = newImplementation.delegatecall(data);\n    require(success);\n  }",
        "@notice": "Upgrade the backing implementation of the proxy and call a function * on the new implementation.",
        "@dev": "This is useful to initialize the proxied contract.",
        "@param1": "newImplementation The address of the new implementation.",
        "@param2": "data Data to send as msg.data in the low level call. * It should include the signature and the parameters of the function to be called, as described in * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.",
        "@gnotice": "Upgrades the contract to a new implementation address and calls its function with the provided `data` parameter",
        "@gparam1": "newImplementation The address of the new implementation contract",
        "@gparam2": "data The data to be passed to the function in the new implementation contract",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function sellLeftoverCompoundOrder(address payable _orderAddress) public {\n        (bool success, ) = peakdefiLogic2.delegatecall(\n            abi.encodeWithSelector(\n                this.sellLeftoverCompoundOrder.selector,\n                _orderAddress\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "@notice": "Sells CompoundOrder left over due to manager not selling or KyberNetwork not having enough volume. Callable by anyone. Money goes to developer.",
        "@param1": "_orderAddress address of the CompoundOrder to be sold",
        "@gnotice": "Sell leftover Compound finance order",
        "@gparam1": "_orderAddress The address of the Compound order to be sold",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function setPause(bool newPauseMode) external {\n        require(_msgSender() == pauser, \"BackedToken: Only pauser\");\n        isPaused = newPauseMode;\n        emit PauseModeChange(newPauseMode);\n    }",
        "@notice": "set the pause in order to block or restore all transfers.",
        "@dev": " Allowed only for pauser * * Emits a { PauseModeChange } event",
        "@param1": "newPauseMode The new pause mode",
        "@gnotice": "Sets the pause state of the contract",
        "@gparam1": "newPauseMode The new pause state to set: `true` for paused state, `false` for unpaused state. The function can only be called by the contract's `pauser`.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function setPermission(uint256 id, bool on) public payable virtual {\n        _authorized();\n\n        _setPermission(id, on);\n    }",
        "@notice": "ID transfer permission toggle",
        "@param1": "id ID to set permission for.",
        "@param2": "on Permission setting.",
        "@dev": "This sets account-based ID restriction globally.",
        "@gnotice": "Set permission for a given `id` to `on`",
        "@gparam1": "id The identifier of the permission to be set",
        "@gparam2": "on Whether the permission should be enabled (true) or disabled (false)",
        "@tnotice": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tdev": 0
    },
    {
        "func": "function accumulativeDividendOf(address _owner) public view override returns(uint256) {\n        return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()\n        .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;\n    }",
        "@notice": "the amount of dividend in wei that an address has earned in total",
        "@dev": "accumulativeDividendOf(_owner) = withdrawableDividendOf(_owner) + withdrawnDividendOf(_owner) /// = (magnifiedDividendPerShare * balanceOf(_owner) + magnifiedDividendCorrections[_owner]) / magnitude",
        "@param1": "_owner The address of a token holder.",
        "@return1": "The amount of dividend `_owner` earned.",
        "@gnotice": "Get the accumulative dividend of `_owner`",
        "@gparam1": "_owner The address of the account to get the accumulative dividend for",
        "@greturn1": "The accumulative dividend of `_owner`",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function withdraw(\n        uint256 shares,\n        uint256 amountEthMin,\n        uint256 amountUsdcMin,\n        uint256 amountOsqthMin\n    ) external override nonReentrant {\n        require(shares > 0, \"C5\");\n\n        uint256 _totalSupply = totalSupply();\n\n        //Burn shares\n        _burn(msg.sender, shares);\n\n        //withdraw user share of tokens from lp positions in the current proportion\n        (uint256 amountUsdc, uint256 amountEth0) = IVaultMath(vaultMath).burnLiquidityShare(\n            Constants.poolEthUsdc,\n            IVaultStorage(vaultStorage).orderEthUsdcLower(),\n            IVaultStorage(vaultStorage).orderEthUsdcUpper(),\n            shares,\n            _totalSupply\n        );\n\n        (uint256 amountEth1, uint256 amountOsqth) = IVaultMath(vaultMath).burnLiquidityShare(\n            Constants.poolEthOsqth,\n            IVaultStorage(vaultStorage).orderOsqthEthLower(),\n            IVaultStorage(vaultStorage).orderOsqthEthUpper(),\n            shares,\n            _totalSupply\n        );\n\n        uint256 amountEth = amountEth0 + amountEth1;\n\n        require(amountEth != 0 || amountUsdc != 0 || amountOsqth != 0, \"C6\");\n\n        require(amountEth >= amountEthMin, \"C7\");\n        require(amountUsdc >= amountUsdcMin, \"C8\");\n        require(amountOsqth >= amountOsqthMin, \"C9\");\n\n        //send tokens to user\n        if (amountEth > 0) IVaultTreasury(vaultTreasury).transfer(Constants.weth, msg.sender, amountEth);\n        if (amountUsdc > 0) IVaultTreasury(vaultTreasury).transfer(Constants.usdc, msg.sender, amountUsdc);\n        if (amountOsqth > 0) IVaultTreasury(vaultTreasury).transfer(Constants.osqth, msg.sender, amountOsqth);\n\n        emit SharedEvents.Withdraw(msg.sender, shares, amountEth, amountUsdc, amountOsqth);\n    }",
        "@notice": "withdraws tokens in proportion to the vault's holdings",
        "@dev": "provide strategy tokens, returns set of ETH, USDC, and oSQTH",
        "@param1": "shares shares burned by sender",
        "@param2": "amountEthMin revert if resulting amount of ETH is smaller than this",
        "@param3": "amountUsdcMin revert if resulting amount of USDC is smaller than this",
        "@param4": "amountOsqthMin revert if resulting amount of oSQTH is smaller than this",
        "@gnotice": "Withdraws `shares` amount of lp tokens, and returns the proportional share of tokens from the lp positions in the specified proportions to the caller",
        "@gparam1": "shares The number of lp tokens to withdraw",
        "@gparam2": "amountEthMin The minimum amount of ETH to receive from the withdrawal",
        "@gparam3": "amountUsdcMin The minimum amount of USDC to receive from the withdrawal",
        "@gparam4": "amountOsqthMin The minimum amount of OSQTH to receive from the withdrawal",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0
    },
    {
        "func": "function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }",
        "@dev": "Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.",
        "@param1": "_spender The address which will spend the funds.",
        "@param2": "_value The amount of tokens to be spent.",
        "@notice": "",
        "@gnotice": "Approve the passed address to spend the specified amount of tokens on behalf of `msg.sender`",
        "@gparam1": "_spender The address which will spend the funds",
        "@gparam2": "_value The amount of tokens to be spent",
        "@greturn1": "Whether or not the approval succeeded",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function transferOwnership(\n    address _newOwner\n  )\n    public\n    onlyOwner\n  {\n    require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }",
        "@notice": "",
        "@dev": "transfer control of the contract to a newOwner.",
        "@param1": "_newOwner The address to transfer ownership to.",
        "@gnotice": "Transfer ownership of the contract to `_newOwner`",
        "@gparam1": "_newOwner The address of the new contract owner, must not be a zero address.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function setBurner(address newBurner) external onlyOwner {\n        burner = newBurner;\n        emit NewBurner(newBurner);\n    }",
        "@notice": "change the contract burner.",
        "@dev": "Allowed only for owner * * Emits a { NewBurner } event",
        "@param1": "newBurner The address of the new burner",
        "@gnotice": "Set the address of the burner to `newBurner`",
        "@gparam1": "newBurner The new burner address",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)\n        isActivated()\n        isHuman()\n        isWithinLimits(_eth)\n        public\n    {\n        // set up our tx event data\n        F3Ddatasets.EventReturns memory _eventData_;\n\n        // fetch player ID\n        uint256 _pID = pIDxAddr_[msg.sender];\n\n        // manage affiliate residuals\n        // if no affiliate code was given or player tried to use their own, lolz\n        if (_affCode == 0 || _affCode == _pID)\n        {\n            // use last stored affiliate code\n            _affCode = plyr_[_pID].laff;\n\n        // if affiliate code was given & its not the same as previously stored\n        } else if (_affCode != plyr_[_pID].laff) {\n            // update last affiliate\n            plyr_[_pID].laff = _affCode;\n        }\n\n        // verify a valid team was selected\n        _team = verifyTeam(_team);\n\n        // reload core\n        reLoadCore(_pID, _affCode, _team, _eth, _eventData_);\n    }",
        "@notice": "",
        "@dev": "essentially the same as buy, but instead of you sending ether * from your wallet, it uses your unwithdrawn earnings. * -functionhash- 0x349cdcac (using ID for affiliate) * -functionhash- 0x82bfc739 (using address for affiliate) * -functionhash- 0x079ce327 (using name for affiliate)",
        "@param1": "_affCode the ID of the player who gets the affiliate fee",
        "@param2": "_team what team is the player playing for?",
        "@param3": "_eth amount of earnings to use",
        "@gnotice": "Reload `Xid` smart contract with `_eth` value and update player's affiliate and team",
        "@gparam1": "_affCode The affiliate ID for the player",
        "@gparam2": "_team The ID of the team player selects",
        "@gparam3": "_eth The ether value for reload",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 1,
        "@tparam3": 1
    },
    {
        "func": "function withdraw(bytes32 _contractId, bytes32 _preimage)\n        external\n        contractExists(_contractId)\n        hashlockMatches(_contractId, _preimage)\n        withdrawable(_contractId)\n        returns (bool)\n    {\n        LockContract storage c = contracts[_contractId];\n        c.preimage = _preimage;\n        c.withdrawn = true;\n        c.receiver.transfer(c.amount);\n        emit LogHTLCWithdraw(_contractId);\n        return true;\n    }",
        "@notice": "",
        "@dev": "Called by the receiver once they know the preimage of the hashlock. * This will transfer the locked funds to their address.",
        "@param1": "_contractId Id of the HTLC.",
        "@param2": "_preimage sha256(_preimage) should equal the contract hashlock.",
        "@return1": "bool true on success",
        "@gnotice": "Withdraws the locked funds of an Hash Time Locked Contract with `_contractId`",
        "@gparam1": "_contractId The identifier of the HTLC",
        "@gparam2": "_preimage The preimage for unlocking the HTLC",
        "@greturn1": "Whether or not the withdrawal succeeded",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 1,
        "@treturn1": 0
    },
    {
        "func": "function delegatedTransfer(\n        address owner,\n        address to,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public override allowedDelegate {\n        super.delegatedTransfer(owner, to, value, deadline, v, r, s);\n    }",
        "@notice": "Perform an intended transfer on one account's behalf, from another account, * who actually pays fees for the transaction. ",
        "@dev": "Allowed only if the sender * is whitelisted, or the delegateMode is set to true",
        "@param1": "owner The account that provided the signature and from which the tokens will be taken",
        "@param2": "to The account that will receive the tokens",
        "@param3": "value The amount of tokens to transfer",
        "@param4": "deadline Expiration time, seconds since the epoch",
        "@param5": "v v part of the signature",
        "@param6": "r r part of the signature",
        "@param7": "s s part of the signature",
        "@gnotice": "Perform a delegated transfer of `value` tokens from `owner` to `to` with a deadline of `deadline`.",
        "@gparam1": "owner The owner of the tokens to transfer",
        "@gparam2": "to The recipient of the tokens",
        "@gparam3": "value The amount of tokens to transfer",
        "@gparam4": "deadline The deadline for the transfer to be executed by",
        "@gparam5": "v The v parameter of the ECDSA signature of the delegator's signature",
        "@gparam6": "r The r parameter of the ECDSA signature of the delegator's signature",
        "@gparam7": "s The s parameter of the ECDSA signature of the delegator's signature",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 1,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 1,
        "@tparam5": 0,
        "@tparam6": 0,
        "@tparam7": 0
    },
    {
        "func": "function _setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa) external returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n        }\n\n        // Verify market is listed\n        Market storage market = markets[address(cToken)];\n        if (!market.isListed) {\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n        }\n\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\n\n        // Check collateral factor <= 0.9\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n        }\n\n        // If collateral factor != 0, fail if price == 0\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(address(cToken)) == 0) {\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n        }\n\n        // Set market's collateral factor to new collateral factor, remember old value\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n        emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }",
        "@notice": "Sets the collateralFactor for a market",
        "@dev": "Admin function to set per-market collateralFactor",
        "@param1": "cToken The market to set the factor on",
        "@param2": "newCollateralFactorMantissa The new collateral factor, scaled by 1e18",
        "@return1": "uint 0=success, otherwise a failure. (See ErrorReporter for details)",
        "@gnotice": "Sets the collateral factor of a CToken market",
        "@gparam1": "cToken The address of the CToken market",
        "@gparam2": "newCollateralFactorMantissa The new collateral factor in mantissa format",
        "@greturn1": "An unsigned integer indicating whether or not the operation succeeded",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 1
    },
    {
        "func": "function getVariableRateSlope2() external view returns (uint256) {\n    return _variableRateSlope2;\n  }",
        "@notice": "Returns the variable rate slope above optimal usage ratio",
        "@dev": "Its the variable rate when usage ratio > OPTIMAL_USAGE_RATIO",
        "@return1": "The variable rate slope",
        "@gnotice": "Returns the value of the `_variableRateSlope2` variable.",
        "@greturn1": "The value of the variable Rate Slope2",
        "@tnotice": 0,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function peakReferralRedeemCommission() public {\n        (bool success, ) = peakdefiLogic3.delegatecall(\n            abi.encodeWithSelector(this.peakReferralRedeemCommission.selector)\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "@notice": "Redeems commission.",
        "@gnotice": "Redeems commissions for referrals in the PeakDefiLogic3 contract. Only callable by the contract owner.",
        "@tnotice": 1,
        "@tdev": 0
    },
    {
        "func": "function calcKeysReceived(uint256 _rID, uint256 _eth)\n        public\n        view\n        returns(uint256)\n    {\n        // grab time\n        uint256 _now = now;\n\n        // are we in a round?\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n            return ( (round_[_rID].eth).keysRec(_eth) );\n        else // rounds over.  need keys for new round\n            return ( (_eth).keys() );\n    }",
        "@notice": "returns the amount of keys you would get given an amount of eth.",
        "@dev": " * -functionhash- 0xce89c80c",
        "@param1": "_rID round ID you want price for",
        "@param2": "_eth amount of eth sent in",
        "@return1": "keys received",
        "@gnotice": "calculates the amount of keys that can be received for a given amount of Ether and a specific round ID",
        "@gparam1": "_rID The ID of the round to calculate keys for",
        "@gparam2": "_eth The amount of Ether to calculate keys for",
        "@greturn1": "The amount of keys that can be received for the given Ether amount and round ID",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function uri(uint256 id) public view virtual returns (string memory) {\n        string memory tokenURI = _uris[id];\n\n        if (bytes(tokenURI).length > 0) return tokenURI;\n        else return uriFetcher.uri(id);\n    }",
        "@notice": "",
        "@dev": "ID metadata fetcher.",
        "@param1": "id ID to fetch from.",
        "@return1": "tokenURI Metadata.",
        "@gnotice": "Returns the Uniform Resource Identifier (URI) for a given token `id`",
        "@gparam1": "id The identifier of the token whose URI is to be fetched",
        "@greturn1": "The URI requested in its string representation, or an empty string if URI does not exist for this token ID",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 1
    },
    {
        "func": "function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }",
        "@notice": "Begins transfer of admin rights.",
        "@dev": "The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.",
        "@param1": "newPendingAdmin New pending admin.",
        "@return1": "uint 0=success, otherwise a failure (see ErrorReporter.sol for details)",
        "@gnotice": "Sets `newPendingAdmin` as the new pending administrator of the contract",
        "@gparam1": "newPendingAdmin The address of the new pending administrator",
        "@greturn1": "An error code (0 if successful) indicating if the operation failed and the reason for the failure if applicable",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function mint(address account, uint256 amount) virtual external {\n        require(_msgSender() == minter, \"BackedToken: Only minter\");\n        _mint(account, amount);\n    }",
        "@notice": "mint tokens.",
        "@dev": "Allowed only for minter",
        "@param1": "account The address that will receive the minted tokens",
        "@param2": "amount The amount of tokens to mint",
        "@gnotice": "Mint new tokens `amount` to the `account`",
        "@gparam1": "account The address of the account to receive the new tokens",
        "@gparam2": "amount The number of tokens to mint",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function setDelegateWhitelist(address whitelistAddress, bool status) external onlyOwner {\n        delegateWhitelist[whitelistAddress] = status;\n        emit DelegateWhitelistChange(whitelistAddress, status);\n    }",
        "@notice": "",
        "@dev": "EIP-712 Function to change the delegate status of account. * Allowed only for owner * * Emits a { DelegateWhitelistChange } event",
        "@param1": "whitelistAddress The address for which to change the delegate status",
        "@param2": "status The new delegate status",
        "@gnotice": "Sets `status` for the `whitelistAddress` in the delegate whitelist",
        "@gparam1": "whitelistAddress The address of the delegate to set the `status` for",
        "@gparam2": "status The boolean `status` to set for the `whitelistAddress`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 1
    },
    {
        "func": "function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }",
        "@dev": "Changes the admin of the proxy.",
        "@notice": "",
        "@gnotice": "Change the admin of the contract to `newAdmin`",
        "@gparam1": "newAdmin The address of the new administrator",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function addMember(uint256 roleId, address newMember) public onlyShared(roleId) onlyRoleManager(roleId) {\n        roles[roleId].sharedRoleMembership.addMember(newMember);\n        emit AddedSharedMember(roleId, newMember, msg.sender);\n    }",
        "@notice": "Adds `newMember` to the shared role, `roleId`.",
        "@dev": "Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the * managing role for `roleId`.",
        "@param1": "roleId the Shared Role membership to modify.",
        "@param2": "newMember the new SharedRole member.",
        "@gnotice": "Add `newMember` to the shared role with ID `roleId`",
        "@gparam1": "roleId The ID of the shared role to add the member to",
        "@gparam2": "newMember The address of the new member to add to the shared role",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function approve(\n    address _approved,\n    uint256 _tokenId\n  )\n    external\n    override\n    canOperate(_tokenId)\n    validNFToken(_tokenId)\n  {\n    address tokenOwner = idToOwner[_tokenId];\n    require(_approved != tokenOwner, IS_OWNER);\n\n    idToApproval[_tokenId] = _approved;\n    emit Approval(tokenOwner, _approved, _tokenId);\n  }",
        "@notice": "Set the approved address for an NFT.",
        "@dev": "This function can be changed to payable.",
        "@param1": "_approved Address to be approved for the given NFT ID.",
        "@param2": "_tokenId ID of the token to be approved.",
        "@gnotice": "Approve the `approved` address for the `tokenId` token",
        "@gparam1": "_approved The address to be approved for the token transfer",
        "@gparam2": "_tokenId The identifier of the token",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function ownerOf(\n    uint256 _tokenId\n  )\n    external\n    override\n    view\n    returns (address _owner)\n  {\n    _owner = idToOwner[_tokenId];\n    require(_owner != address(0), NOT_VALID_NFT);\n  }",
        "@notice": "Returns the address of the owner of the NFT.",
        "@dev": "NFTs assigned to the zero address are * considered invalid, and queries about them do throw.",
        "@param1": "_tokenId The identifier for an NFT.",
        "@return1": "_owner Address of _tokenId owner.",
        "@gnotice": "Get the owner of a specific NFT",
        "@gparam1": "_tokenId The identifier of the NFT",
        "@greturn1": "The address of the owner of the NFT",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function emergencyShutdown() external override isInitialized() nonReentrant() {\n        return;\n    }",
        "@notice": "`emergencyShutdown` and `remargin` are required to be implemented by all financial contracts and exposed to the DVM, but * because this is a minimal demo they will simply exit silently.",
        "@gnotice": "Triggers an emergency shutdown of the protocol. This function can only be called if the protocol has been initialized.",
        "@tnotice": 1,
        "@tdev": 0
    },
    {
        "func": "function votingDelay() public pure returns (uint) { return 1; }",
        "@notice": "The delay before voting on a proposal may take place, once proposed // This also helps protect against flash loan attacks because only the vote balance at the proposal start block is considered",
        "@gnotice": "Returns the duration of the voting delay, in number of blocks",
        "@greturn1": "The duration of the voting delay in number of blocks",
        "@tnotice": 1,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }",
        "@dev": "Transfers ownership of the contract to a new account (`newOwner`).",
        "@notice": "",
        "@gnotice": "Transfer ownership to a new owner address",
        "@gparam1": "newOwner The address of the new owner",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }",
        "@dev": "Returns true if the caller is the current owner.",
        "@notice": "",
        "@gnotice": "Returns true if the caller is the owner of the contract",
        "@greturn1": "True if the caller is the owner, false otherwise",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function name() public view virtual override returns (string memory) {\n        return _name;\n    }",
        "@dev": "Returns the name of the token.",
        "@notice": "",
        "@gnotice": "Get the token name",
        "@greturn1": "The name of the token",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function transferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n    external\n    override\n    canTransfer(_tokenId)\n    validNFToken(_tokenId)\n  {\n    address tokenOwner = idToOwner[_tokenId];\n    require(tokenOwner == _from, NOT_OWNER);\n    require(_to != address(0), ZERO_ADDRESS);\n\n    _transfer(_to, _tokenId);\n  }",
        "@notice": "The caller is responsible to confirm that `_to` is capable of receiving NFTs or else",
        "@dev": "Throws unless `msg.sender` is the current owner, an authorized operator, or the approved * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.",
        "@param1": "_from The address of current owner",
        "@param2": "_to The address of new owner.",
        "@param3": "_tokenId The NFT to transfer.",
        "@gnotice": "Transfer token with ID `_tokenId` from `_from` to `_to` account",
        "@gparam1": "_from The address of the account from which the token will be transferred",
        "@gparam2": "_to The address of the account to which the token will be transferred",
        "@gparam3": "_tokenId The ID of the token to be transferred",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0
    },
    {
        "func": "function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"OptimismValidator 0.1.0\";\n  }",
        "@notice": "versions: * * - OptimismValidator 0.1.0: initial release",
        "@inheritdoc": "TypeAndVersionInterface",
        "@gnotice": "Returns the type and version of the contract",
        "@greturn1": "A string representing the contract's type and version information.",
        "@tnotice": 1,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function getProposerThresholdCount() public view returns (uint96) {\n        LibDiamondStorageDerivaDEX.DiamondStorageDerivaDEX storage dsDerivaDEX =\n            LibDiamondStorageDerivaDEX.diamondStorageDerivaDEX();\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n\n        uint96 totalSupply = dsDerivaDEX.ddxToken.totalSupply().safe96(\"Governance: amount exceeds 96 bits\");\n        return totalSupply.proportion96(dsGovernance.proposalThreshold, 100);\n    }",
        "@notice": "gets the quorum vote count",
        "@return1": "Quorum vote count.",
        "@gnotice": "Returns the number of token holders required to make a proposal",
        "@greturn1": "The number of token holders required for a proposal to be submitted to the governance system.",
        "@tnotice": 0,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function crossDomainMessenger() public view virtual override returns (address) {\n    return OVM_CROSS_DOMAIN_MESSENGER;\n  }",
        "@notice": "This is always the address of the OVM_L2CrossDomainMessenger contract",
        "@inheritdoc": "CrossDomainForwarder",
        "@gnotice": "Get the address of the Optimistic Rollup Cross Domain Messenger contract",
        "@greturn1": "The address of the Cross Domain Messenger contract",
        "@tnotice": 1,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function updateRates(uint[] data) public onlyOwner {\n    if (data.length % 2 > 0)\n      throw;\n    uint i = 0;\n    while (i < data.length / 2) {\n      bytes32 symbol = bytes32(data[i * 2]);\n      uint rate = data[i * 2 + 1];\n      rates[symbol] = rate;\n      RateUpdated(now, symbol, rate);\n      i++;\n    }\n  }",
        "@notice": "",
        "@dev": "update multiple rates.",
        "@param1": "data an array that alternates sha3 hashes of the symbol and the corresponding rate .",
        "@gnotice": "Updates the exchange rates for multiple symbols at once",
        "@gparam1": "data An array containing symbol-rate pairs in the form of [symbol1, rate1, symbol2, rate2, ...]",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function getOwners()\n        public\n        constant\n        returns (address[])\n    {\n        return owners;\n    }",
        "@dev": "Returns list of owners.",
        "@return1": "List of owner addresses.",
        "@notice": "",
        "@gnotice": "Get the list of addresses that own the contract",
        "@greturn1": "The array of addresses that owns the contract",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function getAuthorizer(uint authorizerIndex) external constant returns(address) {\n    return address(authorizers[authorizerIndex + 1]);\n  }",
        "@notice": "",
        "@dev": "get a specific authorizer",
        "@param1": "authorizerIndex index of the authorizer to be retrieved.",
        "@return1": "The address of the authorizer.",
        "@gnotice": "Get the address of the authorizer at index `authorizerIndex`",
        "@gparam1": "authorizerIndex The index of the authorizer to retrieve",
        "@greturn1": "The address of the authorizer at the given index",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    }
]