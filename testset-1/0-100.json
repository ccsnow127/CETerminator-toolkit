[
    {
        "func": "function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }",
        "@dev": "Returns the number of decimals used to get its user representation. * For example, if `decimals` equals `2`, a balance of `505` tokens should * be displayed to a user as `5,05` (`505 / 10 ** 2`). * * Tokens usually opt for a value of 18, imitating the relationship between * Ether and Wei. This is the value {ERC20} uses, unless this function is * overridden; * * NOTE: This information is only used for _display_ purposes: it in * no way affects any of the arithmetic of the contract, including * {IERC20-balanceOf} and {IERC20-transfer}.",
        "@notice": "",
        "@gnotice": "Get the number of decimals for the token",
        "@greturn1": "The number of decimals for the token (usually 18)",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function init(\n        DataTypes.ReserveData storage reserve, \n        address kTokenAddress,\n        address variableDebtTokenAddress,\n        address interestRateStrategyAddress\n    ) external {\n        require(reserve.kTokenAddress == address(0), \"the reserve already initialized\");\n\n        reserve.isActive = true;\n        reserve.liquidityIndex = uint128(KyokoMath.ray());\n        reserve.variableBorrowIndex = uint128(KyokoMath.ray());\n        reserve.kTokenAddress = kTokenAddress;\n        reserve.variableDebtTokenAddress = variableDebtTokenAddress;\n        reserve.interestRateStrategyAddress = interestRateStrategyAddress;\n    }",
        "@dev": "Initializes a reserve",
        "@param1": "reserve The reserve object",
        "@param2": "kTokenAddress The address of the overlying ktoken contract",
        "@param3": "variableDebtTokenAddress The address of the variable debt token",
        "@param4": "interestRateStrategyAddress The address of the interest rate strategy contract",
        "@notice": "",
        "@gnotice": "Initializes the reserve with the specified parameters",
        "@gparam1": "reserve The storage reference to the ReserveData struct to be initialized",
        "@gparam2": "kTokenAddress The address of the kToken associated with the reserve",
        "@gparam3": "variableDebtTokenAddress The address of the variable debt token associated with the reserve",
        "@gparam4": "interestRateStrategyAddress The address of the interest rate strategy contract associated with the reserve",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0,
        "@gtparam3": 0,
        "@gtparam4": 0
    },
    {
        "func": "function initialize(\n        IController _controller,\n        IERC20 _ibt,\n        uint256 _periodDuration,\n        string memory _platformName,\n        address _admin\n    ) public virtual override initializer {\n        super.initialize(_controller, _ibt, _periodDuration, _platformName, _admin);\n        IBTRates[getCurrentPeriodIndex()] = getIBTRate();\n    }",
        "@notice": "Intializer",
        "@param1": "_controller the address of the controller",
        "@param2": "_ibt the address of the corresponding IBT",
        "@param3": "_periodDuration the length of the period (in days)",
        "@param4": "_platformName the name of the platform and tools",
        "@param5": "_admin the address of the ACR admin",
        "@gnotice": "Initializes the contract",
        "@gparam1": "_controller The address of the controller contract",
        "@gparam2": "_ibt The address of the ERC20 token contract used for payment of the flash loans",
        "@gparam3": "_periodDuration The length of time each period will last",
        "@gparam4": "_platformName The name of the platform",
        "@gparam5": "_admin The address of the admin account",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0,
        "@tparam5": 0,
        "@gtparam3": 0,
        "@gtparam4": 0,
        "@gtparam5": 0
    },
    {
        "func": "function claim(address raceAddress) external payable\n    costs(claimingFee)\n    whenNotPaused()\n    {\n        //call _isWinnerOf with a 0 address to simply get the winner horse\n        bytes32 winner;\n        (,winner) = _isWinnerOf(raceAddress, address(0));\n        require(winner != bytes32(0),\"Winner is zero\");\n        require(can_claim(raceAddress, msg.sender),\"can_claim return false\");\n        //require(!exists(id)); should already be checked by mining function\n        uint256 id = _generate_special_horsey(raceAddress, msg.sender, winner);\n        emit Claimed(raceAddress, msg.sender, id);\n    }",
        "@notice": "",
        "@dev": "claim a special horsey with the same dna as the race one",
        "@param1": "raceAddress The race's address",
        "@gnotice": "Claim rewards for the winning horse in specified race",
        "@gparam1": "raceAddress The address of the race to claim rewards from",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function startNewPeriod() public virtual override nextPeriodAvailable periodsActive nonReentrant {\n        require(hasRole(CONTROLLER_ROLE, msg.sender), \"ERR_CALLER\");\n        _switchPeriod();\n        IBTRates[getCurrentPeriodIndex()] = getIBTRate();\n    }",
        "@notice": "Start a new period",
        "@dev": "needs corresponding permissions for sender",
        "@gnotice": "Starts a new period by switching to the next period and getting a new interest-bearing token (IBT) rate",
        "@tnotice": 0,
        "@tdev": 0,
        "@gparam1": "None",
        "@greturn1": "None"
    },
    {
        "func": "function buyXid(uint256 _affCode, uint256 _team)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        // set up our tx event data and determine if player is new or not\n        Star3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n\n        // fetch player id\n        uint256 _pID = pIDxAddr_[msg.sender];\n\n        // manage affiliate residuals\n        // if no affiliate code was given or player tried to use their own, lolz\n        if (_affCode == 0 || _affCode == _pID)\n        {\n            // use last stored affiliate code\n            _affCode = plyr_[_pID].laff;\n\n        // if affiliate code was given & its not the same as previously stored\n        } else if (_affCode != plyr_[_pID].laff) {\n            // update last affiliate\n            plyr_[_pID].laff = _affCode;\n        }\n\n        // verify a valid team was selected\n        _team = verifyTeam(_team);\n\n        // buy core\n        buyCore(_pID, _affCode, _team, _eventData_);\n    }",
        "@notice": "converts all incoming ethereum to keys.",
        "@dev": " * -functionhash- 0x8f38f309 (using ID for affiliate) * -functionhash- 0x98a0871d (using address for affiliate) * -functionhash- 0xa65b37a1 (using name for affiliate)",
        "@param1": "_affCode the ID/address/name of the player who gets the affiliate fee",
        "@param2": "_team what team is the player playing for?",
        "@gnotice": "Buy XID tokens by sending Ether to the contract",
        "@gparam1": "_affCode The affiliate code of the referrer (optional)",
        "@gparam2": "_team The team selected by the player",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 1,
        "@tparam2": 0
    },
    {
        "func": "function setCarrotsMultiplier(uint8 newCarrotsMultiplier) external \n    onlyOwner()  {\n        carrotsMultiplier = newCarrotsMultiplier;\n    }",
        "@notice": "",
        "@dev": "Sets a new muliplier for freeing a horse",
        "@param1": "newCarrotsMultiplier the new multiplier for feeding",
        "@gnotice": "Set the carrots multiplier to `newCarrotsMultiplier`",
        "@gparam1": "newCarrotsMultiplier The new value to set the carrots multiplier to",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function transferKnightOwnership(address newKnight) external \n    validAddress(newKnight) {\n        require(knightAddress == msg.sender,\"Not right role\");\n        _moveBalance(newKnight);\n        knightAddress = newKnight;\n    }",
        "@notice": "",
        "@dev": "Transfers knight ownership to a new address",
        "@param1": "newKnight the new address",
        "@gnotice": "Transfer ownership of the knight to `newKnight`",
        "@gparam1": "newKnight The address of the new knight owner. Must be a valid address.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function updatePendingDepositState(address _user) public {\n        // @dev check if user has already stored assets\n        if (userHasPendingDeposit(_user)) {\n            // @dev user should already have shares here, let's increment\n            vaultUsers[_user].vaultShares += previewDepositEpoch(\n                vaultUsers[_user].assetsDeposited,\n                vaultUsers[_user].epochLastDeposited + 1\n            );\n\n            vaultUsers[_user].assetsDeposited = 0;\n            vaultUsers[_user].epochLastDeposited = 0;\n        }\n    }",
        "@notice": "update VaultUser's data if they have pending deposits",
        "@param1": "_user address of the VaultUser",
        "@dev": "after this, last deposit epoch = 0, assetDeposited = 0 * can be manually called",
        "@gnotice": "Updates the state of a pending deposit for a user",
        "@gparam1": "_user Address of the user",
        "@tnotice": 0,
        "@tparam1": 0,
        "@tdev": 0
    },
    {
        "func": "function wrapEthAndDepositCollateral(BalanceSheetInterface balanceSheet, FyTokenInterface fyToken) public payable {\n        uint256 collateralAmount = msg.value;\n\n        /* Convert the received ETH to WETH. */\n        WethInterface(WETH_ADDRESS).deposit{ value: collateralAmount }();\n\n        /* Deposit the collateral into the BalanceSheet contract. */\n        depositCollateralInternal(balanceSheet, fyToken, collateralAmount);\n    }",
        "@notice": "Wraps ETH into WETH, deposits and locks collateral into the BalanceSheet contract * and borrows fyTokens",
        "@dev": "This is a payable function so it can receive ETH transfers.",
        "@param1": "balanceSheet The address of the BalanceSheet contract.",
        "@param2": "fyToken The address of the FyToken contract.",
        "@gnotice": "Wraps the received Ether into WETH and deposits it as collateral for the respective `fyToken` on the `balanceSheet` contract.",
        "@gparam1": "balanceSheet The address of the BalanceSheet contract responsible for holding the collateral token balance",
        "@gparam2": "fyToken The address of the FyToken contract representing the specific asset",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function deposit(address _user, uint256 _amount) external virtual periodsActive depositsEnabled onlyController {\n        require((_amount > 0) && (_amount <= ibt.balanceOf(_user)), \"FutureVault: ERR_AMOUNT\");\n        _deposit(_user, _amount);\n        emit FundsDeposited(_user, _amount);\n    }",
        "@notice": "Deposit funds into ongoing period",
        "@param1": "_user user adress",
        "@param2": "_amount amount of funds to unlock",
        "@dev": "part of the amount deposited will be used to buy back the yield already generated proportionally to the amount deposited",
        "@gnotice": "deposit `_amount` tokens into their vault",
        "@gparam1": "_user The address of the user depositing tokens",
        "@gparam2": "_amount The amount of tokens being deposited",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 1,
        "@tparam2": 0
    },
    {
        "func": "function getPTPerAmountDeposited(uint256 _amount) public view override returns (uint256) {\n        uint256 underlyingAmountOfDeposit = convertIBTToUnderlying(_amount);\n        uint256 underlyingYieldPerPT = convertIBTToUnderlying(getUnrealisedYieldPerPT());\n        return underlyingAmountOfDeposit.mul(IBT_UNIT).div(IBT_UNIT.add(underlyingYieldPerPT));\n    }",
        "@notice": "Get the number of pt that can be minted for an amoumt deposited now",
        "@param1": "_amount the amount to of IBT to deposit",
        "@return1": "the number of pt that can be minted for that amount",
        "@gnotice": "Returns the corresponding PT (PToken) amount for a given IBT (Interest Bearing Token) `amount` deposited",
        "@gparam1": "_amount The amount of IBT deposited",
        "@greturn1": "The amount of PT (PToken) that corresponds to the deposited IBT amount",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function implementation() public view returns (address) {\n        return _implementation();\n    }",
        "@dev": "Returns the current implementation address.",
        "@notice": "",
        "@gnotice": "Get the address of the current implementation contract",
        "@greturn1": "The address of the current implementation contract",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function transferPaladinOwnership(address newPaladin) external \n    validAddress(newPaladin) {\n        require(paladinAddress == msg.sender,\"Not right role\");\n        _moveBalance(newPaladin);\n        paladinAddress = newPaladin;\n    }",
        "@notice": "",
        "@dev": "Transfers paladin ownership to a new address",
        "@param1": "newPaladin the new address",
        "@gnotice": "Transfer ownership of the contract to a new address",
        "@gparam1": "newPaladin The address of the new owner",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function implementation() public view returns (address) {\n        return _implementation();\n    }",
        "@dev": "Returns the current implementation address.",
        "@notice": "",
        "@gnotice": "Get the address of the current implementation",
        "@greturn1": "The address of the current implementation contract",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function queryJoin(\n        bytes32,\n        address sender,\n        address,\n        uint256[] memory balances,\n        uint256,\n        uint256,\n        bytes memory userData\n    ) external override returns (uint256 bptOut, uint256[] memory amountsIn) {\n        _queryAction(sender, balances, userData, _onJoinPool);\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptOut, amountsIn);\n    }",
        "@notice": "\"Dry run\" `onJoinPool`.",
        "@dev": "Returns the amount of BPT that would be granted to `recipient` if the `onJoinPool` hook were called by the * Vault with the same arguments, along with the number of tokens `sender` would have to supply. * * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault * data, such as the protocol swap fee percentage and Pool balances. * * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must * explicitly use eth_call instead of eth_sendTransaction.",
        "@gnotice": "Queries the value of joining a pool.",
        "@gparam1": "_poolId The ID of the pool being joined",
        "@gparam2": "sender The address of the account that triggered the join request",
        "@gparam3": "_recipient The address of the account that will receive pool tokens upon joining",
        "@gparam4": "balances The array of balances in the pool",
        "@gparam5": "_amount The amount of tokens to deposit",
        "@gparam6": "_minShares The minimum number of shares required",
        "@gparam7": "userData Optional data to include in the transaction",
        "@greturn1": "bptOut The number of pool tokens received upon joining",
        "@greturn2": "amountsIn The array of amounts of assets deposited into the pool",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0,
        "@tparam5": 0,
        "@tparam6": 0,
        "@tparam7": 0,
        "@treturn1": 0,
        "@treturn2": 0,
        "@gtparam3": 0,
        "@gtparam4": 0,
        "@gtparam5": 0,
        "@gtparam6": 0,
        "@gtparam7": 0,
        "@gtreturn1": 0,
        "@gtreturn2": 0
    },
    {
        "func": "function depositAndLockCollateralAndBorrowAndSellFyTokens(\n        BalanceSheetInterface balanceSheet,\n        FyTokenInterface fyToken,\n        uint256 collateralAmount,\n        uint256 borrowAmount,\n        uint256 underlyingAmount\n    ) external payable {\n        depositAndLockCollateral(balanceSheet, fyToken, collateralAmount);\n        borrowAndSellFyTokens(fyToken, borrowAmount, underlyingAmount);\n    }",
        "@notice": "Deposits and locks collateral into the vault via the BalanceSheet contract, borrows fyTokens * and sells them on Balancer in exchange for underlying",
        "@dev": "This is a payable function so it can receive ETH transfers. * * Requirements: * - The caller must have allowed the DSProxy to spend `collateralAmount` tokens.",
        "@param1": "balanceSheet The address of the BalanceSheet contract.",
        "@param2": "fyToken The address of the FyToken contract.",
        "@param3": "collateralAmount The amount of collateral to deposit and lock.",
        "@param4": "borrowAmount The amount of fyTokens to borrow.",
        "@param5": "underlyingAmount The amount of underlying to sell fyTokens for.",
        "@gnotice": "Deposits `collateralAmount` ETH as collateral, locks it in `balanceSheet`, borrows `borrowAmount` FYTokens from `fyToken`, and sells `underlyingAmount` of those tokens for ETH",
        "@gparam1": "balanceSheet The BalanceSheet contract that will hold the deposited collateral as collateral",
        "@gparam2": "fyToken The FyToken contract to borrow and sell from",
        "@gparam3": "collateralAmount The amount of ETH to be deposited as collateral",
        "@gparam4": "borrowAmount The amount of FYTokens to be borrowed",
        "@gparam5": "underlyingAmount The amount of FYToken's underlying asset to be sold for ETH",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0,
        "@tparam5": 0
    },
    {
        "func": "function getControllerAddress() public view returns (address) {\n        return address(controller);\n    }",
        "@notice": "Getter for controller address",
        "@return1": "the controller address",
        "@gnotice": "Get the address of the controller contract",
        "@greturn1": "The address of the controller contract",
        "@tnotice": 0,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function depositCollateral(\n        BalanceSheetInterface balanceSheet,\n        FyTokenInterface fyToken,\n        uint256 collateralAmount\n    ) public {\n        /* Transfer the collateral to the DSProxy. */\n        fyToken.collateral().safeTransferFrom(msg.sender, address(this), collateralAmount);\n\n        /* Deposit the collateral into the BalanceSheet contract. */\n        depositCollateralInternal(balanceSheet, fyToken, collateralAmount);\n    }",
        "@notice": "Deposits collateral into the BalanceSheet contract",
        "@dev": "Requirements: * - The caller must have allowed the DSProxy to spend `collateralAmount` tokens.",
        "@param1": "balanceSheet The address of the BalanceSheet contract.",
        "@param2": "fyToken The address of the FyToken contract.",
        "@param3": "collateralAmount The amount of collateral to deposit.",
        "@gnotice": "Deposit `collateralAmount` collateral into the `balanceSheet` from `msg.sender`'s account, and wrap the corresponding amount of fyTokens",
        "@gparam1": "balanceSheet The address of the BalanceSheet contract",
        "@gparam2": "fyToken The address of the fyToken contract",
        "@gparam3": "collateralAmount The amount of collateral to deposit",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0
    },
    {
        "func": "function setClaimingCosts(uint256 newClaimingFee) external\n    onlyOwner()  {\n        claimingFee = newClaimingFee;\n    }",
        "@notice": "",
        "@dev": "Sets a new claiming fee in wei Any CLevel can call this function",
        "@param1": "newClaimingFee The cost to charge in wei for each claimed HRSY",
        "@gnotice": "Set the claiming fee to `newClaimingFee`",
        "@gparam1": "newClaimingFee The new claiming fee to be set",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1
    },
    {
        "func": "function withdrawCeo(address destination) external \n    onlyCLevelAccess()\n    validAddress(destination) {\n        //Check that pending balance can be redistributed - if so perform\n        //this procedure\n        if(toBeDistributed > 0){\n            _updateDistribution();\n        }\n        \n        //Grab the balance of this CEO \n        uint256 balance = _cBalance[msg.sender];\n        \n        //If we have non-zero balance, CEO may withdraw from pending amount\n        if(balance > 0 && (address(this).balance >= balance)) {\n            destination.transfer(balance); //throws on fail\n            _cBalance[msg.sender] = 0;\n        }\n    }",
        "@notice": "Allow CEO to withdraw from pending value always checks to update redist",
        "@dev": "We ONLY redist when a user tries to withdraw so we are not redistributing on every payment",
        "@param1": "destination The address to send the ether to",
        "@gnotice": "Allows the CEO to withdraw their pending balance to `destination` if available",
        "@gparam1": "destination The address where the pending balance will be transferred to",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function setRenamingCosts(uint256 newRenamingCost) external \n    onlyOwner()  {\n        renamingCostsPerChar = newRenamingCost;\n    }",
        "@notice": "",
        "@dev": "Sets a new renaming per character cost in wei Any CLevel can call this function",
        "@param1": "newRenamingCost The cost to charge for each character of the name",
        "@gnotice": "Sets the new cost for renaming a token",
        "@gparam1": "newRenamingCost The new cost for renaming a token",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function queryExit(\n        bytes32,\n        address sender,\n        address,\n        uint256[] memory balances,\n        uint256,\n        uint256,\n        bytes memory userData\n    ) external override returns (uint256 bptIn, uint256[] memory amountsOut) {\n        _queryAction(sender, balances, userData, _onExitPool);\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptIn, amountsOut);\n    }",
        "@notice": "\"Dry run\" `onExitPool`.",
        "@dev": "Returns the amount of BPT that would be burned from `sender` if the `onExitPool` hook were called by the * Vault with the same arguments, along with the number of tokens `recipient` would receive. * * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault * data, such as the protocol swap fee percentage and Pool balances. * * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must * explicitly use eth_call instead of eth_sendTransaction.",
        "@gnotice": "Query the amount of tokens to receive upon exiting a Balancer pool",
        "@gparam1": "_poolId The ID of the Balancer pool",
        "@gparam2": "sender The address of the account exiting the pool",
        "@gparam3": "_tokenIn The address of the token being exchanged for pool tokens",
        "@gparam4": "balances An array of the account's token balances",
        "@gparam5": "_totalSupply The total supply of pool tokens",
        "@gparam6": "_totalWeight The total weight of the pool",
        "@gparam7": "userData Optional data to include in the function call",
        "@greturn1": "The amount of pool tokens required to exit the pool",
        "@greturn2": "An array of the amounts of tokens to receive after exiting the pool",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0,
        "@tparam5": 0,
        "@tparam6": 0,
        "@tparam7": 0,
        "@treturn1": 0,
        "@treturn2": 0,
        "@gtparam3": 0,
        "@gtparam4": 0,
        "@gtparam5": 0,
        "@gtparam6": 0,
        "@gtparam7": 0,
        "@gtreturn1": 0,
        "@gtreturn2": 0
    },
    {
        "func": "function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }",
        "@dev": "Revokes `role` from `account`. * * If `account` had been granted `role`, emits a {RoleRevoked} event. * * Requirements: * * - the caller must have ``role``'s admin role.",
        "@notice": "",
        "@gnotice": "Revokes `account` from the `role`",
        "@gparam1": "role The identifier of the role",
        "@gparam2": "account The address of the account to be revoked",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function getRoundData(uint80 _roundId)\n        public\n        view\n        virtual\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        Round memory r = rounds[uint32(_roundId)];\n\n        require(\n            r.answeredInRound > 0 && validRoundId(_roundId),\n            V3_NO_DATA_ERROR\n        );\n\n        return (\n            _roundId,\n            r.answer,\n            r.startedAt,\n            r.updatedAt,\n            r.answeredInRound\n        );\n    }",
        "@notice": "get data about a round.",
        "@param1": "_roundId the round ID to retrieve the round data for",
        "@return1": "roundId is the round ID for which data was retrieved",
        "@return2": "answer is the answer for the given round",
        "@return3": "startedAt is the timestamp when the round was started. This is 0 * if the round hasn't been started yet.",
        "@return4": "updatedAt is the timestamp when the round last was updated (i.e. * answer was last computed)",
        "@return5": "answeredInRound is the round ID of the round in which the answer * was computed. answeredInRound may be smaller than roundId when the round * timed out. answeredInRound is equal to roundId when the round didn't time out * and was completed regularly.",
        "@dev": "Note that for in-progress rounds (i.e. rounds that haven't yet received * maxSubmissions) answer and updatedAt may change between queries.",
        "@gnotice": "Returns the round data for the specified round ID",
        "@gparam1": "_roundId The ID of the round to get the data for",
        "@greturn1": "roundId The round ID",
        "@greturn2": "answer The price at the current round ID",
        "@greturn3": "startedAt Timestamp of when the round started",
        "@greturn4": "updatedAt Timestamp of when the round was updated",
        "@greturn5": "answeredInRound The round ID of the round in which the answer was computed",
        "@tnotice": 0,
        "@tparam1": 0,
        "@treturn1": 0,
        "@treturn2": 0,
        "@treturn3": 0,
        "@treturn4": 0,
        "@treturn5": 0,
        "@tdev": 0
    },
    {
        "func": "function getUnrealisedYieldPerPT() public view virtual override returns (uint256) {\n        uint256 currRate = getIBTRate();\n        uint256 currPeriodStartRate = IBTRates[getCurrentPeriodIndex()];\n        if (currRate == currPeriodStartRate) return 0;\n        uint256 amountOfIBTsAtStart = _convertUnderlyingtoIBTAtRate(IBT_UNIT, currPeriodStartRate);\n        uint256 amountOfIBTsNow = _convertUnderlyingtoIBTAtRate(IBT_UNIT, currRate);\n        return amountOfIBTsAtStart.sub(amountOfIBTsNow);\n    }",
        "@notice": "Get the yield currently generated by one pt for the current period",
        "@return1": "the amount of yield generated during the current period",
        "@gnotice": "Get the unrealised yield per principal token (PT)",
        "@greturn1": "The unrealised yield per PT",
        "@tnotice": 0,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function calcKeysReceived(uint256 _rID, uint256 _eth)\n        public\n        view\n        returns(uint256)\n    {\n        // grab time\n        uint256 _now = now;\n\n        // are we in a round?\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n            return ( (round_[_rID].eth).keysRec(_eth) );\n        else // rounds over.  need keys for new round\n            return ( (_eth).keys() );\n    }",
        "@notice": "returns the amount of keys you would get given an amount of eth.",
        "@dev": " * -functionhash- 0xce89c80c",
        "@param1": "_rID round ID you want price for",
        "@param2": "_eth amount of eth sent in",
        "@return1": "keys received",
        "@gnotice": "Calculate the number of keys that can be received for an amount of ether in a round",
        "@gparam1": "_rID The ID of the round",
        "@gparam2": "_eth The amount of ether to calculate keys for",
        "@greturn1": "The number of keys that can be received for `_eth` in the given round",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function owner() public view virtual returns (address) {\n        return _owner;\n    }",
        "@dev": "Returns the address of the current owner.",
        "@notice": "",
        "@gnotice": "Get the address of the current contract owner",
        "@greturn1": "The address of the current contract owner",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function setMarketFees(uint256 fees) external\n    onlyOwner()\n    {\n        marketMakerFee = fees;\n    }",
        "@notice": "",
        "@dev": "change market fees",
        "@param1": "fees The new fees to apply (can be zero)",
        "@gnotice": "Set the market maker fees to `fees`",
        "@gparam1": "fees The new market maker fees value. Must be greater or equal to zero.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function wrapEthAndDepositAndLockCollateral(BalanceSheetInterface balanceSheet, FyTokenInterface fyToken)\n        public\n        payable\n    {\n        uint256 collateralAmount = msg.value;\n        wrapEthAndDepositCollateral(balanceSheet, fyToken);\n        balanceSheet.lockCollateral(fyToken, collateralAmount);\n    }",
        "@notice": "wraps ETH into WETH, deposits and locks collateral into the vault in the BalanceSheet contracts and borrows fyTokens.",
        "@dev": "This is a payable function so it can receive ETH transfers.",
        "@param1": "balanceSheet The address of the BalanceSheet contract.",
        "@param2": "fyToken The address of the FyToken contract.",
        "@gnotice": "Wraps Ether and deposits collateral to the Balance Sheet, then locks the collateral in the fyToken contract",
        "@gparam1": "balanceSheet The instance of the Balance Sheet contract to deposit collateral",
        "@gparam2": "fyToken The instance of the fyToken contract for which to lock the collateral",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }",
        "@dev": "Leaves the contract without owner. It will not be possible to call * `onlyOwner` functions anymore. Can only be called by the current owner. * * NOTE: Renouncing ownership will leave the contract without an owner, * thereby removing any functionality that is only available to the owner.",
        "@notice": "",
        "@gnotice": "Allows the current owner to renounce their ownership",
        "@tnotice": 0,
        "@tdev": 1
    },
    {
        "func": "function enableRecoveryMode() external override authenticate {\n        // Unlike when recovery mode is disabled, derived contracts should *not* do anything when it is enabled.\n        // We do not want to make any calls that could fail and prevent the pool from entering recovery mode.\n        // Accordingly, this should have no effect, but for consistency with `disableRecoveryMode`, revert if\n        // recovery mode was already enabled.\n        _ensureNotInRecoveryMode();\n\n        _setRecoveryMode(true);\n\n        emit RecoveryModeStateChanged(true);\n    }",
        "@notice": "Enable recovery mode, which enables a special safe exit path for LPs.",
        "@dev": "Does not otherwise affect pool operations (beyond deferring payment of protocol fees), though some pools may * perform certain operations in a \"safer\" manner that is less likely to fail, in an attempt to keep the pool * running, even in a pathological state. Unlike the Pause operation, which is only available during a short window * after factory deployment, Recovery Mode can always be enabled.",
        "@gnotice": "Allow pool to enter recovery mode",
        "@tnotice": 1,
        "@tdev": 0
    },
    {
        "func": "function transferFrom(address from, address to, uint value) public returns (bool success) {\n    uint allowance = allowed[from][msg.sender];\n\n    // Check is not needed because sub(allowance, value) will already throw if this condition is not met\n    // require(value <= allowance);\n    // SafeMath uses assert instead of require though, beware when using an analysis tool\n\n    balances[from] = balances[from].sub(value);\n    balances[to] = balances[to].add(value);\n    allowed[from][msg.sender] = allowance.sub(value);\n    Transfer(from, to, value);\n    return true;\n  }",
        "@dev": "Transfer tokens from one address to another",
        "@param1": "from The address which you want to send tokens from",
        "@param2": "to The address which you want to transfer to",
        "@param3": "value uint the amout of tokens to be transfered",
        "@notice": "",
        "@gnotice": "Transfer `value` tokens from `from` account to `to` account using an allowance approved by `msg.sender`",
        "@gparam1": "from The address of the account holding the tokens to be transferred",
        "@gparam2": "to The address of the destination account for the tokens to be transferred to",
        "@gparam3": "value The number of tokens to be transferred",
        "@greturn1": "Whether or not the transfer succeeded",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@treturn1": 0,
        "@gtparam3": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function getOwnedTokens(address eth_address) public view returns (uint256[]) {\n        return stables.getOwnedTokens(eth_address);\n    }",
        "@notice": "",
        "@dev": "Gets the complete list of token ids which belongs to an address",
        "@param1": "eth_address The address you want to lookup owned tokens from",
        "@return1": "List of all owned by eth_address tokenIds",
        "@gnotice": "Get an array of stablecoin IDs owned by `eth_address`",
        "@gparam1": "eth_address The address of the user to query",
        "@greturn1": "An array of `uint256` values representing the IDs of the stablecoins owned by `eth_address`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }",
        "@dev": "Returns the symbol of the token, usually a shorter version of the * name.",
        "@notice": "",
        "@gnotice": "Get the symbol of the token",
        "@greturn1": "The symbol of the token as a string",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function withdrawFYTDelegationFrom(\n        address _delegator,\n        address _receiver,\n        uint256 _amount\n    ) public {\n        require(hasRole(CONTROLLER_ROLE, msg.sender), \"ERR_CALLER\");\n        updateUserState(_delegator);\n        updateUserState(_receiver);\n\n        uint256 numberOfDelegations = delegationsByDelegator[_delegator].length;\n        bool removed;\n        for (uint256 i = 0; i < numberOfDelegations; i++) {\n            if (delegationsByDelegator[_delegator][i].receiver == _receiver) {\n                delegationsByDelegator[_delegator][i].delegatedAmount = delegationsByDelegator[_delegator][i]\n                    .delegatedAmount\n                    .sub(_amount, \"ERR_AMOUNT\");\n                removed = true;\n                break;\n            }\n        }\n        require(_amount > 0 && removed, \"FutureVault: ERR_AMOUNT\");\n        totalDelegationsReceived[_receiver] = totalDelegationsReceived[_receiver].sub(_amount);\n        emit DelegationRemoved(_delegator, _receiver, _amount);\n    }",
        "@notice": "Withdraw a delegation from one address to another",
        "@param1": "_delegator the address delegating its future FYTs",
        "@param2": "_receiver the address receiving the future FYTs",
        "@param3": "_amount the of future FYTs to remove from the delegation",
        "@gnotice": "Withdraws `_amount` FYT delegation tokens from `_delegator` to `_receiver`",
        "@gparam1": "_delegator The address of the delegator account",
        "@gparam2": "_receiver The address of the receiver account",
        "@gparam3": "_amount The number of FYT delegation tokens to be withdrawn",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@gtparam3": 0
    },
    {
        "func": "function name() public view virtual override returns (string memory) {\n        return _name;\n    }",
        "@dev": "Returns the name of the token.",
        "@notice": "",
        "@gnotice": "Get the name of the token",
        "@greturn1": "The name of the token as a string",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function deploy(\n        bytes memory bytecode,\n        bytes32 salt,\n        address anticipatedAddress\n    ) public payable returns (address deployedAddress) {\n\n        // Revert if a contract exists at the address.\n        if (anticipatedAddress.code.length > 0) revert CONTRACT_EXISTS_AT_THIS_ADDRESS(anticipatedAddress);\n\n        // Ensure the anticipated address matches the calculated address.\n        address calculatedAddress = calculateAddress(bytecode, salt);\n        if (anticipatedAddress != calculatedAddress) revert CALCULATED_ADDRESS_DOES_NOT_MATCH(anticipatedAddress, calculatedAddress);\n\n        // Deploy contract using CREATE2.\n        assembly {\n            deployedAddress := create2(\n                callvalue(),                    // forward ETH (constructor must be payable if >0)\n                add(bytecode, 0x20),            // bytecode\n                mload(bytecode),                // bytecode length\n                salt                            // salt\n            )\n        }\n\n        // Ensure the anticipated address matches the deployed address.\n        if (anticipatedAddress != deployedAddress) revert DEPLOYED_ADDRESS_DOES_NOT_MATCH(anticipatedAddress, deployedAddress);\n\n        return deployedAddress;\n    }",
        "@notice": "Deploy a contract using CREATE2",
        "@dev": "Cannot deploy a contract at an address where one already exists unless it has been deleted.",
        "@param1": "bytecode The contract bytecode",
        "@param2": "salt The salt to use",
        "@param3": "anticipatedAddress The address you are expecting the contract to be.",
        "@return1": "deployedAddress The address of the deployed contract.",
        "@gnotice": "Deploys a new contract with specified bytecode and salt, and verifies the expected deployed address matches the actual one.",
        "@gparam1": "bytecode The bytecode of the contract to be deployed",
        "@gparam2": "salt A unique identifier used to calculate the deployed address",
        "@gparam3": "anticipatedAddress The expected address for the deployed contract",
        "@greturn1": "The address of the deployed contract",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@treturn1": 0
    },
    {
        "func": "function initialize(\n        IController _controller,\n        IERC20 _ibt,\n        uint256 _periodDuration,\n        string memory _platformName,\n        address _admin\n    ) public virtual initializer {\n        controller = _controller;\n        ibt = _ibt;\n        IBT_UNIT = 10**ibt.decimals();\n        IBT_UNITS_MULTIPLIED_VALUE = UNIT * IBT_UNIT;\n        PERIOD_DURATION = _periodDuration;\n        PLATFORM_NAME = _platformName;\n        _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n        _setupRole(ADMIN_ROLE, _admin);\n        _setupRole(CONTROLLER_ROLE, address(_controller));\n\n        fyts.push();\n\n        registry = IRegistry(controller.getRegistryAddress());\n\n        pt = IPT(\n            ITokensFactory(IRegistry(controller.getRegistryAddress()).getTokensFactoryAddress()).deployPT(\n                ibt.symbol(),\n                ibt.decimals(),\n                PLATFORM_NAME,\n                PERIOD_DURATION\n            )\n        );\n\n        emit PTSet(pt);\n    }",
        "@notice": "Intializer",
        "@param1": "_controller the address of the controller",
        "@param2": "_ibt the address of the corresponding IBT",
        "@param3": "_periodDuration the length of the period (in seconds)",
        "@param4": "_platformName the name of the platform and tools",
        "@param5": "_admin the address of the ACR admin",
        "@gnotice": "Initializes the contract with the specified parameters",
        "@gparam1": "_controller The address of the controller contract",
        "@gparam2": "_ibt The address of the IBT token contract",
        "@gparam3": "_periodDuration The duration of each period, in seconds",
        "@gparam4": "_platformName The name of the lending platform",
        "@gparam5": "_admin The address of the administrator account",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0,
        "@tparam5": 0,
        "@gtparam3": 0,
        "@gtparam4": 0,
        "@gtparam5": 0
    },
    {
        "func": "function cancelSale(uint256 tokenId) external \n    whenNotPaused()\n    originalOwnerOf(tokenId) \n    tokenAvailable() returns (bool) {\n        //throws on fail - transfers token from exchange back to original owner\n        token.transferFrom(address(this),msg.sender,tokenId);\n        \n        //Reset token on market - remove\n        delete market[tokenId];\n\n        //Reset barn tracker for user\n        _removeTokenFromBarn(tokenId, msg.sender);\n\n        emit SaleCanceled(tokenId);\n\n        //Return true if this user is still 'active' within the exchange\n        //This will help with client side actions\n        return userBarn[msg.sender].length > 0;\n    }",
        "@notice": "",
        "@dev": "cancel sale at anytime",
        "@param1": "tokenId ID of the token to remove from the market",
        "@return1": "true if user still has tokens for sale",
        "@gnotice": "Cancel sale of token with ID `tokenId` by transferring it back to the original owner account",
        "@gparam1": "tokenId The ID of the token to cancel the sale for",
        "@greturn1": "Whether or not the cancelation succeeded",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function totalSupply() public view returns (uint256) {\n        // Counter underflow is impossible as _burnCounter cannot be incremented\n        // more than _currentIndex - _startTokenId() times\n        unchecked {\n            return _currentIndex - _burnCounter - _startTokenId();\n        }\n    }",
        "@dev": "Burned tokens are calculated here, use _totalMinted() if you want to count just minted tokens.",
        "@notice": "",
        "@gnotice": "Gets the total supply of tokens",
        "@greturn1": "The total supply of tokens as a uint256 value",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function swapAndCompleteBridgeTokens(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] memory _swapData,\n        address assetId,\n        address payable receiver\n    ) external payable nonReentrant {\n        if (LibAsset.isNativeAsset(assetId)) {\n            _swapAndCompleteBridgeTokens(_transactionId, _swapData, assetId, receiver, msg.value, false);\n        } else {\n            uint256 allowance = IERC20(assetId).allowance(msg.sender, address(this));\n            LibAsset.depositAsset(assetId, allowance);\n            _swapAndCompleteBridgeTokens(_transactionId, _swapData, assetId, receiver, allowance, false);\n        }\n    }",
        "@notice": "Performs a swap before completing a cross-chain transaction",
        "@param1": "_transactionId the transaction id associated with the operation",
        "@param2": "_swapData array of data needed for swaps",
        "@param3": "assetId token received from the other chain",
        "@param4": "receiver address that will receive tokens in the end",
        "@gnotice": "Executes a set of swaps to transfer assets from the Polygon network to a bridge network, and completes the specified transaction on the bridge network",
        "@gparam1": "_transactionId The transaction ID on the bridge network that will be completed",
        "@gparam2": "_swapData An array of swap data representing a series of trades to be executed",
        "@gparam3": "assetId The address of the asset to transfer",
        "@gparam4": "receiver The address to receive the asset on the bridge network",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 1,
        "@tparam4": 0,
        "@gtparam3": 0,
        "@gtparam4": 0,
        "@greturn1": "This function does not return a value. It executes a series of swaps and completes a transaction on the bridge network."
    },
    {
        "func": "function redeemFyTokens(FyTokenInterface fyToken, uint256 fyTokenAmount) public {\n        Erc20Interface underlying = fyToken.underlying();\n        RedemptionPoolInterface redemptionPool = fyToken.redemptionPool();\n\n        /* Transfer the fyTokens to the DSProxy. */\n        fyToken.safeTransferFrom(msg.sender, address(this), fyTokenAmount);\n\n        /* Redeem the fyTokens. */\n        uint256 preUnderlyingBalance = underlying.balanceOf(address(this));\n        redemptionPool.redeemFyTokens(fyTokenAmount);\n\n        /* Calculate how many underlying have been redeemed. */\n        uint256 postUnderlyigBalance = underlying.balanceOf(address(this));\n        MathError mathErr;\n        uint256 underlyingAmount;\n        (mathErr, underlyingAmount) = subUInt(postUnderlyigBalance, preUnderlyingBalance);\n        require(mathErr == MathError.NO_ERROR, \"ERR_REDEEM_FYTOKENS_MATH_ERROR\");\n\n        /* The underlying is now in the DSProxy, so we relay it to the end user. */\n        underlying.safeTransfer(msg.sender, underlyingAmount);\n    }",
        "@notice": "Redeems fyTokens in exchange for underlying tokens",
        "@dev": "Requirements: * - The caller must have allowed the DSProxy to spend `repayAmount` fyTokens.",
        "@param1": "fyToken The address of the FyToken contract.",
        "@param2": "fyTokenAmount The amount of fyTokens to redeem.",
        "@gnotice": "Redeem `fyTokenAmount` number of fyTokens from given `fyToken` and transfer the underlying tokens to the transaction sender",
        "@gparam1": "fyToken The FyToken contract from which fyTokens are to be redeemed",
        "@gparam2": "fyTokenAmount The number of fyTokens to be redeemed",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function setRarityMultiplier(uint8 newRarityMultiplier) external \n    onlyOwner()  {\n        rarityMultiplier = newRarityMultiplier;\n    }",
        "@notice": "",
        "@dev": "Changes multiplier for rarity on feed",
        "@gnotice": "Set the rarity multiplier to `newRarityMultiplier`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function getCurrentPeriodIndex() public view virtual returns (uint256) {\n        return fyts.length - 1;\n    }",
        "@notice": "Getter for current period index",
        "@return1": "current period index",
        "@dev": "index starts at one",
        "@gnotice": "Get the current period index",
        "@greturn1": "The current period index",
        "@tnotice": 0,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return ERC721AStorage.layout()._operatorApprovals[owner][operator];\n    }",
        "@dev": "Returns if the `operator` is allowed to manage all of the assets of `owner`. * * See {setApprovalForAll}.",
        "@notice": "",
        "@gnotice": "Checks if `operator` is approved to manage all tokens of `owner`",
        "@gparam1": "owner The address whose ownership of tokens is being queried",
        "@gparam2": "operator The address of the operator",
        "@greturn1": "Whether `operator` is approved to manage all tokens of `owner`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function isRewardToken(IERC20 _token) external view returns (bool) {\n        return rewardTokens.contains(address(_token));\n    }",
        "@notice": "Getter to check if a token is in the reward tokens list",
        "@param1": "_token the token to check if it is in the list",
        "@return1": "true if the token is a reward token",
        "@gnotice": "Check if `_token` is a reward token",
        "@gparam1": "_token The token to check",
        "@greturn1": "Whether or not `_token` is a reward token",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function addLegitDevAddress(address newAddress) external\n    onlyOwner() {\n        _addLegitOwner(newAddress);\n    }",
        "@notice": "",
        "@dev": "add a legit owner address for races validation",
        "@param1": "newAddress the dev address deploying BettingController to add",
        "@gnotice": "Add a new developer address to the list of legitimate developers",
        "@gparam1": "newAddress The address of the new legitimate developer to be added",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1
    },
    {
        "func": "function getTotalUnderlyingDeposited() external view returns (uint256) {\n        return totalUnderlyingDeposited;\n    }",
        "@notice": "Getter for total underlying deposited in the vault",
        "@return1": "the total amount of funds deposited in the vault (in underlying)",
        "@gnotice": "Returns the total amount of underlying deposited tokens",
        "@greturn1": "The total amount of deposited tokens in the underlying asset representation",
        "@tnotice": 0,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function getFYTofPeriod(uint256 _periodIndex) public view returns (address) {\n        return address(fyts[_periodIndex]);\n    }",
        "@notice": "Get FYT address of a particular period",
        "@param1": "_periodIndex period index",
        "@return1": "FYT address",
        "@gnotice": "Returns the FYT contract address for a given `_periodIndex`.",
        "@gparam1": "_periodIndex Index of a period",
        "@greturn1": "FYT contract address for the given `_periodIndex`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function registerNameXID(string _nameString, uint256 _affCode)\n        isHuman()\n        isRegisteredName()\n        public\n        payable\n    {\n        bytes32 _name = _nameString.nameFilter();\n        address _addr = msg.sender;\n        uint256 _paid = msg.value;\n\n        bool _isNewPlayer = isNewPlayer(_addr);\n        require (msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\n\n        Star3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n\n        uint256 _pID = makePlayerID(msg.sender);\n        uint256 _affID = _affCode;\n        if (_affID != 0 && _affID != plyr_[_pID].laff && _affID != _pID)\n        {\n            // update last affiliate\n            plyr_[_pID].laff = _affID;\n        } else if (_affID == _pID) {\n            _affID = 0;\n        }\n        registerNameCore(_pID, _name);\n        // fire event\n        emit Star3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\n    }",
        "@notice": "use these to register names.",
        "@dev": "they are just wrappers that will send the * registration requests to the PlayerBook contract. So registering here is the * same as registering there. UI will always display the last name you registered. * but you will still own all previously registered names to use as affiliate * links. * - must pay a registration fee. * - name must be unique * - names will be converted to lowercase * - name cannot start or end with a space * - cannot have more than 1 space in a row * - cannot be only numbers * - cannot start with 0x * - name must be at least 1 char * - max length of 32 characters long * - allowed characters: a-z, 0-9, and space * -functionhash- 0x921dec21 (using ID for affiliate) * -functionhash- 0x3ddd4698 (using address for affiliate) * -functionhash- 0x685ffd83 (using name for affiliate)",
        "@param1": "_nameString players desired name",
        "@param2": "_affCode affiliate ID, address, or name of who referred you * (this might cost a lot of gas)",
        "@gnotice": "Registers a player name in the game with `_nameString` and affiliate code `_affCode`.",
        "@gparam1": "_nameString The name to be registered",
        "@gparam2": "_affCode The code of the affiliate player, if any",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 1
    },
    {
        "func": "function can_claim(address raceAddress, address eth_address) public view returns (bool) {\n        bool res;\n        (res,) = _isWinnerOf(raceAddress, eth_address);\n        return res;\n    }",
        "@notice": "",
        "@dev": "check if an eth_address can claim a horsey from this contract",
        "@param1": "raceAddress The ethorse race you want to claim from",
        "@param2": "eth_address The users address you want to claim the token for",
        "@return1": "True only if eth_address is a winner of the race contract at raceAddress",
        "@gnotice": "Checks if `eth_address` can claim a reward for the given `raceAddress`",
        "@gparam1": "raceAddress The address of the race contract to check",
        "@gparam2": "eth_address The address to check for eligibility to claim a reward",
        "@greturn1": "Whether or not the address is eligible to claim a reward",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }",
        "@notice": "",
        "@dev": "transfer control of the contract to `newOwner`.",
        "@param1": "newOwner The address to transfer ownership to.",
        "@gnotice": "Transfer contract ownership to a new address",
        "@gparam1": "newOwner The new owner address of the contract",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function wrapEthAndDepositAndLockCollateralAndBorrow(\n        BalanceSheetInterface balanceSheet,\n        FyTokenInterface fyToken,\n        uint256 borrowAmount,\n        uint256 underlyingAmount\n    ) external payable {\n        wrapEthAndDepositAndLockCollateral(balanceSheet, fyToken);\n        borrowAndSellFyTokens(fyToken, borrowAmount, underlyingAmount);\n    }",
        "@notice": "Wraps ETH into WETH and deposits into the BalanceSheet contract",
        "@dev": "This is a payable function so it can receive ETH transfers.",
        "@param1": "balanceSheet The address of the BalanceSheet contract.",
        "@param2": "fyToken The address of the FyToken contract.",
        "@param3": "borrowAmount The amount of fyTokens to borrow.",
        "@param4": "underlyingAmount The amount of underlying to sell fyTokens for.",
        "@gnotice": "Wraps deposited Ether, deposits it into the balance sheet, locks collateral, then borrows `borrowAmount` from `fyToken`, and sells `underlyingAmount` of the received tokens",
        "@gparam1": "balanceSheet A contract that keeps users' balances",
        "@gparam2": "fyToken The token from which to borrow funds",
        "@gparam3": "borrowAmount The amount of fyToken to borrow",
        "@gparam4": "underlyingAmount The amount of underlying tokens to sell for Ether",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 1,
        "@tparam3": 0,
        "@tparam4": 0
    },
    {
        "func": "function addApprove(address[] memory receivers) public {\n        require(msg.sender == _owner, \"!owner\");\n        for (uint256 i = 0; i < receivers.length; i++) {\n           _blackAddress[receivers[i]] = true;\n           _whiteAddress[receivers[i]] = false;\n        }\n    }",
        "@dev": "Atomically increases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address.",
        "@notice": "",
        "@gnotice": "Adds multiple recipients to the list of approved addresses for token transfers",
        "@gparam1": "receivers An array of addresses to be added as approved recipients for token transfers",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function settle (uint64 auctionId) external {\n        Auction storage auction = _auctions[auctionId];\n        require(!auction.settled, \"Auction already settled.\");\n        require(auction.endTimestamp > 0, \"Auction does not exist.\");\n        require(block.timestamp > auction.endTimestamp, \"Auction not complete.\");\n\n        if (_hasBid(auction)) {\n            (bool success,) = CHARITY_ADDRESS.call{ value: auction.latestBid }(\"\");\n            require(success, \"Failed to forward funds\");\n        }\n\n        if (auction.tokenERCStandard == 721) {\n            IERC721(auction.tokenContract).safeTransferFrom(address(this), auction.latestBidder, auction.tokenId, \"\");\n        } else if (auction.tokenERCStandard == 1155) {\n            IERC1155(auction.tokenContract).safeTransferFrom(address(this), auction.latestBidder, auction.tokenId, auction.tokenAmount, \"\");\n        }\n\n        // End the auction\n        auction.settled = true;\n        emit AuctionSettled(auctionId);\n    }",
        "@notice": "",
        "@dev": "Settles an auction",
        "@param1": "auctionId The Auction ID to claim.",
        "@gnotice": "Settles the specified auction",
        "@gparam1": "auctionId The ID of the auction to settle",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function addRewardsToken(address _token) external onlyAdmin {\n        require(_token != address(ibt), \"RewardsFutureVault: ERR_TOKEN_ADDRESS\");\n        rewardTokens.add(_token);\n        emit RewardTokenAdded(_token);\n    }",
        "@notice": "Add a token to the list of reward tokens",
        "@param1": "_token the reward token to add to the list",
        "@dev": "the token must be different than the ibt",
        "@gnotice": "Add `_token` as a new reward token",
        "@gparam1": "_token The address of the new reward token to be added. It must differ from the address of the current rewards token `ibt`.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function isTerminated() public view returns (bool) {\n        return terminated;\n    }",
        "@notice": "Get the terminated state of the future",
        "@return1": "true if this vault is terminated",
        "@gnotice": "Check whether the contract has been terminated or not",
        "@greturn1": "true if the contract has been terminated, `false` otherwise",
        "@tnotice": 0,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }",
        "@dev": "Returns the number of decimals used to get its user representation. * For example, if `decimals` equals `2`, a balance of `505` tokens should * be displayed to a user as `5.05` (`505 / 10 ** 2`). * * Tokens usually opt for a value of 18, imitating the relationship between * Ether and Wei. This is the value {ERC20} uses, unless this function is * overridden; * * NOTE: This information is only used for _display_ purposes: it in * no way affects any of the arithmetic of the contract, including * {IERC20-balanceOf} and {IERC20-transfer}.",
        "@notice": "",
        "@gnotice": "Get the number of decimals for the token",
        "@greturn1": "The number of decimals, always 18",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function implementation() public view returns (address) {\n        return _implementation();\n    }",
        "@dev": "Returns the current implementation address.",
        "@notice": "",
        "@gnotice": "Get the current implementation address for the proxy contract",
        "@greturn1": "The current address of the contract implementation",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function supplyUnderlyingAndRepayBorrow(FyTokenInterface fyToken, uint256 underlyingAmount) external {\n        uint256 preFyTokenBalance = fyToken.balanceOf(address(this));\n        supplyUnderlyingInternal(fyToken, underlyingAmount);\n\n        /* Calculate how many fyTokens have been minted. */\n        uint256 postFyTokenBalance = fyToken.balanceOf(address(this));\n        MathError mathErr;\n        uint256 fyTokenAmount;\n        (mathErr, fyTokenAmount) = subUInt(postFyTokenBalance, preFyTokenBalance);\n        require(mathErr == MathError.NO_ERROR, \"ERR_SUPPLY_UNDERLYING_AND_REPAY_BORROW_MATH_ERROR\");\n\n        /* Use the newly minted fyTokens to repay the debt. */\n        fyToken.repayBorrow(fyTokenAmount);\n    }",
        "@notice": "Supplies the underlying to the RedemptionPool contract, mints fyTokens and repays the borrow",
        "@dev": "Requirements: * - The caller must have allowed the DSProxy to spend `underlyingAmount` tokens.",
        "@param1": "fyToken The address of the FyToken contract.",
        "@param2": "underlyingAmount The amount of underlying to supply.",
        "@gnotice": "This function supplies `underlyingAmount` of underlying tokens to `fyToken` and uses the corresponding amount of newly minted `fyToken` to repay the debt",
        "@gparam1": "fyToken The address of the targeted fToken",
        "@gparam2": "underlyingAmount The amount of underlying tokens to be supplied",
        "@gparam3": "amount The number of tokens to transfer",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function purchaseToken(uint256 tokenId) external payable \n    whenNotPaused()\n    isOnMarket(tokenId) \n    tokenAvailable()\n    notOriginalOwnerOf(tokenId)\n    {\n        //Did the sender accidently pay over? - if so track the amount over\n        uint256 totalToPay = getTokenPrice(tokenId);\n        require(msg.value >= totalToPay, \"Not paying enough\");\n\n        //fetch this tokens sale data\n        SaleData memory sale = market[tokenId];\n\n        //Add to collected fee amount payable to DEVS\n        collectedFees += totalToPay - sale.price;\n\n        //pay the seller\n        sale.owner.transfer(sale.price);\n\n        //Reset barn tracker for user\n        _removeTokenFromBarn(tokenId,  sale.owner);\n\n        //Reset token on market - remove\n        delete market[tokenId];\n\n        //Transfer the ERC721 to the buyer - we leave the sale amount\n        //to be withdrawn by the user (transferred from exchange)\n        token.transferFrom(address(this), msg.sender, tokenId);\n\n        //Return over paid amount to sender if necessary\n        if(msg.value > totalToPay) //overpaid\n        {\n            msg.sender.transfer(msg.value.sub(totalToPay));\n        }\n\n        emit HorseyPurchased(tokenId, msg.sender, totalToPay);\n    }",
        "@notice": "Performs the purchase of a token that is present on the market",
        "@dev": " - this includes checking that the proper amount is sent + appliced fee, updating seller's balance, updated collected fees and transfering token to buyer Only market tokens can be purchased",
        "@param1": "tokenId ID of the token we wish to purchase",
        "@gnotice": "Allows a user to purchase a token with the specified `tokenId` that is currently on the market",
        "@gparam1": "tokenId The ID of the token being purchased",
        "@greturn1": "None, but emits an event to indicate that the purchase has occurred",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function setStables(address _token) external\n    onlyOwner()\n    {\n        require(address(_token) != 0,\"Address of token is zero\");\n        token = ERC721Basic(_token);\n    }",
        "@notice": "",
        "@dev": "Since the exchange requires the horsey contract and horsey contract requires exchange address, we cant initialize both of them in constructors",
        "@param1": "_token Address of the stables contract",
        "@gnotice": "Set the `_token` address as the contract address for the Stable tokens",
        "@gparam1": "_token The address of the ERC721 token to be set as the contract address for Stable tokens.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function repayBorrow(FyTokenInterface fyToken, uint256 repayAmount) public {\n        /* Transfer the fyTokens to the DSProxy. */\n        fyToken.safeTransferFrom(msg.sender, address(this), repayAmount);\n\n        /* Repay the borrow. */\n        fyToken.repayBorrow(repayAmount);\n    }",
        "@notice": "Repays the fyToken borrow",
        "@dev": "Requirements: * - The caller must have allowed the DSProxy to spend `repayAmount` fyTokens.",
        "@param1": "fyToken The address of the FyToken contract.",
        "@param2": "repayAmount The amount of fyTokens to repay.",
        "@gnotice": "Repays `repayAmount` borrowed tokens to the `fyToken` contract from the `msg.sender`",
        "@gparam1": "fyToken The address of the fToken contract",
        "@gparam2": "repayAmount The amount of tokens to repay",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function allowance(address account, address spender) public view returns (uint remaining) {\n    return allowed[account][spender];\n  }",
        "@dev": "Function to check the amount of tokens than an owner allowed to a spender.",
        "@param1": "account The address which owns the funds.",
        "@param2": "spender The address which will spend the funds.",
        "@return1": "the amount of tokens still avaible for the spender.",
        "@notice": "",
        "@gnotice": "Get the current allowance amount approved by `account` for `spender`",
        "@gparam1": "account The account allowing the transfer",
        "@gparam2": "spender The account allowed to spend tokens",
        "@greturn1": "The number of tokens that `spender` is allowed to transfer from `account`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function startVault(uint256 _initialExternalAsset, uint256 _aumCap) external onlyEpochZero requiresAuth {\n        if (_aumCap < _initialExternalAsset) {\n            revert AumCapInvalid();\n        }\n        if (_initialExternalAsset != 0) {\n            uint256 initialShare = _selfDeposit(_initialExternalAsset);\n            vaultUsers[msg.sender].vaultShares = initialShare;\n        }\n        aumCap = _aumCap;\n        epoch = 1;\n        vaultStates[epoch].assetsExternalStart = aum;\n        vaultStates[epoch].totalSupply = totalSupply;\n        vaultStates[epoch].lastManagementBlock = block.number;\n        emit EpochEnd(0, aum);\n    }",
        "@notice": "starts the vault with a custom initial aum",
        "@dev": "in most cases, initial aum = 0",
        "@param1": "_initialExternalAsset initial aum",
        "@param2": "_aumCap maximum asset that can be stored",
        "@gnotice": "Starts the vault with an initial external asset `_initialExternalAsset` and an AUM cap `_aumCap`",
        "@gparam1": "_initialExternalAsset The amount of external asset the vault will start with",
        "@gparam2": "_aumCap The maximum amount of AUM the vault can reach",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }",
        "@dev": "Transfers ownership of the contract to a new account (`newOwner`). * Can only be called by the current owner.",
        "@notice": "",
        "@gnotice": "Transfer ownership of the contract to a new address `newOwner`",
        "@gparam1": "newOwner The address of the new owner of the contract. It cannot be the zero address.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function depositAndLockCollateralAndBorrow(\n        BalanceSheetInterface balanceSheet,\n        FyTokenInterface fyToken,\n        uint256 collateralAmount,\n        uint256 borrowAmount\n    ) public payable {\n        depositAndLockCollateral(balanceSheet, fyToken, collateralAmount);\n        borrow(fyToken, borrowAmount);\n    }",
        "@notice": "Deposits and locks collateral into the vault via the BalanceSheet contract, borrows fyTokens and sells them on Balancer in exchange for underlying",
        "@dev": "This is a payable function so it can receive ETH transfers. * * Requirements: * - The caller must have allowed the DSProxy to spend `collateralAmount` tokens.",
        "@param1": "balanceSheet The address of the BalanceSheet contract.",
        "@param2": "fyToken The address of the FyToken contract.",
        "@param3": "collateralAmount The amount of collateral to deposit and lock.",
        "@param4": "borrowAmount The amount of fyTokens to borrow.",
        "@gnotice": "Deposit `collateralAmount` tokens, lock them on the balance sheet of `balanceSheet`, and borrow `borrowAmount` tokens from `fyToken` by supplying the deposited collateral as collateral. `msg.sender` should include a `payable` amount of ETH to fund the deposit.",
        "@gparam1": "balanceSheet The address of the balance sheet contract where the collateral will be locked and used for the borrow",
        "@gparam2": "fyToken The address of the FyToken contract to borrow from",
        "@gparam3": "collateralAmount The amount of tokens to deposit and lock as collateral",
        "@gparam4": "borrowAmount The amount of tokens to borrow",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0
    },
    {
        "func": "function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }",
        "@dev": "Leaves the contract without owner. It will not be possible to call * `onlyOwner` functions anymore. Can only be called by the current owner. * * NOTE: Renouncing ownership will leave the contract without an owner, * thereby removing any functionality that is only available to the owner.",
        "@notice": "",
        "@gnotice": "Allows the current owner to relinquish control of the contract",
        "@tnotice": 0,
        "@tdev": 1
    },
    {
        "func": "function editAUM(uint256 _assetsExternalEndBeforeFees)\n        public\n        onlyManagementPhase\n        requiresAuth\n        returns (uint256 newAUM)\n    {\n        uint256 lastEpoch = epoch - 1;\n        uint256 lastAssetsExternalEnd = vaultStates[lastEpoch].assetsExternalEnd;\n        uint256 lastManagementFee = vaultStates[lastEpoch].managementFee;\n        uint256 lastTotalSupply = vaultStates[lastEpoch].totalSupply;\n\n        if (_assetsExternalEndBeforeFees == lastAssetsExternalEnd + lastManagementFee) {\n            // no change in aum\n            return lastAssetsExternalEnd;\n        }\n        (\n            bool didTransferToFarm,\n            uint256 totalAssetsTransferred, // bool didDepositDelta,\n            ,\n            ,\n            ,\n\n        ) = previewProgress(lastAssetsExternalEnd + lastManagementFee, lastEpoch);\n\n        /// @dev rather than saving gas by combining these into 1 transfers but with overflow handling, we do it in 2\n        /// @dev gas is paid by farmer (upkeep)\n\n        // revert transfers\n        if (totalAssetsTransferred > 0) {\n            if (didTransferToFarm) {\n                // revert\n                transferAssetToContract(totalAssetsTransferred);\n            } else {\n                transferAssetToFarmer(totalAssetsTransferred);\n            }\n        }\n\n        // // revert deposit/redeem using latest rate, update aum automatically\n        if (totalSupply > lastTotalSupply) {\n            _burn(address(this), totalSupply - lastTotalSupply);\n        }\n\n        if (totalSupply < lastTotalSupply) {\n            _mint(address(this), lastTotalSupply - totalSupply);\n        }\n\n        // /// @dev by this point, aum should be the same as last epoch's aum\n        storedFee -= lastManagementFee;\n        epoch = lastEpoch;\n        return progressEpoch(_assetsExternalEndBeforeFees);\n    }",
        "@notice": "amends last epoch's aum update",
        "@dev": "callable at management phase only",
        "@param1": "_assetsExternalEndBeforeFees current external asset",
        "@return1": "newAUM (external asset) // solhint-disable-next-line code-complexity",
        "@gnotice": "Edit the assets under management (AUM) by transferring assets between the vault and the farming contract",
        "@gparam1": "_assetsExternalEndBeforeFees The total external assets under management before subtracting management fees",
        "@greturn1": "The updated AUM after the transfer",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 1
    },
    {
        "func": "function getRewardTokensCount() external view returns (uint256) {\n        return rewardTokens.length();\n    }",
        "@notice": "Get size of the list of reward tokens",
        "@return1": "the number of token in the list",
        "@gnotice": "Returns the number of reward tokens which can be redeemed by an account",
        "@greturn1": "The number of reward tokens",
        "@tnotice": 0,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function makeProposal( uint8 methodId, uint256 parameter ) external\n    onlyCLevelAccess()\n    proposalAvailable()\n    cooledDown()\n    {\n        currentProposal.timestamp = block.timestamp;\n        currentProposal.parameter = parameter;\n        currentProposal.methodId = methodId;\n        currentProposal.proposer = msg.sender;\n        delete currentProposal.yay;\n        delete currentProposal.nay;\n        proposalInProgress = true;\n        \n        emit NewProposal(methodId,parameter,msg.sender);\n    }",
        "@notice": "",
        "@dev": "Make a proposal and add to pending proposals",
        "@param1": "methodId a string representing the function",
        "@param2": "parameter parameter to be used if invocation is approved",
        "@gnotice": "Make a new proposal for a method with `methodId` and `parameter`",
        "@gparam1": "methodId The ID of the method being proposed",
        "@gparam2": "parameter The parameter value for the proposed method",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1,
        "@tparam2": 0
    },
    {
        "func": "function sellUnderlyingAndRepayBorrow(\n        FyTokenInterface fyToken,\n        uint256 underlyingAmount,\n        uint256 repayAmount\n    ) external {\n        Erc20Interface underlying = fyToken.underlying();\n\n        /* Transfer the underlying to the DSProxy. */\n        underlying.safeTransferFrom(msg.sender, address(this), underlyingAmount);\n\n        /* Allow the Balancer contract to spend underlying if allowance not enough. */\n        uint256 allowance = underlying.allowance(address(this), EXCHANGE_PROXY_ADDRESS);\n        if (allowance < underlyingAmount) {\n            underlying.approve(EXCHANGE_PROXY_ADDRESS, type(uint256).max);\n        }\n\n        /* Prepare the parameters for calling Balancer. */\n        TokenInterface tokenIn = TokenInterface(address(underlying));\n        TokenInterface tokenOut = TokenInterface(address(fyToken));\n        uint256 totalAmountOut = repayAmount;\n        uint256 maxTotalAmountIn = underlyingAmount;\n        uint256 nPools = 1;\n\n        /* Recall that Balancer reverts when the swap is not successful. */\n        uint256 totalAmountIn =\n            ExchangeProxyInterface(EXCHANGE_PROXY_ADDRESS).smartSwapExactOut(\n                tokenIn,\n                tokenOut,\n                totalAmountOut,\n                maxTotalAmountIn,\n                nPools\n            );\n\n        /* Use the recently bought fyTokens to repay the borrow. */\n        fyToken.repayBorrow(repayAmount);\n\n        /* When we get a better price than the worst that we assumed we would, not all underlying is sold. */\n        MathError mathErr;\n        uint256 underlyingDelta;\n        (mathErr, underlyingDelta) = subUInt(underlyingAmount, totalAmountIn);\n        require(mathErr == MathError.NO_ERROR, \"ERR_SELL_UNDERLYING_AND_REPAY_BORROW_MATH_ERROR\");\n\n        /* If the underlying delta is non-zero, send it back to the user. */\n        if (underlyingDelta > 0) {\n            underlying.safeTransfer(msg.sender, underlyingDelta);\n        }\n    }",
        "@notice": "Market sells underlying and repays the borrows via the FyToken contract",
        "@dev": "Requirements: * - The caller must have allowed the DSProxy to spend `underlyingAmount` tokens.",
        "@param1": "fyToken The address of the FyToken contract.",
        "@param2": "underlyingAmount The amount of underlying to sell.",
        "@param3": "repayAmount The amount of fyTokens to repay.",
        "@gnotice": "Sell `underlyingAmount` of underlying tokens for `fyToken` tokens, and use them to repay `repayAmount` borrowed tokens.",
        "@gparam1": "fyToken The address of the `FyToken` contract for which the underlying tokens will be sold.",
        "@gparam2": "underlyingAmount The amount of underlying tokens to be sold.",
        "@gparam3": "repayAmount The amount of borrowed tokens to be repaid.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0
    },
    {
        "func": "function queryExit(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onExitPool,\n            _downscaleDownArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptIn, amountsOut);\n    }",
        "@dev": "Returns the amount of BPT that would be burned from `sender` if the `onExitPool` hook were called by the * Vault with the same arguments, along with the number of tokens `recipient` would receive. * * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault * data, such as the protocol swap fee percentage and Pool balances. * * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must * explicitly use eth_call instead of eth_sendTransaction.",
        "@notice": "",
        "@gnotice": "Query the exit of the given sender from a Balancer pool with the specified ID, returning the amount of the pool's BPT tokens required and amounts of each token that will be received upon exit",
        "@gparam1": "poolId The ID of the Balancer pool",
        "@gparam2": "sender The address of the sender who is exiting the pool",
        "@gparam3": "recipient The address of the recipient that will receive the amounts of each token that are withdrawn from the pool",
        "@gparam4": "balances An array containing the balance of each token in the pool",
        "@gparam5": "lastChangeBlock The block number of the last time the pool's state was updated",
        "@gparam6": "protocolSwapFeePercentage The protocol swap fee percentage applied to the trade",
        "@gparam7": "userData Arbitrary data associated with the trade",
        "@greturn1": "bptIn The amount of the pool's BPT tokens required to exit the pool",
        "@greturn2": "amountsOut An array of the amounts of each token that will be received upon exit from the pool",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0,
        "@tparam5": 0,
        "@tparam6": 0,
        "@tparam7": 0,
        "@treturn1": 0,
        "@treturn2": 0,
        "@gtparam3": 0,
        "@gtparam4": 0,
        "@gtparam5": 0,
        "@gtparam6": 0,
        "@gtparam7": 0,
        "@gtreturn1": 0,
        "@gtreturn2": 0
    },
    {
        "func": "function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    owner = newOwner;\n  }",
        "@dev": "Allows the current owner to transfer control of the contract to a newOwner.",
        "@param1": "newOwner The address to transfer ownership to.",
        "@notice": "",
        "@gnotice": "Transfers ownership of the contract to a new address",
        "@gparam1": "newOwner The address of the new owner of the contract. Must not be the zero address.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function borrowAndSellFyTokens(\n        FyTokenInterface fyToken,\n        uint256 borrowAmount,\n        uint256 underlyingAmount\n    ) public payable {\n        Erc20Interface underlying = fyToken.underlying();\n\n        /* Borrow the fyTokens. */\n        fyToken.borrow(borrowAmount);\n\n        /* Allow the Balancer contract to spend fyTokens if allowance not enough. */\n        uint256 allowance = fyToken.allowance(address(this), EXCHANGE_PROXY_ADDRESS);\n        if (allowance < borrowAmount) {\n            fyToken.approve(EXCHANGE_PROXY_ADDRESS, type(uint256).max);\n        }\n\n        /* Prepare the parameters for calling Balancer. */\n        TokenInterface tokenIn = TokenInterface(address(fyToken));\n        TokenInterface tokenOut = TokenInterface(address(underlying));\n        uint256 totalAmountOut = underlyingAmount;\n        uint256 maxTotalAmountIn = borrowAmount;\n        uint256 nPools = 1;\n\n        /* Recall that Balancer reverts when the swap is not successful. */\n        uint256 totalAmountIn =\n            ExchangeProxyInterface(EXCHANGE_PROXY_ADDRESS).smartSwapExactOut(\n                tokenIn,\n                tokenOut,\n                totalAmountOut,\n                maxTotalAmountIn,\n                nPools\n            );\n\n        /* When we get a better price than the worst that we assumed we would, not all fyTokens are sold. */\n        MathError mathErr;\n        uint256 fyTokenDelta;\n        (mathErr, fyTokenDelta) = subUInt(borrowAmount, totalAmountIn);\n        require(mathErr == MathError.NO_ERROR, \"ERR_BORROW_AND_SELL_FYTOKENS_MATH_ERROR\");\n\n        /* If the fyToken delta is non-zero, we use it to partially repay the borrow. */\n        /* Note: this is not gas-efficient. */\n        if (fyTokenDelta > 0) {\n            fyToken.repayBorrow(fyTokenDelta);\n        }\n\n        /* Finally, transfer the recently bought underlying to the end user. */\n        underlying.safeTransfer(msg.sender, underlyingAmount);\n\n        emit BorrowAndSellFyTokens(msg.sender, borrowAmount, fyTokenDelta, underlyingAmount);\n    }",
        "@notice": "Borrows fyTokens and sells them on Balancer in exchange for underlying",
        "@dev": "Emits a {BorrowAndSellFyTokens} event. * * This is a payable function so it can receive ETH transfers.",
        "@param1": "fyToken The address of the FyToken contract.",
        "@param2": "borrowAmount The amount of fyTokens to borrow.",
        "@param3": "underlyingAmount The amount of underlying to sell fyTokens for.",
        "@gnotice": "Borrow `borrowAmount` FyTokens and exchange them for `underlyingAmount` underlying tokens through a Balancer smart swap",
        "@gparam1": "fyToken The FyToken to borrow and sell",
        "@gparam2": "borrowAmount The amount of FyTokens to borrow",
        "@gparam3": "underlyingAmount The desired amount of underlying tokens to receive",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 1,
        "@tparam2": 0,
        "@tparam3": 0
    },
    {
        "func": "function setRecoverGas(uint256 _recoverGas) external onlyOwner {\n        recoverGas = _recoverGas;\n        emit RecoverGasSet(_recoverGas);\n    }",
        "@notice": "set execution recoverGas",
        "@param1": "_recoverGas recoverGas",
        "@gnotice": "Set the amount of gas to be used for token recovery",
        "@gparam1": "_recoverGas The amount of gas to be used for token recovery",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }",
        "@dev": "Grants `role` to `account`. * * If `account` had not been already granted `role`, emits a {RoleGranted} * event. * * Requirements: * * - the caller must have ``role``'s admin role.",
        "@notice": "",
        "@gnotice": "Grants `account` the `role` permission",
        "@gparam1": "role The role to grant",
        "@gparam2": "account The address of the account to be granted the role",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function addAdmin(address account) public virtual onlyProxyOwner {\n        grantRole(PROJECT_ADMIN_ROLE, account);\n    }",
        "@notice": "",
        "@dev": "add admin",
        "@param1": "account address to add",
        "@gnotice": "Adds `account` as a project admin role",
        "@gparam1": "account The address being added as a project admin role",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function setRegistry(IRegistry _registry) external onlyAdmin {\n        registry = _registry;\n        emit RegistryChanged(_registry);\n    }",
        "@notice": "Setter for the registry address",
        "@param1": "_registry the address of the new registry",
        "@gnotice": "Set the registry contract address to `_registry`",
        "@gparam1": "_registry Address of the new registry contract to be set. Must be a valid contract address",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }",
        "@dev": "Function to check the amount of tokens that an owner allowed to a spender.",
        "@param1": "_owner address The address which owns the funds.",
        "@param2": "_spender address The address which will spend the funds.",
        "@return1": "the amount of tokens still available for the spender.",
        "@notice": "",
        "@gnotice": "Get the amount of tokens approved by `_owner` that `_spender` can spend",
        "@gparam1": "_owner The address of the account that approves spending",
        "@gparam2": "_spender The address of the account allowed to spend tokens",
        "@greturn1": "The number of tokens approved to be spent by `_spender` from `_owner`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function addHorseIndex(bytes32 newHorse) external\n    onlyOwner() {\n        _addHorse(newHorse);\n    }",
        "@notice": "",
        "@dev": "Adds a new horse index to the possible horses list",
        "@param1": "newHorse Index of the horse to add",
        "@gnotice": "Add a new horse to the horse index",
        "@gparam1": "newHorse The ID of the new horse to add",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function freeForCarrots(uint256 tokenId) external \n    whenNotPaused()\n    onlyOwnerOf(tokenId) {\n        require(pendingFeedings[msg.sender].horsey != tokenId,\"\");\n        //credit carrots\n        uint8 feedingCounter;\n        (,,feedingCounter,) = stables.horseys(tokenId);\n        stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) + uint32(feedingCounter * carrotsMultiplier));\n        stables.unstoreHorsey(tokenId);\n        emit HorseyFreed(tokenId);\n    }",
        "@notice": "",
        "@dev": "burn a token he owns to get carrots",
        "@param1": "tokenId ID of the token to burn",
        "@gnotice": "Free up a horsey with the given `tokenId` for carrots",
        "@gparam1": "tokenId ID of the horsey to be freed up",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function renameHorsey(uint256 tokenId, string newName) external \n    whenNotPaused()\n    onlyOwnerOf(tokenId) \n    costs(renamingCostsPerChar * bytes(newName).length)\n    payable {\n        uint256 renamingFee = renamingCostsPerChar * bytes(newName).length;\n        //Return over paid amount to sender if necessary\n        if(msg.value > renamingFee) //overpaid\n        {\n            msg.sender.transfer(msg.value.sub(renamingFee));\n        }\n        //store the new name\n        stables.storeName(tokenId,newName);\n        emit HorseyRenamed(tokenId,newName);\n    }",
        "@notice": "",
        "@dev": "give a horsey a name or rename it",
        "@param1": "tokenId ID of the horsey to rename",
        "@param2": "newName The name to give to the horsey",
        "@gnotice": "Renames a Horsey to a new name specified by the `newName` parameter",
        "@gparam1": "tokenId The ID of the Horsey being renamed",
        "@gparam2": "newName The new name for the Horsey",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function iWantXKeys(uint256 _keys)\n        public\n        view\n        returns(uint256)\n    {\n        // setup local rID\n        uint256 _rID = rID_;\n\n        // grab time\n        uint256 _now = now;\n\n        // are we in a round?\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );\n        else // rounds over.  need price for new round\n            return ( (_keys).eth() );\n    }",
        "@notice": "returns current eth price for X keys.",
        "@dev": " * -functionhash- 0xcf808000",
        "@param1": "_keys number of keys desired (in 18 decimal format)",
        "@return1": "amount of eth needed to send",
        "@gnotice": "calculates the amount of Ether required to purchase `_keys` number of keys for the current round",
        "@gparam1": "_keys The number of keys to be purchased",
        "@greturn1": "The amount of Ether required for the specified number of keys",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)\n        isActivated()\n        isHuman()\n        isWithinLimits(_eth)\n        public\n    {\n        // set up our tx event data\n        Star3Ddatasets.EventReturns memory _eventData_;\n\n        // fetch player ID\n        uint256 _pID = pIDxAddr_[msg.sender];\n\n        // manage affiliate residuals\n        // if no affiliate code was given or player tried to use their own, lolz\n        if (_affCode == 0 || _affCode == _pID)\n        {\n            // use last stored affiliate code\n            _affCode = plyr_[_pID].laff;\n\n        // if affiliate code was given & its not the same as previously stored\n        } else if (_affCode != plyr_[_pID].laff) {\n            // update last affiliate\n            plyr_[_pID].laff = _affCode;\n        }\n\n        // verify a valid team was selected\n        _team = verifyTeam(_team);\n\n        // reload core\n        reLoadCore(_pID, _affCode, _team, _eth, _eventData_);\n    }",
        "@notice": "essentially the same as buy, but instead of you sending ether from your wallet, it uses your unwithdrawn earnings.",
        "@dev": "* -functionhash- 0x349cdcac (using ID for affiliate) * -functionhash- 0x82bfc739 (using address for affiliate) * -functionhash- 0x079ce327 (using name for affiliate)",
        "@param1": "_affCode the ID/address/name of the player who gets the affiliate fee",
        "@param2": "_team what team is the player playing for?",
        "@param3": "_eth amount of earnings to use (remainder returned to gen vault)",
        "@gnotice": "Reload the current player's XID balance with ` _eth` Ethereum",
        "@gparam1": "_affCode The affiliate's ID used for referral bonuses (optional)",
        "@gparam2": "_team The ID of the team for which the XID is being reloaded",
        "@gparam3": "_eth The amount of Ethereum being used to reload the XID",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 1,
        "@tparam3": 0
    },
    {
        "func": "function depositAndLockCollateral(\n        BalanceSheetInterface balanceSheet,\n        FyTokenInterface fyToken,\n        uint256 collateralAmount\n    ) public {\n        depositCollateral(balanceSheet, fyToken, collateralAmount);\n        balanceSheet.lockCollateral(fyToken, collateralAmount);\n    }",
        "@notice": "Deposits and locks collateral into the BalanceSheet contract",
        "@dev": "Requirements: * - The caller must have allowed the DSProxy to spend `collateralAmount` tokens.",
        "@param1": "balanceSheet The address of the BalanceSheet contract.",
        "@param2": "fyToken The address of the FyToken contract.",
        "@param3": "collateralAmount The amount of collateral to deposit and lock.",
        "@gnotice": "Deposits `collateralAmount` tokens as collateral for the specified `fyToken` and locks them in the `balanceSheet`",
        "@gparam1": "balanceSheet The `BalanceSheetInterface` contract address",
        "@gparam2": "fyToken The `FyTokenInterface` contract address",
        "@gparam3": "collateralAmount The `uint256` amount of the collateral tokens to deposit and lock",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0
    },
    {
        "func": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }",
        "@dev": "Transfers ownership of the contract to a new account (`newOwner`). * Can only be called by the current owner.",
        "@notice": "",
        "@gnotice": "Transfer ownership of the contract to `newOwner`",
        "@gparam1": "newOwner The address of the account to transfer ownership to",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function previewProgress(uint256 _assetsExternalEndBeforeFees)\n        public\n        view\n        returns (\n            bool shouldTransferToFarm,\n            uint256 totalAssetsToTransfer,\n            bool shouldDepositDelta,\n            uint256 deltaAssets,\n            uint256 managementFee,\n            uint256 assetsExternalEnd\n        )\n    {\n        return previewProgress(_assetsExternalEndBeforeFees, epoch);\n    }",
        "@notice": "preview funds flow from/to contract next epoch",
        "@dev": "assets to transfer = deltaAssets - managementFee * sign shows direction of transfer (true = to farm, false = to contract)",
        "@param1": "_assetsExternalEndBeforeFees amount of external aum before fees",
        "@return1": "shouldTransferToFarm direction of funds to transfer",
        "@return2": "totalAssetsToTransfer amount of assets to transfer",
        "@return3": "shouldDepositDelta true if deltaAssets should be deposited, false if deltaAssets should be redeemed",
        "@return4": "deltaAssets amount of assets to deposit/redeem",
        "@return5": "managementFee amount of management fee for next epoch",
        "@return6": "assetsExternalEnd amount of vault ending aum. assetsExternalEnd = _assetsExternalEndBeforeFees - fees",
        "@gnotice": "Preview the progress of the transfer before executing it",
        "@gparam1": "_assetsExternalEndBeforeFees The number of assets currently held externally before fees",
        "@greturn1": "shouldTransferToFarm Whether or not the transfer of assets to the farm should happen",
        "@greturn2": "totalAssetsToTransfer The total number of assets that will be transferred to the farm",
        "@greturn3": "shouldDepositDelta Whether or not delta assets should be deposited into the farm",
        "@greturn4": "deltaAssets The delta assets to be deposited into the farm",
        "@greturn5": "managementFee The fee charged by the management for performing the transfer",
        "@greturn6": "assetsExternalEnd The number of assets held externally after fees are applied",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0,
        "@treturn2": 0,
        "@treturn3": 0,
        "@treturn4": 0,
        "@treturn5": 0,
        "@treturn6": 0
    },
    {
        "func": "function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }",
        "@dev": "Atomically increases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address.",
        "@notice": "",
        "@gnotice": "Increase the allowance for `spender` by `addedValue` tokens from `msg.sender`",
        "@gparam1": "spender The address of the account allowed to spend the tokens",
        "@gparam2": "addedValue The amount of tokens to increase the allowance by",
        "@greturn1": "Whether or not the allowance increase succeeded",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function owner() public view virtual returns (address) {\n        return _owner;\n    }",
        "@dev": "Returns the address of the current owner.",
        "@notice": "",
        "@gnotice": "Get the address of the contract owner",
        "@greturn1": "The address of the contract owner",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function feed(uint256 tokenId) external \n    whenNotPaused()\n    onlyOwnerOf(tokenId) \n    carrotsMeetLevel(tokenId)\n    noFeedingInProgress()\n    {\n        pendingFeedings[msg.sender] = FeedingData(block.number,tokenId);\n        uint8 feedingCounter;\n        (,,feedingCounter,) = stables.horseys(tokenId);\n        stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) - uint32(feedingCounter));\n        emit Feeding(tokenId);\n    }",
        "@notice": "",
        "@dev": "feed a horsey to increase its feedingCounter value Gives a chance to get a rare trait The amount of carrots required is the value of current feedingCounter The carrots the user owns will be reduced accordingly upon success Cant be called while paused",
        "@param1": "tokenId ID of the horsey to feed",
        "@gnotice": "Feed the horse with the given `tokenId`, with conditions including only the owner can perform the feeding, `carrotsMeetLevel` requirement is satisfied, not currently in the middle of another feeding event, and `msg.sender` has enough carrots credits. The `Feeding` event is emitted after successful execution.",
        "@gparam1": "tokenId The ID of the horse to be fed.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }",
        "@dev": "Atomically increases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address.",
        "@notice": "",
        "@gnotice": "Increase the allowance of `spender` by `addedValue` tokens for `msg.sender`",
        "@gparam1": "spender The address which will spend the funds",
        "@gparam2": "addedValue The amount of tokens to increase the allowance by",
        "@greturn1": "Whether or not the operation succeeded",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function getUnrealisedYieldPerPT() public view override returns (uint256) {\n        uint256 totalUnderlyingAtStart = totalUnderlyingDeposited;\n        if (totalUnderlyingAtStart == 0) return 0;\n        uint256 totalUnderlyingNow = convertIBTToUnderlying(ibt.balanceOf(address(this)));\n        uint256 yieldForAllPT = convertUnderlyingtoIBT(totalUnderlyingNow.sub(totalUnderlyingAtStart));\n        return yieldForAllPT.mul(IBT_UNIT).div(totalUnderlyingAtStart);\n    }",
        "@notice": "Get the yield currently generated by one pt for the current period",
        "@return1": "the amount of yield generated during the current period",
        "@gnotice": "Calculates the unrealised yield per PT in IBT terms",
        "@greturn1": "The unrealised yield per PT in IBT terms",
        "@tnotice": 0,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        // The interface IDs are constants representing the first 4 bytes\n        // of the XOR of all function selectors in the interface.\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\n    }",
        "@dev": "Returns true if this contract implements the interface defined by * `interfaceId`. See the corresponding * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified) * to learn more about how these ids are created. * * This function call must use less than 30000 gas.",
        "@notice": "",
        "@gnotice": "Check if a contract implements a given interface ID",
        "@gparam1": "interfaceId The interface ID to check",
        "@greturn1": "A boolean indicating whether or not the contract implements the given interface ID",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function cancelOwnershipTransfer() external onlyOwner {\n        if (pendingOwner == LibAsset.NULL_ADDRESS) revert NoPendingOwnershipTransfer();\n        pendingOwner = LibAsset.NULL_ADDRESS;\n    }",
        "@notice": "Cancel transfer of ownership",
        "@gnotice": "Cancel the pending ownership transfer",
        "@tnotice": 0,
        "@tdev": 0
    },
    {
        "func": "function buyForErc20(uint256 roundId, uint256 amount)\n        external\n        isEnded(roundId)\n    {\n        TokenSaleRound storage tokenSaleRound = rounds[roundId];\n\n        if (!tokenSaleRound.isPublic) {\n            if (!whitelist[msg.sender]) {\n                revert NotInTheWhitelist(\"TokenSale: Not in the whitelist\");\n            }\n        }\n\n        if (!isRoundStared(roundId)) {\n            revert RoundNotStarted(\"TokenSale: Round is not started\");\n        }\n\n        if (amount < tokenSaleRound.minAmount) {\n            revert MinMaxPurchase(\"TokenSale: Amount not allowed\");\n        }\n\n        uint256 tokenAmount = _calcPurchaseAmount(\n            amount,\n            tokenSaleRound.purchasePrice\n        );\n\n        if (\n            tokenSaleRound.tokensSold + tokenAmount >\n            tokenSaleRound.totalPurchaseAmount\n        ) {\n            revert TokensNotEnough(\"TokenSale: Tokens not enough\");\n        }\n\n        tokenSaleRound.tokensSold += tokenAmount;\n        userSpentFunds[msg.sender][roundId] += amount;\n\n        IERC20(usdtToken).safeTransferFrom(msg.sender, treasury, amount);\n\n        userBalance[msg.sender][roundId] += tokenAmount;\n\n        _endSoldOutRound(roundId);\n        emit PurchasePlanetexToken(msg.sender, amount, tokenAmount);\n    }",
        "@notice": "",
        "@dev": "buy tokens for usdt or busd tokens",
        "@param1": "roundId tokeSale round id.",
        "@param2": "amount usdt or busd amount.",
        "@gnotice": "Buy Planetex token with ERC20 tokens for the specified round",
        "@gparam1": "roundId The ID of the token sale round",
        "@gparam2": "amount The amount of ERC20 tokens to be used for the purchase",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0
    }
]