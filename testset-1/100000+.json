[
    {
        "func": "function depositCollateral(address _asset, uint256 _amount) external payable virtual {\n    if (_asset != address(0)) {\n      // asset = ERC20\n      require(msg.value == 0, Errors.VT_COLLATERAL_DEPOSIT_INVALID);\n    } else {\n      // asset = ETH\n      require(msg.value == _amount, Errors.VT_COLLATERAL_DEPOSIT_REQUIRE_ETH);\n    }\n    // Deposit asset to vault and receive stAsset\n    // Ex: if user deposit 100ETH, this will deposit 100ETH to Lido and receive 100stETH\n    (address _stAsset, uint256 _stAssetAmount) = _depositToYieldPool(_asset, _amount);\n\n    // Deposit stAsset to lendingPool, then user will get aToken of stAsset\n    ILendingPool(_addressesProvider.getLendingPool()).deposit(\n      _stAsset,\n      _stAssetAmount,\n      msg.sender,\n      0\n    );\n\n    emit DepositCollateral(_asset, msg.sender, _amount);\n  }",
        "@notice": "",
        "@dev": "Deposits an `amount` of asset as collateral to borrow other asset.",
        "@param1": "_asset The asset address for collateral * _asset = 0x0000000000000000000000000000000000000000 means to use ETH as collateral",
        "@param2": "_amount The deposit amount",
        "@gnotice": "Allows the user to deposit collateral, either an ERC20 token or ETH",
        "@gparam1": "_asset The address of the collateral asset, can be an ERC20 token or 0x0 for ETH",
        "@gparam2": "_amount The amount of collateral to deposit",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1,
        "@tparam2": 0
    },
    {
        "func": "function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }",
        "@notice": "",
        "@dev": "transfer control of the contract to a newOwner.",
        "@param1": "newOwner The address to transfer ownership to.",
        "@gnotice": "Transfer ownership of the contract to a new owner",
        "@gparam1": "newOwner The address of the new owner of the contract",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function mint(\n        address account,\n        uint256 amount\n        )\n        external\n        override\n    {\n        require(isMinter[msg.sender], \"Only minters are allowed to mint\");\n        _mint(account, amount);\n    }",
        "@notice": "Mints tokens",
        "@param1": "account Address that will receive the minted tokens",
        "@param2": "amount Amount that will be minted",
        "@gnotice": "Create `amount` new tokens and give to `account`",
        "@gparam1": "account The address of the account to receive the new tokens",
        "@gparam2": "amount The number of tokens to create",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function votingDelay() public pure returns (uint) { return 1; }",
        "@notice": "The delay before voting on a proposal may take place, once proposed // This also helps protect against flash loan attacks because only the vote balance at the proposal start block is considered",
        "@gnotice": "Get the duration of delay required between a proposal being made and being able to be voted on",
        "@greturn1": "The duration of the voting delay in number of blocks (uint)",
        "@tnotice": 1,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function cancelOrderRFQ(uint256 orderInfo) external {\n        _invalidateOrder(msg.sender, orderInfo, 0);\n    }",
        "@notice": "Cancels order's quote",
        "@param1": "orderInfo Order info (only order id in lowest 64 bits is used)",
        "@gnotice": "Cancel an RFQ order",
        "@gparam1": "orderInfo The encoded information of the RFQ order to be cancelled",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 1
    },
    {
        "func": "function cancelPendingDelegation(uint delegationId) external checkDelegationExists(delegationId) {\n        require(msg.sender == delegations[delegationId].holder, \"Only token holders can cancel delegation request\");\n        require(getState(delegationId) == State.PROPOSED, \"Token holders are only able to cancel PROPOSED delegations\");\n\n        delegations[delegationId].finished = _getCurrentMonth();\n        _subtractFromLockedInPendingDelegations(delegations[delegationId].holder, delegations[delegationId].amount);\n\n        emit DelegationRequestCanceledByUser(delegationId);\n    }",
        "@dev": "Allows a token holder to cancel a delegation proposal.",
        "@param1": "delegationId uint ID of delegation proposal",
        "@notice": "",
        "@gnotice": "Cancel a pending delegation request with the specified delegation ID",
        "@gparam1": "delegationId The ID of the delegation request to cancel",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function lockTokens(uint256 amount, uint256 durationSec)\n        external\n        onlyOwner\n    {\n        require(\n            unlockSchedules.length < _maxUnlockSchedules,\n            \"TokenGeyser: reached maximum unlock schedules\"\n        );\n\n        // Update lockedTokens amount before using it in computations after.\n        updateAccounting();\n\n        uint256 lockedTokens = totalLocked();\n        uint256 mintedLockedShares =\n            (lockedTokens > 0)\n                ? totalLockedShares.mul(amount).div(lockedTokens)\n                : amount.mul(_initialSharesPerToken);\n\n        UnlockSchedule memory schedule;\n        schedule.initialLockedShares = mintedLockedShares;\n        schedule.lastUnlockTimestampSec = block.timestamp;\n        schedule.endAtSec = block.timestamp.add(durationSec);\n        schedule.durationSec = durationSec;\n        unlockSchedules.push(schedule);\n\n        totalLockedShares = totalLockedShares.add(mintedLockedShares);\n\n        require(\n            _lockedPool.token().transferFrom(\n                msg.sender,\n                address(_lockedPool),\n                amount\n            ),\n            \"TokenGeyser: transfer into locked pool failed\"\n        );\n        emit TokensLocked(amount, durationSec, totalLocked());\n    }",
        "@notice": "",
        "@dev": "This funcion allows the contract owner to add more locked distribution tokens, along * with the associated \"unlock schedule\". These locked tokens immediately begin unlocking * linearly over the duraction of durationSec timeframe.",
        "@param1": "amount Number of distribution tokens to lock. These are transferred from the caller.",
        "@param2": "durationSec Length of time to linear unlock the tokens.",
        "@gnotice": "Lock `amount` tokens for duration of `durationSec` seconds",
        "@gparam1": "amount The number of tokens to lock",
        "@gparam2": "durationSec The duration for which tokens will be locked",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function isValidZone(\n        OrderParameters memory orderParameters\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        // If not restricted, zone isn't checked\n        if (\n            uint8(orderParameters.orderType) < 2 ||\n            uint8(orderParameters.orderType) == 4\n        ) {\n            return errorsAndWarnings;\n        }\n\n        if (orderParameters.zone == address(0)) {\n            // Zone is not set\n            errorsAndWarnings.addError(ZoneIssue.NotSet.parseInt());\n            return errorsAndWarnings;\n        }\n\n        // EOA zone is always valid\n        if (address(orderParameters.zone).code.length == 0) {\n            // Address is EOA. Valid order\n            return errorsAndWarnings;\n        }\n\n        // Check the EIP165 zone interface\n        if (!checkInterface(orderParameters.zone, ZONE_INTERFACE_ID)) {\n            errorsAndWarnings.addError(ZoneIssue.InvalidZone.parseInt());\n            return errorsAndWarnings;\n        }\n\n        // Check if the contract offerer implements SIP-5\n        try ZoneInterface(orderParameters.zone).getSeaportMetadata() {} catch {\n            errorsAndWarnings.addError(ZoneIssue.InvalidZone.parseInt());\n        }\n    }",
        "@notice": "validate the zone call for an order",
        "@dev": "see validateOrderWithZone",
        "@param1": "orderParameters The order parameters to check.",
        "@return1": "errorsAndWarnings The errors and warnings",
        "@gnotice": "Check whether the specified `OrderParameters` object is valid or not, based on the specified rules",
        "@gparam1": "orderParameters The `OrderParameters` object to be validated",
        "@greturn1": "An `ErrorsAndWarnings` object containing any errors or warnings encountered during the validation process",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function metapool_swap(\n        address from_vault,\n        address to_vault,\n        uint256 amount,\n        uint256 min_amount_out\n    ) public {\n        metapool_swap(from_vault, to_vault, amount, min_amount_out, DEFAULT_DONATION, UNKNOWN_ORIGIN);\n    }",
        "@notice": "swap tokens from one meta pool vault to an other",
        "@dev": "Remove funds from a vault, move one side of the asset from one curve pool to an other and deposit into the new vault.",
        "@param1": "from_vault The vault tokens should be taken from",
        "@param2": "to_vault The vault tokens should be deposited to",
        "@param3": "amount The amount of tokens you whish to use from the from_vault",
        "@param4": "min_amount_out The minimum amount of tokens you would expect from the to_vault",
        "@gnotice": "Swap `amount` tokens from `from_vault` and deposit resulting tokens to `to_vault`, ensuring minimum of `min_amount_out` of resulting tokens are received",
        "@gparam1": "from_vault The address of the source vault",
        "@gparam2": "to_vault The address of the destination vault",
        "@gparam3": "amount The number of tokens to be swapped",
        "@gparam4": "min_amount_out The minimum amount of resulting tokens desired. If this amount is not reached, the transaction fails",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0
    },
    {
        "func": "function withdrawCollateral(\n    address _asset,\n    uint256 _amount,\n    uint256 _slippage,\n    address _to\n  ) external virtual {\n    // Before withdraw from lending pool, get the stAsset address and withdrawal amount\n    // Ex: In Lido vault, it will return stETH address and same amount\n    (address _stAsset, uint256 _stAssetAmount) = _getWithdrawalAmount(_asset, _amount);\n\n    // withdraw from lendingPool, it will convert user's aToken to stAsset\n    uint256 _amountToWithdraw = ILendingPool(_addressesProvider.getLendingPool()).withdrawFrom(\n      _stAsset,\n      _stAssetAmount,\n      msg.sender,\n      address(this)\n    );\n\n    // Withdraw from vault, it will convert stAsset to asset and send to user\n    // Ex: In Lido vault, it will return ETH or stETH to user\n    uint256 withdrawAmount = _withdrawFromYieldPool(_asset, _amountToWithdraw, _to);\n\n    if (_amount == type(uint256).max) {\n      uint256 decimal;\n      if (_asset == address(0)) {\n        decimal = 18;\n      } else {\n        decimal = IERC20Detailed(_asset).decimals();\n      }\n\n      _amount = (_amountToWithdraw * this.pricePerShare()) / 10**decimal;\n    }\n    require(\n      withdrawAmount >= _amount.percentMul(PercentageMath.PERCENTAGE_FACTOR - _slippage),\n      Errors.VT_WITHDRAW_AMOUNT_MISMATCH\n    );\n\n    emit WithdrawCollateral(_asset, _to, _amount);\n  }",
        "@notice": "",
        "@dev": "Withdraw an `amount` of asset used as collateral to user.",
        "@param1": "_asset The asset address for collateral * _asset = 0x0000000000000000000000000000000000000000 means to use ETH as collateral",
        "@param2": "_amount The amount to be withdrawn",
        "@param3": "_slippage The slippage of the withdrawal amount. 1% = 100",
        "@param4": "_to Address that will receive the underlying, same as msg.sender if the user * wants to receive it on his own wallet, or a different address if the beneficiary is a * different wallet",
        "@gnotice": "Allows a user to withdraw collateral by converting aToken to stAsset and then stAsset to original asset and sends it to `_to`",
        "@gparam1": "_asset The address of the underlying asset being withdrawn",
        "@gparam2": "_amount The amount of the underlying asset being withdrawn",
        "@gparam3": "_slippage The maximum slippage that the user is willing to accept",
        "@gparam4": "_to The address where the withdrawn asset will be sent",
        "@greturn1": "This function does not return anything",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1,
        "@tparam2": 0,
        "@tparam3": 1,
        "@tparam4": 0
    },
    {
        "func": "function balanceOf(address _owner) public view returns (uint256 balance) {\n return erc20Store.balances(_owner);\n }",
        "@notice": "Core logic of the ERC20 `balanceOf` function.",
        "@gnotice": "Get the token balance of `_owner`",
        "@gparam1": "_owner The address of the account to query",
        "@greturn1": "The balance of `_owner`",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function stakeFor(\n        address user,\n        uint256 amount\n    ) external override onlyOwner {\n        _stakeFor(msg.sender, user, amount);\n    }",
        "@notice": "",
        "@dev": "Transfers amount of deposit tokens from the caller on behalf of user.",
        "@param1": "user address of who gains credit for this stake operation.",
        "@param2": "amount Number of deposit tokens to stake.",
        "@gnotice": "Stake `amount` tokens on behalf of `user`",
        "@gparam1": "user The address of the user to stake tokens on behalf of",
        "@gparam2": "amount The number of tokens to stake",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function setExchangeRate(address _exchangeRate) public onlyOwner {\n    exchangeRate = ExchangeRate(_exchangeRate);\n  }",
        "@notice": "",
        "@dev": "set the exchangerate contract.",
        "@param1": "_exchangeRate the exchangerate address",
        "@gnotice": "Sets the address of the `ExchangeRate` contract used to determine the exchange rate",
        "@gparam1": "_exchangeRate The address of the `ExchangeRate` contract to use for determining the exchange rate",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function getCreatorFeeInfo(\n        address token,\n        uint256 tokenId,\n        uint256 transactionAmountStart,\n        uint256 transactionAmountEnd\n    )\n        public\n        view\n        returns (\n            address payable recipient,\n            uint256 creatorFeeAmountStart,\n            uint256 creatorFeeAmountEnd\n        )\n    {\n        // Check if creator fee engine is on this chain\n        if (address(creatorFeeEngine) != address(0)) {\n            // Creator fee engine may revert if no creator fees are present.\n            try\n                creatorFeeEngine.getRoyaltyView(\n                    token,\n                    tokenId,\n                    transactionAmountStart\n                )\n            returns (\n                address payable[] memory creatorFeeRecipients,\n                uint256[] memory creatorFeeAmountsStart\n            ) {\n                if (creatorFeeRecipients.length != 0) {\n                    // Use first recipient and amount\n                    recipient = creatorFeeRecipients[0];\n                    creatorFeeAmountStart = creatorFeeAmountsStart[0];\n                }\n            } catch {\n                // Creator fee not found\n            }\n\n            // If fees found for start amount, check end amount\n            if (recipient != address(0)) {\n                // Creator fee engine may revert if no creator fees are present.\n                try\n                    creatorFeeEngine.getRoyaltyView(\n                        token,\n                        tokenId,\n                        transactionAmountEnd\n                    )\n                returns (\n                    address payable[] memory,\n                    uint256[] memory creatorFeeAmountsEnd\n                ) {\n                    creatorFeeAmountEnd = creatorFeeAmountsEnd[0];\n                } catch {}\n            }\n        } else {\n            // Fallback to ERC2981\n            {\n                // Static call to token using ERC2981\n                (bool success, bytes memory res) = token.staticcall(\n                    abi.encodeWithSelector(\n                        IERC2981.royaltyInfo.selector,\n                        tokenId,\n                        transactionAmountStart\n                    )\n                );\n                // Check if call succeeded\n                if (success) {\n                    // Ensure 64 bytes returned\n                    if (res.length == 64) {\n                        // Decode result and assign recipient and start amount\n                        (recipient, creatorFeeAmountStart) = abi.decode(\n                            res,\n                            (address, uint256)\n                        );\n                    }\n                }\n            }\n\n            // Only check end amount if start amount found\n            if (recipient != address(0)) {\n                // Static call to token using ERC2981\n                (bool success, bytes memory res) = token.staticcall(\n                    abi.encodeWithSelector(\n                        IERC2981.royaltyInfo.selector,\n                        tokenId,\n                        transactionAmountEnd\n                    )\n                );\n                // Check if call succeeded\n                if (success) {\n                    // Ensure 64 bytes returned\n                    if (res.length == 64) {\n                        // Decode result and assign end amount\n                        (, creatorFeeAmountEnd) = abi.decode(\n                            res,\n                            (address, uint256)\n                        );\n                    }\n                }\n            }\n        }\n    }",
        "@notice": "Gets the on chain creator fees",
        "@dev": "Uses the creatorFeeEngine when available, otherwise fallback to `IERC2981`.",
        "@param1": "token The token address",
        "@param2": "tokenId The token identifier",
        "@param3": "transactionAmountStart The transaction start amount",
        "@param4": "transactionAmountEnd The transaction end amount",
        "@return1": "recipient creator fee recipient",
        "@return2": "creatorFeeAmountStart creator fee start amount",
        "@return3": "creatorFeeAmountEnd creator fee end amount",
        "@gnotice": "Gets information about the creator fee for a given token and transaction amount range",
        "@gparam1": "token The address of the token contract",
        "@gparam2": "tokenId The ID of the token",
        "@gparam3": "transactionAmountStart The start of the transaction amount range to check",
        "@gparam4": "transactionAmountEnd The end of the transaction amount range to check",
        "@greturn1": "recipient The recipient address of the creator fee",
        "@greturn2": "creatorFeeAmountStart The creator fee amount for the `transactionAmountStart`",
        "@greturn3": "creatorFeeAmountEnd The creator fee amount for the `transactionAmountEnd`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0,
        "@treturn1": 0,
        "@treturn2": 0,
        "@treturn3": 0
    },
    {
        "func": "function release() public {\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp >= _releaseTime);\n\n        uint256 amount = _token.balanceOf(address(this));\n        require(amount > 0);\n\n        _token.safeTransfer(_beneficiary, amount);\n    }",
        "@notice": "Transfers tokens held by timelock to beneficiary.",
        "@gnotice": "Release the tokens held in the contract if the release time has passed",
        "@tnotice": 1,
        "@tdev": 0
    },
    {
        "func": "function removeAddressesFromWhitelist(address[] _operators)\n    onlyOwner\n    public\n    returns (bool)\n  {\n    for (uint256 i = 0; i < _operators.length; i++) {\n      require(removeAddressFromWhitelist(_operators[i]));\n    }\n    return true;\n  }",
        "@dev": "remove addresses from the whitelist",
        "@param1": "_operators addresses",
        "@return1": "true if all addresses were removed from the whitelist, * or weren't in the whitelist in the first place",
        "@notice": "",
        "@gnotice": "Removes the addresses specified in `_operators` from the whitelist",
        "@gparam1": "_operators Array of addresses to remove from the whitelist",
        "@greturn1": "True if all addresses were successfully removed from the whitelist, false otherwise",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }",
        "@dev": "Leaves the contract without owner. It will not be possible to call * `onlyOwner` functions anymore. Can only be called by the current owner. * * NOTE: Renouncing ownership will leave the contract without an owner, * thereby removing any functionality that is only available to the owner.",
        "@notice": "",
        "@gnotice": "Allows the current owner to renounce their ownership and set ownership to address(0)",
        "@tnotice": 0,
        "@tdev": 0
    },
    {
        "func": "function rescueFundsFromStakingPool(\n        address tokenToRescue,\n        address to,\n        uint256 amount\n    ) public onlyOwner returns (bool) {\n        return _stakingPool.rescueFunds(tokenToRescue, to, amount);\n    }",
        "@notice": "",
        "@dev": "Lets the owner rescue funds air-dropped to the staking pool.",
        "@param1": "tokenToRescue Address of the token to be rescued.",
        "@param2": "to Address to which the rescued funds are to be sent.",
        "@param3": "amount Amount of tokens to be rescued.",
        "@return1": "Transfer success.",
        "@gnotice": "Allows the owner to rescue `amount` of `tokenToRescue` from the staking pool and send it to `to`.",
        "@gparam1": "tokenToRescue The address of the token to be rescued.",
        "@gparam2": "to The address of the destination account.",
        "@gparam3": "amount The number of tokens to be rescued.",
        "@greturn1": "Whether or not the rescue operation succeeded.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@treturn1": 1
    },
    {
        "func": "function getCurrentVotes(address account) external view returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }",
        "@notice": "Gets the current votes balance for `account`",
        "@param1": "account The address to get votes balance",
        "@return1": "The number of current votes for `account`",
        "@gnotice": "Get the current number of votes of `account`",
        "@gparam1": "account The address of the account to get the votes for",
        "@greturn1": "The number of votes cast by `account` in the current voting period",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function borrowRatePerBlock() external view returns (uint) {\n bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"borrowRatePerBlock()\"));\n return abi.decode(data, (uint));\n }",
        "@notice": "Returns the current per-block borrow interest rate for this cToken",
        "@return1": "The borrow interest rate per block, scaled by 1e18",
        "@gnotice": "Gets the current borrow rate per block",
        "@greturn1": "The borrow rate per block as a percentage with 18 decimal places",
        "@tnotice": 0,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function setResolver(bytes32 node, address resolver) public virtual override authorised(node) {\n        emit NewResolver(node, resolver);\n        records[node].resolver = resolver;\n    }",
        "@notice": "",
        "@dev": "Sets the resolver address for the specified node.",
        "@param1": "node The node to update.",
        "@param2": "resolver The address of the resolver.",
        "@gnotice": "Set the resolver address for a specific ENS `node`",
        "@gparam1": "node The ENS node to set the resolver for",
        "@gparam2": "resolver The new resolver address to set",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1,
        "@tparam2": 0
    },
    {
        "func": "function exchangeRateStored() public view returns (uint) {\n (MathError err, uint result) = exchangeRateStoredInternal();\n require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n return result;\n }",
        "@notice": "Calculates the exchange rate from the underlying to the CToken",
        "@dev": "This function does not accrue interest before calculating the exchange rate",
        "@return1": "Calculated exchange rate",
        "@gnotice": "Get the current stored exchange rate for cTokens",
        "@greturn1": "The current stored exchange rate",
        "@tnotice": 0,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function decreaseApprovalWithSender(\n address _sender,\n address _spender,\n uint256 _subtractedValue\n )\n public\n onlyProxy\n returns (bool success)\n {\n require(_spender != address(0)); // disallow unspendable approvals\n uint256 currentAllowance = erc20Store.allowed(_sender, _spender);\n uint256 newAllowance = currentAllowance - _subtractedValue;\n\n require(newAllowance <= currentAllowance);\n\n erc20Store.setAllowance(_sender, _spender, newAllowance);\n erc20Proxy.emitApproval(_sender, _spender, newAllowance);\n return true;\n }",
        "@notice": "Core logic of the `decreaseApproval` function.",
        "@dev": "This function can only be called by the referenced proxy, * which has a `decreaseApproval` function. * Every argument passed to that function as well as the original * `msg.sender` gets passed to this function. * NOTE: approvals for the zero address (unspendable) are disallowed.",
        "@param1": "_sender The address initiating the approval.",
        "@gnotice": "Decrease the allowance for a spender by `_subtractedValue` tokens on behalf of `_sender`",
        "@gparam1": "_sender The address of the account that is setting the allowance",
        "@gparam2": "_spender The address of the account authorized to spend the allowance",
        "@gparam3": "_subtractedValue The amount by which to decrease the allowance",
        "@greturn1": "`true` if the operation was successful, `false` otherwise",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@treturn1": 0,
        "@gtparam3": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function changeController(address _newController) public onlyOwner {\n        snt.changeController(_newController);\n        ControllerChanged(_newController);\n    }",
        "@notice": "The owner of this contract can change the controller of the SNT token /// Please, be sure that the owner is a trusted agent or 0x0 address.",
        "@param1": "_newController The address of the new controller",
        "@gnotice": "Change the Fusion token controller to `_newController`",
        "@gparam1": "_newController The address of the new controller contract",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }",
        "@notice": "",
        "@dev": "transfer control of the contract to a newOwner.",
        "@param1": "newOwner The address to transfer ownership to.",
        "@gnotice": "Transfer ownership of the contract to `newOwner`",
        "@gparam1": "newOwner The address of the new owner",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function validateOfferItems(\n        OrderParameters memory orderParameters\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        // Iterate over each offer item and validate it\n        for (uint256 i = 0; i < orderParameters.offer.length; i++) {\n            errorsAndWarnings.concat(validateOfferItem(orderParameters, i));\n\n            // Check for duplicate offer item\n            OfferItem memory offerItem1 = orderParameters.offer[i];\n\n            for (uint256 j = i + 1; j < orderParameters.offer.length; j++) {\n                // Iterate over each remaining offer item\n                // (previous items already check with this item)\n                OfferItem memory offerItem2 = orderParameters.offer[j];\n\n                // Check if token and id are the same\n                if (\n                    offerItem1.token == offerItem2.token &&\n                    offerItem1.identifierOrCriteria ==\n                    offerItem2.identifierOrCriteria\n                ) {\n                    errorsAndWarnings.addError(\n                        OfferIssue.DuplicateItem.parseInt()\n                    );\n                }\n            }\n        }\n\n        // You must have an offer item\n        if (orderParameters.offer.length == 0) {\n            errorsAndWarnings.addWarning(OfferIssue.ZeroItems.parseInt());\n        }\n\n        // Warning if there is more than one offer item\n        if (orderParameters.offer.length > 1) {\n            errorsAndWarnings.addWarning(OfferIssue.MoreThanOneItem.parseInt());\n        }\n    }",
        "@notice": "Validates an offer item",
        "@dev": "Amounts are not summed and verified, just the individual amounts.",
        "@param1": "orderParameters The parameters for the order to validate",
        "@return1": "errorsAndWarnings The errors and warnings",
        "@gnotice": "Validates the `offer` items in the given `orderParameters` and checks for duplicates",
        "@gparam1": "orderParameters An instance of `OrderParameters` containing the `offer` to be validated",
        "@greturn1": "An instance of `ErrorsAndWarnings` that contains any errors or warnings encountered during validation. If there are no issues, both the `errors` and `warnings` arrays will be empty.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function unstakeAndClaim(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external override onlyOnline {\n        // fetch vault storage reference\n        VaultData storage vaultData = _vaults[vault];\n\n        // verify non-zero amount\n        require(amount != 0, \"Aludel: no amount unstaked\");\n\n        // check for sufficient vault stake amount\n        require(vaultData.totalStake >= amount, \"Aludel: insufficient vault stake\");\n\n        // check for sufficient Aludel stake amount\n        // if this check fails, there is a bug in stake accounting\n        assert(_aludel.totalStake >= amount);\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // get reward amount remaining\n        uint256 remainingRewards = IERC20(_aludel.rewardToken).balanceOf(_aludel.rewardPool);\n\n        // calculate vested portion of reward pool\n        uint256 unlockedRewards =\n            calculateUnlockedRewards(\n                _aludel.rewardSchedules,\n                remainingRewards,\n                _aludel.rewardSharesOutstanding,\n                block.timestamp\n            );\n\n        // calculate vault time weighted reward with scaling\n        RewardOutput memory out =\n            calculateRewardFromStakes(\n                vaultData.stakes,\n                amount,\n                unlockedRewards,\n                _aludel.totalStakeUnits,\n                block.timestamp,\n                _aludel.rewardScaling\n            );\n\n        // update stake data in storage\n        if (out.newStakesCount == 0) {\n            // all stakes have been unstaked\n            delete vaultData.stakes;\n        } else {\n            // some stakes have been completely or partially unstaked\n            // delete fully unstaked stakes\n            while (vaultData.stakes.length > out.newStakesCount) vaultData.stakes.pop();\n\n            // update stake amount when lastStakeAmount is set\n            if (out.lastStakeAmount > 0) {\n                // update partially unstaked stake\n                vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;\n            }\n        }\n\n        // update cached stake totals\n        vaultData.totalStake = vaultData.totalStake.sub(amount);\n        _aludel.totalStake = _aludel.totalStake.sub(amount);\n        _aludel.totalStakeUnits = out.newTotalStakeUnits;\n\n        // unlock staking tokens from vault\n        IUniversalVault(vault).unlock(_aludel.stakingToken, amount, permission);\n\n        // emit event\n        emit Unstaked(vault, amount);\n\n        // only perform on non-zero reward\n        if (out.reward > 0) {\n            // calculate shares to burn\n            // sharesToBurn = sharesOutstanding * reward / remainingRewards\n            uint256 sharesToBurn =\n                _aludel.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);\n\n            // burn claimed shares\n            _aludel.rewardSharesOutstanding = _aludel.rewardSharesOutstanding.sub(sharesToBurn);\n\n            // transfer bonus tokens from reward pool to vault\n            if (_bonusTokenSet.length() > 0) {\n                for (uint256 index = 0; index < _bonusTokenSet.length(); index++) {\n                    // fetch bonus token address reference\n                    address bonusToken = _bonusTokenSet.at(index);\n\n                    // calculate bonus token amount\n                    // bonusAmount = bonusRemaining * reward / remainingRewards\n                    uint256 bonusAmount =\n                        IERC20(bonusToken).balanceOf(_aludel.rewardPool).mul(out.reward).div(\n                            remainingRewards\n                        );\n\n                    // transfer bonus token\n                    IRewardPool(_aludel.rewardPool).sendERC20(bonusToken, vault, bonusAmount);\n\n                    // emit event\n                    emit RewardClaimed(vault, bonusToken, bonusAmount);\n                }\n            }\n\n            // transfer reward tokens from reward pool to vault\n            IRewardPool(_aludel.rewardPool).sendERC20(_aludel.rewardToken, vault, out.reward);\n\n            // emit event\n            emit RewardClaimed(vault, _aludel.rewardToken, out.reward);\n        }\n    }",
        "@notice": "Unstake staking tokens and claim reward",
        "@dev": "rewards can only be claimed when unstaking, thus reseting the reward multiplier /// access control: anyone with a valid permission /// state machine: /// - when vault exists on this Aludel /// - after stake from vault /// - can be called multiple times while sufficient stake remains /// - only online /// state scope: /// - decrease _aludel.rewardSharesOutstanding /// - decrease _aludel.totalStake /// - increase _aludel.lastUpdate /// - modify _aludel.totalStakeUnits /// - modify _vaults[vault].stakes /// - decrease _vaults[vault].totalStake /// token transfer: /// - transfer reward tokens from reward pool to vault /// - transfer bonus tokens from reward pool to vault",
        "@param1": "vault address The vault to unstake from",
        "@param2": "amount uint256 The amount of staking tokens to unstake",
        "@param3": "permission bytes The signed lock permission for the universal vault",
        "@gnotice": "Unstake `amount` staking tokens from `vault`, claim rewards, and transfer both staking tokens and rewards to the caller's address",
        "@gparam1": "vault The address of the vault to unstake from",
        "@gparam2": "amount The number of staking tokens to unstake",
        "@gparam3": "permission The permission needed to unstake from the vault",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 1
    },
    {
        "func": "function symbol() public view returns (string memory) {\n        return _symbol;\n    }",
        "@dev": "Returns the symbol of the token",
        "@notice": "",
        "@gnotice": "Get the token symbol",
        "@greturn1": "The token symbol as a string",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function totalSupply() public view returns (uint256) {\n return erc20Store.totalSupply();\n }",
        "@notice": "Core logic of the ERC20 `totalSupply` function.",
        "@gnotice": "Get the total number of tokens in circulation",
        "@greturn1": "The total number of tokens in circulation",
        "@tnotice": 1,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function setAltDeposit(uint totalAltDeposits) public onlyOwner {\n    altDeposits = totalAltDeposits;\n  }",
        "@notice": "",
        "@dev": "set the total alt deposit",
        "@param1": "totalAltDeposits total amount ETH equivalent",
        "@gnotice": "Set the value of `altDeposits` to `totalAltDeposits`",
        "@gparam1": "totalAltDeposits The new value for the `altDeposits` variable",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function setApprovalForAll(address operator, bool approved) external virtual override {\n        operators[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }",
        "@notice": "This works even if sender doesn't own any tokens at the time",
        "@dev": "Enable or disable approval for a third party (\"operator\") to manage * all of `msg.sender`'s ENS records. Emits the ApprovalForAll event.",
        "@param1": "operator Address to add to the set of authorized operators.",
        "@param2": "approved True if the operator is approved",
        "@gnotice": "Approve or revoke approval for the `operator` to manage all assets on behalf of the `msg.sender`",
        "@gparam1": "operator The address of the operator",
        "@gparam2": "approved The approval status for the operator",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function setBeneficiary(address payable beneficiary) public onlyOwner {\n        require(beneficiary != _NULL_ADDRESS, \"Invalid beneficiary\");\n        _beneficiary = beneficiary;\n        emit BeneficiaryChanged(_beneficiary);\n    }",
        "@notice": "",
        "@dev": "Set a new beneficiary address",
        "@param1": "beneficiary New beneficiary target address",
        "@gnotice": "Set the beneficiary address for this contract",
        "@gparam1": "beneficiary The new beneficiary address to set",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function updateMinterStatus(\n        address minterAddress,\n        bool minterStatus\n        )\n        external\n        override\n        onlyOwner\n    {\n        require(\n            isMinter[minterAddress] != minterStatus,\n            \"Input will not update state\"\n            );\n        isMinter[minterAddress] = minterStatus;\n        emit MinterStatusUpdated(minterAddress, minterStatus);\n    }",
        "@notice": "Updates if an address is authorized to mint tokens",
        "@param1": "minterAddress Address whose minter authorization status will be /// updated",
        "@param2": "minterStatus Updated minter authorization status",
        "@gnotice": "Updates the minter status of the `minterAddress`",
        "@gparam1": "minterAddress The address of the minter to update",
        "@gparam2": "minterStatus The new status of the minter (true/false)",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function increaseApproval(\n address _spender,\n uint256 _addedValue\n )\n public\n returns (bool)\n {\n allowed[msg.sender][_spender] = (\n allowed[msg.sender][_spender].add(_addedValue));\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }",
        "@dev": "Increase the amount of tokens that an owner allowed to a spender.",
        "@param1": "_spender The address which will spend the funds.",
        "@param2": "_addedValue The amount of tokens to increase the allowance by.",
        "@notice": "",
        "@gnotice": "Increases the approval of `_spender` to spend `_addedValue` tokens on behalf of the `msg.sender`",
        "@gparam1": "_spender The address authorized to spend on behalf of the `msg.sender`",
        "@gparam2": "_addedValue The number of tokens to increase the approval by",
        "@greturn1": "Whether or not the approval increase succeeded",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function owner() public view virtual returns (address) {\n        return _owner;\n    }",
        "@dev": "Returns the address of the current owner.",
        "@notice": "",
        "@gnotice": "Returns the current owner address of the contract",
        "@greturn1": "The current owner address",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function name() public view virtual returns (string memory) {\n        return _name;\n    }",
        "@dev": "Returns the name of the token.",
        "@notice": "",
        "@gnotice": "Gets the token name",
        "@greturn1": "A string representing the token name",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\n bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"repayBorrowBehalf(address,uint256)\", borrower, repayAmount));\n return abi.decode(data, (uint));\n }",
        "@notice": "repays a borrow belonging to borrower",
        "@param1": "borrower the account with the debt being payed off",
        "@param2": "repayAmount The amount to repay",
        "@return1": "uint 0=success, otherwise a failure (see ErrorReporter.sol for details)",
        "@gnotice": "Repay `repayAmount` of borrow on behalf of `borrower`",
        "@gparam1": "borrower The address of the borrower account to repay on behalf of",
        "@gparam2": "repayAmount The amount of underlying tokens to repay",
        "@greturn1": "The actual repayment amount",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 1,
        "@gtreturn1": 0
    },
    {
        "func": "function setStart(uint _start) public onlyOwner {\n    start = _start;\n  }",
        "@notice": "",
        "@dev": "set the starting time.",
        "@param1": "_start the new _start",
        "@gnotice": "Sets the start time for the contract",
        "@gparam1": "_start The start time for the contract in Unix timestamp format",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1
    },
    {
        "func": "function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }",
        "@notice": "",
        "@dev": "check the amount of tokens that an owner allowed to a spender.",
        "@param1": "_owner address The address which owns the funds.",
        "@param2": "_spender address The address which will spend the funds.",
        "@return1": "the amount of tokens still available for the spender.",
        "@gnotice": "Get the amount of tokens approved by `_owner` that `_spender` can transfer",
        "@gparam1": "_owner The address of the account that owns the tokens",
        "@gparam2": "_spender The address of the account that is authorized to spend the tokens",
        "@greturn1": "The number of tokens `_spender` is allowed to spend on behalf of `_owner`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function startContractChange(bytes32 _id, address _newContractAddr) public onlyOwner {\n        require(entries[_id].exists, ERR_ENTRY_NON_EXISTENT);\n        require(!entries[_id].inWaitPeriodChange, ERR_ALREADY_IN_WAIT_PERIOD_CHANGE);\n\n        entries[_id].changeStartTime = block.timestamp; // solhint-disable-line\n        entries[_id].inContractChange = true;\n\n        pendingAddresses[_id] = _newContractAddr;\n\n        logger.Log(\n            address(this),\n            msg.sender,\n            \"StartContractChange\",\n            abi.encode(_id, entries[_id].contractAddr, _newContractAddr)\n        );\n    }",
        "@notice": "Starts an address change for an existing entry",
        "@dev": "Can override a change that is currently in progress",
        "@param1": "_id Id of contract",
        "@param2": "_newContractAddr Address of the new contract",
        "@gnotice": "Initiate a change in contract address linked to the entry `_id`",
        "@gparam1": "_id Identifier of the contract entry",
        "@gparam2": "_newContractAddr The new contract address to be linked to the entry `_id`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function transferFromWithSender(\n address _sender,\n address _from,\n address _to,\n uint256 _value\n )\n public\n onlyProxy\n returns (bool success)\n {\n require(_to != address(0)); // ensure burn is the cannonical transfer to 0x0\n\n uint256 balanceOfFrom = erc20Store.balances(_from);\n require(_value <= balanceOfFrom);\n\n uint256 senderAllowance = erc20Store.allowed(_from, _sender);\n require(_value <= senderAllowance);\n\n erc20Store.setBalance(_from, balanceOfFrom - _value);\n erc20Store.addBalance(_to, _value);\n\n erc20Store.setAllowance(_from, _sender, senderAllowance - _value);\n\n erc20Proxy.emitTransfer(_from, _to, _value);\n\n return true;\n }",
        "@notice": "Core logic of the ERC20 `transferFrom` function.",
        "@dev": "This function can only be called by the referenced proxy, * which has a `transferFrom` function. * Every argument passed to that function as well as the original * `msg.sender` gets passed to this function. * NOTE: transfers to the zero address are disallowed.",
        "@param1": "_sender The address initiating the transfer in proxy.",
        "@gnotice": "Transfers `_value` tokens from `_from` to `_to` with `_sender` as the key holder of the allowance",
        "@gparam1": "_sender The address of the key holder of the allowance",
        "@gparam2": "_from The address from where the tokens are withdrawn",
        "@gparam3": "_to The address of the destination account",
        "@gparam4": "_value The number of tokens to transfer",
        "@greturn1": "Whether or not the transfer succeeded",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0,
        "@treturn1": 0,
        "@gtparam3": 0,
        "@gtparam4": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function initialize(address contractsAddress) public override initializer {\n        Permissions.initialize(contractsAddress);\n\n        numberOfActiveNodes = 0;\n        numberOfLeavingNodes = 0;\n        numberOfLeftNodes = 0;\n    }",
        "@dev": "constructor in Permissions approach",
        "@param1": "contractsAddress needed in Permissions constructor",
        "@notice": "",
        "@gnotice": "Initialize the contract with `contractsAddress`",
        "@gparam1": "contractsAddress The address of the contracts",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1
    },
    {
        "func": "function borrowBalanceStored(address account) public view returns (uint) {\n (MathError err, uint result) = borrowBalanceStoredInternal(account);\n require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n return result;\n }",
        "@notice": "Return the borrow balance of account based on stored data",
        "@param1": "account The address whose balance should be calculated",
        "@return1": "The calculated balance",
        "@gnotice": "Get the stored borrow balance of `account`",
        "@gparam1": "account The address of the account to query",
        "@greturn1": "The borrow balance of `account`, with scaling factor applied",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function upgradeToAndCall(address newImplementation, bytes calldata data)\n        external\n        payable\n        ifAdmin\n    {\n        _upgradeTo(newImplementation);\n        (bool success, ) = newImplementation.delegatecall(data);\n        require(success);\n    }",
        "@dev": "Upgrade the backing implementation of the proxy and call a function * on the new implementation. * This is useful to initialize the proxied contract.",
        "@param1": "newImplementation Address of the new implementation.",
        "@param2": "data Data to send as msg.data in the low level call. * It should include the signature and the parameters of the function to be called, as described in * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.",
        "@notice": "",
        "@gnotice": "Upgrades the contract to a new implementation and forwards the given `data` to the new implementation.",
        "@gparam1": "newImplementation The address of the new implementation contract",
        "@gparam2": "data The data to be forwarded to the new implementation contract",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function revertToPreviousAddress(bytes32 _id) public onlyOwner {\n        require(entries[_id].exists, ERR_ENTRY_NON_EXISTENT);\n        require(previousAddresses[_id] != address(0), ERR_EMPTY_PREV_ADDR);\n\n        address currentAddr = entries[_id].contractAddr;\n        entries[_id].contractAddr = previousAddresses[_id];\n\n        logger.Log(\n            address(this),\n            msg.sender,\n            \"RevertToPreviousAddress\",\n            abi.encode(_id, currentAddr, previousAddresses[_id])\n        );\n    }",
        "@notice": "Revertes to the previous address immediately",
        "@dev": "In case the new version has a fault, a quick way to fallback to the old contract",
        "@param1": "_id Id of contract",
        "@gnotice": "Revert the contract address associated with the specified `_id` parameter to its previous state",
        "@gparam1": "_id The unique identifier for the contract address to revert",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function unregisterAddressesProvider(address provider) external override onlyOwner {\n    require(_addressesProviders[provider] > 0, Errors.LPAPR_PROVIDER_NOT_REGISTERED);\n    _addressesProviders[provider] = 0;\n    emit AddressesProviderUnregistered(provider);\n  }",
        "@notice": "",
        "@dev": "unregister a LendingPoolAddressesProvider from the list of registered addresses provider",
        "@param1": "provider The LendingPoolAddressesProvider address",
        "@gnotice": "Unregisters an AddressesProvider from the contract",
        "@gparam1": "provider The address of the AddressesProvider to unregister",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function rescue(address token, address target) external virtual {\n        // make sure we're not stealing funds or something\n        _authorizeRescue(token, target);\n\n        // transfer token to target\n        IERC20 tokenContract = IERC20(token);\n        tokenContract.safeTransfer(\n            target,\n            tokenContract.balanceOf(address(this))\n        );\n    }",
        "@notice": "Rescues ERC20 tokens sent to the contract in error",
        "@dev": "Need to implement {_authorizeRescue} to do access-control for this function.",
        "@param1": "token The ERC20 token to rescue",
        "@param2": "target The address to send the tokens to",
        "@gnotice": "This function rescues tokens from the contract and transfers them to the specified `target` address",
        "@gparam1": "token The address of the token to be rescued",
        "@gparam2": "target The address of the recipient account",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function setMultisigVault(address _multisigVault) public onlyOwner {\n    if (_multisigVault != address(0)) {\n      multisigVault = _multisigVault;\n    }\n  }",
        "@notice": "",
        "@dev": "set the multisig contract.",
        "@param1": "_multisigVault the multisig contract address",
        "@gnotice": "Set the address of the multisig vault for the owner",
        "@gparam1": "_multisigVault The address of the multisig vault to set as the owner's vault",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function requestCustodianChange(address _proposedCustodian) public returns (bytes32 lockId) {\n require(_proposedCustodian != address(0));\n\n lockId = generateLockId();\n\n custodianChangeReqs[lockId] = CustodianChangeRequest({\n proposedNew: _proposedCustodian\n });\n\n emit CustodianChangeRequested(lockId, msg.sender, _proposedCustodian);\n }",
        "@notice": "Requests a change of the custodian associated with this contract.",
        "@dev": "Returns a unique lock id associated with the request. * Anyone can call this function, but confirming the request is authorized * by the custodian.",
        "@param1": "_proposedCustodian The address of the new custodian.",
        "@return1": "lockId A unique identifier for this request.",
        "@gnotice": "Request a change in custodian address to `_proposedCustodian` address",
        "@gparam1": "_proposedCustodian The proposed address of the new custodian",
        "@greturn1": "A unique identifier of the custodian change request, `lockId`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function setAllowanceTarget(address payable newAllowanceTarget) public onlyOwner {\n        require(newAllowanceTarget != _NULL_ADDRESS, \"Invalid allowance target\");\n        _allowanceTarget = newAllowanceTarget;\n        emit AllowanceTargetChanged(_allowanceTarget);\n    }",
        "@notice": "",
        "@dev": "Set a new new allowance target address",
        "@param1": "newAllowanceTarget New allowance target address",
        "@gnotice": "Sets new allowance target for the contract",
        "@gparam1": "newAllowanceTarget Address of the new allowance target",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function createTokens(address recipient) public isUnderHardCap saleIsOn payable {\n    uint rate = exchangeRate.getRate(\"ETH\");\n    uint tokens = rate.mul(msg.value).div(1 ether);\n    token.mint(recipient, tokens);\n    require(multisigVault.send(msg.value));\n    TokenSold(recipient, msg.value, tokens, rate);\n  }",
        "@notice": "",
        "@dev": "create tokens by depositing ether.",
        "@param1": "recipient the recipient to receive tokens.",
        "@gnotice": "Creates tokens for `recipient` in exchange for `msg.value` ether",
        "@gparam1": "recipient The account to receive the newly created tokens. Must be whitelisted.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function validateStrictLogic(\n        OrderParameters memory orderParameters,\n        address primaryFeeRecipient,\n        uint256 primaryFeeBips,\n        bool checkCreatorFee\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        // Check that order matches the required format (listing or offer)\n        {\n            bool canCheckFee = true;\n            // Single offer item and at least one consideration\n            if (\n                orderParameters.offer.length != 1 ||\n                orderParameters.consideration.length == 0\n            ) {\n                // Not listing or offer, can't check fees\n                canCheckFee = false;\n            } else if (\n                // Can't have both items be fungible\n                isPaymentToken(orderParameters.offer[0].itemType) &&\n                isPaymentToken(orderParameters.consideration[0].itemType)\n            ) {\n                // Not listing or offer, can't check fees\n                canCheckFee = false;\n            } else if (\n                // Can't have both items be non-fungible\n                !isPaymentToken(orderParameters.offer[0].itemType) &&\n                !isPaymentToken(orderParameters.consideration[0].itemType)\n            ) {\n                // Not listing or offer, can't check fees\n                canCheckFee = false;\n            }\n            if (!canCheckFee) {\n                // Does not match required format\n                errorsAndWarnings.addError(\n                    GenericIssue.InvalidOrderFormat.parseInt()\n                );\n                return errorsAndWarnings;\n            }\n        }\n\n        // Validate secondary consideration items (fees)\n        (\n            uint256 tertiaryConsiderationIndex,\n            ErrorsAndWarnings memory errorsAndWarningsLocal\n        ) = _validateSecondaryConsiderationItems(\n                orderParameters,\n                primaryFeeRecipient,\n                primaryFeeBips,\n                checkCreatorFee\n            );\n\n        errorsAndWarnings.concat(errorsAndWarningsLocal);\n\n        // Validate tertiary consideration items if not 0 (0 indicates error).\n        // Only if no prior errors\n        if (tertiaryConsiderationIndex != 0) {\n            errorsAndWarnings.concat(\n                _validateTertiaryConsiderationItems(\n                    orderParameters,\n                    tertiaryConsiderationIndex\n                )\n            );\n        }\n    }",
        "@notice": "Strict validation operates under tight assumptions.",
        "@dev": "Only checks first fee recipient provided by CreatorFeeEngine. * Order of consideration items must be as follows: * 1. Primary consideration * 2. Primary fee * 3. Creator fee * 4. Private sale consideration",
        "@param1": "orderParameters The parameters for the order to validate.",
        "@param2": "primaryFeeRecipient The primary fee recipient. Set to null address for no primary fee.",
        "@param3": "primaryFeeBips The primary fee in BIPs.",
        "@param4": "checkCreatorFee Should check for creator fee.",
        "@return1": "errorsAndWarnings The errors and warnings.",
        "@gnotice": "Validate order parameters based on strict logic and check fees",
        "@gparam1": "orderParameters Struct containing the order parameters",
        "@gparam2": "primaryFeeRecipient Address of the primary fee recipient",
        "@gparam3": "primaryFeeBips Basis points of the primary fee",
        "@gparam4": "checkCreatorFee Whether or not to check creator fee",
        "@greturn1": "Struct containing any errors and warnings encountered",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 1,
        "@treturn1": 0
    },
    {
        "func": "function setBalance(\n address _owner,\n uint256 _newBalance\n )\n public\n onlyImpl\n {\n balances[_owner] = _newBalance;\n }",
        "@notice": "Sets the balance of `_owner` to `_newBalance`.",
        "@dev": "Intended for use by token implementation functions * that update balances. The only authorized caller * is the active implementation.",
        "@param1": "_owner The account that will hold a new balance.",
        "@param2": "_newBalance The balance to set.",
        "@gnotice": "Set the balance of `_owner` to `_newBalance`",
        "@gparam1": "_owner The address of the account to set the balance for",
        "@gparam2": "_newBalance The new balance to set for the account",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function recordExists(bytes32 node) public virtual override view returns (bool) {\n        return records[node].owner != address(0x0);\n    }",
        "@notice": "",
        "@dev": "Returns whether a record has been imported to the registry.",
        "@param1": "node The specified node.",
        "@return1": "Bool if record exists",
        "@gnotice": "Check if a record exists for the given `node`",
        "@gparam1": "node The hash of the node to check for a record",
        "@greturn1": "Whether or not a record exists for the given `node`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1,
        "@treturn1": 0
    },
    {
        "func": "function setGuaranteedAddress(address _th, uint256 _limit) public initialized onlyOwner {\n        require(getBlockNumber() < startBlock);\n        require(_limit > 0 && _limit <= maxGuaranteedLimit);\n        guaranteedBuyersLimit[_th] = _limit;\n        GuaranteedAddress(_th, _limit);\n    }",
        "@notice": "Sets the limit for a guaranteed address. All the guaranteed addresses /// will be able to get SNTs during the contribution period with his own /// specific limit. /// This method should be called by the owner after the initialization /// and before the contribution starts.",
        "@param1": "_th Guaranteed address",
        "@param2": "_limit Limit for the guaranteed address.",
        "@gnotice": "Sets guaranteed purchase limit for `_th` address to `_limit`",
        "@gparam1": "_th The address of the buyer",
        "@gparam2": "_limit The maximum number of tokens buyer can purchase",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function ttl(bytes32 node) public virtual override view returns (uint64) {\n        return records[node].ttl;\n    }",
        "@notice": "",
        "@dev": "Returns the TTL of a node",
        "@param1": "node The specified node.",
        "@return1": "ttl of the node.",
        "@gnotice": "Returns the time-to-live (TTL) of the specified DNS `node`",
        "@gparam1": "node The DNS `node` whose TTL we want to retrieve",
        "@greturn1": "The time-to-live (TTL) of the specified DNS `node`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1,
        "@treturn1": 0
    },
    {
        "func": "function mint(uint mintAmount) external returns (uint) {\n return mintInternal(mintAmount);\n }",
        "@notice": "Sender supplies assets into the market and receives cTokens in exchange",
        "@dev": "Accrues interest whether or not the operation succeeds, unless reverted",
        "@param1": "mintAmount The amount of the underlying asset to supply",
        "@return1": "uint 0=success, otherwise a failure (see ErrorReporter.sol for details)",
        "@gnotice": "Mint `mintAmount` new tokens",
        "@gparam1": "mintAmount The number of tokens to mint",
        "@greturn1": "The total supply of tokens after the minting",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 1,
        "@gtreturn1": 0
    },
    {
        "func": "function authorizedCreateTokens(address recipient, uint tokens) public onlyAuthorized {\n    token.mint(recipient, tokens);\n    AuthorizedCreate(recipient, tokens);\n  }",
        "@notice": "Allows authorized acces to create tokens.",
        "@dev": "This is used for Bitcoin and ERC20 deposits",
        "@param1": "recipient the recipient to receive tokens.",
        "@param2": "tokens number of tokens to be created.",
        "@gnotice": "Creates `tokens` and assigns them to `recipient` if `msg.sender` is an authorized account",
        "@gparam1": "recipient The address of the recipient for the new tokens",
        "@gparam2": "tokens The amount of tokens to create",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }",
        "@dev": "Allows the current owner to relinquish control of the contract.",
        "@notice": "Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore.",
        "@gnotice": "Relinquish ownership and set ownership address to 0",
        "@tnotice": 1,
        "@tdev": 0
    },
    {
        "func": "function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual override {\n        bytes32 subnode = setSubnodeOwner(node, label, owner);\n        _setResolverAndTTL(subnode, resolver, ttl);\n    }",
        "@notice": "",
        "@dev": "Sets the record for a subnode.",
        "@param1": "node The parent node.",
        "@param2": "label The hash of the label specifying the subnode.",
        "@param3": "owner The address of the new owner.",
        "@param4": "resolver The address of the resolver.",
        "@param5": "ttl The TTL in seconds.",
        "@gnotice": "Set the owner, resolver, and time-to-live (TTL) for a subdomain of a given node",
        "@gparam1": "node The hash of the parent domain node",
        "@gparam2": "label The hash of the subdomain label to set the record for",
        "@gparam3": "owner The address of the account that will own the subdomain",
        "@gparam4": "resolver The address of the resolver contract to use for the subdomain",
        "@gparam5": "ttl The time-to-live value for the subdomain",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0,
        "@tparam5": 1
    },
    {
        "func": "function setTTL(bytes32 node, uint64 ttl) public virtual override authorised(node) {\n        emit NewTTL(node, ttl);\n        records[node].ttl = ttl;\n    }",
        "@notice": "",
        "@dev": "Sets the TTL for the specified node.",
        "@param1": "node The node to update.",
        "@param2": "ttl The TTL in seconds.",
        "@gnotice": "Set the time-to-live (TTL) value for a domain name `node`.",
        "@gparam1": "node The domain name node for which to set the TTL",
        "@gparam2": "ttl The new TTL value for the domain name",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1,
        "@tparam2": 1
    },
    {
        "func": "function resolver(bytes32 node) public virtual override view returns (address) {\n        return records[node].resolver;\n    }",
        "@notice": "",
        "@dev": "Returns the address of the resolver for the specified node.",
        "@param1": "node The specified node.",
        "@return1": "address of the resolver.",
        "@gnotice": "Get the resolver address for a given ENS node",
        "@gparam1": "node The ENS node hash to query",
        "@greturn1": "The address of the resolver contract that manages the given node",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function setOwner(bytes32 node, address owner) public virtual override authorised(node) {\n        _setOwner(node, owner);\n        emit Transfer(node, owner);\n    }",
        "@notice": "set ownership of a node to a new address.",
        "@dev": "May only be called by the current owner of the node.",
        "@param1": "node The node to transfer ownership of.",
        "@param2": "owner The address of the new owner.",
        "@gnotice": "Set `owner` as the owner of the ENS `node`",
        "@gparam1": "node The node to change ownership of",
        "@gparam2": "owner The new owner to set for the ENS `node`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function increaseApprovalWithSender(\n address _sender,\n address _spender,\n uint256 _addedValue\n )\n public\n onlyProxy\n returns (bool success)\n {\n require(_spender != address(0)); // disallow unspendable approvals\n uint256 currentAllowance = erc20Store.allowed(_sender, _spender);\n uint256 newAllowance = currentAllowance + _addedValue;\n\n require(newAllowance >= currentAllowance);\n\n erc20Store.setAllowance(_sender, _spender, newAllowance);\n erc20Proxy.emitApproval(_sender, _spender, newAllowance);\n return true;\n }",
        "@notice": "Core logic of the `increaseApproval` function.",
        "@dev": "This function can only be called by the referenced proxy, * which has an `increaseApproval` function. * Every argument passed to that function as well as the original * `msg.sender` gets passed to this function. * NOTE: approvals for the zero address (unspendable) are disallowed.",
        "@param1": "_sender The address initiating the approval.",
        "@gnotice": "Increases the allowance of `_spender` over the `_sender`'s tokens by `_addedValue`",
        "@gparam1": "_sender The address of the account that is granting the allowance",
        "@gparam2": "_spender The address of the account that will be granted an allowance increase",
        "@gparam3": "_addedValue The amount of tokens to increase the allowance by",
        "@greturn1": "Whether or not the allowance increase succeeded",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@treturn1": 0,
        "@gtparam3": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function retrieveTokens(address _token) public onlyOwner {\n    ERC20 token = ERC20(_token);\n    token.transfer(multisigVault, token.balanceOf(this));\n  }",
        "@notice": "",
        "@dev": "transfer ERC20 tokens to the multi sig vault",
        "@param1": "_token the contract address of the ERC20 contract",
        "@gnotice": "Retrieve ERC20 tokens mistakenly sent to this contract",
        "@gparam1": "_token The address of the ERC20 token that needs to be retrieved",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }",
        "@dev": "called by the owner to pause, triggers stopped state",
        "@notice": "",
        "@gnotice": "Pauses all the transfers",
        "@tnotice": 0,
        "@tdev": 0
    },
    {
        "func": "function _checkContractOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public returns (bool) {\n        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n            return retval == IERC721Receiver(to).onERC721Received.selector;\n        } catch (bytes memory reason) {\n            if (reason.length == 0) {\n                revert TransferToNonERC721ReceiverImplementer();\n            } else {\n                assembly {\n                    revert(add(32, reason), mload(reason))\n                }\n            }\n        }\n    }",
        "@notice": "",
        "@dev": "Internal function to invoke {IERC721Receiver-onERC721Received} on a target contract.",
        "@param1": "from address of the previous owner of the given token ID",
        "@param2": "to address that will receive the tokens",
        "@param3": "tokenId ID of the token to be transferred",
        "@param4": "_data bytes optional data to send along with the call",
        "@return1": "bool whether the call correctly returned the expected magic value",
        "@gnotice": "Checks whether the receiving contract implements the ERC721Receiver interface and calls its `onERC721Received` function",
        "@gparam1": "from The address transferring the token",
        "@gparam2": "to The address receiving the token",
        "@gparam3": "tokenId The ID of the token being transferred",
        "@gparam4": "_data Additional data with no specified format, which is passed back to the caller",
        "@greturn1": "Whether or not the receiving contract implemented the ERC721Receiver interface and `onERC721Received` function was called successfully.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 1,
        "@treturn1": 0
    },
    {
        "func": "function approveWithSender(\n address _sender,\n address _spender,\n uint256 _value\n )\n public\n onlyProxy\n returns (bool success)\n {\n require(_spender != address(0)); // disallow unspendable approvals\n erc20Store.setAllowance(_sender, _spender, _value);\n erc20Proxy.emitApproval(_sender, _spender, _value);\n return true;\n }",
        "@notice": "Core logic of the ERC20 `approve` function.",
        "@dev": "This function can only be called by the referenced proxy, * which has an `approve` function. * Every argument passed to that function as well as the original * `msg.sender` gets passed to this function. * NOTE: approvals for the zero address (unspendable) are disallowed.",
        "@param1": "_sender The address initiating the approval in proxy.",
        "@gnotice": "Approve the address `_spender` to spend `_value` tokens on behalf of `_sender`",
        "@gparam1": "_sender The address granting approval",
        "@gparam2": "_spender The address being granted approval to spend tokens",
        "@gparam3": "_value The number of tokens being approved for spending",
        "@greturn1": "Whether or not the approval succeeded",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@treturn1": 0,
        "@gtparam3": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function setHyperDex(IHyperDex newHyperDex) public onlyOwner{\n        require(address(newHyperDex) != _NULL_ADDRESS, \"Invalid HyperDex address\");\n        _hyperDex = newHyperDex;\n        emit HyperDexChanged(address(_hyperDex));\n    }",
        "@notice": "",
        "@dev": "Set a new MultiSwap proxy contract address",
        "@param1": "newHyperDex New Exchange proxy address",
        "@gnotice": "Set a new HyperDex instance for the contract",
        "@gparam1": "newHyperDex The address of the new HyperDex instance",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }",
        "@dev": "Increase the amount of tokens that an owner allowed to a spender.",
        "@param1": "_spender The address which will spend the funds.",
        "@param2": "_addedValue The amount of tokens to increase the allowance by.",
        "@notice": "",
        "@gnotice": "Increase the allowance granted to `_spender` by `_addedValue`",
        "@gparam1": "_spender The address which can spend the funds",
        "@gparam2": "_addedValue The amount of tokens to increase the allowance by",
        "@greturn1": "Whether or not the increase in allowance succeeded",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function transferableTokens(address holder, uint64 time) constant public returns (uint256) {\n    uint256 grantIndex = tokenGrantsCount(holder);\n\n    if (grantIndex == 0) return balanceOf(holder); // shortcut for holder without grants\n\n    // Iterate through all the grants the holder has, and add all non-vested tokens\n    uint256 nonVested = 0;\n    for (uint256 i = 0; i < grantIndex; i++) {\n      nonVested = SafeMath.add(nonVested, nonVestedTokens(grants[holder][i], time));\n    }\n\n    // Balance - totalNonVested is the amount of tokens a holder can transfer at any given time\n    uint256 vestedTransferable = SafeMath.sub(balanceOf(holder), nonVested);\n\n    // Return the minimum of how many vested can transfer and other value\n    // in case there are other limiting transferability factors (default is balanceOf)\n    return SafeMath.min256(vestedTransferable, super.transferableTokens(holder, time));\n  }",
        "@dev": "Calculate the total amount of transferable tokens of a holder at a given time",
        "@param1": "holder The address of the holder",
        "@param2": "time uint64 The specific time.",
        "@return1": "holder's total amount of transferable tokens.",
        "@notice": "",
        "@gnotice": "Returns the number of tokens that the holder `holder` can transfer at the current time `time`, taking into account any vested tokens and transfers that may be limited by other factors",
        "@gparam1": "holder The address of the token holder",
        "@gparam2": "time The current time in seconds since the Unix epoch",
        "@greturn1": "The number of transferable tokens for the holder at the current time",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function setTotalSupply(\n uint256 _newTotalSupply\n )\n public\n onlyImpl\n {\n totalSupply = _newTotalSupply;\n }",
        "@notice": "The function to set the total supply of tokens.",
        "@dev": "Intended for use by token implementation functions * that update the total supply. The only authorized caller * is the active implementation.",
        "@param1": "_newTotalSupply the value to set as the new total supply",
        "@gnotice": "Set the total supply of the token to `_newTotalSupply`",
        "@gparam1": "_newTotalSupply The new total supply of the token",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function transferWithSender(\n address _sender,\n address _to,\n uint256 _value\n )\n public\n onlyProxy\n returns (bool success)\n {\n require(_to != address(0)); // ensure burn is the cannonical transfer to 0x0\n\n uint256 balanceOfSender = erc20Store.balances(_sender);\n require(_value <= balanceOfSender);\n\n erc20Store.setBalance(_sender, balanceOfSender - _value);\n erc20Store.addBalance(_to, _value);\n\n erc20Proxy.emitTransfer(_sender, _to, _value);\n\n return true;\n }",
        "@notice": "Core logic of the ERC20 `transfer` function.",
        "@dev": "This function can only be called by the referenced proxy, * which has a `transfer` function. * Every argument passed to that function as well as the original * `msg.sender` gets passed to this function. * NOTE: transfers to the zero address are disallowed.",
        "@param1": "_sender The address initiating the transfer in proxy.",
        "@gnotice": "Transfer `_value` tokens from `_sender` to `_to`",
        "@gparam1": "_sender The address of the account initiating the transfer",
        "@gparam2": "_to The address of the destination account",
        "@gparam3": "_value The number of tokens to transfer",
        "@greturn1": "Whether or not the transfer succeeded",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@treturn1": 0,
        "@gtparam3": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function burn(uint256 _value) public {\n    _burn(msg.sender, _value);\n  }",
        "@dev": "Burns a specific amount of tokens.",
        "@param1": "_value The amount of token to be burned.",
        "@notice": "",
        "@gnotice": "Burn `_value` tokens from `msg.sender`",
        "@gparam1": "_value The number of tokens to be burned from `msg.sender`'s balance.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function name() public view virtual returns (string memory) {\n return _name;\n }",
        "@dev": "Returns the name of the token.",
        "@notice": "",
        "@gnotice": "Get the token name",
        "@greturn1": "The name of the token as a string",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function batchTransfer(address[] _tos, uint256[] _values) public returns (bool success) {\n require(_tos.length == _values.length);\n\n uint256 numTransfers = _tos.length;\n uint256 senderBalance = erc20Store.balances(msg.sender);\n\n for (uint256 i = 0; i < numTransfers; i++) {\n address to = _tos[i];\n require(to != address(0));\n uint256 v = _values[i];\n require(senderBalance >= v);\n\n if (msg.sender != to) {\n senderBalance -= v;\n erc20Store.addBalance(to, v);\n }\n erc20Proxy.emitTransfer(msg.sender, to, v);\n }\n\n erc20Store.setBalance(msg.sender, senderBalance);\n\n return true;\n }",
        "@notice": "A function for a sender to issue multiple transfers to multiple * different addresses at once. This function is implemented for gas * considerations when someone wishes to transfer, as one transaction is * cheaper than issuing several distinct individual `transfer` transactions.",
        "@dev": "By specifying a set of destination addresses and values, the * sender can issue one transaction to transfer multiple amounts to * distinct addresses, rather than issuing each as a separate * transaction. The `_tos` and `_values` arrays must be equal length, and * an index in one array corresponds to the same index in the other array * (e.g. `_tos[0]` will receive `_values[0]`, `_tos[1]` will receive * `_values[1]`, and so on.) * NOTE: transfers to the zero address are disallowed.",
        "@param1": "_tos The destination addresses to receive the transfers.",
        "@param2": "_values The values for each destination address.",
        "@return1": "success If transfers succeeded.",
        "@gnotice": "Batch transfer `_values` of tokens to `_tos` addresses array",
        "@gparam1": "_tos The array of destination addresses",
        "@gparam2": "_values The array of token values to be transferred",
        "@greturn1": "Success status of the batch transfer operation",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function name() public view virtual returns (string memory) {\n return _name;\n }",
        "@dev": "Returns the name of the token.",
        "@notice": "",
        "@gnotice": "Gets the token's name",
        "@greturn1": "A string representing the token name",
        "@tnotice": 0,
        "@tdev": 1,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function burn(uint256 value) public {\n _burn(msg.sender, value);\n }",
        "@dev": "Burns a specific amount of tokens.",
        "@param1": "value The amount of lowest token units to be burned.",
        "@notice": "",
        "@gnotice": "Burn `value` tokens from `msg.sender`",
        "@gparam1": "value The number of tokens to burn",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }",
        "@dev": "increases the allowance granted to `spender` by the caller.",
        "@notice": "",
        "@gnotice": "Increase the allowance granted to `spender` by the caller by `addedValue` tokens",
        "@gparam1": "spender The address of the account allowed to spend the tokens",
        "@gparam2": "addedValue The increase in approved spending",
        "@greturn1": "Whether or not the approval succeeded after the increase in allowance",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return erc20Store.allowed(_owner, _spender);\n }",
        "@notice": "Core logic of the ERC20 `allowance` function.",
        "@gnotice": "Get the remaining number of tokens that `spender` is allowed to spend on behalf of `owner` through `approve` function",
        "@gparam1": "_owner The address of the token owner",
        "@gparam2": "_spender The address of the spender",
        "@greturn1": "The remaining number of tokens that `spender` is allowed to spend on behalf of `owner`",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\n\n // These next few lines are used when the totalSupply of the token is\n // requested before a check point was ever created for this token, it\n // requires that the `parentToken.totalSupplyAt` be queried at the\n // genesis block for this token as that contains totalSupply of this\n // token at this block number.\n if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0) {\n return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n\n // This will return the expected totalSupply during normal situations\n } else {\n return getValueAt(totalSupplyHistory, _blockNumber);\n }\n }",
        "@notice": "Total amount of tokens at a specific `_blockNumber`.",
        "@param1": "_blockNumber The block number when the totalSupply is queried",
        "@return1": "The total amount of tokens at `_blockNumber`",
        "@gnotice": "Get the total supply of the token at a specific block number",
        "@gparam1": "_blockNumber The block number at which the total supply of the token is requested",
        "@greturn1": "The total supply of the token at a specific block number",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function totalBorrowsCurrent() external returns (uint) {\n bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"totalBorrowsCurrent()\"));\n return abi.decode(data, (uint));\n }",
        "@notice": "Returns the current total borrows plus accrued interest",
        "@return1": "The total borrows with interest",
        "@gnotice": "Get the current total amount of borrows from all users",
        "@greturn1": "The total amount of borrows",
        "@tnotice": 0,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function initialize(ILendingPoolAddressesProvider _provider) external initializer {\n    _addressesProvider = _provider;\n  }",
        "@notice": "",
        "@dev": "Function is invoked by the proxy contract when the Vault contract is deployed.",
        "@param1": "_provider The address of the provider",
        "@gnotice": "Initializes the contract with the given `_provider` address for the lending pool",
        "@gparam1": "_provider The address of the `ILendingPoolAddressesProvider`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n return true;\n }",
        "@dev": "decreases the allowance granted to `spender` by the caller.",
        "@notice": "",
        "@gnotice": "Decrease the allowance granted to `spender` by `subtractedValue` tokens",
        "@gparam1": "spender The address authorized to spend tokens",
        "@gparam2": "subtractedValue The amount of tokens to reduce the allowance by",
        "@greturn1": "Whether or not the allowance was successfully decreased",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function validateOfferItemParameters(\n        OrderParameters memory orderParameters,\n        uint256 offerItemIndex\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        // Get the offer item at offerItemIndex\n        OfferItem memory offerItem = orderParameters.offer[offerItemIndex];\n\n        // Check if start amount and end amount are zero\n        if (offerItem.startAmount == 0 && offerItem.endAmount == 0) {\n            errorsAndWarnings.addError(OfferIssue.AmountZero.parseInt());\n            return errorsAndWarnings;\n        }\n\n        // Check that amount velocity is not too high.\n        if (\n            offerItem.startAmount != offerItem.endAmount &&\n            orderParameters.endTime > orderParameters.startTime\n        ) {\n            // Assign larger and smaller amount values\n            (uint256 maxAmount, uint256 minAmount) = offerItem.startAmount >\n                offerItem.endAmount\n                ? (offerItem.startAmount, offerItem.endAmount)\n                : (offerItem.endAmount, offerItem.startAmount);\n\n            uint256 amountDelta = maxAmount - minAmount;\n            // delta of time that order exists for\n            uint256 timeDelta = orderParameters.endTime -\n                orderParameters.startTime;\n\n            // Velocity scaled by 1e10 for precision\n            uint256 velocity = (amountDelta * 1e10) / timeDelta;\n            // gives velocity percentage in hundredth of a basis points per second in terms of larger value\n            uint256 velocityPercentage = velocity / (maxAmount * 1e4);\n\n            // 278 * 60 * 30 ~= 500,000\n            if (velocityPercentage > 278) {\n                // Over 50% change per 30 min\n                errorsAndWarnings.addError(\n                    OfferIssue.AmountVelocityHigh.parseInt()\n                );\n            }\n            // Over 50% change per 30 min\n            else if (velocityPercentage > 28) {\n                // Over 5% change per 30 min\n                errorsAndWarnings.addWarning(\n                    OfferIssue.AmountVelocityHigh.parseInt()\n                );\n            }\n\n            // Check for large amount steps\n            if (minAmount <= 1e15) {\n                errorsAndWarnings.addWarning(\n                    OfferIssue.AmountStepLarge.parseInt()\n                );\n            }\n        }\n\n        if (offerItem.itemType == ItemType.ERC721) {\n            // ERC721 type requires amounts to be 1\n            if (offerItem.startAmount != 1 || offerItem.endAmount != 1) {\n                errorsAndWarnings.addError(ERC721Issue.AmountNotOne.parseInt());\n            }\n\n            // Check the EIP165 token interface\n            if (!checkInterface(offerItem.token, ERC721_INTERFACE_ID)) {\n                errorsAndWarnings.addError(ERC721Issue.InvalidToken.parseInt());\n            }\n        } else if (offerItem.itemType == ItemType.ERC721_WITH_CRITERIA) {\n            // Check the EIP165 token interface\n            if (!checkInterface(offerItem.token, ERC721_INTERFACE_ID)) {\n                errorsAndWarnings.addError(ERC721Issue.InvalidToken.parseInt());\n            }\n\n            if (offerItem.startAmount > 1 || offerItem.endAmount > 1) {\n                // Require partial fill enabled. Even orderTypes are full\n                if (uint8(orderParameters.orderType) % 2 == 0) {\n                    errorsAndWarnings.addError(\n                        ERC721Issue.CriteriaNotPartialFill.parseInt()\n                    );\n                }\n            }\n        } else if (\n            offerItem.itemType == ItemType.ERC1155 ||\n            offerItem.itemType == ItemType.ERC1155_WITH_CRITERIA\n        ) {\n            // Check the EIP165 token interface\n            if (!checkInterface(offerItem.token, ERC1155_INTERFACE_ID)) {\n                errorsAndWarnings.addError(\n                    ERC1155Issue.InvalidToken.parseInt()\n                );\n            }\n        } else if (offerItem.itemType == ItemType.ERC20) {\n            // ERC20 must have `identifierOrCriteria` be zero\n            if (offerItem.identifierOrCriteria != 0) {\n                errorsAndWarnings.addError(\n                    ERC20Issue.IdentifierNonZero.parseInt()\n                );\n            }\n\n            // Validate contract, should return an uint256 if its an ERC20\n            if (\n                !offerItem.token.safeStaticCallUint256(\n                    abi.encodeWithSelector(\n                        ERC20Interface.allowance.selector,\n                        address(seaport),\n                        address(seaport)\n                    ),\n                    0\n                )\n            ) {\n                errorsAndWarnings.addError(ERC20Issue.InvalidToken.parseInt());\n            }\n        } else {\n            // Must be native\n            // NATIVE must have `token` be zero address\n            if (offerItem.token != address(0)) {\n                errorsAndWarnings.addError(NativeIssue.TokenAddress.parseInt());\n            }\n\n            // NATIVE must have `identifierOrCriteria` be zero\n            if (offerItem.identifierOrCriteria != 0) {\n                errorsAndWarnings.addError(\n                    NativeIssue.IdentifierNonZero.parseInt()\n                );\n            }\n        }\n    }",
        "@notice": "Validates the OfferItem parameters.",
        "@dev": "OfferItems with criteria are currently not allowed",
        "@param1": "orderParameters The parameters for the order to validate",
        "@param2": "offerItemIndex The index of the offerItem in offer array to validate",
        "@return1": "errorsAndWarnings An ErrorsAndWarnings structs with results",
        "@gnotice": "This function validates the parameters of an order item in a Dutch auction",
        "@gparam1": "orderParameters The struct containing the parameters of the order",
        "@gparam2": "offerItemIndex The index of the offer item being validated",
        "@greturn1": "An ErrorsAndWarnings struct containing any errors or warnings encountered during validation",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function registerAddressesProvider(address provider, uint256 id) external override onlyOwner {\n    require(id != 0, Errors.LPAPR_INVALID_ADDRESSES_PROVIDER_ID);\n\n    _addressesProviders[provider] = id;\n    _addToAddressesProvidersList(provider);\n    emit AddressesProviderRegistered(provider);\n  }",
        "@notice": "",
        "@dev": "Registers an addresses provider",
        "@param1": "provider The address of the new LendingPoolAddressesProvider",
        "@param2": "id The id for the new LendingPoolAddressesProvider, referring to the market it belongs to",
        "@gnotice": "Register an addresses provider contract",
        "@gparam1": "provider Address of the contract implementing the AddressesProvider interface",
        "@gparam2": "id ID of the addresses provider contract",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function verifyMerkleProof(\n        bytes32 merkleRoot,\n        bytes32[] memory merkleProof,\n        uint256 valueToProve\n    ) public pure returns (bool) {\n        bytes32 hashedValue = keccak256(abi.encode(valueToProve));\n\n        return _verifyProof(merkleRoot, merkleProof, hashedValue);\n    }",
        "@notice": "Verifies a merkle proof for the value to prove and given root and proof",
        "@dev": "The `valueToProve` is hashed prior to executing the proof verification.",
        "@param1": "merkleRoot The root of the merkle tree",
        "@param2": "merkleProof The merkle proof",
        "@param3": "valueToProve The value to prove",
        "@return1": "whether proof is valid",
        "@gnotice": "Verify a Merkle proof for a given hashed value.",
        "@gparam1": "merkleRoot The Merkle root hash of the Merkle tree that the proof is being verified against.",
        "@gparam2": "merkleProof The Merkle proof to be verified.",
        "@gparam3": "valueToProve The original value to be hashed and verified against the Merkle root hash.",
        "@greturn1": "Whether or not the Merkle proof is valid for the given hashed value.",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@treturn1": 0
    },
    {
        "func": "function stake(uint256 amount) external override {\n        _stakeFor(msg.sender, msg.sender, amount);\n    }",
        "@notice": "",
        "@dev": "Transfers amount of deposit tokens from the user.",
        "@param1": "amount Number of deposit tokens to stake.",
        "@gnotice": "Stake `amount` tokens for `msg.sender`",
        "@gparam1": "amount The number of tokens to stake for `msg.sender`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function totalSupply() public view returns (uint256) {\n return erc20Impl.totalSupply();\n }",
        "@notice": "Returns the total token supply.",
        "@return1": "the total token supply.",
        "@gnotice": "Get the total token supply",
        "@greturn1": "The total token supply as a uint256 value",
        "@tnotice": 0,
        "@tdev": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }",
        "@dev": "Returns the number of accounts that have `role`.",
        "@notice": "",
        "@gnotice": "Get the number of accounts assigned to the `role`.",
        "@gparam1": "role The identifier for the role",
        "@greturn1": "The number of accounts assigned to the `role`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n    totalSupply = totalSupply.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    Mint(_to, _amount);\n    Transfer(0x0, _to, _amount);\n    return true;\n  }",
        "@notice": "",
        "@dev": "mint tokens",
        "@param1": "_to The address that will receive the minted tokens.",
        "@param2": "_amount The amount of tokens to mint.",
        "@return1": "A boolean that indicates if the operation was successful.",
        "@gnotice": "Mint `_amount` tokens and assign them to `_to`",
        "@gparam1": "_to The address of the account to receive the minted tokens",
        "@gparam2": "_amount The number of tokens to mint",
        "@greturn1": "Whether or not the minting succeeded",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\n require(blockNumber < block.number, \"Uni::getPriorVotes: not yet determined\");\n\n uint32 nCheckpoints = numCheckpoints[account];\n if (nCheckpoints == 0) {\n return 0;\n }\n\n // First check most recent balance\n if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n return checkpoints[account][nCheckpoints - 1].votes;\n }\n\n // Next check implicit zero balance\n if (checkpoints[account][0].fromBlock > blockNumber) {\n return 0;\n }\n\n uint32 lower = 0;\n uint32 upper = nCheckpoints - 1;\n while (upper > lower) {\n uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n Checkpoint memory cp = checkpoints[account][center];\n if (cp.fromBlock == blockNumber) {\n return cp.votes;\n } else if (cp.fromBlock < blockNumber) {\n lower = center;\n } else {\n upper = center - 1;\n }\n }\n return checkpoints[account][lower].votes;\n }",
        "@notice": "Determine the prior number of votes for an account as of a block number",
        "@dev": "Block number must be a finalized block or else this function will revert to prevent misinformation.",
        "@param1": "account The address of the account to check",
        "@param2": "blockNumber The block number to get the vote balance at",
        "@return1": "The number of votes the account had as of the given block",
        "@gnotice": "Returns the prior number of votes for an account at a specific block",
        "@gparam1": "account The address of the account to check",
        "@gparam2": "blockNumber The block number to retrieve the vote balance at",
        "@greturn1": "The number of votes the account had at the given block number",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0,
        "@gtreturn1": 0
    },
    {
        "func": "function unstake(uint256 amount) override external {\n        _unstake(amount);\n    }",
        "@notice": "Unstakes a certain amount of previously deposited tokens.",
        "@dev": "User also receives their * alotted number of distribution tokens.",
        "@param1": "amount Number of deposit tokens to unstake / withdraw.",
        "@gnotice": "Unstake `amount` tokens from the caller's staked balance",
        "@gparam1": "amount The number of tokens to unstake",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function balanceOf(address _owner) public constant returns (uint256 balance) {\n    return balances[_owner];\n  }",
        "@notice": "",
        "@dev": "Gets the balance of `_owner`",
        "@param1": "_owner The address to query the the balance of.",
        "@return1": "the amount owned by `_owner`",
        "@gnotice": "Get the token balance of `_owner`",
        "@gparam1": "_owner The address to query the balance of",
        "@greturn1": "The balance of `_owner`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function changeAdmin(address newAdmin) external ifAdmin {\n require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n emit AdminChanged(_admin(), newAdmin);\n _setAdmin(newAdmin);\n }",
        "@dev": "Changes the admin of the proxy. ",
        "@param1": "newAdmin Address to transfer proxy administration to.",
        "@notice": "",
        "@gnotice": "Changes the admin of a proxy",
        "@gparam1": "newAdmin The address of the new admin",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function setTreasuryInfo(address _treasury, uint256 _fee) external payable onlyAdmin {\n    require(_treasury != address(0), Errors.VT_TREASURY_INVALID);\n    require(_fee <= 30_00, Errors.VT_FEE_TOO_BIG);\n    _treasuryAddress = _treasury;\n    _vaultFee = _fee;\n\n    emit SetTreasuryInfo(_treasury, _fee);\n  }",
        "@notice": "",
        "@dev": "Set treasury address and vault fee",
        "@param1": "_treasury The treasury address",
        "@param2": "_fee The vault fee which has more two decimals, ex: 100% = 100_00",
        "@gnotice": "Set the treasury address and the vault fee",
        "@gparam1": "_treasury The address of the treasury where the vault fees will be sent",
        "@gparam2": "_fee The percentage of the vault fee",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 1
    },
    {
        "func": "function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external virtual override {\n        setOwner(node, owner);\n        _setResolverAndTTL(node, resolver, ttl);\n    }",
        "@notice": "",
        "@dev": "Sets the record for a node.",
        "@param1": "node The node to update.",
        "@param2": "owner The address of the new owner.",
        "@param3": "resolver The address of the resolver.",
        "@param4": "ttl The TTL in seconds.",
        "@gnotice": "Set the owner, resolver, and time-to-live (TTL) parameters for a specified node in the Namecoin registrar",
        "@gparam1": "node The node name to set the parameters for",
        "@gparam2": "owner The address of the account that will own the node",
        "@gparam3": "resolver The address of the resolver contract for the node",
        "@gparam4": "ttl The time-to-live value for the node",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 1
    },
    {
        "func": "function owner(bytes32 node) public virtual override view returns (address) {\n        address addr = records[node].owner;\n        if (addr == address(this)) {\n            return address(0x0);\n        }\n\n        return addr;\n    }",
        "@notice": "",
        "@dev": "Returns the address that owns the specified node.",
        "@param1": "node The specified node.",
        "@return1": "address of the owner.",
        "@gnotice": "Get the owner of the specified ENS `node`",
        "@gparam1": "node The ENS node hash",
        "@greturn1": "The address of the node's owner, or `address(0x0)` if the node has no owner.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function setHardCap(uint _hardcap) public onlyOwner {\n    hardcap = _hardcap;\n  }",
        "@notice": "",
        "@dev": "set the hardcap.",
        "@param1": "_hardcap the new hardcap",
        "@gnotice": "Set the maximum amount of tokens that can be sold in the crowdsale",
        "@gparam1": "_hardcap The new hard cap to be set by the owner of the contract",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    }
]