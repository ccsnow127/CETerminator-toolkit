[
    {
        "func": "function withdraw(\n        uint256 shares,\n        uint256 amountEthMin,\n        uint256 amountUsdcMin,\n        uint256 amountOsqthMin\n    ) external override nonReentrant {\n        require(shares > 0, \"C5\");\n\n        uint256 _totalSupply = totalSupply();\n\n        //Burn shares\n        _burn(msg.sender, shares);\n\n        //withdraw user share of tokens from lp positions in the current proportion\n        (uint256 amountUsdc, uint256 amountEth0) = IVaultMath(vaultMath).burnLiquidityShare(\n            Constants.poolEthUsdc,\n            IVaultStorage(vaultStorage).orderEthUsdcLower(),\n            IVaultStorage(vaultStorage).orderEthUsdcUpper(),\n            shares,\n            _totalSupply\n        );\n\n        (uint256 amountEth1, uint256 amountOsqth) = IVaultMath(vaultMath).burnLiquidityShare(\n            Constants.poolEthOsqth,\n            IVaultStorage(vaultStorage).orderOsqthEthLower(),\n            IVaultStorage(vaultStorage).orderOsqthEthUpper(),\n            shares,\n            _totalSupply\n        );\n\n        uint256 amountEth = amountEth0 + amountEth1;\n\n        require(amountEth != 0 || amountUsdc != 0 || amountOsqth != 0, \"C6\");\n\n        require(amountEth >= amountEthMin, \"C7\");\n        require(amountUsdc >= amountUsdcMin, \"C8\");\n        require(amountOsqth >= amountOsqthMin, \"C9\");\n\n        //send tokens to user\n        if (amountEth > 0) IVaultTreasury(vaultTreasury).transfer(Constants.weth, msg.sender, amountEth);\n        if (amountUsdc > 0) IVaultTreasury(vaultTreasury).transfer(Constants.usdc, msg.sender, amountUsdc);\n        if (amountOsqth > 0) IVaultTreasury(vaultTreasury).transfer(Constants.osqth, msg.sender, amountOsqth);\n\n        emit SharedEvents.Withdraw(msg.sender, shares, amountEth, amountUsdc, amountOsqth);\n    }",
        "@notice": "withdraws tokens in proportion to the vault's holdings",
        "@dev": "provide strategy tokens, returns set of ETH, USDC, and oSQTH",
        "@param1": "shares shares burned by sender",
        "@param2": "amountEthMin revert if resulting amount of ETH is smaller than this",
        "@param3": "amountUsdcMin revert if resulting amount of USDC is smaller than this",
        "@param4": "amountOsqthMin revert if resulting amount of oSQTH is smaller than this",
        "@gnotice": "Withdraws `shares` amount of lp tokens, and returns the proportional share of tokens from the lp positions in the specified proportions to the caller",
        "@gparam1": "shares The number of lp tokens to withdraw",
        "@gparam2": "amountEthMin The minimum amount of ETH to receive from the withdrawal",
        "@gparam3": "amountUsdcMin The minimum amount of USDC to receive from the withdrawal",
        "@gparam4": "amountOsqthMin The minimum amount of OSQTH to receive from the withdrawal",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0
    },
    {
        "func": "function setSanctionsList(address newSanctionsList) external onlyOwner {\n        // Check the proposed sanctions list contract has the right interface:\n        require(!SanctionsList(newSanctionsList).isSanctioned(address(this)), \"BackedToken: Wrong List interface\");\n\n        sanctionsList = SanctionsList(newSanctionsList);\n        emit NewSanctionsList(newSanctionsList);\n    }",
        "@notice": "change the contract Senctions List",
        "@dev": "Allowed only for owner * * Emits a { NewSanctionsList } event",
        "@param1": "newSanctionsList The address of the new Senctions List following the Chainalysis standard",
        "@gnotice": "Set a new Sanctions List contract address",
        "@gparam1": "newSanctionsList The address of the new SanctionsList contract",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function setStart(uint _start) public onlyOwner {\n    start = _start;\n  }",
        "@notice": "",
        "@dev": "set the starting time.",
        "@param1": "_start the new _start",
        "@gnotice": "Sets the start time for the contract",
        "@gparam1": "_start The start time for the contract in Unix timestamp format",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1
    },
    {
        "func": "function _setMarketBorrowCaps(CToken[] calldata cTokens, uint[] calldata newBorrowCaps) external {\n    \trequire(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\"); \n\n        uint numMarkets = cTokens.length;\n        uint numBorrowCaps = newBorrowCaps.length;\n\n        require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n        for(uint i = 0; i < numMarkets; i++) {\n            borrowCaps[address(cTokens[i])] = newBorrowCaps[i];\n            emit NewBorrowCap(cTokens[i], newBorrowCaps[i]);\n        }\n    }",
        "@notice": "set the borrow caps.",
        "@dev": "A borrow cap of 0 corresponds to unlimited borrowing.",
        "@param1": "cTokens The addresses of the markets to change the borrow caps for",
        "@param2": "newBorrowCaps The new borrow cap values in underlying to be set.",
        "@gnotice": "Sets borrow caps for multiple markets",
        "@gparam1": "cTokens An array of `CToken` addresses to set the borrow caps for",
        "@gparam2": "newBorrowCaps An array of new borrow caps for the corresponding `cTokens`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function balanceOf(address _owner) public constant returns (uint256 balance) {\n    return balances[_owner];\n  }",
        "@notice": "",
        "@dev": "Gets the balance of `_owner`",
        "@param1": "_owner The address to query the the balance of.",
        "@return1": "the amount owned by `_owner`",
        "@gnotice": "Get the token balance of `_owner`",
        "@gparam1": "_owner The address to query the balance of",
        "@greturn1": "The balance of `_owner`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function _checkContractOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public returns (bool) {\n        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n            return retval == IERC721Receiver(to).onERC721Received.selector;\n        } catch (bytes memory reason) {\n            if (reason.length == 0) {\n                revert TransferToNonERC721ReceiverImplementer();\n            } else {\n                assembly {\n                    revert(add(32, reason), mload(reason))\n                }\n            }\n        }\n    }",
        "@notice": "",
        "@dev": "Internal function to invoke {IERC721Receiver-onERC721Received} on a target contract.",
        "@param1": "from address of the previous owner of the given token ID",
        "@param2": "to address that will receive the tokens",
        "@param3": "tokenId ID of the token to be transferred",
        "@param4": "_data bytes optional data to send along with the call",
        "@return1": "bool whether the call correctly returned the expected magic value",
        "@gnotice": "Checks whether the receiving contract implements the ERC721Receiver interface and calls its `onERC721Received` function",
        "@gparam1": "from The address transferring the token",
        "@gparam2": "to The address receiving the token",
        "@gparam3": "tokenId The ID of the token being transferred",
        "@gparam4": "_data Additional data with no specified format, which is passed back to the caller",
        "@greturn1": "Whether or not the receiving contract implemented the ERC721Receiver interface and `onERC721Received` function was called successfully.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 1,
        "@treturn1": 0
    },
    {
        "func": "function exitMarket(address cTokenAddress) external override returns (uint) {\n        CToken cToken = CToken(cTokenAddress);\n        /* Get sender tokensHeld and amountOwed underlying from the cToken */\n        (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n        require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n        /* Fail if the sender has a borrow balance */\n        if (amountOwed != 0) {\n            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n        }\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n        uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n        if (allowed != 0) {\n            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n        }\n\n        Market storage marketToExit = markets[address(cToken)];\n\n        /* Return true if the sender is not already \u2018in\u2019 the market */\n        if (!marketToExit.accountMembership[msg.sender]) {\n            return uint(Error.NO_ERROR);\n        }\n\n        /* Set cToken account membership to false */\n        delete marketToExit.accountMembership[msg.sender];\n\n        /* Delete cToken from the account\u2019s list of assets */\n        // load into memory for faster iteration\n        CToken[] memory userAssetList = accountAssets[msg.sender];\n        uint len = userAssetList.length;\n        uint assetIndex = len;\n        for (uint i = 0; i < len; i++) {\n            if (userAssetList[i] == cToken) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        CToken[] storage storedList = accountAssets[msg.sender];\n        storedList[assetIndex] = storedList[storedList.length - 1];\n        storedList.pop();\n\n        emit MarketExited(cToken, msg.sender);\n\n        return uint(Error.NO_ERROR);\n    }",
        "@notice": "Removes asset from sender's account liquidity calculation",
        "@dev": "Sender must not have an outstanding borrow balance in the asset, * or be providing necessary collateral for an outstanding borrow.",
        "@param1": "cTokenAddress The address of the asset to be removed",
        "@return1": "Whether or not the account successfully exited the market",
        "@gnotice": "Allows a user to exit a given market by redeeming all underlying tokens",
        "@gparam1": "cTokenAddress The address of the Compound token to exit",
        "@greturn1": "an error code, 0 if successful",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function mint(\n    address _to,\n    uint256 _amount\n  )\n    public\n    returns (bool)\n  {\n    require(totalSupply_.add(_amount) <= cap);\n\n    return super.mint(_to, _amount);\n  }",
        "@notice": "",
        "@dev": "mint tokens",
        "@param1": "_to The address that will receive the minted tokens.",
        "@param2": "_amount The amount of tokens to mint.",
        "@return1": "A boolean that indicates if the operation was successful.",
        "@gnotice": "Create `_amount` new tokens and assign them to `_to`, but require that the total number of tokens does not exceed the `cap`",
        "@gparam1": "_to The address that will receive the minted tokens",
        "@gparam2": "_amount The amount of tokens to mint",
        "@greturn1": "Whether or not the minting was successful",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function setMinter(address newMinter) external onlyOwner {\n        minter = newMinter;\n        emit NewMinter(newMinter);\n    }",
        "@notice": "change the contract minter.",
        "@dev": " Allowed only for owner * * Emits a { NewMinter } event",
        "@param1": "newMinter The address of the new minter",
        "@gnotice": "Set a new address to act as the minter of the tokens",
        "@gparam1": "newMinter The address to set as the new minter. This address must have the necessary permissions to mint new tokens.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function tokenDataByCategory(uint256 category, uint256 index, uint256 amount)\n        external\n        view\n        returns (uint256[] memory data)\n    {\n        unchecked {\n            uint256 tokensMinted = _tokensMinted();\n            uint256 toIndex;\n            uint256 fromIndex;\n            if (amount == 0) { // Getting all data.\n                amount = _maxSupply;\n                toIndex = tokensMinted;\n            } else { // Getting range.\n                // Precheck for accurate data. \n                if (category == 0 || category == 3 || category == 8) {\n                    // toIndex temporarily holds precheck amount.\n                    uint maxPrecheck = _purchaseLimit + _maxFreePerAccount;\n                    if (index > maxPrecheck) {\n                        toIndex = maxPrecheck;\n                    } else if (index != 0) {\n                        toIndex = index % (maxPrecheck);\n                    }\n                }\n                fromIndex = index - toIndex; // Cannot underflow because index > toIndex (precheck).\n                toIndex += fromIndex + amount; // toIndex is calculated here.\n                // Limit amount.\n                if (toIndex > tokensMinted) {\n                    toIndex = tokensMinted;\n                    amount = toIndex - index; // Cannot underflow because toIndex always > index.\n                }\n            }\n            data = new uint256[](amount); // Create uint array.\n            uint256 holdNumber;\n            if (category != 8) {\n                while (fromIndex < toIndex) {\n                    // Check all minted CryptoBlobs.\n                    uint256 tokenId = _getTokenId(fromIndex); // Get token ID.\n                    bool sacrificed = _isTokenSacrificed(tokenId);\n                    uint256 dataRetrieved;\n                    if (category == 0) {\n                        // Update account of token.\n                        if (_token[tokenId].account != address(0)) {\n                            holdNumber = uint160(_token[tokenId].account);\n                        }\n                        // Add address if not sacrificed.\n                        if (!sacrificed) {\n                            dataRetrieved = holdNumber;\n                        }\n                    } else if (category == 1) {\n                        // Add approval.\n                        dataRetrieved = uint160(_token[tokenId].approval);\n                    } else if (category == 2) {\n                        // Update account of token.\n                        if (_token[tokenId].account != address(0)) {\n                            holdNumber = uint160(_token[tokenId].account);\n                        }\n                        // Add address if sacrificed.\n                        if (sacrificed) {\n                            dataRetrieved = holdNumber;\n                        }\n                    } else if (category == 3) {\n                        // Update latest mint timestamp.\n                        if (_token[tokenId].mintTimestamp != 0) {\n                            holdNumber = _token[tokenId].mintTimestamp;\n                        }\n                        // Add mint timestamp.\n                        dataRetrieved = holdNumber;\n                    } else if (category == 4) {\n                        // Add burn timestamp.\n                        dataRetrieved = _token[tokenId].burnTimestamp;\n                    } else if (category == 5 && !sacrificed) {\n                        // Add souls if not sacrificed.\n                        dataRetrieved = _token[tokenId].souls + 1;\n                    } else if (category == 6 && sacrificed) {\n                        // Add souls transferred if sacrificed.\n                        dataRetrieved = _token[tokenId].souls;\n                    } else if (category == 7 && sacrificed) {\n                        // Add token ID upgraded.\n                        dataRetrieved = _token[tokenId].burnTo;\n                    }\n                    // Add data to array.\n                    if (amount == _maxSupply) {\n                        if (dataRetrieved != 0) {\n                            data[tokenId - 1] = dataRetrieved;\n                        }\n                    } else if (fromIndex >= index) {\n                        if (dataRetrieved != 0) {\n                            data[fromIndex - index] = dataRetrieved;\n                        }\n                    }\n                    fromIndex++;\n                }\n            } else if (category == 8) {\n                uint256 tokensChecked;\n                while (fromIndex < toIndex) {\n                    if (_token[_getTokenId(toIndex - tokensChecked - 1)].account == address(0)) {\n                        holdNumber++;\n                    } else if (holdNumber > 0) {\n                        for (uint256 j; j < holdNumber + 1; j++) {\n                            if (amount == _maxSupply) {\n                                data[_getTokenId(toIndex - tokensChecked - 1 + j) - 1] = j;\n                            } else if (toIndex - tokensChecked - 1 + j >= index) {\n                                data[toIndex - tokensChecked - 1 + j - index] = j;\n                            }\n                        }\n                        delete holdNumber;\n                    }\n                    tokensChecked++;\n                    fromIndex++;\n                }\n            }\n            return data;\n        }\n    }",
        "@notice": "Information about all tokens.",
        "@dev": "Most providers will successfully call this function. * Data can be split by specifying an index and an amount, which uses token indices.",
        "@param1": "category 0 owners, 1 approvals, 2 burners, 3 mintTimestamps, 4 burnTimestamps, 5 ownedSouls, 6 burnSouls, 7 burnTos, 8 distance.",
        "@param2": "index Index to start from when splitting data.",
        "@param3": "amount Amount to query when splitting data.",
        "@return1": "data The number data of all tokens, based on the category.",
        "@gnotice": "Get token data based on `category`, `index`, and `amount`",
        "@gparam1": "category The category of data to retrieve (0-8)",
        "@gparam2": "index The starting index of the range of tokens to retrieve data for",
        "@gparam3": "amount The number of tokens to retrieve data for",
        "@greturn1": "An array of uint256 values containing the requested data for the specified tokens",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 1,
        "@tparam2": 0,
        "@tparam3": 0,
        "@treturn1": 1
    },
    {
        "func": "function setAllowanceTarget(address payable newAllowanceTarget) public onlyOwner {\n        require(newAllowanceTarget != _NULL_ADDRESS, \"Invalid allowance target\");\n        _allowanceTarget = newAllowanceTarget;\n        emit AllowanceTargetChanged(_allowanceTarget);\n    }",
        "@notice": "",
        "@dev": "Set a new new allowance target address",
        "@param1": "newAllowanceTarget New allowance target address",
        "@gnotice": "Sets new allowance target for the contract",
        "@gparam1": "newAllowanceTarget Address of the new allowance target",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function depositCollateral(\n        BalanceSheetInterface balanceSheet,\n        FyTokenInterface fyToken,\n        uint256 collateralAmount\n    ) public {\n        /* Transfer the collateral to the DSProxy. */\n        fyToken.collateral().safeTransferFrom(msg.sender, address(this), collateralAmount);\n\n        /* Deposit the collateral into the BalanceSheet contract. */\n        depositCollateralInternal(balanceSheet, fyToken, collateralAmount);\n    }",
        "@notice": "Deposits collateral into the BalanceSheet contract",
        "@dev": "Requirements: * - The caller must have allowed the DSProxy to spend `collateralAmount` tokens.",
        "@param1": "balanceSheet The address of the BalanceSheet contract.",
        "@param2": "fyToken The address of the FyToken contract.",
        "@param3": "collateralAmount The amount of collateral to deposit.",
        "@gnotice": "Deposit `collateralAmount` collateral into the `balanceSheet` from `msg.sender`'s account, and wrap the corresponding amount of fyTokens",
        "@gparam1": "balanceSheet The address of the BalanceSheet contract",
        "@gparam2": "fyToken The address of the fyToken contract",
        "@gparam3": "collateralAmount The amount of collateral to deposit",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0
    },
    {
        "func": "function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata _data\n  )\n    external\n    override\n  {\n    _safeTransferFrom(_from, _to, _tokenId, _data);\n  }",
        "@notice": "Transfers the ownership of an NFT from one address to another address. ",
        "@dev": "This function can * be changed to payable.",
        "@param1": "_from The current owner of the NFT.",
        "@param2": "_to The new owner.",
        "@param3": "_tokenId The NFT to transfer.",
        "@param4": "_data Additional data with no specified format, sent in call to `_to`.",
        "@gnotice": "Transfers ownership of the ERC721 token with ID `_tokenId` from `_from` to `_to` performing a safe check to determine if `_to` is a contract and if it is, if it can receive ERC721 tokens. `_data` is additional data that can be sent alongside the transfer.",
        "@gparam1": "_from The address of the current owner of the token",
        "@gparam2": "_to The address of the new owner of the token",
        "@gparam3": "_tokenId The ID of the token being transferred",
        "@gparam4": "_data Additional data that can be sent alongside the transfer",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0
    },
    {
        "func": "function repayBorrow(FyTokenInterface fyToken, uint256 repayAmount) public {\n        /* Transfer the fyTokens to the DSProxy. */\n        fyToken.safeTransferFrom(msg.sender, address(this), repayAmount);\n\n        /* Repay the borrow. */\n        fyToken.repayBorrow(repayAmount);\n    }",
        "@notice": "Repays the fyToken borrow",
        "@dev": "Requirements: * - The caller must have allowed the DSProxy to spend `repayAmount` fyTokens.",
        "@param1": "fyToken The address of the FyToken contract.",
        "@param2": "repayAmount The amount of fyTokens to repay.",
        "@gnotice": "Repays `repayAmount` borrowed tokens to the `fyToken` contract from the `msg.sender`",
        "@gparam1": "fyToken The address of the fToken contract",
        "@gparam2": "repayAmount The amount of tokens to repay",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function claim(address raceAddress) external payable\n    costs(claimingFee)\n    whenNotPaused()\n    {\n        //call _isWinnerOf with a 0 address to simply get the winner horse\n        bytes32 winner;\n        (,winner) = _isWinnerOf(raceAddress, address(0));\n        require(winner != bytes32(0),\"Winner is zero\");\n        require(can_claim(raceAddress, msg.sender),\"can_claim return false\");\n        //require(!exists(id)); should already be checked by mining function\n        uint256 id = _generate_special_horsey(raceAddress, msg.sender, winner);\n        emit Claimed(raceAddress, msg.sender, id);\n    }",
        "@notice": "",
        "@dev": "claim a special horsey with the same dna as the race one",
        "@param1": "raceAddress The race's address",
        "@gnotice": "Claim rewards for the winning horse in specified race",
        "@gparam1": "raceAddress The address of the race to claim rewards from",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function initialize(ILendingPoolAddressesProvider _provider) external initializer {\n    _addressesProvider = _provider;\n  }",
        "@notice": "",
        "@dev": "Function is invoked by the proxy contract when the Vault contract is deployed.",
        "@param1": "_provider The address of the provider",
        "@gnotice": "Initializes the contract with the given `_provider` address for the lending pool",
        "@gparam1": "_provider The address of the `ILendingPoolAddressesProvider`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function verifyMerkleProof(\n        bytes32 merkleRoot,\n        bytes32[] memory merkleProof,\n        uint256 valueToProve\n    ) public pure returns (bool) {\n        bytes32 hashedValue = keccak256(abi.encode(valueToProve));\n\n        return _verifyProof(merkleRoot, merkleProof, hashedValue);\n    }",
        "@notice": "Verifies a merkle proof for the value to prove and given root and proof",
        "@dev": "The `valueToProve` is hashed prior to executing the proof verification.",
        "@param1": "merkleRoot The root of the merkle tree",
        "@param2": "merkleProof The merkle proof",
        "@param3": "valueToProve The value to prove",
        "@return1": "whether proof is valid",
        "@gnotice": "Verify a Merkle proof for a given hashed value.",
        "@gparam1": "merkleRoot The Merkle root hash of the Merkle tree that the proof is being verified against.",
        "@gparam2": "merkleProof The Merkle proof to be verified.",
        "@gparam3": "valueToProve The original value to be hashed and verified against the Merkle root hash.",
        "@greturn1": "Whether or not the Merkle proof is valid for the given hashed value.",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@treturn1": 0
    },
    {
        "func": "function balanceOfUnderlying(address owner) external override returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n        return balance;\n    }",
        "@notice": "Get the underlying balance of the `owner`",
        "@dev": "This also accrues interest in a transaction",
        "@param1": "owner The address of the account to query",
        "@return1": "The amount of underlying owned by `owner`",
        "@gnotice": "Get the current balance of `owner` in underlying tokens",
        "@gparam1": "owner The address of the account to query",
        "@greturn1": "The number of underlying tokens owned by `owner`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function setApprovalForAll(\n    address _operator,\n    bool _approved\n  )\n    external\n    override\n  {\n    ownerToOperators[msg.sender][_operator] = _approved;\n    emit ApprovalForAll(msg.sender, _operator, _approved);\n  }",
        "@notice": "This works even if sender doesn't own any tokens at the time",
        "@dev": "Enables or disables approval for a third party (\"operator\") to manage all of * `msg.sender`'s assets. It also emits the ApprovalForAll event.",
        "@param1": "_operator Address to add to the set of authorized operators.",
        "@param2": "_approved True if the operators is approved, false to revoke approval.",
        "@gnotice": "Set approval for `_operator` to operate on all tokens of the `msg.sender`",
        "@gparam1": "_operator The operator that `msg.sender` wants to give approval to",
        "@gparam2": "_approved Whether or not the operator is approved",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function deployStableSwapPool(\n        address _curveFactory,\n        address _crvBasePool,\n        address _crv3PoolTokenAddress,\n        uint256 _amplificationCoefficient,\n        uint256 _fee\n    ) external onlyAdmin {\n        // Create new StableSwap meta pool (uAD <-> 3Crv)\n        address metaPool =\n            ICurveFactory(_curveFactory).deploy_metapool(\n                _crvBasePool,\n                ERC20(dollarTokenAddress).name(),\n                ERC20(dollarTokenAddress).symbol(),\n                dollarTokenAddress,\n                _amplificationCoefficient,\n                _fee\n            );\n        stableSwapMetaPoolAddress = metaPool;\n\n        // Approve the newly-deployed meta pool to transfer this contract's funds\n        uint256 crv3PoolTokenAmount =\n            IERC20(_crv3PoolTokenAddress).balanceOf(address(this));\n        uint256 uADTokenAmount =\n            IERC20(dollarTokenAddress).balanceOf(address(this));\n\n        // safe approve revert if approve from non-zero to non-zero allowance\n        IERC20(_crv3PoolTokenAddress).safeApprove(metaPool, 0);\n        IERC20(_crv3PoolTokenAddress).safeApprove(\n            metaPool,\n            crv3PoolTokenAmount\n        );\n\n        IERC20(dollarTokenAddress).safeApprove(metaPool, 0);\n        IERC20(dollarTokenAddress).safeApprove(metaPool, uADTokenAmount);\n\n        // coin at index 0 is uAD and index 1 is 3CRV\n        require(\n            IMetaPool(metaPool).coins(0) == dollarTokenAddress &&\n                IMetaPool(metaPool).coins(1) == _crv3PoolTokenAddress,\n            \"uADMGR: COIN_ORDER_MISMATCH\"\n        );\n        // Add the initial liquidity to the StableSwap meta pool\n        uint256[2] memory amounts =\n            [\n                IERC20(dollarTokenAddress).balanceOf(address(this)),\n                IERC20(_crv3PoolTokenAddress).balanceOf(address(this))\n            ];\n\n        // set curve 3Pool address\n        curve3PoolTokenAddress = _crv3PoolTokenAddress;\n        IMetaPool(metaPool).add_liquidity(amounts, 0, msg.sender);\n    }",
        "@notice": "deploy a new Curve metapools for uAD Token uAD/3Pool",
        "@dev": "From the curve documentation for uncollateralized algorithmic stablecoins amplification should be 5-10",
        "@param1": "_curveFactory MetaPool factory address",
        "@param2": "_crvBasePool Address of the base pool to use within the new metapool.",
        "@param3": "_crv3PoolTokenAddress curve 3Pool token Address",
        "@param4": "_amplificationCoefficient amplification coefficient. The smaller it is the closer to a constant product we are.",
        "@param5": "_fee Trade fee",
        "@gnotice": "Deploys a new StableSwap meta pool for exchanging between uAD and 3CRV tokens and adds initial liquidity to it",
        "@gparam1": "_curveFactory The address of the Curve Factory contract",
        "@gparam2": "_crvBasePool The address of the base pool contract",
        "@gparam3": "_crv3PoolTokenAddress The address of the 3CRV token contract",
        "@gparam4": "_amplificationCoefficient The amplification coefficient to use for the new StableSwap pool",
        "@gparam5": "_fee The fee to be charged for exchanges on the new StableSwap pool",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0,
        "@tparam5": 0
    },
    {
        "func": "function cancelSale(uint256 tokenId) external \n    whenNotPaused()\n    originalOwnerOf(tokenId) \n    tokenAvailable() returns (bool) {\n        //throws on fail - transfers token from exchange back to original owner\n        token.transferFrom(address(this),msg.sender,tokenId);\n        \n        //Reset token on market - remove\n        delete market[tokenId];\n\n        //Reset barn tracker for user\n        _removeTokenFromBarn(tokenId, msg.sender);\n\n        emit SaleCanceled(tokenId);\n\n        //Return true if this user is still 'active' within the exchange\n        //This will help with client side actions\n        return userBarn[msg.sender].length > 0;\n    }",
        "@notice": "",
        "@dev": "cancel sale at anytime",
        "@param1": "tokenId ID of the token to remove from the market",
        "@return1": "true if user still has tokens for sale",
        "@gnotice": "Cancel sale of token with ID `tokenId` by transferring it back to the original owner account",
        "@gparam1": "tokenId The ID of the token to cancel the sale for",
        "@greturn1": "Whether or not the cancelation succeeded",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function delegatedTransfer(\n        address owner,\n        address to,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public override allowedDelegate {\n        super.delegatedTransfer(owner, to, value, deadline, v, r, s);\n    }",
        "@notice": "Perform an intended transfer on one account's behalf, from another account, * who actually pays fees for the transaction. ",
        "@dev": "Allowed only if the sender * is whitelisted, or the delegateMode is set to true",
        "@param1": "owner The account that provided the signature and from which the tokens will be taken",
        "@param2": "to The account that will receive the tokens",
        "@param3": "value The amount of tokens to transfer",
        "@param4": "deadline Expiration time, seconds since the epoch",
        "@param5": "v v part of the signature",
        "@param6": "r r part of the signature",
        "@param7": "s s part of the signature",
        "@gnotice": "Perform a delegated transfer of `value` tokens from `owner` to `to` with a deadline of `deadline`.",
        "@gparam1": "owner The owner of the tokens to transfer",
        "@gparam2": "to The recipient of the tokens",
        "@gparam3": "value The amount of tokens to transfer",
        "@gparam4": "deadline The deadline for the transfer to be executed by",
        "@gparam5": "v The v parameter of the ECDSA signature of the delegator's signature",
        "@gparam6": "r The r parameter of the ECDSA signature of the delegator's signature",
        "@gparam7": "s The s parameter of the ECDSA signature of the delegator's signature",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 1,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 1,
        "@tparam5": 0,
        "@tparam6": 0,
        "@tparam7": 0
    },
    {
        "func": "function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }",
        "@notice": "",
        "@dev": "transfer control of the contract to a newOwner.",
        "@param1": "newOwner The address to transfer ownership to.",
        "@gnotice": "Transfer ownership of the contract to a new owner",
        "@gparam1": "newOwner The address of the new owner of the contract",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function stake(uint256 amount) external override {\n        _stakeFor(msg.sender, msg.sender, amount);\n    }",
        "@notice": "",
        "@dev": "Transfers amount of deposit tokens from the user.",
        "@param1": "amount Number of deposit tokens to stake.",
        "@gnotice": "Stake `amount` tokens for `msg.sender`",
        "@gparam1": "amount The number of tokens to stake for `msg.sender`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function purchaseToken(uint256 tokenId) external payable \n    whenNotPaused()\n    isOnMarket(tokenId) \n    tokenAvailable()\n    notOriginalOwnerOf(tokenId)\n    {\n        //Did the sender accidently pay over? - if so track the amount over\n        uint256 totalToPay = getTokenPrice(tokenId);\n        require(msg.value >= totalToPay, \"Not paying enough\");\n\n        //fetch this tokens sale data\n        SaleData memory sale = market[tokenId];\n\n        //Add to collected fee amount payable to DEVS\n        collectedFees += totalToPay - sale.price;\n\n        //pay the seller\n        sale.owner.transfer(sale.price);\n\n        //Reset barn tracker for user\n        _removeTokenFromBarn(tokenId,  sale.owner);\n\n        //Reset token on market - remove\n        delete market[tokenId];\n\n        //Transfer the ERC721 to the buyer - we leave the sale amount\n        //to be withdrawn by the user (transferred from exchange)\n        token.transferFrom(address(this), msg.sender, tokenId);\n\n        //Return over paid amount to sender if necessary\n        if(msg.value > totalToPay) //overpaid\n        {\n            msg.sender.transfer(msg.value.sub(totalToPay));\n        }\n\n        emit HorseyPurchased(tokenId, msg.sender, totalToPay);\n    }",
        "@notice": "Performs the purchase of a token that is present on the market",
        "@dev": " - this includes checking that the proper amount is sent + appliced fee, updating seller's balance, updated collected fees and transfering token to buyer Only market tokens can be purchased",
        "@param1": "tokenId ID of the token we wish to purchase",
        "@gnotice": "Allows a user to purchase a token with the specified `tokenId` that is currently on the market",
        "@gparam1": "tokenId The ID of the token being purchased",
        "@greturn1": "None, but emits an event to indicate that the purchase has occurred",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function getPriorVotes(address account, uint blockNumber)\n    external\n    view\n    returns (uint256)\n    {\n        require(blockNumber < block.number, \"getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }",
        "@notice": "",
        "@dev": "Block number must be a finalized block or else this function will revert to prevent misinformation.",
        "@param1": "account The address of the account to check",
        "@param2": "blockNumber The block number to get the vote balance at",
        "@return1": "The number of votes the account had as of the given block",
        "@gnotice": "Get the prior voting power of `account` at `blockNumber`",
        "@gparam1": "account The address of the account to check",
        "@gparam2": "blockNumber The block number to get the voting power at",
        "@greturn1": "The voting number of `account` at `blockNumber`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public override allowedDelegate {\n        super.permit(owner, spender, value, deadline, v, r, s);\n    }",
        "@notice": "Update allowance with a signed permit.",
        "@dev": "Allowed only if * the sender is whitelisted, or the delegateMode is set to true",
        "@param1": "owner Token owner's address (Authorizer)",
        "@param2": "spender Spender's address",
        "@param3": "value Amount of allowance",
        "@param4": "deadline Expiration time, seconds since the epoch",
        "@param5": "v v part of the signature",
        "@param6": "r r part of the signature",
        "@param7": "s s part of the signature",
        "@gnotice": "Allows `spender` to spend up to `value` tokens on behalf of `owner` via `delegate`",
        "@gparam1": "owner The address giving permission to `spender` to spend tokens",
        "@gparam2": "spender The address receiving permission to spend tokens",
        "@gparam3": "value The amount of tokens the spender is granted permission to spend",
        "@gparam4": "deadline Time after which the permit is no longer valid",
        "@gparam5": "v Component of the ECDSA signature",
        "@gparam6": "r Component of the ECDSA signature",
        "@gparam7": "s Component of the ECDSA signature",
        "@greturn1": "None",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 1,
        "@tparam5": 0,
        "@tparam6": 0,
        "@tparam7": 0
    },
    {
        "func": "function seize(address liquidator, address borrower, uint seizeTokens) external override nonReentrant returns (uint) {\n        return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\n    }",
        "@notice": "Transfers collateral tokens to the liquidator",
        "@dev": "Will fail unless called by another cToken during the process of liquidation. * Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.",
        "@param1": "liquidator The account receiving seized collateral",
        "@param2": "borrower The account having collateral seized",
        "@param3": "seizeTokens The number of cTokens to seize",
        "@return1": "uint 0=success, otherwise a failure",
        "@gnotice": "Seizes `seizeTokens` tokens from `borrower` to be transferred to `liquidator` account",
        "@gparam1": "liquidator The account that will receive the seized tokens",
        "@gparam2": "borrower The account that borrowed the tokens to be seized",
        "@gparam3": "seizeTokens The number of tokens to be seized",
        "@greturn1": "The actual amount of tokens seized",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@treturn1": 1
    },
    {
        "func": "function approve(\n    address _approved,\n    uint256 _tokenId\n  )\n    external\n    override\n    canOperate(_tokenId)\n    validNFToken(_tokenId)\n  {\n    address tokenOwner = idToOwner[_tokenId];\n    require(_approved != tokenOwner, IS_OWNER);\n\n    idToApproval[_tokenId] = _approved;\n    emit Approval(tokenOwner, _approved, _tokenId);\n  }",
        "@notice": "Set the approved address for an NFT.",
        "@dev": "This function can be changed to payable.",
        "@param1": "_approved Address to be approved for the given NFT ID.",
        "@param2": "_tokenId ID of the token to be approved.",
        "@gnotice": "Approve the `approved` address for the `tokenId` token",
        "@gparam1": "_approved The address to be approved for the token transfer",
        "@gparam2": "_tokenId The identifier of the token",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function metapool_swap(\n        address from_vault,\n        address to_vault,\n        uint256 amount,\n        uint256 min_amount_out\n    ) public {\n        metapool_swap(from_vault, to_vault, amount, min_amount_out, DEFAULT_DONATION, UNKNOWN_ORIGIN);\n    }",
        "@notice": "swap tokens from one meta pool vault to an other",
        "@dev": "Remove funds from a vault, move one side of the asset from one curve pool to an other and deposit into the new vault.",
        "@param1": "from_vault The vault tokens should be taken from",
        "@param2": "to_vault The vault tokens should be deposited to",
        "@param3": "amount The amount of tokens you whish to use from the from_vault",
        "@param4": "min_amount_out The minimum amount of tokens you would expect from the to_vault",
        "@gnotice": "Swap `amount` tokens from `from_vault` and deposit resulting tokens to `to_vault`, ensuring minimum of `min_amount_out` of resulting tokens are received",
        "@gparam1": "from_vault The address of the source vault",
        "@gparam2": "to_vault The address of the destination vault",
        "@gparam3": "amount The number of tokens to be swapped",
        "@gparam4": "min_amount_out The minimum amount of resulting tokens desired. If this amount is not reached, the transaction fails",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0
    },
    {
        "func": "function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n\n        // Preapproved services:\n        // OpenSea, X2Y2, LooksRare, Rarible, 0x Protocol v4, Element, SudoSwap, NFTX, and NFTTrader.\n        // You can manage these services like usual with {setApprovalForAll} or {batch}.\n\n        uint256 status = _account[owner].approvals[operator];\n        return (\n                    status == 2 || // If approved.\n                    (\n                        status == 0 && // If default value (never approved or revoked by the owner).\n                        _account[operator].preapprovedStatus == 2 && // If preapproved service.\n                        owner != operator // If not self.\n                    )\n                );\n    }",
        "@notice": "Returns if `operator` is an approved account operator of `owner`",
        "@dev": "Account operators can do everything the owner can do expect sign messages and manage their account operators. * Preapproved services: OpenSea, X2Y2, LooksRare, Rarible, 0x Protocol v4, Element, SudoSwap, NFTX, and NFTTrader. * You can revoke these services using {setApprovalForAll} or visit CryptoBlobs.com for a batch tx to revoke all at once. * SuperCollectiv will permanently disable preapproved services if any issues are discovered with these contracts. * Services that list your account operators will not detect that these addresses have * been approved unless you reapprove each service with {setApprovalForAll} or {batch}.",
        "@param1": "owner The address of the account that owns the CryptoBlobs.",
        "@param2": "operator The address of the account to the check the status of.",
        "@return1": "If `operator` is an account operator of `owner`.",
        "@gnotice": "Checks whether a given `operator` is approved by `owner` to manage all of its assets",
        "@gparam1": "owner The address of the owner",
        "@gparam2": "operator The address of the operator to check",
        "@greturn1": "Whether or not `operator` is approved to manage all of `owner`'s assets",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function depositCollateral(address _asset, uint256 _amount) external payable virtual {\n    if (_asset != address(0)) {\n      // asset = ERC20\n      require(msg.value == 0, Errors.VT_COLLATERAL_DEPOSIT_INVALID);\n    } else {\n      // asset = ETH\n      require(msg.value == _amount, Errors.VT_COLLATERAL_DEPOSIT_REQUIRE_ETH);\n    }\n    // Deposit asset to vault and receive stAsset\n    // Ex: if user deposit 100ETH, this will deposit 100ETH to Lido and receive 100stETH\n    (address _stAsset, uint256 _stAssetAmount) = _depositToYieldPool(_asset, _amount);\n\n    // Deposit stAsset to lendingPool, then user will get aToken of stAsset\n    ILendingPool(_addressesProvider.getLendingPool()).deposit(\n      _stAsset,\n      _stAssetAmount,\n      msg.sender,\n      0\n    );\n\n    emit DepositCollateral(_asset, msg.sender, _amount);\n  }",
        "@notice": "",
        "@dev": "Deposits an `amount` of asset as collateral to borrow other asset.",
        "@param1": "_asset The asset address for collateral * _asset = 0x0000000000000000000000000000000000000000 means to use ETH as collateral",
        "@param2": "_amount The deposit amount",
        "@gnotice": "Allows the user to deposit collateral, either an ERC20 token or ETH",
        "@gparam1": "_asset The address of the collateral asset, can be an ERC20 token or 0x0 for ETH",
        "@gparam2": "_amount The amount of collateral to deposit",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1,
        "@tparam2": 0
    },
    {
        "func": "function renameHorsey(uint256 tokenId, string newName) external \n    whenNotPaused()\n    onlyOwnerOf(tokenId) \n    costs(renamingCostsPerChar * bytes(newName).length)\n    payable {\n        uint256 renamingFee = renamingCostsPerChar * bytes(newName).length;\n        //Return over paid amount to sender if necessary\n        if(msg.value > renamingFee) //overpaid\n        {\n            msg.sender.transfer(msg.value.sub(renamingFee));\n        }\n        //store the new name\n        stables.storeName(tokenId,newName);\n        emit HorseyRenamed(tokenId,newName);\n    }",
        "@notice": "",
        "@dev": "give a horsey a name or rename it",
        "@param1": "tokenId ID of the horsey to rename",
        "@param2": "newName The name to give to the horsey",
        "@gnotice": "Renames a Horsey to a new name specified by the `newName` parameter",
        "@gparam1": "tokenId The ID of the Horsey being renamed",
        "@gparam2": "newName The new name for the Horsey",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function supportsInterface(\n    bytes4 _interfaceID\n  )\n    external\n    override\n    view\n    returns (bool)\n  {\n    return supportedInterfaces[_interfaceID];\n  }",
        "@notice": "",
        "@dev": "check which interfaces are suported by this contract.",
        "@param1": "_interfaceID Id of the interface.",
        "@return1": "True if _interfaceID is supported, false otherwise.",
        "@gnotice": "Check if a contract implements an interface",
        "@gparam1": "_interfaceID The interface identifier to check",
        "@greturn1": "Whether or not the contract implements the given interface",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function redeemFyTokens(FyTokenInterface fyToken, uint256 fyTokenAmount) public {\n        Erc20Interface underlying = fyToken.underlying();\n        RedemptionPoolInterface redemptionPool = fyToken.redemptionPool();\n\n        /* Transfer the fyTokens to the DSProxy. */\n        fyToken.safeTransferFrom(msg.sender, address(this), fyTokenAmount);\n\n        /* Redeem the fyTokens. */\n        uint256 preUnderlyingBalance = underlying.balanceOf(address(this));\n        redemptionPool.redeemFyTokens(fyTokenAmount);\n\n        /* Calculate how many underlying have been redeemed. */\n        uint256 postUnderlyigBalance = underlying.balanceOf(address(this));\n        MathError mathErr;\n        uint256 underlyingAmount;\n        (mathErr, underlyingAmount) = subUInt(postUnderlyigBalance, preUnderlyingBalance);\n        require(mathErr == MathError.NO_ERROR, \"ERR_REDEEM_FYTOKENS_MATH_ERROR\");\n\n        /* The underlying is now in the DSProxy, so we relay it to the end user. */\n        underlying.safeTransfer(msg.sender, underlyingAmount);\n    }",
        "@notice": "Redeems fyTokens in exchange for underlying tokens",
        "@dev": "Requirements: * - The caller must have allowed the DSProxy to spend `repayAmount` fyTokens.",
        "@param1": "fyToken The address of the FyToken contract.",
        "@param2": "fyTokenAmount The amount of fyTokens to redeem.",
        "@gnotice": "Redeem `fyTokenAmount` number of fyTokens from given `fyToken` and transfer the underlying tokens to the transaction sender",
        "@gparam1": "fyToken The FyToken contract from which fyTokens are to be redeemed",
        "@gparam2": "fyTokenAmount The number of fyTokens to be redeemed",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function setHyperDex(IHyperDex newHyperDex) public onlyOwner{\n        require(address(newHyperDex) != _NULL_ADDRESS, \"Invalid HyperDex address\");\n        _hyperDex = newHyperDex;\n        emit HyperDexChanged(address(_hyperDex));\n    }",
        "@notice": "",
        "@dev": "Set a new MultiSwap proxy contract address",
        "@param1": "newHyperDex New Exchange proxy address",
        "@gnotice": "Set a new HyperDex instance for the contract",
        "@gparam1": "newHyperDex The address of the new HyperDex instance",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function depositAndLockCollateral(\n        BalanceSheetInterface balanceSheet,\n        FyTokenInterface fyToken,\n        uint256 collateralAmount\n    ) public {\n        depositCollateral(balanceSheet, fyToken, collateralAmount);\n        balanceSheet.lockCollateral(fyToken, collateralAmount);\n    }",
        "@notice": "Deposits and locks collateral into the BalanceSheet contract",
        "@dev": "Requirements: * - The caller must have allowed the DSProxy to spend `collateralAmount` tokens.",
        "@param1": "balanceSheet The address of the BalanceSheet contract.",
        "@param2": "fyToken The address of the FyToken contract.",
        "@param3": "collateralAmount The amount of collateral to deposit and lock.",
        "@gnotice": "Deposits `collateralAmount` tokens as collateral for the specified `fyToken` and locks them in the `balanceSheet`",
        "@gparam1": "balanceSheet The `BalanceSheetInterface` contract address",
        "@gparam2": "fyToken The `FyTokenInterface` contract address",
        "@gparam3": "collateralAmount The `uint256` amount of the collateral tokens to deposit and lock",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0
    },
    {
        "func": "function setPause(bool newPauseMode) external {\n        require(_msgSender() == pauser, \"BackedToken: Only pauser\");\n        isPaused = newPauseMode;\n        emit PauseModeChange(newPauseMode);\n    }",
        "@notice": "set the pause in order to block or restore all transfers.",
        "@dev": " Allowed only for pauser * * Emits a { PauseModeChange } event",
        "@param1": "newPauseMode The new pause mode",
        "@gnotice": "Sets the pause state of the contract",
        "@gparam1": "newPauseMode The new pause state to set: `true` for paused state, `false` for unpaused state. The function can only be called by the contract's `pauser`.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function addressesToENS(address[] memory accounts) public view returns (string[] memory ensNames) {\n        return IReverseRecords(_reverseRecordsAddress).getNames(accounts);\n    }",
        "@notice": "Reverse records for the primary ENS name of accounts",
        "@dev": "_reverseRecordsAddress Can be updated to support additional features.",
        "@param1": "accounts The addresses of the accounts.",
        "@return1": "ensNames ENS names of `accounts`.",
        "@gnotice": "Returns the ENS names associated with the provided `accounts`",
        "@gparam1": "accounts An array of addresses",
        "@greturn1": "An array of ENS names (as strings) corresponding to the provided `accounts`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\n        // Check caller is admin\n    \trequire(msg.sender == admin, \"only admin can set close factor\");\n\n        uint oldCloseFactorMantissa = closeFactorMantissa;\n        closeFactorMantissa = newCloseFactorMantissa;\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }",
        "@notice": "",
        "@dev": "set closeFactor",
        "@param1": "newCloseFactorMantissa New close factor, scaled by 1e18",
        "@return1": "uint 0=success, otherwise a failure",
        "@gnotice": "Sets the `closeFactorMantissa` to `newCloseFactorMantissa`",
        "@gparam1": "newCloseFactorMantissa The new close factor mantissa value to set",
        "@greturn1": "An unsigned integer representing the error code associated with the function execution.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function mint(\n    address _to,\n    uint256 _amount\n  )\n    public\n    hasMintPermission\n    canMint\n    returns (bool)\n  {\n    totalSupply_ = totalSupply_.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    emit Mint(_to, _amount);\n    emit Transfer(address(0), _to, _amount);\n    return true;\n  }",
        "@notice": "",
        "@dev": "mint tokens",
        "@param1": "_to The address that will receive the minted tokens.",
        "@param2": "_amount The amount of tokens to mint.",
        "@return1": "A boolean that indicates if the operation was successful.",
        "@gnotice": "Mint `_amount` tokens and assign them to `_to` address",
        "@gparam1": "_to The address to mint tokens to",
        "@gparam2": "_amount The amount of tokens to mint",
        "@greturn1": "A boolean indicating whether or not the minting was successful",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }",
        "@notice": "",
        "@dev": "transfer control of the contract to a newOwner.",
        "@param1": "newOwner The address to transfer ownership to.",
        "@gnotice": "Transfer ownership of the contract to `newOwner`",
        "@gparam1": "newOwner The address of the new owner",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function unstakeAndClaim(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external override onlyOnline {\n        // fetch vault storage reference\n        VaultData storage vaultData = _vaults[vault];\n\n        // verify non-zero amount\n        require(amount != 0, \"Aludel: no amount unstaked\");\n\n        // check for sufficient vault stake amount\n        require(vaultData.totalStake >= amount, \"Aludel: insufficient vault stake\");\n\n        // check for sufficient Aludel stake amount\n        // if this check fails, there is a bug in stake accounting\n        assert(_aludel.totalStake >= amount);\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // get reward amount remaining\n        uint256 remainingRewards = IERC20(_aludel.rewardToken).balanceOf(_aludel.rewardPool);\n\n        // calculate vested portion of reward pool\n        uint256 unlockedRewards =\n            calculateUnlockedRewards(\n                _aludel.rewardSchedules,\n                remainingRewards,\n                _aludel.rewardSharesOutstanding,\n                block.timestamp\n            );\n\n        // calculate vault time weighted reward with scaling\n        RewardOutput memory out =\n            calculateRewardFromStakes(\n                vaultData.stakes,\n                amount,\n                unlockedRewards,\n                _aludel.totalStakeUnits,\n                block.timestamp,\n                _aludel.rewardScaling\n            );\n\n        // update stake data in storage\n        if (out.newStakesCount == 0) {\n            // all stakes have been unstaked\n            delete vaultData.stakes;\n        } else {\n            // some stakes have been completely or partially unstaked\n            // delete fully unstaked stakes\n            while (vaultData.stakes.length > out.newStakesCount) vaultData.stakes.pop();\n\n            // update stake amount when lastStakeAmount is set\n            if (out.lastStakeAmount > 0) {\n                // update partially unstaked stake\n                vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;\n            }\n        }\n\n        // update cached stake totals\n        vaultData.totalStake = vaultData.totalStake.sub(amount);\n        _aludel.totalStake = _aludel.totalStake.sub(amount);\n        _aludel.totalStakeUnits = out.newTotalStakeUnits;\n\n        // unlock staking tokens from vault\n        IUniversalVault(vault).unlock(_aludel.stakingToken, amount, permission);\n\n        // emit event\n        emit Unstaked(vault, amount);\n\n        // only perform on non-zero reward\n        if (out.reward > 0) {\n            // calculate shares to burn\n            // sharesToBurn = sharesOutstanding * reward / remainingRewards\n            uint256 sharesToBurn =\n                _aludel.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);\n\n            // burn claimed shares\n            _aludel.rewardSharesOutstanding = _aludel.rewardSharesOutstanding.sub(sharesToBurn);\n\n            // transfer bonus tokens from reward pool to vault\n            if (_bonusTokenSet.length() > 0) {\n                for (uint256 index = 0; index < _bonusTokenSet.length(); index++) {\n                    // fetch bonus token address reference\n                    address bonusToken = _bonusTokenSet.at(index);\n\n                    // calculate bonus token amount\n                    // bonusAmount = bonusRemaining * reward / remainingRewards\n                    uint256 bonusAmount =\n                        IERC20(bonusToken).balanceOf(_aludel.rewardPool).mul(out.reward).div(\n                            remainingRewards\n                        );\n\n                    // transfer bonus token\n                    IRewardPool(_aludel.rewardPool).sendERC20(bonusToken, vault, bonusAmount);\n\n                    // emit event\n                    emit RewardClaimed(vault, bonusToken, bonusAmount);\n                }\n            }\n\n            // transfer reward tokens from reward pool to vault\n            IRewardPool(_aludel.rewardPool).sendERC20(_aludel.rewardToken, vault, out.reward);\n\n            // emit event\n            emit RewardClaimed(vault, _aludel.rewardToken, out.reward);\n        }\n    }",
        "@notice": "Unstake staking tokens and claim reward",
        "@dev": "rewards can only be claimed when unstaking, thus reseting the reward multiplier /// access control: anyone with a valid permission /// state machine: /// - when vault exists on this Aludel /// - after stake from vault /// - can be called multiple times while sufficient stake remains /// - only online /// state scope: /// - decrease _aludel.rewardSharesOutstanding /// - decrease _aludel.totalStake /// - increase _aludel.lastUpdate /// - modify _aludel.totalStakeUnits /// - modify _vaults[vault].stakes /// - decrease _vaults[vault].totalStake /// token transfer: /// - transfer reward tokens from reward pool to vault /// - transfer bonus tokens from reward pool to vault",
        "@param1": "vault address The vault to unstake from",
        "@param2": "amount uint256 The amount of staking tokens to unstake",
        "@param3": "permission bytes The signed lock permission for the universal vault",
        "@gnotice": "Unstake `amount` staking tokens from `vault`, claim rewards, and transfer both staking tokens and rewards to the caller's address",
        "@gparam1": "vault The address of the vault to unstake from",
        "@gparam2": "amount The number of staking tokens to unstake",
        "@gparam3": "permission The permission needed to unstake from the vault",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 1
    },
    {
        "func": "function transferKnightOwnership(address newKnight) external \n    validAddress(newKnight) {\n        require(knightAddress == msg.sender,\"Not right role\");\n        _moveBalance(newKnight);\n        knightAddress = newKnight;\n    }",
        "@notice": "",
        "@dev": "Transfers knight ownership to a new address",
        "@param1": "newKnight the new address",
        "@gnotice": "Transfer ownership of the knight to `newKnight`",
        "@gparam1": "newKnight The address of the new knight owner. Must be a valid address.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function _supportMarket(CToken cToken) external returns (uint) {\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n        }\n\n        if (markets[address(cToken)].isListed) {\n            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n        }\n\n        cToken.isCToken(); // Sanity check to make sure its really a CToken\n\n        // Note that isComped is not in active use anymore\n        markets[address(cToken)] = Market({isListed: true, isComped: false, collateralFactorMantissa: 0});\n\n        _addMarketInternal(address(cToken));\n\n        emit MarketListed(cToken);\n\n        return uint(Error.NO_ERROR);\n    }",
        "@notice": "Add the market to the markets mapping and set it as listed",
        "@dev": "Admin function to set isListed and add support for the market",
        "@param1": "cToken The address of the market (token) to list",
        "@return1": "uint 0=success, otherwise a failure. (See enum Error for details)",
        "@gnotice": "Adds a new market corresponding to `cToken`",
        "@gparam1": "cToken The address of the cToken contract to list",
        "@greturn1": "An error code indicating success or failure",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function setMultisigVault(address _multisigVault) public onlyOwner {\n    if (_multisigVault != address(0)) {\n      multisigVault = _multisigVault;\n    }\n  }",
        "@notice": "",
        "@dev": "set the multisig contract.",
        "@param1": "_multisigVault the multisig contract address",
        "@gnotice": "Set the address of the multisig vault for the owner",
        "@gparam1": "_multisigVault The address of the multisig vault to set as the owner's vault",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function setDelegateWhitelist(address whitelistAddress, bool status) external onlyOwner {\n        delegateWhitelist[whitelistAddress] = status;\n        emit DelegateWhitelistChange(whitelistAddress, status);\n    }",
        "@notice": "",
        "@dev": "EIP-712 Function to change the delegate status of account. * Allowed only for owner * * Emits a { DelegateWhitelistChange } event",
        "@param1": "whitelistAddress The address for which to change the delegate status",
        "@param2": "status The new delegate status",
        "@gnotice": "Sets `status` for the `whitelistAddress` in the delegate whitelist",
        "@gparam1": "whitelistAddress The address of the delegate to set the `status` for",
        "@gparam2": "status The boolean `status` to set for the `whitelistAddress`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function refund(bytes32 _contractId)\n        external\n        contractExists(_contractId)\n        refundable(_contractId)\n        returns (bool)\n    {\n        LockContract storage c = contracts[_contractId];\n        c.refunded = true;\n        c.sender.transfer(c.amount);\n        emit LogHTLCRefund(_contractId);\n        return true;\n    }",
        "@notice": "",
        "@dev": "Called by the sender if there was no withdraw AND the time lock has * expired. This will refund the contract amount.",
        "@param1": "_contractId Id of HTLC to refund from.",
        "@return1": "bool true on success",
        "@gnotice": "Refunds the amount deposited in the LockContract with `_contractId` back to the sender's account",
        "@gparam1": "_contractId The identifier for the LockContract",
        "@greturn1": "Whether or not the refund was successful",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function deploy(\n        bytes memory bytecode,\n        bytes32 salt,\n        address anticipatedAddress\n    ) public payable returns (address deployedAddress) {\n\n        // Revert if a contract exists at the address.\n        if (anticipatedAddress.code.length > 0) revert CONTRACT_EXISTS_AT_THIS_ADDRESS(anticipatedAddress);\n\n        // Ensure the anticipated address matches the calculated address.\n        address calculatedAddress = calculateAddress(bytecode, salt);\n        if (anticipatedAddress != calculatedAddress) revert CALCULATED_ADDRESS_DOES_NOT_MATCH(anticipatedAddress, calculatedAddress);\n\n        // Deploy contract using CREATE2.\n        assembly {\n            deployedAddress := create2(\n                callvalue(),                    // forward ETH (constructor must be payable if >0)\n                add(bytecode, 0x20),            // bytecode\n                mload(bytecode),                // bytecode length\n                salt                            // salt\n            )\n        }\n\n        // Ensure the anticipated address matches the deployed address.\n        if (anticipatedAddress != deployedAddress) revert DEPLOYED_ADDRESS_DOES_NOT_MATCH(anticipatedAddress, deployedAddress);\n\n        return deployedAddress;\n    }",
        "@notice": "Deploy a contract using CREATE2",
        "@dev": "Cannot deploy a contract at an address where one already exists unless it has been deleted.",
        "@param1": "bytecode The contract bytecode",
        "@param2": "salt The salt to use",
        "@param3": "anticipatedAddress The address you are expecting the contract to be.",
        "@return1": "deployedAddress The address of the deployed contract.",
        "@gnotice": "Deploys a new contract with specified bytecode and salt, and verifies the expected deployed address matches the actual one.",
        "@gparam1": "bytecode The bytecode of the contract to be deployed",
        "@gparam2": "salt A unique identifier used to calculate the deployed address",
        "@gparam3": "anticipatedAddress The expected address for the deployed contract",
        "@greturn1": "The address of the deployed contract",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@treturn1": 0
    },
    {
        "func": "function updateRate(string _symbol, uint _rate) public onlyOwner {\n    rates[sha3(_symbol)] = _rate;\n    RateUpdated(now, sha3(_symbol), _rate);\n  }",
        "@notice": "",
        "@dev": "update a single rate.",
        "@param1": "_symbol The symbol to be updated.",
        "@param2": "_rate the rate for the symbol.",
        "@gnotice": "Update the exchange rate for a given symbol",
        "@gparam1": "_symbol The symbol whose exchange rate is being updated",
        "@gparam2": "_rate The new exchange rate for the given symbol",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function setRenamingCosts(uint256 newRenamingCost) external \n    onlyOwner()  {\n        renamingCostsPerChar = newRenamingCost;\n    }",
        "@notice": "",
        "@dev": "Sets a new renaming per character cost in wei Any CLevel can call this function",
        "@param1": "newRenamingCost The cost to charge for each character of the name",
        "@gnotice": "Sets the new cost for renaming a token",
        "@gparam1": "newRenamingCost The new cost for renaming a token",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override returns (bool) {\n        return\n            // ERC165 Interface ID for ERC721TokenReceiver.\n            interfaceId == this.onERC721Received.selector ||\n            // ERC165 Interface ID for ERC1155TokenReceiver.\n            interfaceId == type(ERC1155TokenReceiver).interfaceId ||\n            // ERC165 interface ID for ERC1155MetadataURI.\n            interfaceId == this.uri.selector ||\n            // ERC165 Interface IDs for ERC1155.\n            super.supportsInterface(interfaceId);\n    }",
        "@notice": "If an interface ID is supported",
        "@dev": "ERC165 interface detection.",
        "@param1": "interfaceId ID to check.",
        "@return1": "Fetch detection success.",
        "@gnotice": "Check if the contract implements the specified interface ID `interfaceId`",
        "@gparam1": "interfaceId The interface ID to check for support",
        "@greturn1": "Whether or not the contract implements the specified interface ID. True if the contract implements the interface ID, false otherwise.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 1
    },
    {
        "func": "function removeAdmin(address account) public virtual onlyOwner {\n        renounceRole(ADMIN_ROLE, account);\n    }",
        "@notice": "",
        "@dev": "remove admin",
        "@param1": "account address to remove",
        "@gnotice": "Removes the `ADMIN_ROLE` from the specified account",
        "@gparam1": "account The address from which to remove the `ADMIN_ROLE`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function validateStrictLogic(\n        OrderParameters memory orderParameters,\n        address primaryFeeRecipient,\n        uint256 primaryFeeBips,\n        bool checkCreatorFee\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        // Check that order matches the required format (listing or offer)\n        {\n            bool canCheckFee = true;\n            // Single offer item and at least one consideration\n            if (\n                orderParameters.offer.length != 1 ||\n                orderParameters.consideration.length == 0\n            ) {\n                // Not listing or offer, can't check fees\n                canCheckFee = false;\n            } else if (\n                // Can't have both items be fungible\n                isPaymentToken(orderParameters.offer[0].itemType) &&\n                isPaymentToken(orderParameters.consideration[0].itemType)\n            ) {\n                // Not listing or offer, can't check fees\n                canCheckFee = false;\n            } else if (\n                // Can't have both items be non-fungible\n                !isPaymentToken(orderParameters.offer[0].itemType) &&\n                !isPaymentToken(orderParameters.consideration[0].itemType)\n            ) {\n                // Not listing or offer, can't check fees\n                canCheckFee = false;\n            }\n            if (!canCheckFee) {\n                // Does not match required format\n                errorsAndWarnings.addError(\n                    GenericIssue.InvalidOrderFormat.parseInt()\n                );\n                return errorsAndWarnings;\n            }\n        }\n\n        // Validate secondary consideration items (fees)\n        (\n            uint256 tertiaryConsiderationIndex,\n            ErrorsAndWarnings memory errorsAndWarningsLocal\n        ) = _validateSecondaryConsiderationItems(\n                orderParameters,\n                primaryFeeRecipient,\n                primaryFeeBips,\n                checkCreatorFee\n            );\n\n        errorsAndWarnings.concat(errorsAndWarningsLocal);\n\n        // Validate tertiary consideration items if not 0 (0 indicates error).\n        // Only if no prior errors\n        if (tertiaryConsiderationIndex != 0) {\n            errorsAndWarnings.concat(\n                _validateTertiaryConsiderationItems(\n                    orderParameters,\n                    tertiaryConsiderationIndex\n                )\n            );\n        }\n    }",
        "@notice": "Strict validation operates under tight assumptions.",
        "@dev": "Only checks first fee recipient provided by CreatorFeeEngine. * Order of consideration items must be as follows: * 1. Primary consideration * 2. Primary fee * 3. Creator fee * 4. Private sale consideration",
        "@param1": "orderParameters The parameters for the order to validate.",
        "@param2": "primaryFeeRecipient The primary fee recipient. Set to null address for no primary fee.",
        "@param3": "primaryFeeBips The primary fee in BIPs.",
        "@param4": "checkCreatorFee Should check for creator fee.",
        "@return1": "errorsAndWarnings The errors and warnings.",
        "@gnotice": "Validate order parameters based on strict logic and check fees",
        "@gparam1": "orderParameters Struct containing the order parameters",
        "@gparam2": "primaryFeeRecipient Address of the primary fee recipient",
        "@gparam3": "primaryFeeBips Basis points of the primary fee",
        "@gparam4": "checkCreatorFee Whether or not to check creator fee",
        "@greturn1": "Struct containing any errors and warnings encountered",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 1,
        "@treturn1": 0
    },
    {
        "func": "function farm(bytes[] calldata data)\n        external\n        payable\n        returns (bytes[] memory results)\n    {\n        return _farm(data);\n    }",
        "@notice": "Execute multiple function calls in Depot",
        "@param1": "data list of encoded function calls to be executed",
        "@return1": "results list of return data from each function call",
        "@dev": "Implementation from https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/Multicall.sol.",
        "@gnotice": "Allows users to farm by calling multiple functions in a single transaction",
        "@gparam1": "data An array of function call data in the form of bytes",
        "@greturn1": "An array of return values for each function called in the same order as `data`",
        "@tnotice": 0,
        "@tparam1": 0,
        "@treturn1": 0,
        "@tdev": 0
    },
    {
        "func": "function ownerOf(\n    uint256 _tokenId\n  )\n    external\n    override\n    view\n    returns (address _owner)\n  {\n    _owner = idToOwner[_tokenId];\n    require(_owner != address(0), NOT_VALID_NFT);\n  }",
        "@notice": "Returns the address of the owner of the NFT.",
        "@dev": "NFTs assigned to the zero address are * considered invalid, and queries about them do throw.",
        "@param1": "_tokenId The identifier for an NFT.",
        "@return1": "_owner Address of _tokenId owner.",
        "@gnotice": "Get the owner of a specific NFT",
        "@gparam1": "_tokenId The identifier of the NFT",
        "@greturn1": "The address of the owner of the NFT",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function buyForErc20(uint256 roundId, uint256 amount)\n        external\n        isEnded(roundId)\n    {\n        TokenSaleRound storage tokenSaleRound = rounds[roundId];\n\n        if (!tokenSaleRound.isPublic) {\n            if (!whitelist[msg.sender]) {\n                revert NotInTheWhitelist(\"TokenSale: Not in the whitelist\");\n            }\n        }\n\n        if (!isRoundStared(roundId)) {\n            revert RoundNotStarted(\"TokenSale: Round is not started\");\n        }\n\n        if (amount < tokenSaleRound.minAmount) {\n            revert MinMaxPurchase(\"TokenSale: Amount not allowed\");\n        }\n\n        uint256 tokenAmount = _calcPurchaseAmount(\n            amount,\n            tokenSaleRound.purchasePrice\n        );\n\n        if (\n            tokenSaleRound.tokensSold + tokenAmount >\n            tokenSaleRound.totalPurchaseAmount\n        ) {\n            revert TokensNotEnough(\"TokenSale: Tokens not enough\");\n        }\n\n        tokenSaleRound.tokensSold += tokenAmount;\n        userSpentFunds[msg.sender][roundId] += amount;\n\n        IERC20(usdtToken).safeTransferFrom(msg.sender, treasury, amount);\n\n        userBalance[msg.sender][roundId] += tokenAmount;\n\n        _endSoldOutRound(roundId);\n        emit PurchasePlanetexToken(msg.sender, amount, tokenAmount);\n    }",
        "@notice": "",
        "@dev": "buy tokens for usdt or busd tokens",
        "@param1": "roundId tokeSale round id.",
        "@param2": "amount usdt or busd amount.",
        "@gnotice": "Buy Planetex token with ERC20 tokens for the specified round",
        "@gparam1": "roundId The ID of the token sale round",
        "@gparam2": "amount The amount of ERC20 tokens to be used for the purchase",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function buyForErc20(uint256 roundId, uint256 amount)\n        external\n        isEnded(roundId)\n    {\n        TokenSaleRound storage tokenSaleRound = rounds[roundId];\n\n        if (!tokenSaleRound.isPublic) {\n            if (!whitelist[msg.sender]) {\n                revert NotInTheWhitelist(\"TokenSale: Not in the whitelist\");\n            }\n        }\n\n        if (!isRoundStared(roundId)) {\n            revert RoundNotStarted(\"TokenSale: Round is not started\");\n        }\n\n        if (amount < tokenSaleRound.minAmount) {\n            revert MinMaxPurchase(\"TokenSale: Amount not allowed\");\n        }\n\n        uint256 tokenAmount = _calcPurchaseAmount(\n            amount,\n            tokenSaleRound.purchasePrice\n        );\n\n        if (\n            tokenSaleRound.tokensSold + tokenAmount >\n            tokenSaleRound.totalPurchaseAmount\n        ) {\n            revert TokensNotEnough(\"TokenSale: Tokens not enough\");\n        }\n\n        tokenSaleRound.tokensSold += tokenAmount;\n        userSpentFunds[msg.sender][roundId] += amount;\n\n        IERC20(usdtToken).safeTransferFrom(msg.sender, treasury, amount);\n\n        userBalance[msg.sender][roundId] += tokenAmount;\n\n        _endSoldOutRound(roundId);\n        emit PurchasePlanetexToken(msg.sender, amount, tokenAmount);\n    }",
        "@notice": "",
        "@dev": "buy tokens for usdt or busd tokens",
        "@param1": "roundId tokeSale round id.",
        "@param2": "amount usdt or busd amount.",
        "@gnotice": "Buy Planetex token with ERC20 tokens for the specified round",
        "@gparam1": "roundId The ID of the token sale round",
        "@gparam2": "amount The amount of ERC20 tokens to be used for the purchase",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function iWantXKeys(uint256 _keys)\n        public\n        view\n        returns(uint256)\n    {\n        // setup local rID\n        uint256 _rID = rID_;\n\n        // grab time\n        uint256 _now = now;\n\n        // are we in a round?\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );\n        else // rounds over.  need price for new round\n            return ( (_keys).eth() );\n    }",
        "@notice": "returns current eth price for X keys. ",
        "@dev": "* -functionhash- 0xcf808000",
        "@param1": "_keys number of keys desired (in 18 decimal format)",
        "@return1": "amount of eth needed to send",
        "@gnotice": "Calculates the amount of Ether required to buy `_keys` number of keys based on the current game round's price",
        "@gparam1": "_keys Number of keys to buy",
        "@greturn1": "The amount of Ether required to buy `_keys` number of keys in the current game round. If the current round is not active, returns the Ether required for the next round's price.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function stakeFor(\n        address user,\n        uint256 amount\n    ) external override onlyOwner {\n        _stakeFor(msg.sender, user, amount);\n    }",
        "@notice": "",
        "@dev": "Transfers amount of deposit tokens from the caller on behalf of user.",
        "@param1": "user address of who gains credit for this stake operation.",
        "@param2": "amount Number of deposit tokens to stake.",
        "@gnotice": "Stake `amount` tokens on behalf of `user`",
        "@gparam1": "user The address of the user to stake tokens on behalf of",
        "@gparam2": "amount The number of tokens to stake",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function withdraw(bytes32 _contractId, bytes32 _preimage)\n        external\n        contractExists(_contractId)\n        hashlockMatches(_contractId, _preimage)\n        withdrawable(_contractId)\n        returns (bool)\n    {\n        LockContract storage c = contracts[_contractId];\n        c.preimage = _preimage;\n        c.withdrawn = true;\n        c.receiver.transfer(c.amount);\n        emit LogHTLCWithdraw(_contractId);\n        return true;\n    }",
        "@notice": "",
        "@dev": "Called by the receiver once they know the preimage of the hashlock. * This will transfer the locked funds to their address.",
        "@param1": "_contractId Id of the HTLC.",
        "@param2": "_preimage sha256(_preimage) should equal the contract hashlock.",
        "@return1": "bool true on success",
        "@gnotice": "Withdraws the locked funds of an Hash Time Locked Contract with `_contractId`",
        "@gparam1": "_contractId The identifier of the HTLC",
        "@gparam2": "_preimage The preimage for unlocking the HTLC",
        "@greturn1": "Whether or not the withdrawal succeeded",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 1,
        "@treturn1": 0
    },
    {
        "func": "function setDelegateMode(bool _delegateMode) external onlyOwner {\n        delegateMode = _delegateMode;\n\n        emit DelegateModeChange(_delegateMode);\n    }",
        "@notice": "",
        "@dev": "EIP-712 Function to change the contract delegate mode. Allowed * only for owner * * Emits a { DelegateModeChange } event",
        "@param1": "_delegateMode The new delegate mode for the contract",
        "@gnotice": "Sets the delegate mode to `_delegateMode`",
        "@gparam1": "_delegateMode Whether or not to enable delegate mode",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function authorizedCreateTokens(address recipient, uint tokens) public onlyAuthorized {\n    token.mint(recipient, tokens);\n    AuthorizedCreate(recipient, tokens);\n  }",
        "@notice": "Allows authorized acces to create tokens.",
        "@dev": "This is used for Bitcoin and ERC20 deposits",
        "@param1": "recipient the recipient to receive tokens.",
        "@param2": "tokens number of tokens to be created.",
        "@gnotice": "Creates `tokens` and assigns them to `recipient` if `msg.sender` is an authorized account",
        "@gparam1": "recipient The address of the recipient for the new tokens",
        "@gparam2": "tokens The amount of tokens to create",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function approve(address spender, uint256 rawAmount)\n        external\n        returns (bool)\n    {\n        uint96 amount;\n        if (rawAmount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(rawAmount, \"Comp::approve: amount exceeds 96 bits\");\n        }\n\n        allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }",
        "@notice": "Approve `spender` to transfer up to `amount` from `src`",
        "@dev": "This will overwrite the approval amount for `spender` * and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)",
        "@param1": "spender The address of the account which may transfer tokens",
        "@param2": "rawAmount The number of tokens that are approved (2^256-1 means infinite)",
        "@return1": "Whether or not the approval succeeded",
        "@gnotice": "Approve the `spender` to transfer up to `rawAmount` tokens from the `msg.sender` account",
        "@gparam1": "spender The address authorized to spend the tokens",
        "@gparam2": "rawAmount The maximum number of tokens that can be spent (or uint256(-1) to allow unlimited spending)",
        "@greturn1": "Whether or not the approval succeeded",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function ttl(bytes32 node) public virtual override view returns (uint64) {\n        return records[node].ttl;\n    }",
        "@notice": "",
        "@dev": "Returns the TTL of a node",
        "@param1": "node The specified node.",
        "@return1": "ttl of the node.",
        "@gnotice": "Returns the time-to-live (TTL) of the specified DNS `node`",
        "@gparam1": "node The DNS `node` whose TTL we want to retrieve",
        "@greturn1": "The time-to-live (TTL) of the specified DNS `node`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1,
        "@treturn1": 0
    },
    {
        "func": "function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)\n        isActivated()\n        isHuman()\n        isWithinLimits(_eth)\n        public\n    {\n        // set up our tx event data\n        Star3Ddatasets.EventReturns memory _eventData_;\n\n        // fetch player ID\n        uint256 _pID = pIDxAddr_[msg.sender];\n\n        // manage affiliate residuals\n        // if no affiliate code was given or player tried to use their own, lolz\n        if (_affCode == 0 || _affCode == _pID)\n        {\n            // use last stored affiliate code\n            _affCode = plyr_[_pID].laff;\n\n        // if affiliate code was given & its not the same as previously stored\n        } else if (_affCode != plyr_[_pID].laff) {\n            // update last affiliate\n            plyr_[_pID].laff = _affCode;\n        }\n\n        // verify a valid team was selected\n        _team = verifyTeam(_team);\n\n        // reload core\n        reLoadCore(_pID, _affCode, _team, _eth, _eventData_);\n    }",
        "@notice": "essentially the same as buy, but instead of you sending ether from your wallet, it uses your unwithdrawn earnings.",
        "@dev": "* -functionhash- 0x349cdcac (using ID for affiliate) * -functionhash- 0x82bfc739 (using address for affiliate) * -functionhash- 0x079ce327 (using name for affiliate)",
        "@param1": "_affCode the ID/address/name of the player who gets the affiliate fee",
        "@param2": "_team what team is the player playing for?",
        "@param3": "_eth amount of earnings to use (remainder returned to gen vault)",
        "@gnotice": "Reload the current player's XID balance with ` _eth` Ethereum",
        "@gparam1": "_affCode The affiliate's ID used for referral bonuses (optional)",
        "@gparam2": "_team The ID of the team for which the XID is being reloaded",
        "@gparam3": "_eth The amount of Ethereum being used to reload the XID",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 1,
        "@tparam3": 0
    },
    {
        "func": "function sacrifice(\n        uint256 tokenIdUpgrading,\n        uint256[] memory tokenIdsSacrificing\n    ) public {\n        unchecked {\n\n            // Check if sacrificing is paused.\n            if (_sacrificingPaused) revert SACRIFICING_IS_CURRENTLY_DISABLED();\n\n            // Check if upgrading ID exists.\n            _revertIfTokenIsInvalid(tokenIdUpgrading);\n\n            uint16 totalSouls;\n            uint256 amount = tokenIdsSacrificing.length;\n            uint32 safeBlockTimestamp = _safeBlockTimestamp();\n\n            for (uint256 i; i < amount; i++) {\n\n                // Get sacrificing ID.\n                uint256 tokenIdSacrificing = tokenIdsSacrificing[i];\n\n                // Revert if sacrificing ID matches upgrading.\n                if (tokenIdSacrificing == tokenIdUpgrading) revert INVALID_CRYPTOBLOB_ID();\n\n                // Revert if the caller does not have access and get the owner.\n                address owner = _revertIfNoAccess(msg.sender, tokenIdSacrificing);\n\n                // Update owner's stats. Cannot underflow because ownership is checked.\n                _account[owner].tokensOwned--;\n                _account[owner].tokensBurned++;\n\n                // Implicitly clear approvals.\n                delete _token[tokenIdSacrificing].approval;\n\n                // ERC721 standards says to not emit an Approval event when transferring. https://eips.ethereum.org/EIPS/eip-721\n                // \"When a Transfer event emits, this also indicates that the approved address for that NFT (if any) is reset to none.\"\n\n                // Save the token ID burned to.\n                _token[tokenIdSacrificing].burnTo = uint16(tokenIdUpgrading);\n\n                // Update souls to now say how many were transferred. +1 for own soul.\n                _token[tokenIdSacrificing].souls++;\n\n                // Add to total.\n                totalSouls += _token[tokenIdSacrificing].souls; \n\n                // '_token[].account' now stores the address of the last owner.\n                if (_token[tokenIdSacrificing].account != owner) _token[tokenIdSacrificing].account = owner;\n\n                // Save the timestamp when it was burned.\n                _token[tokenIdSacrificing].burnTimestamp = safeBlockTimestamp;\n\n                // Burn event.\n                emit Transfer(              // 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n                    owner,                  // address indexed from\n                    address(0),             // address indexed to\n                    tokenIdSacrificing      // uint256 indexed tokenId\n                );\n\n            }\n            _token[tokenIdUpgrading].souls += totalSouls; // Transfer souls.\n            _tokensBurned += uint32(amount); // Update total burned.\n\n            // A 'Sacrifice' event is not emitted. Refer to 'Transfer' logs instead or data saved to the contract.\n        }\n    }",
        "@notice": "Sacrifice and upgrade CryptoBlobs",
        "@dev": "Sacrificing permanently removes CryptoBlobs from the circulating supply and * rewards a meta-collectible called souls via a soul transferring system. * The more souls a CryptoBlob possess, the higher its rarity, rank, and value. * The earlier your CryptoBlobs harnesses souls, the easier it will be to collect them. * Only 25,000 souls exist, one for each CryptoBlob. Souls cannot be created or destroyed. * You also earn 1 free CryptoBlob for every 10 sacrificed during the limited-time promotion. * You must have access to a CryptoBlob to sacrifice it but not upgrade it.",
        "@param1": "tokenIdUpgrading The CryptoBlob ID that will harness the souls of `tokenIdsSacrificing`.",
        "@param2": "tokenIdsSacrificing The CryptoBlob IDs being sacrificed.",
        "@gnotice": "Allows the caller to burn a list of token IDs as a sacrifice to upgrade another token ID.",
        "@gparam1": "tokenIdUpgrading The ID of the token to be upgraded by burning other tokens",
        "@gparam2": "tokenIdsSacrificing The list of token IDs to be burnt as a sacrifice",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 1,
        "@tparam2": 0
    },
    {
        "func": "function addAddressToWhitelist(address addr)\n        public\n        onlyOwner\n        returns (bool success)\n    {\n        if (!whitelist[addr]) {\n            whitelist[addr] = true;\n            emit WhitelistedAddressAdded(addr);\n            success = true;\n        }\n    }",
        "@notice": "",
        "@dev": "add an address to the whitelist",
        "@param1": "addr address",
        "@return1": "success if the address was added to the whitelist, false if the address was already in the whitelist",
        "@gnotice": "Adds `addr` to the whitelist",
        "@gparam1": "addr The address to be added to the whitelist",
        "@greturn1": "`success` Whether or not the address was successfully added to the whitelist",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function batch(\n        bytes[] memory batchDataEncoded\n    ) external {\n        unchecked {\n            for (uint256 i; i < batchDataEncoded.length; i++) {\n\n                // Decode this transaction.\n                BatchData memory batchData = abi.decode(batchDataEncoded[i], (BatchData));\n\n                // Determine function and transact.\n                if (batchData.category == 0) {\n                    // Transfer the CryptoBlob if the sender has access to it.\n                    transferFrom(batchData.account1, batchData.account2, batchData.tokenId);\n                } else if (batchData.category == 1) {\n                    // Approve or revoke an account operator.\n                    setApprovalForAll(batchData.account1, batchData.approved);\n                } else if (batchData.category == 2) {\n                    // Approve or revoke a token operator.\n                    approve(batchData.account1, batchData.tokenId);\n                } else if (batchData.category == 3) {\n                    // Cancel a trade or lock/unlock trades for an account you have access to.\n                    manageTrades(batchData.account1, batchData.hash);\n                } else if (batchData.category == 4) {\n                    // Optimize CryptoBlobs.\n                    optimize(batchData.tokenIds);\n                } else if (batchData.category == 5) {\n                    // Sacrifice CryptoBlobs.\n                    sacrifice(batchData.tokenId, batchData.tokenIds);\n                }\n            }\n        }\n    }",
        "@notice": "make multiple transactions in a single transaction",
        "@dev": "Categories: 0 {transferFrom}, 1 {setApprovalForAll}, 2 {approve}, 3 {manageTrades}, 4 {optimize}, 5 {sacrifice}. * Each transaction is separately encoded and processed in the order of the array.",
        "@param1": "batchDataEncoded The encoded batch data.",
        "@gnotice": "Executes a batch of transactions encoded in `batchDataEncoded`",
        "@gparam1": "batchDataEncoded An array of encoded transactions",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function setTTL(bytes32 node, uint64 ttl) public virtual override authorised(node) {\n        emit NewTTL(node, ttl);\n        records[node].ttl = ttl;\n    }",
        "@notice": "",
        "@dev": "Sets the TTL for the specified node.",
        "@param1": "node The node to update.",
        "@param2": "ttl The TTL in seconds.",
        "@gnotice": "Set the time-to-live (TTL) value for a domain name `node`.",
        "@gparam1": "node The domain name node for which to set the TTL",
        "@gparam2": "ttl The new TTL value for the domain name",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1,
        "@tparam2": 1
    },
    {
        "func": "function rescue(address token, address target) external virtual {\n        // make sure we're not stealing funds or something\n        _authorizeRescue(token, target);\n\n        // transfer token to target\n        IERC20 tokenContract = IERC20(token);\n        tokenContract.safeTransfer(\n            target,\n            tokenContract.balanceOf(address(this))\n        );\n    }",
        "@notice": "Rescues ERC20 tokens sent to the contract in error",
        "@dev": "Need to implement {_authorizeRescue} to do access-control for this function.",
        "@param1": "token The ERC20 token to rescue",
        "@param2": "target The address to send the tokens to",
        "@gnotice": "This function rescues tokens from the contract and transfers them to the specified `target` address",
        "@gparam1": "token The address of the token to be rescued",
        "@gparam2": "target The address of the recipient account",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function iWantXKeys(uint256 _keys)\n        public\n        view\n        returns(uint256)\n    {\n        // setup local rID\n        uint256 _rID = rID_;\n\n        // grab time\n        uint256 _now = now;\n\n        // are we in a round?\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );\n        else // rounds over.  need price for new round\n            return ( (_keys).eth() );\n    }",
        "@notice": "returns current eth price for X keys.",
        "@dev": " * -functionhash- 0xcf808000",
        "@param1": "_keys number of keys desired (in 18 decimal format)",
        "@return1": "amount of eth needed to send",
        "@gnotice": "calculates the amount of Ether required to purchase `_keys` number of keys for the current round",
        "@gparam1": "_keys The number of keys to be purchased",
        "@greturn1": "The amount of Ether required for the specified number of keys",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function setResolver(bytes32 node, address resolver) public virtual override authorised(node) {\n        emit NewResolver(node, resolver);\n        records[node].resolver = resolver;\n    }",
        "@notice": "",
        "@dev": "Sets the resolver address for the specified node.",
        "@param1": "node The node to update.",
        "@param2": "resolver The address of the resolver.",
        "@gnotice": "Set the resolver address for a specific ENS `node`",
        "@gparam1": "node The ENS node to set the resolver for",
        "@gparam2": "resolver The new resolver address to set",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1,
        "@tparam2": 0
    },
    {
        "func": "function isValidZone(\n        OrderParameters memory orderParameters\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        // If not restricted, zone isn't checked\n        if (\n            uint8(orderParameters.orderType) < 2 ||\n            uint8(orderParameters.orderType) == 4\n        ) {\n            return errorsAndWarnings;\n        }\n\n        if (orderParameters.zone == address(0)) {\n            // Zone is not set\n            errorsAndWarnings.addError(ZoneIssue.NotSet.parseInt());\n            return errorsAndWarnings;\n        }\n\n        // EOA zone is always valid\n        if (address(orderParameters.zone).code.length == 0) {\n            // Address is EOA. Valid order\n            return errorsAndWarnings;\n        }\n\n        // Check the EIP165 zone interface\n        if (!checkInterface(orderParameters.zone, ZONE_INTERFACE_ID)) {\n            errorsAndWarnings.addError(ZoneIssue.InvalidZone.parseInt());\n            return errorsAndWarnings;\n        }\n\n        // Check if the contract offerer implements SIP-5\n        try ZoneInterface(orderParameters.zone).getSeaportMetadata() {} catch {\n            errorsAndWarnings.addError(ZoneIssue.InvalidZone.parseInt());\n        }\n    }",
        "@notice": "validate the zone call for an order",
        "@dev": "see validateOrderWithZone",
        "@param1": "orderParameters The order parameters to check.",
        "@return1": "errorsAndWarnings The errors and warnings",
        "@gnotice": "Check whether the specified `OrderParameters` object is valid or not, based on the specified rules",
        "@gparam1": "orderParameters The `OrderParameters` object to be validated",
        "@greturn1": "An `ErrorsAndWarnings` object containing any errors or warnings encountered during the validation process",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function startVault(uint256 _initialExternalAsset, uint256 _aumCap) external onlyEpochZero requiresAuth {\n        if (_aumCap < _initialExternalAsset) {\n            revert AumCapInvalid();\n        }\n        if (_initialExternalAsset != 0) {\n            uint256 initialShare = _selfDeposit(_initialExternalAsset);\n            vaultUsers[msg.sender].vaultShares = initialShare;\n        }\n        aumCap = _aumCap;\n        epoch = 1;\n        vaultStates[epoch].assetsExternalStart = aum;\n        vaultStates[epoch].totalSupply = totalSupply;\n        vaultStates[epoch].lastManagementBlock = block.number;\n        emit EpochEnd(0, aum);\n    }",
        "@notice": "starts the vault with a custom initial aum",
        "@dev": "in most cases, initial aum = 0",
        "@param1": "_initialExternalAsset initial aum",
        "@param2": "_aumCap maximum asset that can be stored",
        "@gnotice": "Starts the vault with an initial external asset `_initialExternalAsset` and an AUM cap `_aumCap`",
        "@gparam1": "_initialExternalAsset The amount of external asset the vault will start with",
        "@gparam2": "_aumCap The maximum amount of AUM the vault can reach",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function addAddressesToWhitelist(address[] memory addrs)\n        public\n        onlyOwner\n        returns (bool success)\n    {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (addAddressToWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }",
        "@notice": "",
        "@dev": "add addresses to the whitelist",
        "@param1": "addrs addresses",
        "@return1": "success if at least one address was added to the whitelist",
        "@gnotice": "Add multiple addresses to the whitelist",
        "@gparam1": "addrs Array of addresses to add to the whitelist",
        "@greturn1": "Whether or not the additions were successful",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function setApprovalForAll(address operator, bool approved)\n        public\n        virtual\n        override\n    {\n        unchecked {\n            if (msg.sender == operator) revert CANNOT_APPROVE_THIS_ADDRESS();\n\n            // Numbers are used to enable the preapproved services feature. Works similarly to an enum.\n            // Values:\n            // 0 = default\n            // 1 = revoked\n            // 2 = approved\n\n            if (approved) {\n                _account[msg.sender].approvals[operator] = 2; // Approve.\n            } else {\n                _account[msg.sender].approvals[operator] = 1; // Revoked.\n            }\n\n            emit ApprovalForAll(    // 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31\n                msg.sender,         // address indexed owner\n                operator,           // address indexed operator\n                approved            // bool approved\n            );\n        }\n    }",
        "@notice": "Approves `to` to be an account operator of your account",
        "@dev": "Account operators can do everything the owner can do expect sign messages and manage their account operators. * Preapproved services: OpenSea, X2Y2, LooksRare, Rarible, 0x Protocol v4, Element, SudoSwap, NFTX, and NFTTrader. * You can revoke these services using {setApprovalForAll} or visit CryptoBlobs.com for a batch tx to revoke all at once. * SuperCollectiv will permanently disable preapproved services if any issues are discovered with these contracts. * Services that list your account operators will not detect that these addresses have * been approved unless you reapprove each service with {setApprovalForAll} or {batch}.",
        "@param1": "operator The address of the account to update the operator status of.",
        "@param2": "approved The approval status to set `operator` to.",
        "@gnotice": "Approves `operator` to operate on behalf of the `msg.sender`",
        "@gparam1": "operator The address which will act on behalf of `msg.sender`",
        "@gparam2": "approved Whether or not the `operator` is approved",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function tokenURI(\n    uint256 _tokenId\n  )\n    external\n    override\n    view\n    validNFToken(_tokenId)\n    returns (string memory)\n  {\n    return _tokenURI(_tokenId);\n  }",
        "@notice": "",
        "@dev": "A distinct URI (RFC 3986) for a given NFT.",
        "@param1": "_tokenId Id for which we want uri.",
        "@return1": "URI of _tokenId.",
        "@gnotice": "Returns the Uniform Resource Identifier (URI) for the given token",
        "@gparam1": "_tokenId The ID of the token to retrieve the URI for",
        "@greturn1": "The URI of the given token",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function optimize(\n        uint256[] memory tokenIds\n    ) public {\n        unchecked {\n            uint256 amount = tokenIds.length;\n            for (uint256 i; i < amount; i++) {\n                if (_token[tokenIds[i]].account != address(0)) revert CRYPTOBLOB_DOES_NOT_REQUIRE_OPTIMIZATION();\n                _token[tokenIds[i]].account = ownerOf(tokenIds[i]);\n            }\n            _account[msg.sender].tokensOptimized += uint16(amount);\n\n            emit Optimize(              // 0xff06b6e7e3b7963958aa44cc1dff152337abfc3ef2d0ecd54bdcd8fb9694e0eb\n                msg.sender,             // address indexed account\n                tokenIds,               // uint256[] tokenIds\n                block.timestamp         // uint256 timestamp\n            );\n        }\n    }",
        "@notice": "Optimize CryptoBlobs to lower future transaction fees with it",
        "@dev": "You can optimize any CryptoBlob, even if you do not own it. * You earn one account level per CryptoBlob you optimize.",
        "@param1": "tokenIds The token IDs of the CryptoBlobs.",
        "@gnotice": "Optimize the storage of tokens with the given token IDs",
        "@gparam1": "tokenIds Array of token IDs to optimize storage for",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function resolver(bytes32 node) public virtual override view returns (address) {\n        return records[node].resolver;\n    }",
        "@notice": "",
        "@dev": "Returns the address of the resolver for the specified node.",
        "@param1": "node The specified node.",
        "@return1": "address of the resolver.",
        "@gnotice": "Get the resolver address for a given ENS node",
        "@gparam1": "node The ENS node hash to query",
        "@greturn1": "The address of the resolver contract that manages the given node",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function registerNameXID(string _nameString, uint256 _affCode)\n        isHuman()\n        isRegisteredName()\n        public\n        payable\n    {\n        bytes32 _name = _nameString.nameFilter();\n        address _addr = msg.sender;\n        uint256 _paid = msg.value;\n\n        bool _isNewPlayer = isNewPlayer(_addr);\n        require (msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\n\n        Star3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n\n        uint256 _pID = makePlayerID(msg.sender);\n        uint256 _affID = _affCode;\n        if (_affID != 0 && _affID != plyr_[_pID].laff && _affID != _pID)\n        {\n            // update last affiliate\n            plyr_[_pID].laff = _affID;\n        } else if (_affID == _pID) {\n            _affID = 0;\n        }\n        registerNameCore(_pID, _name);\n        // fire event\n        emit Star3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\n    }",
        "@notice": "use these to register names.",
        "@dev": "they are just wrappers that will send the * registration requests to the PlayerBook contract. So registering here is the * same as registering there. UI will always display the last name you registered. * but you will still own all previously registered names to use as affiliate * links. * - must pay a registration fee. * - name must be unique * - names will be converted to lowercase * - name cannot start or end with a space * - cannot have more than 1 space in a row * - cannot be only numbers * - cannot start with 0x * - name must be at least 1 char * - max length of 32 characters long * - allowed characters: a-z, 0-9, and space * -functionhash- 0x921dec21 (using ID for affiliate) * -functionhash- 0x3ddd4698 (using address for affiliate) * -functionhash- 0x685ffd83 (using name for affiliate)",
        "@param1": "_nameString players desired name",
        "@param2": "_affCode affiliate ID, address, or name of who referred you * (this might cost a lot of gas)",
        "@gnotice": "Registers a player name in the game with `_nameString` and affiliate code `_affCode`.",
        "@gparam1": "_nameString The name to be registered",
        "@gparam2": "_affCode The code of the affiliate player, if any",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 1
    },
    {
        "func": "function _grantComp(address recipient, uint amount) public {\n        require(adminOrInitializing(), \"only admin can grant comp\");\n        uint amountLeft = grantCompInternal(recipient, amount);\n        require(amountLeft == 0, \"insufficient comp for grant\");\n        emit CompGranted(recipient, amount);\n    }",
        "@notice": "Transfer COMP to the recipient",
        "@dev": "Note: If there is not enough COMP, we do not perform the transfer all.",
        "@param1": "recipient The address of the recipient to transfer COMP to",
        "@param2": "amount The amount of COMP to (possibly) transfer",
        "@gnotice": "Grants `amount` Comp tokens to `recipient`",
        "@gparam1": "recipient The address of the account receiving the grant",
        "@gparam2": "amount The number of Comp tokens being granted",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function setHardCap(uint _hardcap) public onlyOwner {\n    hardcap = _hardcap;\n  }",
        "@notice": "",
        "@dev": "set the hardcap.",
        "@param1": "_hardcap the new hardcap",
        "@gnotice": "Set the maximum amount of tokens that can be sold in the crowdsale",
        "@gparam1": "_hardcap The new hard cap to be set by the owner of the contract",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function accumulativeDividendOf(address _owner) public view override returns(uint256) {\n        return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()\n        .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;\n    }",
        "@notice": "the amount of dividend in wei that an address has earned in total",
        "@dev": "accumulativeDividendOf(_owner) = withdrawableDividendOf(_owner) + withdrawnDividendOf(_owner) /// = (magnifiedDividendPerShare * balanceOf(_owner) + magnifiedDividendCorrections[_owner]) / magnitude",
        "@param1": "_owner The address of a token holder.",
        "@return1": "The amount of dividend `_owner` earned.",
        "@gnotice": "Get the accumulative dividend of `_owner`",
        "@gparam1": "_owner The address of the account to get the accumulative dividend for",
        "@greturn1": "The accumulative dividend of `_owner`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function newContract(address payable _receiver, bytes32 _hashlock, uint _timelock)\n        external\n        payable\n        fundsSent\n        futureTimelock(_timelock)\n        returns (bytes32 contractId)\n    {\n        contractId = sha256(\n            abi.encodePacked(\n                msg.sender,\n                _receiver,\n                msg.value,\n                _hashlock,\n                _timelock\n            )\n        );\n\n        // Reject if a contract already exists with the same parameters. The\n        // sender must change one of these parameters to create a new distinct\n        // contract.\n        if (haveContract(contractId))\n            revert(\"Contract already exists\");\n\n        contracts[contractId] = LockContract(\n            msg.sender,\n            _receiver,\n            msg.value,\n            _hashlock,\n            _timelock,\n            false,\n            false,\n            0x0\n        );\n\n        emit LogHTLCNew(\n            contractId,\n            msg.sender,\n            _receiver,\n            msg.value,\n            _hashlock,\n            _timelock\n        );\n    }",
        "@notice": "",
        "@dev": "Sender sets up a new hash time lock contract depositing the ETH and * providing the reciever lock terms.",
        "@param1": "_receiver Receiver of the ETH.",
        "@param2": "_hashlock A sha-2 sha256 hash hashlock.",
        "@param3": "_timelock UNIX epoch seconds time that the lock expires at.",
        "@return1": "contractId Id of the new HTLC.",
        "@gnotice": "Creates a new Hashed TimeLock Contract with the specified parameters",
        "@gparam1": "_receiver The address of the destination account for the contract",
        "@gparam2": "_hashlock The hash of the preimage that releases the funds",
        "@gparam3": "_timelock The UNIX timestamp for when the contract can be executed",
        "@greturn1": "The unique identifier for the new Contract",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 1,
        "@tparam2": 1,
        "@tparam3": 1,
        "@treturn1": 0
    },
    {
        "func": "function unstake(uint256 amount) override external {\n        _unstake(amount);\n    }",
        "@notice": "Unstakes a certain amount of previously deposited tokens.",
        "@dev": "User also receives their * alotted number of distribution tokens.",
        "@param1": "amount Number of deposit tokens to unstake / withdraw.",
        "@gnotice": "Unstake `amount` tokens from the caller's staked balance",
        "@gparam1": "amount The number of tokens to unstake",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function settle (uint64 auctionId) external {\n        Auction storage auction = _auctions[auctionId];\n        require(!auction.settled, \"Auction already settled.\");\n        require(auction.endTimestamp > 0, \"Auction does not exist.\");\n        require(block.timestamp > auction.endTimestamp, \"Auction not complete.\");\n\n        if (_hasBid(auction)) {\n            (bool success,) = CHARITY_ADDRESS.call{ value: auction.latestBid }(\"\");\n            require(success, \"Failed to forward funds\");\n        }\n\n        if (auction.tokenERCStandard == 721) {\n            IERC721(auction.tokenContract).safeTransferFrom(address(this), auction.latestBidder, auction.tokenId, \"\");\n        } else if (auction.tokenERCStandard == 1155) {\n            IERC1155(auction.tokenContract).safeTransferFrom(address(this), auction.latestBidder, auction.tokenId, auction.tokenAmount, \"\");\n        }\n\n        // End the auction\n        auction.settled = true;\n        emit AuctionSettled(auctionId);\n    }",
        "@notice": "",
        "@dev": "Settles an auction",
        "@param1": "auctionId The Auction ID to claim.",
        "@gnotice": "Settles the specified auction",
        "@gparam1": "auctionId The ID of the auction to settle",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function buyForEth(uint256 roundId) external payable isEnded(roundId) {\n        if (msg.value == 0) {\n            revert ZeroMsgValue(\"TokenSale: Zero msg.value\");\n        }\n\n        TokenSaleRound storage tokenSaleRound = rounds[roundId];\n\n        if (!tokenSaleRound.isPublic) {\n            if (!whitelist[msg.sender]) {\n                revert NotInTheWhitelist(\"TokenSale: Not in the whitelist\");\n            }\n        }\n\n        if (!isRoundStared(roundId)) {\n            revert RoundNotStarted(\"TokenSale: Round is not started\");\n        }\n\n        uint256[] memory amounts = swapRouter.getAmountsOut(msg.value, path);\n\n        if (amounts[1] < tokenSaleRound.minAmount) {\n            revert MinMaxPurchase(\"TokenSale: Amount not allowed\");\n        }\n\n        uint256 tokenAmount = _calcPurchaseAmount(\n            amounts[1],\n            tokenSaleRound.purchasePrice\n        );\n\n        if (\n            tokenSaleRound.tokensSold + tokenAmount >\n            tokenSaleRound.totalPurchaseAmount\n        ) {\n            revert TokensNotEnough(\"TokenSale: Tokens not enough\");\n        }\n\n        tokenSaleRound.tokensSold += tokenAmount;\n        userSpentFunds[msg.sender][roundId] += amounts[1];\n\n        userBalance[msg.sender][roundId] += tokenAmount;\n\n        _endSoldOutRound(roundId);\n\n        (bool sent, ) = treasury.call{value: msg.value}(\"\");\n        require(sent, \"Failed to send Ether\");\n        emit PurchasePlanetexToken(msg.sender, amounts[1], tokenAmount);\n    }",
        "@notice": "",
        "@dev": "buy tokens for eth or bnb tokens",
        "@param1": "roundId tokeSale round id.",
        "@gnotice": "Buy Planetex tokens for ETH in a token sale round",
        "@gparam1": "roundId The ID of the token sale round",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function calcKeysReceived(uint256 _rID, uint256 _eth)\n        public\n        view\n        returns(uint256)\n    {\n        // grab time\n        uint256 _now = now;\n\n        // are we in a round?\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n            return ( (round_[_rID].eth).keysRec(_eth) );\n        else // rounds over.  need keys for new round\n            return ( (_eth).keys() );\n    }",
        "@notice": "returns the amount of keys you would get given an amount of eth.",
        "@dev": " * -functionhash- 0xce89c80c",
        "@param1": "_rID round ID you want price for",
        "@param2": "_eth amount of eth sent in",
        "@return1": "keys received",
        "@gnotice": "calculates the amount of keys that can be received for a given amount of Ether and a specific round ID",
        "@gparam1": "_rID The ID of the round to calculate keys for",
        "@gparam2": "_eth The amount of Ether to calculate keys for",
        "@greturn1": "The amount of keys that can be received for the given Ether amount and round ID",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function approve(address spender, uint256 amount) external override returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }",
        "@notice": "Approve `spender` to transfer up to `amount` from `src`",
        "@dev": "This will overwrite the approval amount for `spender` * and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)",
        "@param1": "spender The address of the account which may transfer tokens",
        "@param2": "amount The number of tokens that are approved",
        "@return1": "Whether or not the approval succeeded",
        "@gnotice": "Approve the `spender` to transfer up to `amount` tokens from the `msg.sender` account",
        "@gparam1": "spender The address authorized to spend the funds",
        "@gparam2": "amount The maximum amount of tokens the `spender` can transfer",
        "@greturn1": "Whether or not the approval succeeded",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function balanceOf(\n    address _owner\n  )\n    external\n    override\n    view\n    returns (uint256)\n  {\n    require(_owner != address(0), ZERO_ADDRESS);\n    return _getOwnerNFTCount(_owner);\n  }",
        "@notice": "Returns the number of NFTs owned by `_owner`.",
        "@dev": "NFTs assigned to the zero address are * considered invalid, and this function throws for queries about the zero address.",
        "@param1": "_owner Address for whom to query the balance.",
        "@return1": "Balance of _owner.",
        "@gnotice": "Gets the balance of the specified address",
        "@gparam1": "_owner The address to query for the balance",
        "@greturn1": "The balance of the specified address",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function getCreatorFeeInfo(\n        address token,\n        uint256 tokenId,\n        uint256 transactionAmountStart,\n        uint256 transactionAmountEnd\n    )\n        public\n        view\n        returns (\n            address payable recipient,\n            uint256 creatorFeeAmountStart,\n            uint256 creatorFeeAmountEnd\n        )\n    {\n        // Check if creator fee engine is on this chain\n        if (address(creatorFeeEngine) != address(0)) {\n            // Creator fee engine may revert if no creator fees are present.\n            try\n                creatorFeeEngine.getRoyaltyView(\n                    token,\n                    tokenId,\n                    transactionAmountStart\n                )\n            returns (\n                address payable[] memory creatorFeeRecipients,\n                uint256[] memory creatorFeeAmountsStart\n            ) {\n                if (creatorFeeRecipients.length != 0) {\n                    // Use first recipient and amount\n                    recipient = creatorFeeRecipients[0];\n                    creatorFeeAmountStart = creatorFeeAmountsStart[0];\n                }\n            } catch {\n                // Creator fee not found\n            }\n\n            // If fees found for start amount, check end amount\n            if (recipient != address(0)) {\n                // Creator fee engine may revert if no creator fees are present.\n                try\n                    creatorFeeEngine.getRoyaltyView(\n                        token,\n                        tokenId,\n                        transactionAmountEnd\n                    )\n                returns (\n                    address payable[] memory,\n                    uint256[] memory creatorFeeAmountsEnd\n                ) {\n                    creatorFeeAmountEnd = creatorFeeAmountsEnd[0];\n                } catch {}\n            }\n        } else {\n            // Fallback to ERC2981\n            {\n                // Static call to token using ERC2981\n                (bool success, bytes memory res) = token.staticcall(\n                    abi.encodeWithSelector(\n                        IERC2981.royaltyInfo.selector,\n                        tokenId,\n                        transactionAmountStart\n                    )\n                );\n                // Check if call succeeded\n                if (success) {\n                    // Ensure 64 bytes returned\n                    if (res.length == 64) {\n                        // Decode result and assign recipient and start amount\n                        (recipient, creatorFeeAmountStart) = abi.decode(\n                            res,\n                            (address, uint256)\n                        );\n                    }\n                }\n            }\n\n            // Only check end amount if start amount found\n            if (recipient != address(0)) {\n                // Static call to token using ERC2981\n                (bool success, bytes memory res) = token.staticcall(\n                    abi.encodeWithSelector(\n                        IERC2981.royaltyInfo.selector,\n                        tokenId,\n                        transactionAmountEnd\n                    )\n                );\n                // Check if call succeeded\n                if (success) {\n                    // Ensure 64 bytes returned\n                    if (res.length == 64) {\n                        // Decode result and assign end amount\n                        (, creatorFeeAmountEnd) = abi.decode(\n                            res,\n                            (address, uint256)\n                        );\n                    }\n                }\n            }\n        }\n    }",
        "@notice": "Gets the on chain creator fees",
        "@dev": "Uses the creatorFeeEngine when available, otherwise fallback to `IERC2981`.",
        "@param1": "token The token address",
        "@param2": "tokenId The token identifier",
        "@param3": "transactionAmountStart The transaction start amount",
        "@param4": "transactionAmountEnd The transaction end amount",
        "@return1": "recipient creator fee recipient",
        "@return2": "creatorFeeAmountStart creator fee start amount",
        "@return3": "creatorFeeAmountEnd creator fee end amount",
        "@gnotice": "Gets information about the creator fee for a given token and transaction amount range",
        "@gparam1": "token The address of the token contract",
        "@gparam2": "tokenId The ID of the token",
        "@gparam3": "transactionAmountStart The start of the transaction amount range to check",
        "@gparam4": "transactionAmountEnd The end of the transaction amount range to check",
        "@greturn1": "recipient The recipient address of the creator fee",
        "@greturn2": "creatorFeeAmountStart The creator fee amount for the `transactionAmountStart`",
        "@greturn3": "creatorFeeAmountEnd The creator fee amount for the `transactionAmountEnd`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0,
        "@treturn1": 0,
        "@treturn2": 0,
        "@treturn3": 0
    },
    {
        "func": "function uri(uint256 id) public view virtual returns (string memory) {\n        string memory tokenURI = _uris[id];\n\n        if (bytes(tokenURI).length > 0) return tokenURI;\n        else return uriFetcher.uri(id);\n    }",
        "@notice": "",
        "@dev": "ID metadata fetcher.",
        "@param1": "id ID to fetch from.",
        "@return1": "tokenURI Metadata.",
        "@gnotice": "Returns the Uniform Resource Identifier (URI) for a given token `id`",
        "@gparam1": "id The identifier of the token whose URI is to be returned",
        "@greturn1": "The URI requested in its string representation, or an empty string if URI does not exist for this token ID",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 1
    },
    {
        "func": "function addAdmin(address account) public virtual onlyOwner {\n        grantRole(ADMIN_ROLE, account);\n    }",
        "@notice": "",
        "@dev": "add admin",
        "@param1": "account address to add",
        "@gnotice": "Adds `account` as an admin",
        "@gparam1": "account The address to be added as an admin. Must not be null.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function updateRates(uint[] data) public onlyOwner {\n    if (data.length % 2 > 0)\n      throw;\n    uint i = 0;\n    while (i < data.length / 2) {\n      bytes32 symbol = bytes32(data[i * 2]);\n      uint rate = data[i * 2 + 1];\n      rates[symbol] = rate;\n      RateUpdated(now, symbol, rate);\n      i++;\n    }\n  }",
        "@notice": "",
        "@dev": "update multiple rates.",
        "@param1": "data an array that alternates sha3 hashes of the symbol and the corresponding rate .",
        "@gnotice": "Updates the exchange rates for multiple symbols at once",
        "@gparam1": "data An array containing symbol-rate pairs in the form of [symbol1, rate1, symbol2, rate2, ...]",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function setClaimingCosts(uint256 newClaimingFee) external\n    onlyOwner()  {\n        claimingFee = newClaimingFee;\n    }",
        "@notice": "",
        "@dev": "Sets a new claiming fee in wei Any CLevel can call this function",
        "@param1": "newClaimingFee The cost to charge in wei for each claimed HRSY",
        "@gnotice": "Set the claiming fee to `newClaimingFee`",
        "@gparam1": "newClaimingFee The new claiming fee to be set",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1
    },
    {
        "func": "function wrapEthAndDepositAndLockCollateralAndBorrow(\n        BalanceSheetInterface balanceSheet,\n        FyTokenInterface fyToken,\n        uint256 borrowAmount,\n        uint256 underlyingAmount\n    ) external payable {\n        wrapEthAndDepositAndLockCollateral(balanceSheet, fyToken);\n        borrowAndSellFyTokens(fyToken, borrowAmount, underlyingAmount);\n    }",
        "@notice": "Wraps ETH into WETH and deposits into the BalanceSheet contract",
        "@dev": "This is a payable function so it can receive ETH transfers.",
        "@param1": "balanceSheet The address of the BalanceSheet contract.",
        "@param2": "fyToken The address of the FyToken contract.",
        "@param3": "borrowAmount The amount of fyTokens to borrow.",
        "@param4": "underlyingAmount The amount of underlying to sell fyTokens for.",
        "@gnotice": "Wraps deposited Ether, deposits it into the balance sheet, locks collateral, then borrows `borrowAmount` from `fyToken`, and sells `underlyingAmount` of the received tokens",
        "@gparam1": "balanceSheet A contract that keeps users' balances",
        "@gparam2": "fyToken The token from which to borrow funds",
        "@gparam3": "borrowAmount The amount of fyToken to borrow",
        "@gparam4": "underlyingAmount The amount of underlying tokens to sell for Ether",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 1,
        "@tparam3": 0,
        "@tparam4": 0
    },
    {
        "func": "function lockTokens(uint256 amount, uint256 durationSec)\n        external\n        onlyOwner\n    {\n        require(\n            unlockSchedules.length < _maxUnlockSchedules,\n            \"TokenGeyser: reached maximum unlock schedules\"\n        );\n\n        // Update lockedTokens amount before using it in computations after.\n        updateAccounting();\n\n        uint256 lockedTokens = totalLocked();\n        uint256 mintedLockedShares =\n            (lockedTokens > 0)\n                ? totalLockedShares.mul(amount).div(lockedTokens)\n                : amount.mul(_initialSharesPerToken);\n\n        UnlockSchedule memory schedule;\n        schedule.initialLockedShares = mintedLockedShares;\n        schedule.lastUnlockTimestampSec = block.timestamp;\n        schedule.endAtSec = block.timestamp.add(durationSec);\n        schedule.durationSec = durationSec;\n        unlockSchedules.push(schedule);\n\n        totalLockedShares = totalLockedShares.add(mintedLockedShares);\n\n        require(\n            _lockedPool.token().transferFrom(\n                msg.sender,\n                address(_lockedPool),\n                amount\n            ),\n            \"TokenGeyser: transfer into locked pool failed\"\n        );\n        emit TokensLocked(amount, durationSec, totalLocked());\n    }",
        "@notice": "",
        "@dev": "This funcion allows the contract owner to add more locked distribution tokens, along * with the associated \"unlock schedule\". These locked tokens immediately begin unlocking * linearly over the duraction of durationSec timeframe.",
        "@param1": "amount Number of distribution tokens to lock. These are transferred from the caller.",
        "@param2": "durationSec Length of time to linear unlock the tokens.",
        "@gnotice": "Lock `amount` tokens for duration of `durationSec` seconds",
        "@gparam1": "amount The number of tokens to lock",
        "@gparam2": "durationSec The duration, in seconds, for which tokens will be locked",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function owner(bytes32 node) public virtual override view returns (address) {\n        address addr = records[node].owner;\n        if (addr == address(this)) {\n            return address(0x0);\n        }\n\n        return addr;\n    }",
        "@notice": "",
        "@dev": "Returns the address that owns the specified node.",
        "@param1": "node The specified node.",
        "@return1": "address of the owner.",
        "@gnotice": "Get the owner of the specified ENS `node`",
        "@gparam1": "node The ENS node hash",
        "@greturn1": "The address of the node's owner, or `address(0x0)` if the node has no owner.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function trade(\n        address maker,\n        address taker,\n        uint256[] memory makerIds,\n        uint256[] memory takerIds,\n        uint256 price,\n        uint256 expiry,\n        uint256 salt,\n        bytes memory signature\n    ) external payable nonReentrant {\n        unchecked {\n\n            // Check if trading is paused.\n            if (_tradingPaused) revert TRADING_IS_CURRENTLY_DISABLED();\n\n            // Revert if the trade is private and if the sender is not the taker.\n            if (taker != address(0) && msg.sender != taker) revert TRADE_IS_NOT_FOR_YOU();\n\n            // Revert if the amount sent is insufficient.\n            if (msg.value < price) revert INSUFFICIENT_FUNDS_SENT();\n\n            // Get the hash and errors for the trade.\n            (bytes32 hash, uint256[8] memory errors) = isTradeApprovedAndValid(\n                maker,\n                taker,\n                makerIds,\n                takerIds,\n                price,\n                expiry,\n                salt,\n                signature, \n                false\n            );\n\n            // Revert if the trade contains errors.\n            for (uint256 i; i < errors.length; i++) if (errors[i] != 0) revert INVALID_TRADE();\n\n            // Transfer sale price to the maker.\n            if (price > 0) _transferEther(maker, price);\n\n            // Transfer CryptoBlobs.\n            // Third-party NFT marketplaces require an approval to use {transferFrom}, but this trading platform uses {_transfer}, \n            // an internal function, to bypass approvals. This allows takers to complete trades on the maker's behalf using a signature.\n            // Note that {_revertIfNoAccess} returns the owner's address because makers and takers can be approved accounts.\n\n            // Transfer maker IDs. Reverts if the maker does not have access to transfer a maker ID.\n            for (uint256 i; i < makerIds.length; i++) _transfer(_revertIfNoAccess(maker, makerIds[i]), msg.sender, makerIds[i]);\n\n            // Transfer taker IDs. Reverts if the sender does not have access to transfer a taker ID.\n            for (uint256 i; i < takerIds.length; i++) _transfer(_revertIfNoAccess(msg.sender, takerIds[i]), maker, takerIds[i]);\n\n            // Use the trade hash.\n            // The block timestamp is multiplied by 10 to store a binary number. 0 means cancelled. 1 means completed.\n            _account[maker].timestampTradeHashUsed[hash] = (block.timestamp * 10) + 1;\n\n            emit Trade(             // 0x10d92c47650ef2b2a841f26c951f4391ccbb731e57d36a67665a0d138e08ef09\n                hash,               // bytes32 hash\n                maker,              // address indexed maker\n                msg.sender,         // address indexed taker\n                makerIds,           // uint256[] makerIds\n                takerIds,           // uint256[] takerIds\n                price,              // uint256 price\n                expiry,             // uint256 expiry\n                block.timestamp,    // uint256 timestamp\n                true                // bool isTrade\n            );\n        }\n    }",
        "@notice": "Confirm a trade on the integrated trading platform",
        "@dev": "Buy, sell, and trade multiple CryptoBlobs at a time. * Makers and takers can trade CryptoBlobs that they have access to. * Approve accounts with {approve} or {setApprovalForAll}. * Makers do not need to approve this contract to trade. * Only takers can transfer ETH in a trade. Makers can't deposit ETH. * Use {manageTrades} to cancel a trade or lock/unlock your trades. * The trading platform does not currently support EIP-712.",
        "@param1": "maker The address of the maker.",
        "@param2": "taker The address of the taker.",
        "@param3": "makerIds The CryptoBlob IDs `maker` has access to trade.",
        "@param4": "takerIds The CryptoBlob IDs `taker` has access to trade.",
        "@param5": "price The price (in WEI) the `taker` must pay to `maker` to complete the trade.",
        "@param6": "expiry The timestamp the trade auto-expires, or 0 for never expires.",
        "@param7": "salt Salt allows the same trade parameters to be used again, resulting in a different hash.",
        "@param8": "signature The signature is the hash of the trade signed by the maker.",
        "@gnotice": "trade CryptoBlobs IDs for a specific price",
        "@gparam1": "maker The address of the maker account",
        "@gparam2": "taker The address of the taker account",
        "@gparam3": "makerIds An array of IDs representing the CryptoBlobs owned by maker",
        "@gparam4": "takerIds An array of IDs representing the CryptoBlobs owned by taker",
        "@gparam5": "price The price of the trade in wei",
        "@gparam6": "expiry The time at which the trade will expire",
        "@gparam7": "salt A unique number to generate a unique hash for the trade",
        "@gparam8": "signature The signature of the trade hash signed by the maker",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0,
        "@tparam5": 0,
        "@tparam6": 0,
        "@tparam7": 1,
        "@tparam8": 0
    },
    {
        "func": "function getPlayerInfoByAddress(address _addr)\n        public\n        view\n        returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)\n    {\n        // setup local rID\n        uint256 _rID = rID_;\n\n        if (_addr == address(0))\n        {\n            _addr == msg.sender;\n        }\n        uint256 _pID = pIDxAddr_[_addr];\n\n        return\n        (\n            _pID,                               //0\n            plyr_[_pID].name,                   //1\n            plyrRnds_[_pID][_rID].keys,         //2\n            plyr_[_pID].win,                    //3\n            (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),       //4\n            plyr_[_pID].aff,                    //5\n            plyrRnds_[_pID][_rID].eth           //6\n        );\n    }",
        "@notice": "returns player info based on address.",
        "@dev": "if no address is given, it will * use msg.sender * -functionhash- 0xee0b5d8b",
        "@param1": "_addr address of the player you want to lookup",
        "@return1": "_pID player ID",
        "@return2": "plyr_[_pID].name player name",
        "@return3": "plyrRnds_[_pID][_rID].keys keys owned (current round)",
        "@return4": "plyr_[_pID].win winnings vault",
        "@return5": "general vault",
        "@return6": "plyr_[_pID].aff affiliate vault",
        "@return7": "plyrRnds_[_pID][_rID].eth player round eth",
        "@gnotice": "Get player info based on player address `_addr`",
        "@gparam1": "_addr The address of the player",
        "@greturn1": "_pID The unique player ID",
        "@greturn2": "plyr_[_pID].name The player's name",
        "@greturn3": "plyrRnds_[_pID][_rID].keys The number of keys the player has in the current round",
        "@greturn4": "plyr_[_pID].win The amount of winnings the player has earned",
        "@greturn5": "The sum of the player's general vault and the unmasked earnings up to the last payout round",
        "@greturn6": "plyr_[_pID].aff The ID of the player's referrer",
        "@greturn7": "plyrRnds_[_pID][_rID].eth The amount of Ether contributed by the player to the current round",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0,
        "@treturn2": 0,
        "@treturn3": 0,
        "@treturn4": 0,
        "@treturn5": 0,
        "@treturn6": 0,
        "@treturn7": 0
    },
    {
        "func": "function getRoundData(uint80 _roundId)\n        public\n        view\n        virtual\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        Round memory r = rounds[uint32(_roundId)];\n\n        require(\n            r.answeredInRound > 0 && validRoundId(_roundId),\n            V3_NO_DATA_ERROR\n        );\n\n        return (\n            _roundId,\n            r.answer,\n            r.startedAt,\n            r.updatedAt,\n            r.answeredInRound\n        );\n    }",
        "@notice": "get data about a round.",
        "@param1": "_roundId the round ID to retrieve the round data for",
        "@return1": "roundId is the round ID for which data was retrieved",
        "@return2": "answer is the answer for the given round",
        "@return3": "startedAt is the timestamp when the round was started. This is 0 * if the round hasn't been started yet.",
        "@return4": "updatedAt is the timestamp when the round last was updated (i.e. * answer was last computed)",
        "@return5": "answeredInRound is the round ID of the round in which the answer * was computed. answeredInRound may be smaller than roundId when the round * timed out. answeredInRound is equal to roundId when the round didn't time out * and was completed regularly.",
        "@dev": "Note that for in-progress rounds (i.e. rounds that haven't yet received * maxSubmissions) answer and updatedAt may change between queries.",
        "@gnotice": "Returns the round data for the specified round ID",
        "@gparam1": "_roundId The ID of the round to get the data for",
        "@greturn1": "roundId The round ID",
        "@greturn2": "answer The price at the current round ID",
        "@greturn3": "startedAt Timestamp of when the round started",
        "@greturn4": "updatedAt Timestamp of when the round was updated",
        "@greturn5": "answeredInRound The round ID of the round in which the answer was computed",
        "@tnotice": 0,
        "@tparam1": 0,
        "@treturn1": 0,
        "@treturn2": 0,
        "@treturn3": 0,
        "@treturn4": 0,
        "@treturn5": 0,
        "@tdev": 0
    },
    {
        "func": "function withdrawUnsoldTokens(uint256 roundId, address recipient)\n        external\n        onlyOwner\n    {\n        if (roundId > roundsCounter) {\n            revert RoundNotFound(\"TokenSale: Round not found\");\n        }\n        TokenSaleRound storage tokenSaleRound = rounds[roundId];\n        if (tokenSaleRound.endTime > block.timestamp) {\n            revert RoundNotEnd(\"TokenSale: Round not end\");\n        }\n        if (tokenSaleRound.totalPurchaseAmount > tokenSaleRound.tokensSold) {\n            uint256 unsoldTokens = tokenSaleRound.totalPurchaseAmount -\n                tokenSaleRound.tokensSold;\n            tokenSaleRound.tokensSold = tokenSaleRound.totalPurchaseAmount;\n            userBalance[recipient][roundId] += unsoldTokens;\n            emit WithdrawUnsoldTokens(roundId, recipient, unsoldTokens);\n        } else {\n            revert TokensNotEnough(\"TokenSale: Sold out\");\n        }\n\n        tokenSaleRound.isEnded = true;\n    }",
        "@notice": "withdraws tokens that were not sold and writes them to the balance of the specified wallet.",
        "@dev": "Only owner can call it. Only if round is end.",
        "@param1": "roundId tokeSale round id.",
        "@param2": "recipient recipient wallet address",
        "@gnotice": "Withdraws unsold tokens from a specific `roundId` and transfers them to the `recipient` account",
        "@gparam1": "roundId The ID of the sale round to withdraw unsold tokens from",
        "@gparam2": "recipient The address of the account to receive the unsold tokens",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function isApprovedForAll(\n    address _owner,\n    address _operator\n  )\n    external\n    override\n    view\n    returns (bool)\n  {\n    return ownerToOperators[_owner][_operator];\n  }",
        "@notice": "",
        "@dev": "Checks if `_operator` is an approved operator for `_owner`.",
        "@param1": "_owner The address that owns the NFTs.",
        "@param2": "_operator The address that acts on behalf of the owner.",
        "@return1": "True if approved for all, false otherwise.",
        "@gnotice": "Check if `_operator` is approved to manage all assets of `_owner`",
        "@gparam1": "_owner The address of the owner of the assets",
        "@gparam2": "_operator The address of the operator",
        "@greturn1": "Whether or not `_operator` is approved to manage all assets of `_owner`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function removeAddressFromWhitelist(address addr)\n        public\n        onlyOwner\n        returns (bool success)\n    {\n        if (whitelist[addr]) {\n            whitelist[addr] = false;\n            emit WhitelistedAddressRemoved(addr);\n            success = true;\n        }\n    }",
        "@notice": "",
        "@dev": "remove an address from the whitelist",
        "@param1": "addr address",
        "@return1": "success if the address was removed from the whitelist",
        "@gnotice": "Removes `addr` from the whitelist",
        "@gparam1": "addr The address to remove",
        "@greturn1": "Whether or not the removal succeeded",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function validateOfferItems(\n        OrderParameters memory orderParameters\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        // Iterate over each offer item and validate it\n        for (uint256 i = 0; i < orderParameters.offer.length; i++) {\n            errorsAndWarnings.concat(validateOfferItem(orderParameters, i));\n\n            // Check for duplicate offer item\n            OfferItem memory offerItem1 = orderParameters.offer[i];\n\n            for (uint256 j = i + 1; j < orderParameters.offer.length; j++) {\n                // Iterate over each remaining offer item\n                // (previous items already check with this item)\n                OfferItem memory offerItem2 = orderParameters.offer[j];\n\n                // Check if token and id are the same\n                if (\n                    offerItem1.token == offerItem2.token &&\n                    offerItem1.identifierOrCriteria ==\n                    offerItem2.identifierOrCriteria\n                ) {\n                    errorsAndWarnings.addError(\n                        OfferIssue.DuplicateItem.parseInt()\n                    );\n                }\n            }\n        }\n\n        // You must have an offer item\n        if (orderParameters.offer.length == 0) {\n            errorsAndWarnings.addWarning(OfferIssue.ZeroItems.parseInt());\n        }\n\n        // Warning if there is more than one offer item\n        if (orderParameters.offer.length > 1) {\n            errorsAndWarnings.addWarning(OfferIssue.MoreThanOneItem.parseInt());\n        }\n    }",
        "@notice": "Validates an offer item",
        "@dev": "Amounts are not summed and verified, just the individual amounts.",
        "@param1": "orderParameters The parameters for the order to validate",
        "@return1": "errorsAndWarnings The errors and warnings",
        "@gnotice": "Validates the `offer` items in the given `orderParameters` and checks for duplicates",
        "@gparam1": "orderParameters An instance of `OrderParameters` containing the `offer` to be validated",
        "@greturn1": "An instance of `ErrorsAndWarnings` that contains any errors or warnings encountered during validation. If there are no issues, both the `errors` and `warnings` arrays will be empty.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return interfaceId == type(IERC165).interfaceId ||          // 0x01ffc9a7\n            interfaceId == type(IERC721).interfaceId ||             // 0x80ac58cd\n            interfaceId == type(IERC721Metadata).interfaceId ||     // 0x5b5e139f\n            interfaceId == type(IERC721Enumerable).interfaceId;     // 0x780e9d63\n    }",
        "@notice": "If an interface ID is supported",
        "@dev": "Supported interfaces: IERC165 (0x01ffc9a7), IERC721 (0x80ac58cd), IERC721Metadata (0x5b5e139f), IERC721Enumerable (0x780e9d63).",
        "@param1": "interfaceId Interface ID to check.",
        "@return1": "If `interfaceId` is supported.",
        "@gnotice": "if `interfaceId` is supported by the contract",
        "@gparam1": "interfaceId The interface ID to check for support",
        "@greturn1": "`true` if the contract supports `interfaceId`, otherwise `false`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function addLegitDevAddress(address newAddress) external\n    onlyOwner() {\n        _addLegitOwner(newAddress);\n    }",
        "@notice": "",
        "@dev": "add a legit owner address for races validation",
        "@param1": "newAddress the dev address deploying BettingController to add",
        "@gnotice": "Add a new developer address to the list of legitimate developers",
        "@gparam1": "newAddress The address of the new legitimate developer to be added",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1
    },
    {
        "func": "function wrapEthAndDepositAndLockCollateral(BalanceSheetInterface balanceSheet, FyTokenInterface fyToken)\n        public\n        payable\n    {\n        uint256 collateralAmount = msg.value;\n        wrapEthAndDepositCollateral(balanceSheet, fyToken);\n        balanceSheet.lockCollateral(fyToken, collateralAmount);\n    }",
        "@notice": "wraps ETH into WETH, deposits and locks collateral into the vault in the BalanceSheet contracts and borrows fyTokens.",
        "@dev": "This is a payable function so it can receive ETH transfers.",
        "@param1": "balanceSheet The address of the BalanceSheet contract.",
        "@param2": "fyToken The address of the FyToken contract.",
        "@gnotice": "Wraps Ether and deposits collateral to the Balance Sheet, then locks the collateral in the fyToken contract",
        "@gparam1": "balanceSheet The instance of the Balance Sheet contract to deposit collateral",
        "@gparam2": "fyToken The instance of the fyToken contract for which to lock the collateral",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function editAUM(uint256 _assetsExternalEndBeforeFees)\n        public\n        onlyManagementPhase\n        requiresAuth\n        returns (uint256 newAUM)\n    {\n        uint256 lastEpoch = epoch - 1;\n        uint256 lastAssetsExternalEnd = vaultStates[lastEpoch].assetsExternalEnd;\n        uint256 lastManagementFee = vaultStates[lastEpoch].managementFee;\n        uint256 lastTotalSupply = vaultStates[lastEpoch].totalSupply;\n\n        if (_assetsExternalEndBeforeFees == lastAssetsExternalEnd + lastManagementFee) {\n            // no change in aum\n            return lastAssetsExternalEnd;\n        }\n        (\n            bool didTransferToFarm,\n            uint256 totalAssetsTransferred, // bool didDepositDelta,\n            ,\n            ,\n            ,\n\n        ) = previewProgress(lastAssetsExternalEnd + lastManagementFee, lastEpoch);\n\n        /// @dev rather than saving gas by combining these into 1 transfers but with overflow handling, we do it in 2\n        /// @dev gas is paid by farmer (upkeep)\n\n        // revert transfers\n        if (totalAssetsTransferred > 0) {\n            if (didTransferToFarm) {\n                // revert\n                transferAssetToContract(totalAssetsTransferred);\n            } else {\n                transferAssetToFarmer(totalAssetsTransferred);\n            }\n        }\n\n        // // revert deposit/redeem using latest rate, update aum automatically\n        if (totalSupply > lastTotalSupply) {\n            _burn(address(this), totalSupply - lastTotalSupply);\n        }\n\n        if (totalSupply < lastTotalSupply) {\n            _mint(address(this), lastTotalSupply - totalSupply);\n        }\n\n        // /// @dev by this point, aum should be the same as last epoch's aum\n        storedFee -= lastManagementFee;\n        epoch = lastEpoch;\n        return progressEpoch(_assetsExternalEndBeforeFees);\n    }",
        "@notice": "amends last epoch's aum update",
        "@dev": "callable at management phase only",
        "@param1": "_assetsExternalEndBeforeFees current external asset",
        "@return1": "newAUM (external asset) // solhint-disable-next-line code-complexity",
        "@gnotice": "Edit the assets under management (AUM) by transferring assets between the vault and the farming contract",
        "@gparam1": "_assetsExternalEndBeforeFees The total external assets under management before subtracting management fees",
        "@greturn1": "The updated AUM after the transfer",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 1
    },
    {
        "func": "function setOwner(bytes32 node, address owner) public virtual override authorised(node) {\n        _setOwner(node, owner);\n        emit Transfer(node, owner);\n    }",
        "@notice": "set ownership of a node to a new address.",
        "@dev": "May only be called by the current owner of the node.",
        "@param1": "node The node to transfer ownership of.",
        "@param2": "owner The address of the new owner.",
        "@gnotice": "Set `owner` as the owner of the ENS `node`",
        "@gparam1": "node The ENS node to change ownership of",
        "@gparam2": "owner The new owner to set for the ENS `node`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function approve(address to, uint256 tokenId) public virtual override {\n        // Get the owner of `tokenId`.\n        address owner = ownerOf(tokenId);\n\n        // Cannot approve the current owner.\n        if (to == owner) revert CANNOT_APPROVE_THIS_ADDRESS();\n\n        // Revert if not the owner and not approved for all.\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) revert RESTRICTED_ACCESS();\n\n        // Approve `to` to manage `tokenId`.\n        _token[tokenId].approval = to;\n\n        emit Approval(  // 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925\n            owner,      // address indexed owner\n            to,         // address indexed approved\n            tokenId     // uint256 indexed tokenId\n        );\n    }",
        "@notice": "Approves `to` to be a token operator of `tokenId`",
        "@dev": "You must be the owner of `tokenId` or an account operator of the owner. * Only a single account can be approved at a time. * Approve the zero address to clear the current approval. * The approval is cleared when the token is transferred.",
        "@param1": "to The address of the account to approve.",
        "@gnotice": "Approves `to` to operate with `tokenId`",
        "@gparam1": "to The approved address",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function burn(uint256 _value) public {\n    _burn(msg.sender, _value);\n  }",
        "@notice": "",
        "@dev": "Burns a specific amount of tokens.",
        "@param1": "_value The amount of token to be burned.",
        "@gnotice": "Burn `_value` tokens from `msg.sender`",
        "@gparam1": "_value The number of tokens to burn",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function makeProposal( uint8 methodId, uint256 parameter ) external\n    onlyCLevelAccess()\n    proposalAvailable()\n    cooledDown()\n    {\n        currentProposal.timestamp = block.timestamp;\n        currentProposal.parameter = parameter;\n        currentProposal.methodId = methodId;\n        currentProposal.proposer = msg.sender;\n        delete currentProposal.yay;\n        delete currentProposal.nay;\n        proposalInProgress = true;\n        \n        emit NewProposal(methodId,parameter,msg.sender);\n    }",
        "@notice": "",
        "@dev": "Make a proposal and add to pending proposals",
        "@param1": "methodId a string representing the function",
        "@param2": "parameter parameter to be used if invocation is approved",
        "@gnotice": "Make a new proposal for a method with `methodId` and `parameter`",
        "@gparam1": "methodId The ID of the method being proposed",
        "@gparam2": "parameter The parameter value for the proposed method",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1,
        "@tparam2": 0
    },
    {
        "func": "function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }",
        "@notice": "Begins transfer of admin rights.",
        "@dev": "The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.",
        "@param1": "newPendingAdmin New pending admin.",
        "@return1": "uint 0=success, otherwise a failure (see ErrorReporter.sol for details)",
        "@gnotice": "Sets `newPendingAdmin` as the new pending administrator of the contract",
        "@gparam1": "newPendingAdmin The address of the new pending administrator",
        "@greturn1": "An error code (0 if successful) indicating if the operation failed and the reason for the failure if applicable",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function createTokens(address recipient) public isUnderHardCap saleIsOn payable {\n    uint rate = exchangeRate.getRate(\"ETH\");\n    uint tokens = rate.mul(msg.value).div(1 ether);\n    token.mint(recipient, tokens);\n    require(multisigVault.send(msg.value));\n    TokenSold(recipient, msg.value, tokens, rate);\n  }",
        "@notice": "",
        "@dev": "create tokens by depositing ether.",
        "@param1": "recipient the recipient to receive tokens.",
        "@gnotice": "Creates tokens for `recipient` in exchange for `msg.value` ether",
        "@gparam1": "recipient The account to receive the newly created tokens. Must be whitelisted.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function getAuthorizer(uint authorizerIndex) external constant returns(address) {\n    return address(authorizers[authorizerIndex + 1]);\n  }",
        "@notice": "",
        "@dev": "get a specific authorizer",
        "@param1": "authorizerIndex index of the authorizer to be retrieved.",
        "@return1": "The address of the authorizer.",
        "@gnotice": "Get the address of the authorizer at index `authorizerIndex`",
        "@gparam1": "authorizerIndex The index of the authorizer to retrieve",
        "@greturn1": "The address of the authorizer at the given index",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function transferAdmin(address newAdmin) external virtual onlyOwner {\n        require(newAdmin != address(0), \"Accessible: zero address\");\n        require(msg.sender != newAdmin, \"Accessible: same admin\");\n\n        grantRole(PROJECT_ADMIN_ROLE, newAdmin);\n        renounceRole(PROJECT_ADMIN_ROLE, msg.sender);\n    }",
        "@notice": "",
        "@dev": "transfer admin",
        "@param1": "newAdmin new admin address",
        "@gnotice": "Transfer the project ownership to `newAdmin`",
        "@gparam1": "newAdmin The address of the new project owner. Must not be the zero address and not the current owner of the project.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function setUserPermission(\n        address to,\n        uint256 id,\n        bool on\n    ) public payable virtual {\n        _authorized();\n\n        _setUserPermission(to, id, on);\n    }",
        "@notice": "ID transfer permission setting",
        "@param1": "to Account to set permission for.",
        "@param2": "id ID to set permission for.",
        "@param3": "on Permission setting.",
        "@dev": "This sets account-based ID restriction specifically.",
        "@gnotice": "Sets permission `on` for address `to` on permit `id`",
        "@gparam1": "to The address of the account for which permission is being set",
        "@gparam2": "id The identification number of the permit being set",
        "@gparam3": "on If `true`, permission is granted. If `false`, permission is revoked.",
        "@tnotice": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tdev": 0
    },
    {
        "func": "function addAdmin(address account) public virtual onlyProxyOwner {\n        grantRole(PROJECT_ADMIN_ROLE, account);\n    }",
        "@notice": "",
        "@dev": "add admin",
        "@param1": "account address to add",
        "@gnotice": "Adds `account` as a project admin role",
        "@gparam1": "account The address being added as a project admin role",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function setPermission(uint256 id, bool on) public payable virtual {\n        _authorized();\n\n        _setPermission(id, on);\n    }",
        "@notice": "ID transfer permission toggle",
        "@param1": "id ID to set permission for.",
        "@param2": "on Permission setting.",
        "@dev": "This sets account-based ID restriction globally.",
        "@gnotice": "Set permission for a given `id` to `on`",
        "@gparam1": "id The identifier of the permission to be set",
        "@gparam2": "on Whether the permission should be enabled (true) or disabled (false)",
        "@tnotice": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tdev": 0
    },
    {
        "func": "function addAuthorized(address _addr) external onlyAuthorized {\n    authorizerIndex[_addr] = authorizers.length;\n    authorizers.length++;\n    authorizers[authorizers.length - 1] = _addr;\n  }",
        "@notice": "",
        "@dev": "add a new authorizer",
        "@param1": "_addr the address to add as a new authorizer.",
        "@gnotice": "Adds `_addr` to the list of authorized addresses",
        "@gparam1": "_addr The address to add to the list of authorized addresses",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function setAltDeposit(uint totalAltDeposits) public onlyOwner {\n    altDeposits = totalAltDeposits;\n  }",
        "@notice": "",
        "@dev": "set the total alt deposit",
        "@param1": "totalAltDeposits total amount ETH equivalent",
        "@gnotice": "Set the value of `altDeposits` to `totalAltDeposits`",
        "@gparam1": "totalAltDeposits The new value for the `altDeposits` variable",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function getPriorVotes(address account, uint256 blockNumber)\n        public\n        view\n        returns (uint96)\n    {\n        require(\n            blockNumber < block.number,\n            \"Comp::getPriorVotes: not yet determined\"\n        );\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }",
        "@notice": "Determine the prior number of votes for an account as of a block number",
        "@dev": "Block number must be a finalized block or else this function will revert to prevent misinformation.",
        "@param1": "account The address of the account to check",
        "@param2": "blockNumber The block number to get the vote balance at",
        "@return1": "The number of votes the account had as of the given block",
        "@gnotice": "Gets the prior voting power of `account` at a specific `blockNumber`",
        "@gparam1": "account The address of the voter",
        "@gparam2": "blockNumber The block number for which to get the voting power",
        "@greturn1": "The prior voting power of `account` at `blockNumber`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function buyXid(uint256 _affCode, uint256 _team)\n        isActivated()\n        isHuman()\n        isWithinLimits(msg.value)\n        public\n        payable\n    {\n        // set up our tx event data and determine if player is new or not\n        Star3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n\n        // fetch player id\n        uint256 _pID = pIDxAddr_[msg.sender];\n\n        // manage affiliate residuals\n        // if no affiliate code was given or player tried to use their own, lolz\n        if (_affCode == 0 || _affCode == _pID)\n        {\n            // use last stored affiliate code\n            _affCode = plyr_[_pID].laff;\n\n        // if affiliate code was given & its not the same as previously stored\n        } else if (_affCode != plyr_[_pID].laff) {\n            // update last affiliate\n            plyr_[_pID].laff = _affCode;\n        }\n\n        // verify a valid team was selected\n        _team = verifyTeam(_team);\n\n        // buy core\n        buyCore(_pID, _affCode, _team, _eventData_);\n    }",
        "@notice": "converts all incoming ethereum to keys.",
        "@dev": " * -functionhash- 0x8f38f309 (using ID for affiliate) * -functionhash- 0x98a0871d (using address for affiliate) * -functionhash- 0xa65b37a1 (using name for affiliate)",
        "@param1": "_affCode the ID/address/name of the player who gets the affiliate fee",
        "@param2": "_team what team is the player playing for?",
        "@gnotice": "Buy XID tokens by sending Ether to the contract",
        "@gparam1": "_affCode The affiliate code of the referrer (optional)",
        "@gparam2": "_team The team selected by the player",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 1,
        "@tparam2": 0
    },
    {
        "func": "function recordExists(bytes32 node) public virtual override view returns (bool) {\n        return records[node].owner != address(0x0);\n    }",
        "@notice": "",
        "@dev": "Returns whether a record has been imported to the registry.",
        "@param1": "node The specified node.",
        "@return1": "Bool if record exists",
        "@gnotice": "Check if a record exists for the given `node`",
        "@gparam1": "node The hash of the node to check for a record",
        "@greturn1": "Whether or not a record exists for the given `node`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }",
        "@notice": "",
        "@dev": "Gets the balance of the specified address.",
        "@param1": "_owner The address to query the the balance of.",
        "@return1": "the amount owned by the passed address.",
        "@gnotice": "Get the token balance of `_owner`",
        "@gparam1": "_owner The address of the account to check",
        "@greturn1": "The balance of tokens held by `_owner`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function previewProgress(uint256 _assetsExternalEndBeforeFees)\n        public\n        view\n        returns (\n            bool shouldTransferToFarm,\n            uint256 totalAssetsToTransfer,\n            bool shouldDepositDelta,\n            uint256 deltaAssets,\n            uint256 managementFee,\n            uint256 assetsExternalEnd\n        )\n    {\n        return previewProgress(_assetsExternalEndBeforeFees, epoch);\n    }",
        "@notice": "preview funds flow from/to contract next epoch",
        "@dev": "assets to transfer = deltaAssets - managementFee * sign shows direction of transfer (true = to farm, false = to contract)",
        "@param1": "_assetsExternalEndBeforeFees amount of external aum before fees",
        "@return1": "shouldTransferToFarm direction of funds to transfer",
        "@return2": "totalAssetsToTransfer amount of assets to transfer",
        "@return3": "shouldDepositDelta true if deltaAssets should be deposited, false if deltaAssets should be redeemed",
        "@return4": "deltaAssets amount of assets to deposit/redeem",
        "@return5": "managementFee amount of management fee for next epoch",
        "@return6": "assetsExternalEnd amount of vault ending aum. assetsExternalEnd = _assetsExternalEndBeforeFees - fees",
        "@gnotice": "Preview the progress of the transfer before executing it",
        "@gparam1": "_assetsExternalEndBeforeFees The number of assets currently held externally before fees",
        "@greturn1": "shouldTransferToFarm Whether or not the transfer of assets to the farm should happen",
        "@greturn2": "totalAssetsToTransfer The total number of assets that will be transferred to the farm",
        "@greturn3": "shouldDepositDelta Whether or not delta assets should be deposited into the farm",
        "@greturn4": "deltaAssets The delta assets to be deposited into the farm",
        "@greturn5": "managementFee The fee charged by the management for performing the transfer",
        "@greturn6": "assetsExternalEnd The number of assets held externally after fees are applied",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0,
        "@treturn2": 0,
        "@treturn3": 0,
        "@treturn4": 0,
        "@treturn5": 0,
        "@treturn6": 0
    },
    {
        "func": "function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external virtual override {\n        bytes32 subnode = setSubnodeOwner(node, label, owner);\n        _setResolverAndTTL(subnode, resolver, ttl);\n    }",
        "@notice": "",
        "@dev": "Sets the record for a subnode.",
        "@param1": "node The parent node.",
        "@param2": "label The hash of the label specifying the subnode.",
        "@param3": "owner The address of the new owner.",
        "@param4": "resolver The address of the resolver.",
        "@param5": "ttl The TTL in seconds.",
        "@gnotice": "Set the owner, resolver, and time-to-live (TTL) for a subdomain of a given node",
        "@gparam1": "node The hash of the parent domain node",
        "@gparam2": "label The hash of the subdomain label to set the record for",
        "@gparam3": "owner The address of the account that will own the subdomain",
        "@gparam4": "resolver The address of the resolver contract to use for the subdomain",
        "@gparam5": "ttl The time-to-live value for the subdomain",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0,
        "@tparam5": 0
    },
    {
        "func": "function wrapEthAndDepositCollateral(BalanceSheetInterface balanceSheet, FyTokenInterface fyToken) public payable {\n        uint256 collateralAmount = msg.value;\n\n        /* Convert the received ETH to WETH. */\n        WethInterface(WETH_ADDRESS).deposit{ value: collateralAmount }();\n\n        /* Deposit the collateral into the BalanceSheet contract. */\n        depositCollateralInternal(balanceSheet, fyToken, collateralAmount);\n    }",
        "@notice": "Wraps ETH into WETH, deposits and locks collateral into the BalanceSheet contract * and borrows fyTokens",
        "@dev": "This is a payable function so it can receive ETH transfers.",
        "@param1": "balanceSheet The address of the BalanceSheet contract.",
        "@param2": "fyToken The address of the FyToken contract.",
        "@gnotice": "Wraps the received Ether into WETH and deposits it as collateral for the respective `fyToken` on the `balanceSheet` contract.",
        "@gparam1": "balanceSheet The address of the BalanceSheet contract responsible for holding the collateral token balance",
        "@gparam2": "fyToken The address of the FyToken contract representing the specific asset",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function addHorseIndex(bytes32 newHorse) external\n    onlyOwner() {\n        _addHorse(newHorse);\n    }",
        "@notice": "",
        "@dev": "Adds a new horse index to the possible horses list",
        "@param1": "newHorse Index of the horse to add",
        "@gnotice": "Add a new horse to the horse index",
        "@gparam1": "newHorse The ID of the new horse to add",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function transferAdmin(address newAdmin) external virtual onlyOwner {\n        require(newAdmin != address(0), \"Accessible: zero address\");\n        require(msg.sender != newAdmin, \"Accessible: same admin\");\n\n        grantRole(ADMIN_ROLE, newAdmin);\n        renounceRole(ADMIN_ROLE, msg.sender);\n    }",
        "@notice": "",
        "@dev": "transfer admin",
        "@param1": "newAdmin new admin address",
        "@gnotice": "Transfers the ownership of the contract administrator",
        "@gparam1": "newAdmin The address of the new administrator to be assigned",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function calcKeysReceived(uint256 _rID, uint256 _eth)\n        public\n        view\n        returns(uint256)\n    {\n        // grab time\n        uint256 _now = now;\n\n        // are we in a round?\n        if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n            return ( (round_[_rID].eth).keysRec(_eth) );\n        else // rounds over.  need keys for new round\n            return ( (_eth).keys() );\n    }",
        "@notice": "returns the amount of keys you would get given an amount of eth.",
        "@dev": " * -functionhash- 0xce89c80c",
        "@param1": "_rID round ID you want price for",
        "@param2": "_eth amount of eth sent in",
        "@return1": "keys received",
        "@gnotice": "Calculate the number of keys that can be received for an amount of ether in a round",
        "@gparam1": "_rID The ID of the round",
        "@gparam2": "_eth The amount of ether to calculate keys for",
        "@greturn1": "The number of keys that can be received for `_eth` in the given round",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function validateOfferItemParameters(\n        OrderParameters memory orderParameters,\n        uint256 offerItemIndex\n    ) public view returns (ErrorsAndWarnings memory errorsAndWarnings) {\n        errorsAndWarnings = ErrorsAndWarnings(new uint16[](0), new uint16[](0));\n\n        // Get the offer item at offerItemIndex\n        OfferItem memory offerItem = orderParameters.offer[offerItemIndex];\n\n        // Check if start amount and end amount are zero\n        if (offerItem.startAmount == 0 && offerItem.endAmount == 0) {\n            errorsAndWarnings.addError(OfferIssue.AmountZero.parseInt());\n            return errorsAndWarnings;\n        }\n\n        // Check that amount velocity is not too high.\n        if (\n            offerItem.startAmount != offerItem.endAmount &&\n            orderParameters.endTime > orderParameters.startTime\n        ) {\n            // Assign larger and smaller amount values\n            (uint256 maxAmount, uint256 minAmount) = offerItem.startAmount >\n                offerItem.endAmount\n                ? (offerItem.startAmount, offerItem.endAmount)\n                : (offerItem.endAmount, offerItem.startAmount);\n\n            uint256 amountDelta = maxAmount - minAmount;\n            // delta of time that order exists for\n            uint256 timeDelta = orderParameters.endTime -\n                orderParameters.startTime;\n\n            // Velocity scaled by 1e10 for precision\n            uint256 velocity = (amountDelta * 1e10) / timeDelta;\n            // gives velocity percentage in hundredth of a basis points per second in terms of larger value\n            uint256 velocityPercentage = velocity / (maxAmount * 1e4);\n\n            // 278 * 60 * 30 ~= 500,000\n            if (velocityPercentage > 278) {\n                // Over 50% change per 30 min\n                errorsAndWarnings.addError(\n                    OfferIssue.AmountVelocityHigh.parseInt()\n                );\n            }\n            // Over 50% change per 30 min\n            else if (velocityPercentage > 28) {\n                // Over 5% change per 30 min\n                errorsAndWarnings.addWarning(\n                    OfferIssue.AmountVelocityHigh.parseInt()\n                );\n            }\n\n            // Check for large amount steps\n            if (minAmount <= 1e15) {\n                errorsAndWarnings.addWarning(\n                    OfferIssue.AmountStepLarge.parseInt()\n                );\n            }\n        }\n\n        if (offerItem.itemType == ItemType.ERC721) {\n            // ERC721 type requires amounts to be 1\n            if (offerItem.startAmount != 1 || offerItem.endAmount != 1) {\n                errorsAndWarnings.addError(ERC721Issue.AmountNotOne.parseInt());\n            }\n\n            // Check the EIP165 token interface\n            if (!checkInterface(offerItem.token, ERC721_INTERFACE_ID)) {\n                errorsAndWarnings.addError(ERC721Issue.InvalidToken.parseInt());\n            }\n        } else if (offerItem.itemType == ItemType.ERC721_WITH_CRITERIA) {\n            // Check the EIP165 token interface\n            if (!checkInterface(offerItem.token, ERC721_INTERFACE_ID)) {\n                errorsAndWarnings.addError(ERC721Issue.InvalidToken.parseInt());\n            }\n\n            if (offerItem.startAmount > 1 || offerItem.endAmount > 1) {\n                // Require partial fill enabled. Even orderTypes are full\n                if (uint8(orderParameters.orderType) % 2 == 0) {\n                    errorsAndWarnings.addError(\n                        ERC721Issue.CriteriaNotPartialFill.parseInt()\n                    );\n                }\n            }\n        } else if (\n            offerItem.itemType == ItemType.ERC1155 ||\n            offerItem.itemType == ItemType.ERC1155_WITH_CRITERIA\n        ) {\n            // Check the EIP165 token interface\n            if (!checkInterface(offerItem.token, ERC1155_INTERFACE_ID)) {\n                errorsAndWarnings.addError(\n                    ERC1155Issue.InvalidToken.parseInt()\n                );\n            }\n        } else if (offerItem.itemType == ItemType.ERC20) {\n            // ERC20 must have `identifierOrCriteria` be zero\n            if (offerItem.identifierOrCriteria != 0) {\n                errorsAndWarnings.addError(\n                    ERC20Issue.IdentifierNonZero.parseInt()\n                );\n            }\n\n            // Validate contract, should return an uint256 if its an ERC20\n            if (\n                !offerItem.token.safeStaticCallUint256(\n                    abi.encodeWithSelector(\n                        ERC20Interface.allowance.selector,\n                        address(seaport),\n                        address(seaport)\n                    ),\n                    0\n                )\n            ) {\n                errorsAndWarnings.addError(ERC20Issue.InvalidToken.parseInt());\n            }\n        } else {\n            // Must be native\n            // NATIVE must have `token` be zero address\n            if (offerItem.token != address(0)) {\n                errorsAndWarnings.addError(NativeIssue.TokenAddress.parseInt());\n            }\n\n            // NATIVE must have `identifierOrCriteria` be zero\n            if (offerItem.identifierOrCriteria != 0) {\n                errorsAndWarnings.addError(\n                    NativeIssue.IdentifierNonZero.parseInt()\n                );\n            }\n        }\n    }",
        "@notice": "Validates the OfferItem parameters.",
        "@dev": "OfferItems with criteria are currently not allowed",
        "@param1": "orderParameters The parameters for the order to validate",
        "@param2": "offerItemIndex The index of the offerItem in offer array to validate",
        "@return1": "errorsAndWarnings An ErrorsAndWarnings structs with results",
        "@gnotice": "This function validates the parameters of an order item in a Dutch auction",
        "@gparam1": "orderParameters The struct containing the parameters of the order",
        "@gparam2": "offerItemIndex The index of the offer item being validated",
        "@greturn1": "An ErrorsAndWarnings struct containing any errors or warnings encountered during validation",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function getApproved(\n    uint256 _tokenId\n  )\n    external\n    override\n    view\n    validNFToken(_tokenId)\n    returns (address)\n  {\n    return idToApproval[_tokenId];\n  }",
        "@notice": "",
        "@dev": "Get the approved address for a single NFT.",
        "@param1": "_tokenId ID of the NFT to query the approval of.",
        "@return1": "Address that _tokenId is approved for.",
        "@gnotice": "Returns the approved address for a specific NFT",
        "@gparam1": "_tokenId uint256 ID of the NFT",
        "@greturn1": "The approved address for the specified NFT",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function removeAddressesFromWhitelist(address[] memory addrs)\n        public\n        onlyOwner\n        returns (bool success)\n    {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (removeAddressFromWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }",
        "@notice": "",
        "@dev": "remove addresses from the whitelist",
        "@param1": "addrs addresses",
        "@return1": "success if at least one address was removed from the whitelist, * false if all addresses weren't in the whitelist in the first place",
        "@gnotice": "Removes a list of addresses from the whitelist",
        "@gparam1": "addrs An array of addresses to be removed from the whitelist",
        "@greturn1": "success A boolean indicating whether or not the removal was successful",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function manageTrades(\n        address account,\n        bytes32 hash\n    ) public {\n        unchecked {\n            // Check if the caller has access.\n            if (msg.sender != account && !isApprovedForAll(account, msg.sender)) revert RESTRICTED_ACCESS();\n\n            if (hash == 0x0000000000000000000000000000000000000000000000000000000000000000) { // Unlock trades.\n                delete _account[account].timestampTradesLocked;\n            } else if (hash == 0x0000000000000000000000000000000000000000000000000000000000000001) { // Lock trades.\n                _account[account].timestampTradesLocked = _safeBlockTimestamp();\n            } else if (_account[account].timestampTradeHashUsed[hash] == 0) { // Cancel trade if not cancelled.\n                // The block timestamp is multiplied by 10 to store a binary number. 0 means cancelled. 1 means completed.\n                _account[account].timestampTradeHashUsed[hash] = block.timestamp * 10;\n            } else {\n                revert RESTRICTED_ACCESS();\n            }\n\n            uint256[] memory empty = new uint256[](0); // Empty array.\n\n            // msg.sender is `taker` when isTrade is false, which can be an account operator.\n            emit Trade(             // 0x10d92c47650ef2b2a841f26c951f4391ccbb731e57d36a67665a0d138e08ef09\n                hash,               // address indexed hash\n                account,            // address indexed maker\n                msg.sender,         // address indexed taker\n                empty,              // uint256[] makerIds\n                empty,              // uint256[] takerIds\n                0,                  // uint256 price\n                0,                  // uint256 expiry\n                block.timestamp,    // uint256 timestamp\n                false               // bool isTrade\n            );\n        }\n    }",
        "@notice": "Cancel a trade or lock/unlock your trades",
        "@dev": "This has no effect on third-party NFT marketplaces. * Locking your trades prevents others from completing them. * Trades that auto-expire will continue to countdown when they're locked.",
        "@param1": "account The account to manage the trades of.",
        "@param2": "hash The hash of the trade to cancel. 0 bytes to unlock trades. 1 byte to lock trades.",
        "@gnotice": "Manage trades by locking or unlocking them, cancelling existing trades, or restricting caller access",
        "@gparam1": "account The address of the account to manage trades for",
        "@gparam2": "hash The hash of the trade to manage",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)\n        isActivated()\n        isHuman()\n        isWithinLimits(_eth)\n        public\n    {\n        // set up our tx event data\n        F3Ddatasets.EventReturns memory _eventData_;\n\n        // fetch player ID\n        uint256 _pID = pIDxAddr_[msg.sender];\n\n        // manage affiliate residuals\n        // if no affiliate code was given or player tried to use their own, lolz\n        if (_affCode == 0 || _affCode == _pID)\n        {\n            // use last stored affiliate code\n            _affCode = plyr_[_pID].laff;\n\n        // if affiliate code was given & its not the same as previously stored\n        } else if (_affCode != plyr_[_pID].laff) {\n            // update last affiliate\n            plyr_[_pID].laff = _affCode;\n        }\n\n        // verify a valid team was selected\n        _team = verifyTeam(_team);\n\n        // reload core\n        reLoadCore(_pID, _affCode, _team, _eth, _eventData_);\n    }",
        "@notice": "",
        "@dev": "essentially the same as buy, but instead of you sending ether * from your wallet, it uses your unwithdrawn earnings. * -functionhash- 0x349cdcac (using ID for affiliate) * -functionhash- 0x82bfc739 (using address for affiliate) * -functionhash- 0x079ce327 (using name for affiliate)",
        "@param1": "_affCode the ID/address/name of the player who gets the affiliate fee",
        "@param2": "_team what team is the player playing for?",
        "@param3": "_eth amount of earnings to use (remainder returned to gen vault)",
        "@gnotice": "Reload `Xid` smart contract with `_eth` value and update player's affiliate and team",
        "@gparam1": "_affCode The affiliate ID for the player",
        "@gparam2": "_team The ID of the team player selects",
        "@gparam3": "_eth The ether value for reload",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0
    },
    {
        "func": "function updateStartTime(uint256 roundId, uint256 newStartTime)\n        external\n        onlyOwner\n    {\n        if (roundId > roundsCounter) {\n            revert RoundNotFound(\"TokenSale: Round not found\");\n        }\n        TokenSaleRound storage tokenSaleRound = rounds[roundId];\n        if (tokenSaleRound.startTime < block.timestamp) {\n            revert RoundIsStarted(\"TokenSale: Round is started\");\n        }\n\n        tokenSaleRound.startTime = newStartTime;\n        tokenSaleRound.endTime = newStartTime + tokenSaleRound.duration;\n        emit UpdateRoundStartTime(\n            roundId,\n            tokenSaleRound.startTime,\n            tokenSaleRound.endTime\n        );\n    }",
        "@notice": "update token sale round start time.",
        "@dev": "Only owner can call it. Only if round is not started.",
        "@param1": "roundId tokeSale round id.",
        "@param2": "newStartTime new start time timestamp",
        "@gnotice": "Update the start time and end time of a token sale round",
        "@gparam1": "roundId The ID of the token sale round to be updated",
        "@gparam2": "newStartTime The new start time for the token sale round",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }",
        "@notice": "",
        "@dev": "transfer control of the contract to `newOwner`.",
        "@param1": "newOwner The address to transfer ownership to.",
        "@gnotice": "Transfer contract ownership to a new address",
        "@gparam1": "newOwner The new owner address of the contract",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function rescueFundsFromStakingPool(\n        address tokenToRescue,\n        address to,\n        uint256 amount\n    ) public onlyOwner returns (bool) {\n        return _stakingPool.rescueFunds(tokenToRescue, to, amount);\n    }",
        "@notice": "",
        "@dev": "Lets the owner rescue funds air-dropped to the staking pool.",
        "@param1": "tokenToRescue Address of the token to be rescued.",
        "@param2": "to Address to which the rescued funds are to be sent.",
        "@param3": "amount Amount of tokens to be rescued.",
        "@return1": "Transfer success.",
        "@gnotice": "Allows the owner to rescue `amount` of `tokenToRescue` from the staking pool and send it to `to`.",
        "@gparam1": "tokenToRescue The address of the token to be rescued.",
        "@gparam2": "to The address of the destination account.",
        "@gparam3": "amount The number of tokens to be rescued.",
        "@greturn1": "Whether or not the rescue operation succeeded.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@treturn1": 1
    },
    {
        "func": "function setApprovalForAll(address operator, bool approved) external virtual override {\n        operators[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }",
        "@notice": "This works even if sender doesn't own any tokens at the time",
        "@dev": "Enable or disable approval for a third party (\"operator\") to manage * all of `msg.sender`'s ENS records. Emits the ApprovalForAll event.",
        "@param1": "operator Address to add to the set of authorized operators.",
        "@param2": "approved True if the operator is approved, false to revoke approval.",
        "@gnotice": "Approve or revoke approval for the `operator` to manage all assets on behalf of the `msg.sender`",
        "@gparam1": "operator The address of the operator",
        "@gparam2": "approved The approval status for the operator",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function updatePendingDepositState(address _user) public {\n        // @dev check if user has already stored assets\n        if (userHasPendingDeposit(_user)) {\n            // @dev user should already have shares here, let's increment\n            vaultUsers[_user].vaultShares += previewDepositEpoch(\n                vaultUsers[_user].assetsDeposited,\n                vaultUsers[_user].epochLastDeposited + 1\n            );\n\n            vaultUsers[_user].assetsDeposited = 0;\n            vaultUsers[_user].epochLastDeposited = 0;\n        }\n    }",
        "@notice": "update VaultUser's data if they have pending deposits",
        "@param1": "_user address of the VaultUser",
        "@dev": "after this, last deposit epoch = 0, assetDeposited = 0 * can be manually called",
        "@gnotice": "Updates the state of a pending deposit for a user",
        "@gparam1": "_user Address of the user",
        "@tnotice": 0,
        "@tparam1": 0,
        "@tdev": 0
    },
    {
        "func": "function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external virtual override {\n        setOwner(node, owner);\n        _setResolverAndTTL(node, resolver, ttl);\n    }",
        "@notice": "",
        "@dev": "Sets the record for a node.",
        "@param1": "node The node to update.",
        "@param2": "owner The address of the new owner.",
        "@param3": "resolver The address of the resolver.",
        "@param4": "ttl The TTL in seconds.",
        "@gnotice": "Set the owner, resolver, and time-to-live (TTL) parameters for a specified node in the Namecoin registrar",
        "@gparam1": "node The node name to set the parameters for",
        "@gparam2": "owner The address of the account that will own the node",
        "@gparam3": "resolver The address of the resolver contract for the node",
        "@gparam4": "ttl The time-to-live value for the node",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0
    },
    {
        "func": "function preapprovedServiceStatus(address account) external view returns (uint256 status) {\n        return _account[account].preapprovedStatus;\n    }",
        "@notice": "Returns the status for a preapproved service",
        "@dev": "SuperCollectiv can only manage services preapproved in the constructor. * 0x1E0049783F008A0085193E00003D00cd54003c71 (OpenSea). * 0xF849de01B080aDC3A814FaBE1E2087475cF2E354 (X2Y2). * 0xf42aa99F011A1fA7CDA90E5E98b277E306BcA83e (LooksRare). * 0x4feE7B061C97C9c496b01DbcE9CDb10c02f0a0Be (Rarible). * 0xDef1C0ded9bec7F1a1670819833240f027b25EfF (0x Protocol, Coinbase NFT, and more). * 0x20F780A973856B93f63670377900C1d2a50a77c4 (Element). * 0x2B2e8cDA09bBA9660dCA5cB6233787738Ad68329 (SudoSwap). * 0x0fc584529a2AEfA997697FAfAcbA5831faC0c22d (NFTX). * 0x657E383EdB9A7407E468acBCc9Fe4C9730c7C275 (NFTTrader).",
        "@param1": "account The address of the account.",
        "@return1": "status 0 = service is permanently disabled, 1 = service is temporarily disabled, 2 = service is enabled.",
        "@gnotice": "Get the pre-approved service status of an account",
        "@gparam1": "account The address of the account to query",
        "@greturn1": "The pre-approved service status of the account.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 1
    },
    {
        "func": "function setRarityMultiplier(uint8 newRarityMultiplier) external \n    onlyOwner()  {\n        rarityMultiplier = newRarityMultiplier;\n    }",
        "@notice": "",
        "@dev": "Changes multiplier for rarity on feed",
        "@gnotice": "Set the rarity multiplier to `newRarityMultiplier`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }",
        "@notice": "",
        "@dev": "transfer control of the contract to a newOwner.",
        "@param1": "_newOwner The address to transfer ownership to.",
        "@gnotice": "Transfers ownership of the contract to a new account (`_newOwner`)",
        "@gparam1": "_newOwner The address of the new owner",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function transferPaladinOwnership(address newPaladin) external \n    validAddress(newPaladin) {\n        require(paladinAddress == msg.sender,\"Not right role\");\n        _moveBalance(newPaladin);\n        paladinAddress = newPaladin;\n    }",
        "@notice": "",
        "@dev": "Transfers paladin ownership to a new address",
        "@param1": "newPaladin the new address",
        "@gnotice": "Transfer ownership of the contract to a new address",
        "@gparam1": "newPaladin The address of the new owner",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function startContractChange(bytes32 _id, address _newContractAddr) public onlyOwner {\n        require(entries[_id].exists, ERR_ENTRY_NON_EXISTENT);\n        require(!entries[_id].inWaitPeriodChange, ERR_ALREADY_IN_WAIT_PERIOD_CHANGE);\n\n        entries[_id].changeStartTime = block.timestamp; // solhint-disable-line\n        entries[_id].inContractChange = true;\n\n        pendingAddresses[_id] = _newContractAddr;\n\n        logger.Log(\n            address(this),\n            msg.sender,\n            \"StartContractChange\",\n            abi.encode(_id, entries[_id].contractAddr, _newContractAddr)\n        );\n    }",
        "@notice": "Starts an address change for an existing entry",
        "@dev": "Can override a change that is currently in progress",
        "@param1": "_id Id of contract",
        "@param2": "_newContractAddr Address of the new contract",
        "@gnotice": "Initiate a change in contract address linked to the entry `_id`",
        "@gparam1": "_id Identifier of the contract entry",
        "@gparam2": "_newContractAddr The new contract address to be linked to the entry `_id`",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function accountDataByCategory(address[] memory accounts, uint256 category)\n        external\n        view\n        returns (uint256[] memory data)\n    {\n        unchecked {\n\n            // The following categories can be queried from logs.\n            // tokensMinted\n            // mintedFree\n            // mintedHourlyDrops\n            // mintedSacrifices\n            // mintedReferrals\n            // mintedGiveaway\n            // mintedBogos\n            // mintedSpecial\n            // referralPurchases\n            // timestampHourlyDropLastClaimed\n            // timestampReferralLinkUsed\n\n            // Use {accountData} for claimable specifics.\n            // claimableHourlyDrops\n            // claimableSacrifices\n            // claimableReferrals\n            // claimableGiveaway\n\n            uint256 accountsAmount = accounts.length;\n            if (category == 0) {\n                // Owned, burned, optimized, purchased.\n                // Data for the leaderboards.\n                uint256 amount = 4;\n                data = new uint256[](accountsAmount * amount);\n                for (uint256 i; i < accountsAmount; i++) {\n                    data[i * amount] = balanceOf(accounts[i]);\n                    data[i * amount + 1] = _account[accounts[i]].tokensBurned;\n                    data[i * amount + 2] = _account[accounts[i]].tokensOptimized;\n                    data[i * amount + 3] = _account[accounts[i]].mintedPurchase;\n                }\n            } else if (category == 1) {\n                // Owned, burned, optimized.\n                // Alternative for category 0 because purchases can be retrieved from past logs.\n                uint256 amount = 3;\n                data = new uint256[](accountsAmount * amount);\n                for (uint256 i; i < accountsAmount; i++) {\n                    data[i * amount] = balanceOf(accounts[i]);\n                    data[i * amount + 1] = _account[accounts[i]].tokensBurned;\n                    data[i * amount + 2] = _account[accounts[i]].tokensOptimized;\n                }\n            } else if (category == 2) {\n                // Total claimable.\n                data = new uint256[](accountsAmount);\n                for (uint256 i; i < accountsAmount; i++) {\n                    (\n                        ,\n                        uint256 claimableHourlyDrops, \n                        uint256 claimableSacrifices, \n                        uint256 claimableReferrals, \n                        uint256 claimableGiveaway\n                    ) = _accountToClaimable(accounts[i]);\n                    data[i] = claimableHourlyDrops + claimableSacrifices + claimableReferrals + claimableGiveaway;\n                }\n            } else if (category == 3) {\n                // Timestamp trades locked.\n                data = new uint256[](accountsAmount);\n                for (uint256 i; i < accountsAmount; i++) {\n                    data[i] = _account[accounts[i]].timestampTradesLocked;\n                }\n            } else {\n                // Wallet balance and is contract.\n                uint256 amount = 2;\n                data = new uint256[](accountsAmount * amount);\n                for (uint256 i; i < accountsAmount; i++) {\n                    data[i * amount] = address(accounts[i]).balance;\n                    if (_isContractPastConstruction(accounts[i])) data[i * amount + 1] = 1;\n                }\n            }\n            return data;\n        }\n    }",
        "@notice": "Account data for multiple accounts by categor",
        "@dev": "See past event logs for more data. Use {addressesToENS} for ENS names. * The zero address cannot have an account and returns from it should be ignored. This is not checked to optimize calls.",
        "@param1": "accounts The addresses of the accounts.",
        "@param2": "category (0: owned, burned, optimized, purchased), (1: owned, burned, optimized), 2 total claimable, 3 trades locked, (4: wallet balance, is contract)",
        "@return1": "data The uint data of all accounts, based on the category.",
        "@gnotice": "Get account data by category for given accounts",
        "@gparam1": "accounts An array of account addresses to get data for",
        "@gparam2": "category The category of data to retrieve (0, 1, 2, 3 or 4)",
        "@greturn1": "An array of uint256 values representing the requested account data by category",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 1,
        "@treturn1": 0
    },
    {
        "func": "function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n        }\n\n        // Save current value for use in log\n        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n        // Set liquidation incentive to new incentive\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n        // Emit event with old incentive, new incentive\n        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n        return uint(Error.NO_ERROR);\n    }",
        "@notice": "Sets liquidationIncentive",
        "@dev": "Admin function to set liquidationIncentive",
        "@param1": "newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18",
        "@return1": "uint 0=success, otherwise a failure. (See ErrorReporter for details)",
        "@gnotice": "Sets the liquidation incentive (`newLiquidationIncentiveMantissa`) for the contract",
        "@gparam1": "newLiquidationIncentiveMantissa The new value for the liquidation incentive",
        "@greturn1": "An unsigned integer representing an error code (0 on success)",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 1
    },
    {
        "func": "function setExchangeRate(address _exchangeRate) public onlyOwner {\n    exchangeRate = ExchangeRate(_exchangeRate);\n  }",
        "@notice": "",
        "@dev": "set the exchangerate contract.",
        "@param1": "_exchangeRate the exchangerate address",
        "@gnotice": "Sets the address of the `ExchangeRate` contract used to determine the exchange rate",
        "@gparam1": "_exchangeRate The address of the `ExchangeRate` contract to use for determining the exchange rate",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function freeForCarrots(uint256 tokenId) external \n    whenNotPaused()\n    onlyOwnerOf(tokenId) {\n        require(pendingFeedings[msg.sender].horsey != tokenId,\"\");\n        //credit carrots\n        uint8 feedingCounter;\n        (,,feedingCounter,) = stables.horseys(tokenId);\n        stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) + uint32(feedingCounter * carrotsMultiplier));\n        stables.unstoreHorsey(tokenId);\n        emit HorseyFreed(tokenId);\n    }",
        "@notice": "",
        "@dev": "burn a token he owns to get carrots",
        "@param1": "tokenId ID of the token to burn",
        "@gnotice": "Free up a horsey with the given `tokenId` for carrots",
        "@gparam1": "tokenId ID of the horsey to be freed up",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function setBurner(address newBurner) external onlyOwner {\n        burner = newBurner;\n        emit NewBurner(newBurner);\n    }",
        "@notice": "change the contract burner.",
        "@dev": "Allowed only for owner * * Emits a { NewBurner } event",
        "@param1": "newBurner The address of the new burner",
        "@gnotice": "Set the address of the burner to `newBurner`",
        "@gparam1": "newBurner The new burner address",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function transferOwnership(\n    address _newOwner\n  )\n    public\n    onlyOwner\n  {\n    require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }",
        "@notice": "",
        "@dev": "transfer control of the contract to a newOwner.",
        "@param1": "_newOwner The address to transfer ownership to.",
        "@gnotice": "Transfer ownership of the contract to `_newOwner`",
        "@gparam1": "_newOwner The address of the new contract owner, must not be a zero address.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function depositAndLockCollateralAndBorrow(\n        BalanceSheetInterface balanceSheet,\n        FyTokenInterface fyToken,\n        uint256 collateralAmount,\n        uint256 borrowAmount\n    ) public payable {\n        depositAndLockCollateral(balanceSheet, fyToken, collateralAmount);\n        borrow(fyToken, borrowAmount);\n    }",
        "@notice": "Deposits and locks collateral into the vault via the BalanceSheet contract, borrows fyTokens and sells them on Balancer in exchange for underlying",
        "@dev": "This is a payable function so it can receive ETH transfers. * * Requirements: * - The caller must have allowed the DSProxy to spend `collateralAmount` tokens.",
        "@param1": "balanceSheet The address of the BalanceSheet contract.",
        "@param2": "fyToken The address of the FyToken contract.",
        "@param3": "collateralAmount The amount of collateral to deposit and lock.",
        "@param4": "borrowAmount The amount of fyTokens to borrow.",
        "@gnotice": "Deposit `collateralAmount` tokens, lock them on the balance sheet of `balanceSheet`, and borrow `borrowAmount` tokens from `fyToken` by supplying the deposited collateral as collateral. `msg.sender` should include a `payable` amount of ETH to fund the deposit.",
        "@gparam1": "balanceSheet The address of the balance sheet contract where the collateral will be locked and used for the borrow",
        "@gparam2": "fyToken The address of the FyToken contract to borrow from",
        "@gparam3": "collateralAmount The amount of tokens to deposit and lock as collateral",
        "@gparam4": "borrowAmount The amount of tokens to borrow",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0
    },
    {
        "func": "function withdrawCollateral(\n    address _asset,\n    uint256 _amount,\n    uint256 _slippage,\n    address _to\n  ) external virtual {\n    // Before withdraw from lending pool, get the stAsset address and withdrawal amount\n    // Ex: In Lido vault, it will return stETH address and same amount\n    (address _stAsset, uint256 _stAssetAmount) = _getWithdrawalAmount(_asset, _amount);\n\n    // withdraw from lendingPool, it will convert user's aToken to stAsset\n    uint256 _amountToWithdraw = ILendingPool(_addressesProvider.getLendingPool()).withdrawFrom(\n      _stAsset,\n      _stAssetAmount,\n      msg.sender,\n      address(this)\n    );\n\n    // Withdraw from vault, it will convert stAsset to asset and send to user\n    // Ex: In Lido vault, it will return ETH or stETH to user\n    uint256 withdrawAmount = _withdrawFromYieldPool(_asset, _amountToWithdraw, _to);\n\n    if (_amount == type(uint256).max) {\n      uint256 decimal;\n      if (_asset == address(0)) {\n        decimal = 18;\n      } else {\n        decimal = IERC20Detailed(_asset).decimals();\n      }\n\n      _amount = (_amountToWithdraw * this.pricePerShare()) / 10**decimal;\n    }\n    require(\n      withdrawAmount >= _amount.percentMul(PercentageMath.PERCENTAGE_FACTOR - _slippage),\n      Errors.VT_WITHDRAW_AMOUNT_MISMATCH\n    );\n\n    emit WithdrawCollateral(_asset, _to, _amount);\n  }",
        "@notice": "",
        "@dev": "Withdraw an `amount` of asset used as collateral to user.",
        "@param1": "_asset The asset address for collateral * _asset = 0x0000000000000000000000000000000000000000 means to use ETH as collateral",
        "@param2": "_amount The amount to be withdrawn",
        "@param3": "_slippage The slippage of the withdrawal amount. 1% = 100",
        "@param4": "_to Address that will receive the underlying, same as msg.sender if the user * wants to receive it on his own wallet, or a different address if the beneficiary is a * different wallet",
        "@gnotice": "Allows a user to withdraw collateral by converting aToken to stAsset and then stAsset to original asset and sends it to `_to`",
        "@gparam1": "_asset The address of the underlying asset being withdrawn",
        "@gparam2": "_amount The amount of the underlying asset being withdrawn",
        "@gparam3": "_slippage The maximum slippage that the user is willing to accept",
        "@gparam4": "_to The address where the withdrawn asset will be sent",
        "@greturn1": "This function does not return anything",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0
    },
    {
        "func": "function burn(address account, uint256 amount) external {\n        require(_msgSender() == burner, \"BackedToken: Only burner\");\n        require(account == _msgSender() || account == address(this), \"BackedToken: Cannot burn account\");\n        _burn(account, amount);\n    }",
        "@notice": "burn tokens",
        "@dev": "Allowed only for burner. The burned tokens * must be from the burner (msg.sender), or from the contract itself",
        "@param1": "account The account from which the tokens will be burned",
        "@param2": "amount The amount of tokens to be burned",
        "@gnotice": "Burn `amount` tokens from the `account` address",
        "@gparam1": "account The address from which tokens will be burned",
        "@gparam2": "amount The number of tokens to burn",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function setStables(address _token) external\n    onlyOwner()\n    {\n        require(address(_token) != 0,\"Address of token is zero\");\n        token = ERC721Basic(_token);\n    }",
        "@notice": "",
        "@dev": "Since the exchange requires the horsey contract and horsey contract requires exchange address, we cant initialize both of them in constructors",
        "@param1": "_token Address of the stables contract",
        "@gnotice": "Set the `_token` address as the contract address for the Stable tokens",
        "@gparam1": "_token The address of the ERC721 token to be set as the contract address for Stable tokens.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function setBondingContractAddress(address _bondingContractAddress)\n        external\n        onlyAdmin\n    {\n        bondingContractAddress = _bondingContractAddress;\n    }",
        "@notice": "set the bonding bontract smart contract address",
        "@dev": "bonding contract participants deposit curve LP token for a certain duration to earn uGOV and more curve LP token",
        "@param1": "_bondingContractAddress bonding contract address",
        "@gnotice": "Sets the address of the bonding contract to `_bondingContractAddress`",
        "@gparam1": "_bondingContractAddress The new address of the bonding contract.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function blockchainExchangeFrom(\n    address _from,\n    uint256 _amount, \n    uint256 _network, \n    bytes32 _adr\n  ) public \n  {\n    require(_amount <= allowed[_from][msg.sender], \"Used didn't allow sender to interact with balance\");\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n    _burn(_from, _amount);\n    emit BlockchainExchange(\n      msg.sender, \n      _amount, \n      _network,\n      _adr\n    );\n  }",
        "@notice": "",
        "@dev": "burn allowed tokens from special address and rise event for burn tokens in another network",
        "@param1": "_from The address of holder",
        "@param2": "_amount The amount of tokens that will burn",
        "@param3": "_network The index of target network.",
        "@param4": "_adr The address in new network",
        "@gnotice": "Move tokens from the `_from` address to the contract to represent an exchange action on a different blockchain",
        "@gparam1": "_from The address to take the tokens from",
        "@gparam2": "_amount The amount of tokens to exchange",
        "@gparam3": "_network The integer representing a specific blockchain network",
        "@gparam4": "_adr The address on the specific blockchain network",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0
    },
    {
        "func": "function transferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n    external\n    override\n    canTransfer(_tokenId)\n    validNFToken(_tokenId)\n  {\n    address tokenOwner = idToOwner[_tokenId];\n    require(tokenOwner == _from, NOT_OWNER);\n    require(_to != address(0), ZERO_ADDRESS);\n\n    _transfer(_to, _tokenId);\n  }",
        "@notice": "The caller is responsible to confirm that `_to` is capable of receiving NFTs or else",
        "@dev": "Throws unless `msg.sender` is the current owner, an authorized operator, or the approved * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.",
        "@param1": "_from The current owner of the NFT.",
        "@param2": "_to The new owner.",
        "@param3": "_tokenId The NFT to transfer.",
        "@gnotice": "Transfer token with ID `_tokenId` from `_from` to `_to` account",
        "@gparam1": "_from The address of the account from which the token will be transferred",
        "@gparam2": "_to The address of the account to which the token will be transferred",
        "@gparam3": "_tokenId The ID of the token to be transferred",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0
    },
    {
        "func": "function _setPendingAdmin(address payable newPendingAdmin) external override returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }",
        "@notice": "begin change of admin.",
        "@dev": "The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.",
        "@param1": "newPendingAdmin New pending admin.",
        "@return1": "uint 0=success, otherwise a failure",
        "@gnotice": "Sets a new address as the pending admin",
        "@gparam1": "newPendingAdmin The address of the new pending admin",
        "@greturn1": "An error code (0 if successful)",
        "@tnotice": 1,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function registerAddressesProvider(address provider, uint256 id) external override onlyOwner {\n    require(id != 0, Errors.LPAPR_INVALID_ADDRESSES_PROVIDER_ID);\n\n    _addressesProviders[provider] = id;\n    _addToAddressesProvidersList(provider);\n    emit AddressesProviderRegistered(provider);\n  }",
        "@notice": "",
        "@dev": "Registers an addresses provider",
        "@param1": "provider The address of the new LendingPoolAddressesProvider",
        "@param2": "id The id for the new LendingPoolAddressesProvider, referring to the market it belongs to",
        "@gnotice": "Register an addresses provider contract",
        "@gparam1": "provider Address of the contract implementing the AddressesProvider interface",
        "@gparam2": "id ID of the addresses provider contract",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n    totalSupply = totalSupply.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    Mint(_to, _amount);\n    Transfer(0x0, _to, _amount);\n    return true;\n  }",
        "@notice": "",
        "@dev": "mint tokens",
        "@param1": "_to The address that will receive the minted tokens.",
        "@param2": "_amount The amount of tokens to mint.",
        "@return1": "A boolean that indicates if the operation was successful.",
        "@gnotice": "Mint `_amount` tokens and assign them to `_to`",
        "@gparam1": "_to The address of the account to receive the minted tokens",
        "@gparam2": "_amount The number of tokens to mint",
        "@greturn1": "Whether or not the minting succeeded",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function getApproved(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (address)\n    {\n        _revertIfTokenIsInvalid(tokenId);\n        return _token[tokenId].approval;\n    }",
        "@notice": "",
        "@dev": "Get all approved token operators with {tokenDataByCategory} category 1.",
        "@param1": "tokenId The token ID of the CryptoBlob.",
        "@return1": "The address of the account that can manage `tokenId`.",
        "@gnotice": "Get the approved address for a specific token",
        "@gparam1": "tokenId The ID of the token",
        "@greturn1": "The address approved to transfer the token, or zero address if no approval is set",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function getOwnedTokens(address eth_address) public view returns (uint256[]) {\n        return stables.getOwnedTokens(eth_address);\n    }",
        "@notice": "",
        "@dev": "Gets the complete list of token ids which belongs to an address",
        "@param1": "eth_address The address you want to lookup owned tokens from",
        "@return1": "List of all owned by eth_address tokenIds",
        "@gnotice": "Get an array of stablecoin IDs owned by `eth_address`",
        "@gparam1": "eth_address The address of the user to query",
        "@greturn1": "An array of `uint256` values representing the IDs of the stablecoins owned by `eth_address`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function supplyUnderlyingAndRepayBorrow(FyTokenInterface fyToken, uint256 underlyingAmount) external {\n        uint256 preFyTokenBalance = fyToken.balanceOf(address(this));\n        supplyUnderlyingInternal(fyToken, underlyingAmount);\n\n        /* Calculate how many fyTokens have been minted. */\n        uint256 postFyTokenBalance = fyToken.balanceOf(address(this));\n        MathError mathErr;\n        uint256 fyTokenAmount;\n        (mathErr, fyTokenAmount) = subUInt(postFyTokenBalance, preFyTokenBalance);\n        require(mathErr == MathError.NO_ERROR, \"ERR_SUPPLY_UNDERLYING_AND_REPAY_BORROW_MATH_ERROR\");\n\n        /* Use the newly minted fyTokens to repay the debt. */\n        fyToken.repayBorrow(fyTokenAmount);\n    }",
        "@notice": "Supplies the underlying to the RedemptionPool contract, mints fyTokens and repays the borrow",
        "@dev": "Requirements: * - The caller must have allowed the DSProxy to spend `underlyingAmount` tokens.",
        "@param1": "fyToken The address of the FyToken contract.",
        "@param2": "underlyingAmount The amount of underlying to supply.",
        "@gnotice": "This function supplies `underlyingAmount` of underlying tokens to `fyToken` and uses the corresponding amount of newly minted `fyToken` to repay the debt",
        "@gparam1": "fyToken The address of the targeted fToken",
        "@gparam2": "underlyingAmount The amount of underlying tokens to be supplied",
        "@gparam3": "amount The number of tokens to transfer",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function sellUnderlyingAndRepayBorrow(\n        FyTokenInterface fyToken,\n        uint256 underlyingAmount,\n        uint256 repayAmount\n    ) external {\n        Erc20Interface underlying = fyToken.underlying();\n\n        /* Transfer the underlying to the DSProxy. */\n        underlying.safeTransferFrom(msg.sender, address(this), underlyingAmount);\n\n        /* Allow the Balancer contract to spend underlying if allowance not enough. */\n        uint256 allowance = underlying.allowance(address(this), EXCHANGE_PROXY_ADDRESS);\n        if (allowance < underlyingAmount) {\n            underlying.approve(EXCHANGE_PROXY_ADDRESS, type(uint256).max);\n        }\n\n        /* Prepare the parameters for calling Balancer. */\n        TokenInterface tokenIn = TokenInterface(address(underlying));\n        TokenInterface tokenOut = TokenInterface(address(fyToken));\n        uint256 totalAmountOut = repayAmount;\n        uint256 maxTotalAmountIn = underlyingAmount;\n        uint256 nPools = 1;\n\n        /* Recall that Balancer reverts when the swap is not successful. */\n        uint256 totalAmountIn =\n            ExchangeProxyInterface(EXCHANGE_PROXY_ADDRESS).smartSwapExactOut(\n                tokenIn,\n                tokenOut,\n                totalAmountOut,\n                maxTotalAmountIn,\n                nPools\n            );\n\n        /* Use the recently bought fyTokens to repay the borrow. */\n        fyToken.repayBorrow(repayAmount);\n\n        /* When we get a better price than the worst that we assumed we would, not all underlying is sold. */\n        MathError mathErr;\n        uint256 underlyingDelta;\n        (mathErr, underlyingDelta) = subUInt(underlyingAmount, totalAmountIn);\n        require(mathErr == MathError.NO_ERROR, \"ERR_SELL_UNDERLYING_AND_REPAY_BORROW_MATH_ERROR\");\n\n        /* If the underlying delta is non-zero, send it back to the user. */\n        if (underlyingDelta > 0) {\n            underlying.safeTransfer(msg.sender, underlyingDelta);\n        }\n    }",
        "@notice": "Market sells underlying and repays the borrows via the FyToken contract",
        "@dev": "Requirements: * - The caller must have allowed the DSProxy to spend `underlyingAmount` tokens.",
        "@param1": "fyToken The address of the FyToken contract.",
        "@param2": "underlyingAmount The amount of underlying to sell.",
        "@param3": "repayAmount The amount of fyTokens to repay.",
        "@gnotice": "Sell `underlyingAmount` of underlying tokens for `fyToken` tokens, and use them to repay `repayAmount` borrowed tokens.",
        "@gparam1": "fyToken The address of the `FyToken` contract for which the underlying tokens will be sold.",
        "@gparam2": "underlyingAmount The amount of underlying tokens to be sold.",
        "@gparam3": "repayAmount The amount of borrowed tokens to be repaid.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0
    },
    {
        "func": "function can_claim(address raceAddress, address eth_address) public view returns (bool) {\n        bool res;\n        (res,) = _isWinnerOf(raceAddress, eth_address);\n        return res;\n    }",
        "@notice": "",
        "@dev": "check if an eth_address can claim a horsey from this contract",
        "@param1": "raceAddress The ethorse race you want to claim from",
        "@param2": "eth_address The users address you want to claim the token for",
        "@return1": "True only if eth_address is a winner of the race contract at raceAddress",
        "@gnotice": "Checks if `eth_address` can claim a reward for the given `raceAddress`",
        "@gparam1": "raceAddress The address of the race contract to check",
        "@gparam2": "eth_address The address to check for eligibility to claim a reward",
        "@greturn1": "Whether or not the address is eligible to claim a reward",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 1,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        unchecked {\n            if (_getTokenIndex(tokenId) >= _tokensMinted()) revert INVALID_CRYPTOBLOB_ID();\n\n            uint256 souls;\n            if (!_isTokenSacrificed(tokenId)) souls = _token[tokenId].souls + 1; // Get souls harnessed and +1 for self.\n            if (souls > _URIMaxSoulsLimit) souls = _URIMaxSoulsLimit; // Limit souls.\n\n            if (bytes(_tokenURIPrefix).length > 0) {\n                // Single URI with an extension.\n                return string(abi.encodePacked(_tokenURIPrefix, _toPaddedString(souls), \"/\", _toPaddedString(tokenId)));\n            } else if (bytes(_tokenURIPrefixes[souls]).length > 0) {\n                // Multi URI with no extension.\n                return string(abi.encodePacked(_tokenURIPrefixes[souls], _toPaddedString(tokenId)));\n            } else {\n                // If no token URI.\n                return \"\";\n            }\n        }\n    }",
        "@notice": "",
        "@dev": "Unminted CryptoBlobs revert with an error. * Sacrificed CryptoBlobs still have metadata.",
        "@param1": "tokenId The token ID of the CryptoBlob.",
        "@return1": "The token URI of `tokenId`.",
        "@gnotice": "Get the URI for a specific token ID",
        "@gparam1": "tokenId The ID of the token to get the URI for",
        "@greturn1": "The URI associated with the given token ID",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function unregisterAddressesProvider(address provider) external override onlyOwner {\n    require(_addressesProviders[provider] > 0, Errors.LPAPR_PROVIDER_NOT_REGISTERED);\n    _addressesProviders[provider] = 0;\n    emit AddressesProviderUnregistered(provider);\n  }",
        "@notice": "",
        "@dev": "unregister a LendingPoolAddressesProvider from the list of registered addresses provider",
        "@param1": "provider The LendingPoolAddressesProvider address",
        "@gnotice": "Unregisters an AddressesProvider from the contract",
        "@gparam1": "provider The address of the AddressesProvider to unregister",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }",
        "@notice": "",
        "@dev": "check the amount of tokens that an owner allowed to a spender.",
        "@param1": "_owner address The address which owns the funds.",
        "@param2": "_spender address The address which will spend the funds.",
        "@return1": "the amount of tokens still available for the spender.",
        "@gnotice": "Get the amount of tokens approved by `_owner` that `_spender` can transfer",
        "@gparam1": "_owner The address of the account that owns the tokens",
        "@gparam2": "_spender The address of the account that is authorized to spend the tokens",
        "@greturn1": "The number of tokens `_spender` is allowed to spend on behalf of `_owner`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function blockchainExchange(\n    uint256 _amount, \n    uint256 _network, \n    bytes32 _adr\n  ) public \n  {\n    burn(_amount);\n    cap.sub(_amount);\n    emit BlockchainExchange(\n      msg.sender, \n      _amount, \n      _network, \n      _adr\n    );\n  }",
        "@notice": "",
        "@dev": "burn tokens and rise event for burn tokens in another network",
        "@param1": "_amount The amount of tokens that will burn",
        "@param2": "_network The index of target network.",
        "@param3": "_adr The address in new network",
        "@gnotice": "Exchange tokens for another blockchain asset",
        "@gparam1": "_amount The amount of tokens to exchange",
        "@gparam2": "_network The blockchain network for the asset to receive",
        "@gparam3": "_adr The address of the asset to receive",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0
    },
    {
        "func": "function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n    external\n    override\n  {\n    _safeTransferFrom(_from, _to, _tokenId, \"\");\n  }",
        "@notice": "Transfers the ownership of an NFT from one address to another address. ",
        "@dev": "This function can * be changed to payable.",
        "@param1": "_from The current owner of the NFT.",
        "@param2": "_to The new owner.",
        "@param3": "_tokenId The NFT to transfer.",
        "@gnotice": "Safely transfer token with identifier `_tokenId` from `_from` to `_to`.",
        "@gparam1": "_from The address of the current owner of the token",
        "@gparam2": "_to The address of the new owner of the token",
        "@gparam3": "_tokenId The identifier of the token being transferred",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0
    },
    {
        "func": "function _setInterestRateModel(InterestRateModel newInterestRateModel) public override returns (uint) {\n        uint error = accrueInterest();\n        if (error != uint(Error.NO_ERROR)) {\n            // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n            return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n        }\n        // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }",
        "@notice": "",
        "@dev": "accrue interest and update the interest rate model",
        "@param1": "newInterestRateModel the new interest rate model to use",
        "@return1": "uint 0=success, otherwise a failure (see ErrorReporter.sol for details)",
        "@gnotice": "Set a new interest rate model for the market",
        "@gparam1": "newInterestRateModel The new interest rate model to be set",
        "@greturn1": "uint representing success or failure of the transaction",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@treturn1": 0
    },
    {
        "func": "function mint(address account, uint256 amount) virtual external {\n        require(_msgSender() == minter, \"BackedToken: Only minter\");\n        _mint(account, amount);\n    }",
        "@notice": "mint tokens.",
        "@dev": "Allowed only for minter",
        "@param1": "account The address that will receive the minted tokens",
        "@param2": "amount The amount of tokens to mint",
        "@gnotice": "Mint new tokens `amount` to the `account`",
        "@gparam1": "account The address of the account to receive the new tokens",
        "@gparam2": "amount The number of tokens to mint",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function setTreasuryAddress(address _treasuryAddress) external onlyAdmin {\n        treasuryAddress = _treasuryAddress;\n    }",
        "@notice": "set the treasury address",
        "@dev": "the treasury fund is used to maintain the protocol",
        "@param1": "_treasuryAddress treasury fund address",
        "@gnotice": "Sets the treasury address for the contract",
        "@gparam1": "_treasuryAddress The address to set as the new treasury address.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function setMarketFees(uint256 fees) external\n    onlyOwner()\n    {\n        marketMakerFee = fees;\n    }",
        "@notice": "",
        "@dev": "change market fees",
        "@param1": "fees The new fees to apply (can be zero)",
        "@gnotice": "Set the market maker fees to `fees`",
        "@gparam1": "fees The new market maker fees value. Must be greater or equal to zero.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function depositAndLockCollateralAndBorrowAndSellFyTokens(\n        BalanceSheetInterface balanceSheet,\n        FyTokenInterface fyToken,\n        uint256 collateralAmount,\n        uint256 borrowAmount,\n        uint256 underlyingAmount\n    ) external payable {\n        depositAndLockCollateral(balanceSheet, fyToken, collateralAmount);\n        borrowAndSellFyTokens(fyToken, borrowAmount, underlyingAmount);\n    }",
        "@notice": "Deposits and locks collateral into the vault via the BalanceSheet contract, borrows fyTokens * and sells them on Balancer in exchange for underlying",
        "@dev": "This is a payable function so it can receive ETH transfers. * * Requirements: * - The caller must have allowed the DSProxy to spend `collateralAmount` tokens.",
        "@param1": "balanceSheet The address of the BalanceSheet contract.",
        "@param2": "fyToken The address of the FyToken contract.",
        "@param3": "collateralAmount The amount of collateral to deposit and lock.",
        "@param4": "borrowAmount The amount of fyTokens to borrow.",
        "@param5": "underlyingAmount The amount of underlying to sell fyTokens for.",
        "@gnotice": "Deposits `collateralAmount` ETH as collateral, locks it in `balanceSheet`, borrows `borrowAmount` FYTokens from `fyToken`, and sells `underlyingAmount` of those tokens for ETH",
        "@gparam1": "balanceSheet The BalanceSheet contract that will hold the deposited collateral as collateral",
        "@gparam2": "fyToken The FyToken contract to borrow and sell from",
        "@gparam3": "collateralAmount The amount of ETH to be deposited as collateral",
        "@gparam4": "borrowAmount The amount of FYTokens to be borrowed",
        "@gparam5": "underlyingAmount The amount of FYToken's underlying asset to be sold for ETH",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@tparam3": 0,
        "@tparam4": 0,
        "@tparam5": 0
    },
    {
        "func": "function setTreasuryInfo(address _treasury, uint256 _fee) external payable onlyAdmin {\n    require(_treasury != address(0), Errors.VT_TREASURY_INVALID);\n    require(_fee <= 30_00, Errors.VT_FEE_TOO_BIG);\n    _treasuryAddress = _treasury;\n    _vaultFee = _fee;\n\n    emit SetTreasuryInfo(_treasury, _fee);\n  }",
        "@notice": "",
        "@dev": "Set treasury address and vault fee",
        "@param1": "_treasury The treasury address",
        "@param2": "_fee The vault fee which has more two decimals, ex: 100% = 100_00",
        "@gnotice": "Set the treasury address and the vault fee",
        "@gparam1": "_treasury The address of the treasury where the vault fees will be sent",
        "@gparam2": "_fee The percentage of the vault fee",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0
    },
    {
        "func": "function cancelWager(uint256 _wagerId) external nonReentrant {\n        Wager memory wager = wagers[_wagerId];\n        if (wager.isClosed) revert WagerAlreadyClosed();\n        if (msg.sender != wager.userA && msg.sender != wager.userB)\n            revert UnauthorizedSender();\n        if (wager.isFilled) revert WagerAlreadyFilled();\n\n        wagers[_wagerId].isClosed = true;\n\n        if (\n            wager.paymentToken ==\n            address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n        ) {\n            _transfer(payable(wager.userA), wager.amountUserA);\n        } else {\n            IERC20(wager.paymentToken).safeTransfer(\n                wager.userA,\n                wager.amountUserA\n            );\n        }\n        emit WagerCancelled(_wagerId, msg.sender);\n    }",
        "@notice": "Cancels a wager that has not been filled",
        "@dev": "Fee is not refunded if wager was created as p2m",
        "@param1": "_wagerId id of the wager",
        "@gnotice": "Cancel a specified wager",
        "@gparam1": "_wagerId The ID of the wager to be cancelled",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function feed(uint256 tokenId) external \n    whenNotPaused()\n    onlyOwnerOf(tokenId) \n    carrotsMeetLevel(tokenId)\n    noFeedingInProgress()\n    {\n        pendingFeedings[msg.sender] = FeedingData(block.number,tokenId);\n        uint8 feedingCounter;\n        (,,feedingCounter,) = stables.horseys(tokenId);\n        stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) - uint32(feedingCounter));\n        emit Feeding(tokenId);\n    }",
        "@notice": "",
        "@dev": "feed a horsey to increase its feedingCounter value Gives a chance to get a rare trait The amount of carrots required is the value of current feedingCounter The carrots the user owns will be reduced accordingly upon success Cant be called while paused",
        "@param1": "tokenId ID of the horsey to feed",
        "@gnotice": "Feed the horse with the given `tokenId`, with conditions including only the owner can perform the feeding, `carrotsMeetLevel` requirement is satisfied, not currently in the middle of another feeding event, and `msg.sender` has enough carrots credits. The `Feeding` event is emitted after successful execution.",
        "@gparam1": "tokenId The ID of the horse to be fed.",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function setPauser(address newPauser) external onlyOwner {\n        pauser = newPauser;\n        emit NewPauser(newPauser);\n    }",
        "@notice": "change the contract pauser",
        "@dev": "Allowed only for owner * * Emits a { NewPauser } event",
        "@param1": "newPauser The address of the new pauser",
        "@gnotice": "Set the address of the Pauser to `newPauser`",
        "@gparam1": "newPauser The new address of the Pauser contract or account. The caller must have the `owner` role.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function retrieveTokens(address _token) public onlyOwner {\n    ERC20 token = ERC20(_token);\n    token.transfer(multisigVault, token.balanceOf(this));\n  }",
        "@notice": "",
        "@dev": "transfer ERC20 tokens to the multi sig vault",
        "@param1": "_token the contract address of the ERC20 contract",
        "@gnotice": "Retrieve ERC20 tokens mistakenly sent to this contract",
        "@gparam1": "_token The address of the ERC20 token that needs to be retrieved",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function _setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa) external returns (uint) {\n        // Check caller is admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n        }\n\n        // Verify market is listed\n        Market storage market = markets[address(cToken)];\n        if (!market.isListed) {\n            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n        }\n\n        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\n\n        // Check collateral factor <= 0.9\n        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\n        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n        }\n\n        // If collateral factor != 0, fail if price == 0\n        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(address(cToken)) == 0) {\n            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n        }\n\n        // Set market's collateral factor to new collateral factor, remember old value\n        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n        market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n        // Emit event with asset, old collateral factor, and new collateral factor\n        emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n        return uint(Error.NO_ERROR);\n    }",
        "@notice": "Sets the collateralFactor for a market",
        "@dev": "Admin function to set per-market collateralFactor",
        "@param1": "cToken The market to set the factor on",
        "@param2": "newCollateralFactorMantissa The new collateral factor, scaled by 1e18",
        "@return1": "uint 0=success, otherwise a failure. (See ErrorReporter for details)",
        "@gnotice": "Sets the collateral factor of a CToken market",
        "@gparam1": "cToken The address of the CToken market",
        "@gparam2": "newCollateralFactorMantissa The new collateral factor in mantissa format",
        "@greturn1": "An unsigned integer indicating whether or not the operation succeeded",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 1
    },
    {
        "func": "function withdrawCeo(address destination) external \n    onlyCLevelAccess()\n    validAddress(destination) {\n        //Check that pending balance can be redistributed - if so perform\n        //this procedure\n        if(toBeDistributed > 0){\n            _updateDistribution();\n        }\n        \n        //Grab the balance of this CEO \n        uint256 balance = _cBalance[msg.sender];\n        \n        //If we have non-zero balance, CEO may withdraw from pending amount\n        if(balance > 0 && (address(this).balance >= balance)) {\n            destination.transfer(balance); //throws on fail\n            _cBalance[msg.sender] = 0;\n        }\n    }",
        "@notice": "Allow CEO to withdraw from pending value always checks to update redist",
        "@dev": "We ONLY redist when a user tries to withdraw so we are not redistributing on every payment",
        "@param1": "destination The address to send the ether to",
        "@gnotice": "Allows the CEO to withdraw their pending balance to `destination` if available",
        "@gparam1": "destination The address where the pending balance will be transferred to",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function revertToPreviousAddress(bytes32 _id) public onlyOwner {\n        require(entries[_id].exists, ERR_ENTRY_NON_EXISTENT);\n        require(previousAddresses[_id] != address(0), ERR_EMPTY_PREV_ADDR);\n\n        address currentAddr = entries[_id].contractAddr;\n        entries[_id].contractAddr = previousAddresses[_id];\n\n        logger.Log(\n            address(this),\n            msg.sender,\n            \"RevertToPreviousAddress\",\n            abi.encode(_id, currentAddr, previousAddresses[_id])\n        );\n    }",
        "@notice": "Revertes to the previous address immediately",
        "@dev": "In case the new version has a fault, a quick way to fallback to the old contract",
        "@param1": "_id Id of contract",
        "@gnotice": "Revert the contract address associated with the specified `_id` parameter to its previous state",
        "@gparam1": "_id The unique identifier for the contract address to revert",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0
    },
    {
        "func": "function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }",
        "@notice": "",
        "@dev": "check the amount of tokens that `_owner` allowed to `spender`.",
        "@param1": "_owner address The address which owns the funds.",
        "@param2": "_spender address The address which will spend the funds.",
        "@return1": "the amount of tokens still available for the spender.",
        "@gnotice": "Get the allowance amount `_spender` can spend on behalf of `_owner`",
        "@gparam1": "_owner The address of the owner account",
        "@gparam2": "_spender The address of the spender account",
        "@greturn1": "The number of tokens `_spender` is allowed to spend on behalf of `_owner`",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 0
    },
    {
        "func": "function batchTradeHashUsedAndHasAccess(\n        address[] memory accounts,\n        uint256[] memory numbers\n    ) \n        external\n        view\n        returns (\n            uint256[] memory data\n        )\n    {\n        uint256 maxSupply = _maxSupply; // Get max supply.\n        uint256 accountsAmount = accounts.length; // Get return length.\n        data = new uint256[](accountsAmount); // Create array.\n        for (uint256 i; i < accountsAmount; i++) {\n            if (numbers[i] > maxSupply) { // If checking hash.\n                data[i] = _account[accounts[i]].timestampTradeHashUsed[bytes32(numbers[i])]; // Convert to bytes32 and check if used.\n            } else {\n                bool hasAccess;\n                (hasAccess,) = _hasAccess(accounts[i], numbers[i]);\n                if (hasAccess) data[i] = 1; // Return 1 if account has access.\n            }\n        }\n        return data;\n    }",
        "@notice": "Check if trade hashes have been used and if an account can access token IDs",
        "@dev": "Token ID is checked if number is <= 25000, else the hash is checked. * Hashes must be converted to uint.",
        "@param1": "accounts The addresses of the accounts.",
        "@param2": "numbers The hashes to check.",
        "@return1": "data Data returned.",
        "@gnotice": "Returns an array of data indicating if the account at the corresponding index in the `accounts` array has used the trade hash if `numbers[i]` is greater than `_maxSupply`, or if the account at the corresponding index in `accounts` has access to the trade if `numbers[i]` is less than or equal to `_maxSupply`.",
        "@gparam1": "accounts An array of account addresses to check for trade hash usage or trade access",
        "@gparam2": "numbers An array of numbers to check for trade hash usage or trade access",
        "@greturn1": "An array of uint256 values indicating if each account has used the trade hash or has access to the trade. A value of 1 indicates the corresponding account has access or the trade hash has been used. A value of 0 indicates the corresponding account does not have access or the trade hash has not been used.",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 0,
        "@tparam2": 0,
        "@treturn1": 1
    },
    {
        "func": "function setCarrotsMultiplier(uint8 newCarrotsMultiplier) external \n    onlyOwner()  {\n        carrotsMultiplier = newCarrotsMultiplier;\n    }",
        "@notice": "",
        "@dev": "Sets a new muliplier for freeing a horse",
        "@param1": "newCarrotsMultiplier the new multiplier for feeding",
        "@gnotice": "Set the carrots multiplier to `newCarrotsMultiplier`",
        "@gparam1": "newCarrotsMultiplier The new value to set the carrots multiplier to",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    },
    {
        "func": "function borrowAndSellFyTokens(\n        FyTokenInterface fyToken,\n        uint256 borrowAmount,\n        uint256 underlyingAmount\n    ) public payable {\n        Erc20Interface underlying = fyToken.underlying();\n\n        /* Borrow the fyTokens. */\n        fyToken.borrow(borrowAmount);\n\n        /* Allow the Balancer contract to spend fyTokens if allowance not enough. */\n        uint256 allowance = fyToken.allowance(address(this), EXCHANGE_PROXY_ADDRESS);\n        if (allowance < borrowAmount) {\n            fyToken.approve(EXCHANGE_PROXY_ADDRESS, type(uint256).max);\n        }\n\n        /* Prepare the parameters for calling Balancer. */\n        TokenInterface tokenIn = TokenInterface(address(fyToken));\n        TokenInterface tokenOut = TokenInterface(address(underlying));\n        uint256 totalAmountOut = underlyingAmount;\n        uint256 maxTotalAmountIn = borrowAmount;\n        uint256 nPools = 1;\n\n        /* Recall that Balancer reverts when the swap is not successful. */\n        uint256 totalAmountIn =\n            ExchangeProxyInterface(EXCHANGE_PROXY_ADDRESS).smartSwapExactOut(\n                tokenIn,\n                tokenOut,\n                totalAmountOut,\n                maxTotalAmountIn,\n                nPools\n            );\n\n        /* When we get a better price than the worst that we assumed we would, not all fyTokens are sold. */\n        MathError mathErr;\n        uint256 fyTokenDelta;\n        (mathErr, fyTokenDelta) = subUInt(borrowAmount, totalAmountIn);\n        require(mathErr == MathError.NO_ERROR, \"ERR_BORROW_AND_SELL_FYTOKENS_MATH_ERROR\");\n\n        /* If the fyToken delta is non-zero, we use it to partially repay the borrow. */\n        /* Note: this is not gas-efficient. */\n        if (fyTokenDelta > 0) {\n            fyToken.repayBorrow(fyTokenDelta);\n        }\n\n        /* Finally, transfer the recently bought underlying to the end user. */\n        underlying.safeTransfer(msg.sender, underlyingAmount);\n\n        emit BorrowAndSellFyTokens(msg.sender, borrowAmount, fyTokenDelta, underlyingAmount);\n    }",
        "@notice": "Borrows fyTokens and sells them on Balancer in exchange for underlying",
        "@dev": "Emits a {BorrowAndSellFyTokens} event. * * This is a payable function so it can receive ETH transfers.",
        "@param1": "fyToken The address of the FyToken contract.",
        "@param2": "borrowAmount The amount of fyTokens to borrow.",
        "@param3": "underlyingAmount The amount of underlying to sell fyTokens for.",
        "@gnotice": "Borrow `borrowAmount` FyTokens and exchange them for `underlyingAmount` underlying tokens through a Balancer smart swap",
        "@gparam1": "fyToken The FyToken to borrow and sell",
        "@gparam2": "borrowAmount The amount of FyTokens to borrow",
        "@gparam3": "underlyingAmount The desired amount of underlying tokens to receive",
        "@tnotice": 0,
        "@tdev": 0,
        "@tparam1": 1,
        "@tparam2": 0,
        "@tparam3": 0
    },
    {
        "func": "function setBeneficiary(address payable beneficiary) public onlyOwner {\n        require(beneficiary != _NULL_ADDRESS, \"Invalid beneficiary\");\n        _beneficiary = beneficiary;\n        emit BeneficiaryChanged(_beneficiary);\n    }",
        "@notice": "",
        "@dev": "Set a new beneficiary address",
        "@param1": "beneficiary New beneficiary target address",
        "@gnotice": "Set the beneficiary address for this contract",
        "@gparam1": "beneficiary The new beneficiary address to set",
        "@tnotice": 0,
        "@tdev": 1,
        "@tparam1": 0
    }
]