[
    {
        "transactions": 17909,
        "function_num": 252
    },
    {
        "name": "init712",
        "visibility": "public",
        "args": [],
        "func": "function init712() public phase(\"712\") {\n        DOMAIN_SEPARATOR = keccak256(abi.encode(EIP712DOMAIN_TYPEHASH, keccak256(\"The Sandbox 3D\"), keccak256(\"1\"), address(this)));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setMinter",
        "visibility": "external",
        "args": [
            {
                "name": "minter",
                "type": "address"
            },
            {
                "name": "enabled",
                "type": "bool"
            }
        ],
        "func": "function setMinter(address minter, bool enabled) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        _setMinter(minter, enabled);\n    }",
        "comments": [
            "",
            "    /// @notice Enable or disable the ability of `minter` to mint tokens",
            "    /// @param minter address that will be given/removed minter right.",
            "    /// @param enabled set whether the minter is enabled or disabled.",
            "    "
        ],
        "comt": "\n    /// @notice Enable or disable the ability of `minter` to mint tokens\n    /// @param minter address that will be given/removed minter right.\n    /// @param enabled set whether the minter is enabled or disabled.\n    ",
        "@notice": "Enable or disable the ability of `minter` to mint tokens",
        "@param1": "minter address that will be given/removed minter right.",
        "@param2": "enabled set whether the minter is enabled or disabled.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isMinter",
        "visibility": "public",
        "args": [
            {
                "name": "who",
                "type": "address"
            }
        ],
        "func": "function isMinter(address who) public view returns (bool) {\n        return _minters[who];\n    }",
        "comments": [
            "",
            "    /// @notice check whether address `who` is given minter rights.",
            "    /// @param who The address to query.",
            "    /// @return whether the address has minter rights.",
            "    "
        ],
        "comt": "\n    /// @notice check whether address `who` is given minter rights.\n    /// @param who The address to query.\n    /// @return whether the address has minter rights.\n    ",
        "@notice": "check whether address `who` is given minter rights.",
        "@param1": "who The address to query.",
        "@return1": "whether the address has minter rights.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function mint(\n        address to,\n        uint256 id,\n        uint256 amount\n    ) external {\n        require(_minters[msg.sender], \"NOT_AUTHORIZED_MINTER\");\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        mapping(uint256 => uint256) storage toPack = _packedTokenBalance[to];\n        toPack[bin] = toPack[bin].updateTokenBalance(index, amount, ObjectLib32.Operations.ADD);\n        _packedSupplies[bin] = _packedSupplies[bin].updateTokenBalance(index, amount, ObjectLib32.Operations.ADD);\n        _erc20s[id].emitTransferEvent(address(0), to, amount);\n    }",
        "comments": [
            "",
            "    /// @dev mint more tokens of a specific subToken .",
            "    /// @param to address receiving the tokens.",
            "    /// @param id subToken id (also the index at which it was added).",
            "    /// @param amount of token minted.",
            "    "
        ],
        "comt": "\n    /// @dev mint more tokens of a specific subToken .\n    /// @param to address receiving the tokens.\n    /// @param id subToken id (also the index at which it was added).\n    /// @param amount of token minted.\n    ",
        "@dev": "mint more tokens of a specific subToken .",
        "@param1": "to address receiving the tokens.",
        "@param2": "id subToken id (also the index at which it was added).",
        "@param3": "amount of token minted.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "batchMint",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "ids",
                "type": "uint256[] calldata"
            },
            {
                "name": "amounts",
                "type": "uint256[] calldata"
            }
        ],
        "func": "function batchMint(\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external {\n        require(_minters[msg.sender], \"NOT_AUTHORIZED_MINTER\");\n        require(ids.length == amounts.length, \"INVALID_INCONSISTENT_LENGTH\");\n        _batchMint(to, ids, amounts);\n    }",
        "comments": [
            "",
            "    /// @dev mint more tokens of a several subToken .",
            "    /// @param to address receiving the tokens.",
            "    /// @param ids subToken ids (also the index at which it was added).",
            "    /// @param amounts for each token minted.",
            "    "
        ],
        "comt": "\n    /// @dev mint more tokens of a several subToken .\n    /// @param to address receiving the tokens.\n    /// @param ids subToken ids (also the index at which it was added).\n    /// @param amounts for each token minted.\n    ",
        "@dev": "mint more tokens of a several subToken .",
        "@param1": "to address receiving the tokens.",
        "@param2": "ids subToken ids (also the index at which it was added).",
        "@param3": "amounts for each token minted.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "supplyOf",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function supplyOf(uint256 id) external view returns (uint256 supply) {\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        return _packedSupplies[bin].getValueInBin(index);\n    }",
        "comments": [
            "",
            "    /// @notice return the current total supply of a specific subToken.",
            "    /// @param id subToken id.",
            "    /// @return supply current total number of tokens.",
            "    "
        ],
        "comt": "\n    /// @notice return the current total supply of a specific subToken.\n    /// @param id subToken id.\n    /// @return supply current total number of tokens.\n    ",
        "@notice": "return the current total supply of a specific subToken.",
        "@param1": "id subToken id.",
        "@return1": "supply current total number of tokens.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function balanceOf(address owner, uint256 id) public view returns (uint256 balance) {\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        return _packedTokenBalance[owner][bin].getValueInBin(index);\n    }",
        "comments": [
            "",
            "    /// @notice return the balance of a particular owner for a particular subToken.",
            "    /// @param owner whose balance it is of.",
            "    /// @param id subToken id.",
            "    /// @return balance of the owner",
            "    "
        ],
        "comt": "\n    /// @notice return the balance of a particular owner for a particular subToken.\n    /// @param owner whose balance it is of.\n    /// @param id subToken id.\n    /// @return balance of the owner\n    ",
        "@notice": "return the balance of a particular owner for a particular subToken.",
        "@param1": "owner whose balance it is of.",
        "@param2": "id subToken id.",
        "@return1": "balance of the owner",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOfBatch",
        "visibility": "external",
        "args": [
            {
                "name": "owners",
                "type": "address[] calldata"
            },
            {
                "name": "ids",
                "type": "uint256[] calldata"
            }
        ],
        "func": "function balanceOfBatch(address[] calldata owners, uint256[] calldata ids) external view returns (uint256[] memory balances) {\n        require(owners.length == ids.length, \"INVALID_INCONSISTENT_LENGTH\");\n        balances = new uint256[](ids.length);\n        for (uint256 i = 0; i < ids.length; i++) {\n            balances[i] = balanceOf(owners[i], ids[i]);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice return the balances of a list of owners / subTokens.",
            "    /// @param owners list of addresses to which we want to know the balance.",
            "    /// @param ids list of subTokens's addresses.",
            "    /// @return balances list of balances for each request.",
            "    "
        ],
        "comt": "\n    /// @notice return the balances of a list of owners / subTokens.\n    /// @param owners list of addresses to which we want to know the balance.\n    /// @param ids list of subTokens's addresses.\n    /// @return balances list of balances for each request.\n    ",
        "@notice": "return the balances of a list of owners / subTokens.",
        "@param1": "owners list of addresses to which we want to know the balance.",
        "@param2": "ids list of subTokens's addresses.",
        "@return1": "balances list of balances for each request.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "singleTransferFrom",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            },
            {
                "name": "value",
                "type": "uint256"
            }
        ],
        "func": "function singleTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value\n    ) external {\n        require(to != address(0), \"INVALID_TO_ZERO_ADDRESS\");\n        ERC20SubToken erc20 = _erc20s[id];\n        require(\n            from == msg.sender ||\n                msg.sender == address(erc20) ||\n                _metaTransactionContracts[msg.sender] ||\n                _superOperators[msg.sender] ||\n                _operatorsForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        mapping(uint256 => uint256) storage fromPack = _packedTokenBalance[from];\n        mapping(uint256 => uint256) storage toPack = _packedTokenBalance[to];\n        fromPack[bin] = fromPack[bin].updateTokenBalance(index, value, ObjectLib32.Operations.SUB);\n        toPack[bin] = toPack[bin].updateTokenBalance(index, value, ObjectLib32.Operations.ADD);\n        erc20.emitTransferEvent(from, to, value);\n    }",
        "comments": [
            "",
            "    /// @notice transfer a number of subToken from one address to another.",
            "    /// @param from owner to transfer from.",
            "    /// @param to destination address that will receive the tokens.",
            "    /// @param id subToken id.",
            "    /// @param value amount of tokens to transfer.",
            "    "
        ],
        "comt": "\n    /// @notice transfer a number of subToken from one address to another.\n    /// @param from owner to transfer from.\n    /// @param to destination address that will receive the tokens.\n    /// @param id subToken id.\n    /// @param value amount of tokens to transfer.\n    ",
        "@notice": "transfer a number of subToken from one address to another.",
        "@param1": "from owner to transfer from.",
        "@param2": "to destination address that will receive the tokens.",
        "@param3": "id subToken id.",
        "@param4": "value amount of tokens to transfer.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "batchTransferFrom",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "ids",
                "type": "uint256[] calldata"
            },
            {
                "name": "values",
                "type": "uint256[] calldata"
            }
        ],
        "func": "function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values\n    ) external {\n        require(ids.length == values.length, \"INVALID_INCONSISTENT_LENGTH\");\n        require(to != address(0), \"INVALID_TO_ZERO_ADDRESS\");\n        require(\n            from == msg.sender || _superOperators[msg.sender] || _operatorsForAll[from][msg.sender] || _metaTransactionContracts[msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n        _batchTransferFrom(from, to, ids, values);\n    }",
        "comments": [
            "",
            "    /// @notice transfer a number of different subTokens from one address to another.",
            "    /// @param from owner to transfer from.",
            "    /// @param to destination address that will receive the tokens.",
            "    /// @param ids list of subToken ids to transfer.",
            "    /// @param values list of amount for eacg subTokens to transfer.",
            "    "
        ],
        "comt": "\n    /// @notice transfer a number of different subTokens from one address to another.\n    /// @param from owner to transfer from.\n    /// @param to destination address that will receive the tokens.\n    /// @param ids list of subToken ids to transfer.\n    /// @param values list of amount for eacg subTokens to transfer.\n    ",
        "@notice": "transfer a number of different subTokens from one address to another.",
        "@param1": "from owner to transfer from.",
        "@param2": "to destination address that will receive the tokens.",
        "@param3": "ids list of subToken ids to transfer.",
        "@param4": "values list of amount for eacg subTokens to transfer.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setApprovalForAllFor",
        "visibility": "external",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "approved",
                "type": "bool"
            }
        ],
        "func": "function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) external {\n        require(msg.sender == sender || _metaTransactionContracts[msg.sender] || _superOperators[msg.sender], \"NOT_AUTHORIZED\");\n        _setApprovalForAll(sender, operator, approved);\n    }",
        "comments": [
            "",
            "    /// @notice grant or revoke the ability for an address to transfer token on behalf of another address.",
            "    /// @param sender address granting/revoking the approval.",
            "    /// @param operator address being granted/revoked ability to transfer.",
            "    /// @param approved whether the operator is revoked or approved.",
            "    "
        ],
        "comt": "\n    /// @notice grant or revoke the ability for an address to transfer token on behalf of another address.\n    /// @param sender address granting/revoking the approval.\n    /// @param operator address being granted/revoked ability to transfer.\n    /// @param approved whether the operator is revoked or approved.\n    ",
        "@notice": "grant or revoke the ability for an address to transfer token on behalf of another address.",
        "@param1": "sender address granting/revoking the approval.",
        "@param2": "operator address being granted/revoked ability to transfer.",
        "@param3": "approved whether the operator is revoked or approved.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setApprovalForAll",
        "visibility": "external",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "approved",
                "type": "bool"
            }
        ],
        "func": "function setApprovalForAll(address operator, bool approved) external {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }",
        "comments": [
            "",
            "    /// @notice grant or revoke the ability for an address to transfer token on your behalf.",
            "    /// @param operator address being granted/revoked ability to transfer.",
            "    /// @param approved whether the operator is revoked or approved.",
            "    "
        ],
        "comt": "\n    /// @notice grant or revoke the ability for an address to transfer token on your behalf.\n    /// @param operator address being granted/revoked ability to transfer.\n    /// @param approved whether the operator is revoked or approved.\n    ",
        "@notice": "grant or revoke the ability for an address to transfer token on your behalf.",
        "@param1": "operator address being granted/revoked ability to transfer.",
        "@param2": "approved whether the operator is revoked or approved.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isApprovedForAll",
        "visibility": "external",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function isApprovedForAll(address owner, address operator) external view returns (bool isOperator) {\n        return _operatorsForAll[owner][operator] || _superOperators[operator];\n    }",
        "comments": [
            "",
            "    /// @notice return whether an oeprator has the ability to transfer on behalf of another address.",
            "    /// @param owner address who would have granted the rights.",
            "    /// @param operator address being given the ability to transfer.",
            "    /// @return isOperator whether the operator has approval rigths or not.",
            "    "
        ],
        "comt": "\n    /// @notice return whether an oeprator has the ability to transfer on behalf of another address.\n    /// @param owner address who would have granted the rights.\n    /// @param operator address being given the ability to transfer.\n    /// @return isOperator whether the operator has approval rigths or not.\n    ",
        "@notice": "return whether an oeprator has the ability to transfer on behalf of another address.",
        "@param1": "owner address who would have granted the rights.",
        "@param2": "operator address being given the ability to transfer.",
        "@return1": "isOperator whether the operator has approval rigths or not.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isAuthorizedToTransfer",
        "visibility": "external",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "sender",
                "type": "address"
            }
        ],
        "func": "function isAuthorizedToTransfer(address owner, address sender) external view returns (bool) {\n        return _metaTransactionContracts[sender] || _superOperators[sender] || _operatorsForAll[owner][sender];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isAuthorizedToApprove",
        "visibility": "external",
        "args": [
            {
                "name": "sender",
                "type": "address"
            }
        ],
        "func": "function isAuthorizedToApprove(address sender) external view returns (bool) {\n        return _metaTransactionContracts[sender] || _superOperators[sender];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "batchBurnFrom",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "ids",
                "type": "uint256[] calldata"
            },
            {
                "name": "amounts",
                "type": "uint256[] calldata"
            }
        ],
        "func": "function batchBurnFrom(\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external {\n        require(from != address(0), \"INVALID_FROM_ZERO_ADDRESS\");\n        require(\n            from == msg.sender || _metaTransactionContracts[msg.sender] || _superOperators[msg.sender] || _operatorsForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        _batchBurnFrom(from, ids, amounts);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burnFrom",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            },
            {
                "name": "value",
                "type": "uint256"
            }
        ],
        "func": "function burnFrom(\n        address from,\n        uint256 id,\n        uint256 value\n    ) external {\n        require(\n            from == msg.sender || _superOperators[msg.sender] || _operatorsForAll[from][msg.sender] || _metaTransactionContracts[msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n        _burn(from, id, value);\n    }",
        "comments": [
            "",
            "    /// @notice burn token for a specific owner and subToken.",
            "    /// @param from fron which address the token are burned from.",
            "    /// @param id subToken id.",
            "    /// @param value amount of tokens to burn.",
            "    "
        ],
        "comt": "\n    /// @notice burn token for a specific owner and subToken.\n    /// @param from fron which address the token are burned from.\n    /// @param id subToken id.\n    /// @param value amount of tokens to burn.\n    ",
        "@notice": "burn token for a specific owner and subToken.",
        "@param1": "from fron which address the token are burned from.",
        "@param2": "id subToken id.",
        "@param3": "value amount of tokens to burn.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint256"
            },
            {
                "name": "value",
                "type": "uint256"
            }
        ],
        "func": "function burn(uint256 id, uint256 value) external {\n        _burn(msg.sender, id, value);\n    }",
        "comments": [
            "",
            "    /// @notice burn token for a specific subToken.",
            "    /// @param id subToken id.",
            "    /// @param value amount of tokens to burn.",
            "    "
        ],
        "comt": "\n    /// @notice burn token for a specific subToken.\n    /// @param id subToken id.\n    /// @param value amount of tokens to burn.\n    ",
        "@notice": "burn token for a specific subToken.",
        "@param1": "id subToken id.",
        "@param2": "value amount of tokens to burn.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "name",
        "visibility": "public",
        "args": [],
        "func": "function name() public view returns (string memory) {\n        return _name;\n    }",
        "comments": [
            "",
            "    /// @notice A descriptive name for the tokens",
            "    /// @return name of the tokens",
            "    "
        ],
        "comt": "\n    /// @notice A descriptive name for the tokens\n    /// @return name of the tokens\n    ",
        "@notice": "A descriptive name for the tokens",
        "@return1": "name of the tokens",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "symbol",
        "visibility": "public",
        "args": [],
        "func": "function symbol() public view returns (string memory) {\n        return _symbol;\n    }",
        "comments": [
            "",
            "    /// @notice An abbreviated name for the tokens",
            "    /// @return symbol of the tokens",
            "    "
        ],
        "comt": "\n    /// @notice An abbreviated name for the tokens\n    /// @return symbol of the tokens\n    ",
        "@notice": "An abbreviated name for the tokens",
        "@return1": "symbol of the tokens",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "groupTokenId",
        "visibility": "external",
        "args": [],
        "func": "function groupTokenId() external view returns (uint256) {\n        return _index;\n    }",
        "comments": [
            "",
            "    /// @notice the tokenId in ERC20Group",
            "    /// @return the tokenId in ERC20Group",
            "    "
        ],
        "comt": "\n    /// @notice the tokenId in ERC20Group\n    /// @return the tokenId in ERC20Group\n    ",
        "@notice": "the tokenId in ERC20Group",
        "@return1": "the tokenId in ERC20Group",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "groupAddress",
        "visibility": "external",
        "args": [],
        "func": "function groupAddress() external view returns (address) {\n        return address(_group);\n    }",
        "comments": [
            "",
            "    /// @notice the ERC20Group address",
            "    /// @return the address of the group",
            "    "
        ],
        "comt": "\n    /// @notice the ERC20Group address\n    /// @return the address of the group\n    ",
        "@notice": "the ERC20Group address",
        "@return1": "the address of the group",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "external",
        "args": [],
        "func": "function totalSupply() external view returns (uint256) {\n        return _group.supplyOf(_index);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "external",
        "args": [
            {
                "name": "who",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address who) external view returns (uint256) {\n        return _group.balanceOf(who, _index);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decimals",
        "visibility": "external",
        "args": [],
        "func": "function decimals() external pure returns (uint8) {\n        return uint8(0);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address to, uint256 amount) external returns (bool success) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool success) {\n        if (msg.sender != from && !_group.isAuthorizedToTransfer(from, msg.sender)) {\n            uint256 allowance = _mAllowed[from][msg.sender];\n            if (allowance != ~uint256(0)) {\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n                require(allowance >= amount, \"NOT_AUTHOIZED_ALLOWANCE\");\n                _mAllowed[from][msg.sender] = allowance - amount;\n            }\n        }\n        _transfer(from, to, amount);\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "external",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function approve(address spender, uint256 amount) external returns (bool success) {\n        _approveFor(msg.sender, spender, amount);\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approveFor",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function approveFor(\n        address from,\n        address spender,\n        uint256 amount\n    ) external returns (bool success) {\n        require(msg.sender == from || _group.isAuthorizedToApprove(msg.sender), \"NOT_AUTHORIZED\");\n        _approveFor(from, spender, amount);\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "emitTransferEvent",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function emitTransferEvent(\n        address from,\n        address to,\n        uint256 amount\n    ) external {\n        require(msg.sender == address(_group), \"NOT_AUTHORIZED_GROUP_ONLY\");\n        emit Transfer(from, to, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allowance",
        "visibility": "external",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            }
        ],
        "func": "function allowance(address owner, address spender) external view returns (uint256 remaining) {\n        return _mAllowed[owner][spender];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setSuperOperator",
        "visibility": "external",
        "args": [
            {
                "name": "superOperator",
                "type": "address"
            },
            {
                "name": "enabled",
                "type": "bool"
            }
        ],
        "func": "function setSuperOperator(address superOperator, bool enabled) external {\n        require(msg.sender == _admin, \"only admin is allowed to add super operators\");\n        _superOperators[superOperator] = enabled;\n        emit SuperOperator(superOperator, enabled);\n    }",
        "comments": [
            "",
            "    /// @notice Enable or disable the ability of `superOperator` to transfer tokens of all (superOperator rights).",
            "    /// @param superOperator address that will be given/removed superOperator right.",
            "    /// @param enabled set whether the superOperator is enabled or disabled.",
            "    "
        ],
        "comt": "\n    /// @notice Enable or disable the ability of `superOperator` to transfer tokens of all (superOperator rights).\n    /// @param superOperator address that will be given/removed superOperator right.\n    /// @param enabled set whether the superOperator is enabled or disabled.\n    ",
        "@notice": "Enable or disable the ability of `superOperator` to transfer tokens of all (superOperator rights).",
        "@param1": "superOperator address that will be given/removed superOperator right.",
        "@param2": "enabled set whether the superOperator is enabled or disabled.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isSuperOperator",
        "visibility": "public",
        "args": [
            {
                "name": "who",
                "type": "address"
            }
        ],
        "func": "function isSuperOperator(address who) public view returns (bool) {\n        return _superOperators[who];\n    }",
        "comments": [
            "",
            "    /// @notice check whether address `who` is given superOperator rights.",
            "    /// @param who The address to query.",
            "    /// @return whether the address has superOperator rights.",
            "    "
        ],
        "comt": "\n    /// @notice check whether address `who` is given superOperator rights.\n    /// @param who The address to query.\n    /// @return whether the address has superOperator rights.\n    ",
        "@notice": "check whether address `who` is given superOperator rights.",
        "@param1": "who The address to query.",
        "@return1": "whether the address has superOperator rights.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAdmin",
        "visibility": "external",
        "args": [],
        "func": "function getAdmin() external view returns (address) {\n        return _admin;\n    }",
        "comments": [
            "",
            "    /// @dev gives the current administrator of this contract.",
            "    /// @return the current administrator of this contract.",
            "    "
        ],
        "comt": "\n    /// @dev gives the current administrator of this contract.\n    /// @return the current administrator of this contract.\n    ",
        "@dev": "gives the current administrator of this contract.",
        "@return1": "the current administrator of this contract.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeAdmin",
        "visibility": "external",
        "args": [
            {
                "name": "newAdmin",
                "type": "address"
            }
        ],
        "func": "function changeAdmin(address newAdmin) external {\n        require(msg.sender == _admin, \"only admin can change admin\");\n        emit AdminChanged(_admin, newAdmin);\n        _admin = newAdmin;\n    }",
        "comments": [
            "",
            "    /// @dev change the administrator to be `newAdmin`.",
            "    /// @param newAdmin address of the new administrator.",
            "    "
        ],
        "comt": "\n    /// @dev change the administrator to be `newAdmin`.\n    /// @param newAdmin address of the new administrator.\n    ",
        "@dev": "change the administrator to be `newAdmin`.",
        "@param1": "newAdmin address of the new administrator.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setMetaTransactionProcessor",
        "visibility": "public",
        "args": [
            {
                "name": "metaTransactionProcessor",
                "type": "address"
            },
            {
                "name": "enabled",
                "type": "bool"
            }
        ],
        "func": "function setMetaTransactionProcessor(address metaTransactionProcessor, bool enabled) public {\n        require(msg.sender == _admin, \"only admin can setup metaTransactionProcessors\");\n        _setMetaTransactionProcessor(metaTransactionProcessor, enabled);\n    }",
        "comments": [
            "",
            "    /// @dev Enable or disable the ability of `metaTransactionProcessor` to perform meta-tx (metaTransactionProcessor rights).",
            "    /// @param metaTransactionProcessor address that will be given/removed metaTransactionProcessor rights.",
            "    /// @param enabled set whether the metaTransactionProcessor is enabled or disabled.",
            "    "
        ],
        "comt": "\n    /// @dev Enable or disable the ability of `metaTransactionProcessor` to perform meta-tx (metaTransactionProcessor rights).\n    /// @param metaTransactionProcessor address that will be given/removed metaTransactionProcessor rights.\n    /// @param enabled set whether the metaTransactionProcessor is enabled or disabled.\n    ",
        "@dev": "Enable or disable the ability of `metaTransactionProcessor` to perform meta-tx (metaTransactionProcessor rights).",
        "@param1": "metaTransactionProcessor address that will be given/removed metaTransactionProcessor rights.",
        "@param2": "enabled set whether the metaTransactionProcessor is enabled or disabled.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isMetaTransactionProcessor",
        "visibility": "external",
        "args": [
            {
                "name": "who",
                "type": "address"
            }
        ],
        "func": "function isMetaTransactionProcessor(address who) external view returns (bool) {\n        return _metaTransactionContracts[who];\n    }",
        "comments": [
            "",
            "    /// @dev check whether address `who` is given meta-transaction execution rights.",
            "    /// @param who The address to query.",
            "    /// @return whether the address has meta-transaction execution rights.",
            "    "
        ],
        "comt": "\n    /// @dev check whether address `who` is given meta-transaction execution rights.\n    /// @param who The address to query.\n    /// @return whether the address has meta-transaction execution rights.\n    ",
        "@dev": "check whether address `who` is given meta-transaction execution rights.",
        "@param1": "who The address to query.",
        "@return1": "whether the address has meta-transaction execution rights.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "external",
        "args": [
            {
                "name": "owner",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address owner) external view returns (uint256) {\n        require(owner != address(0), \"owner is zero address\");\n        return _numNFTPerAddress[owner];\n    }",
        "comments": [
            "/**",
            "     * @notice Return the number of Land owned by an address",
            "     * @param owner The address to look for",
            "     * @return The number of Land token owned by the address",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Return the number of Land owned by an address\n     * @param owner The address to look for\n     * @return The number of Land token owned by the address\n     */\n",
        "@notice": "Return the number of Land owned by an address",
        "@param1": "owner The address to look for",
        "@return1": "The number of Land token owned by the address",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "ownerOf",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function ownerOf(uint256 id) external view returns (address owner) {\n        owner = _ownerOf(id);\n        require(owner != address(0), \"token does not exist\");\n    }",
        "comments": [
            "/**",
            "     * @notice Return the owner of a Land",
            "     * @param id The id of the Land",
            "     * @return owner The address of the owner",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Return the owner of a Land\n     * @param id The id of the Land\n     * @return owner The address of the owner\n     */\n",
        "@notice": "Return the owner of a Land",
        "@param1": "id The id of the Land",
        "@return1": "owner The address of the owner",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approveFor",
        "visibility": "external",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function approveFor(\n        address sender,\n        address operator,\n        uint256 id\n    ) external {\n        address owner = _ownerOf(id);\n        require(sender != address(0), \"sender is zero address\");\n        require(\n            msg.sender == sender || _metaTransactionContracts[msg.sender] || _superOperators[msg.sender] || _operatorsForAll[sender][msg.sender],\n            \"not authorized to approve\"\n        );\n        require(owner == sender, \"owner != sender\");\n        _approveFor(owner, operator, id);\n    }",
        "comments": [
            "/**",
            "     * @notice Approve an operator to spend tokens on the sender behalf",
            "     * @param sender The address giving the approval",
            "     * @param operator The address receiving the approval",
            "     * @param id The id of the token",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n",
        "@notice": "Approve an operator to spend tokens on the sender behalf",
        "@param1": "sender The address giving the approval",
        "@param2": "operator The address receiving the approval",
        "@param3": "id The id of the token",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "external",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function approve(address operator, uint256 id) external {\n        address owner = _ownerOf(id);\n        require(owner != address(0), \"token does not exist\");\n        require(owner == msg.sender || _superOperators[msg.sender] || _operatorsForAll[owner][msg.sender], \"not authorized to approve\");\n        _approveFor(owner, operator, id);\n    }",
        "comments": [
            "/**",
            "     * @notice Approve an operator to spend tokens on the sender behalf",
            "     * @param operator The address receiving the approval",
            "     * @param id The id of the token",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Approve an operator to spend tokens on the sender behalf\n     * @param operator The address receiving the approval\n     * @param id The id of the token\n     */\n",
        "@notice": "Approve an operator to spend tokens on the sender behalf",
        "@param1": "operator The address receiving the approval",
        "@param2": "id The id of the token",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getApproved",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function getApproved(uint256 id) external view returns (address) {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(owner != address(0), \"token does not exist\");\n        if (operatorEnabled) {\n            return _operators[id];\n        } else {\n            return address(0);\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Get the approved operator for a specific token",
            "     * @param id The id of the token",
            "     * @return The address of the operator",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Get the approved operator for a specific token\n     * @param id The id of the token\n     * @return The address of the operator\n     */\n",
        "@notice": "Get the approved operator for a specific token",
        "@param1": "id The id of the token",
        "@return1": "The address of the operator",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) external {\n        bool metaTx = _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            require(_checkOnERC721Received(metaTx ? from : msg.sender, from, to, id, \"\"), \"erc721 transfer rejected by to\");\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Transfer a token between 2 addresses",
            "     * @param from The sender of the token",
            "     * @param to The recipient of the token",
            "     * @param id The id of the token",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfer a token between 2 addresses\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     */\n",
        "@notice": "Transfer a token between 2 addresses",
        "@param1": "from The sender of the token",
        "@param2": "to The recipient of the token",
        "@param3": "id The id of the token",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "safeTransferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            },
            {
                "name": "data",
                "type": "bytes memory"
            }
        ],
        "func": "function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public {\n        bool metaTx = _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract()) {\n            require(_checkOnERC721Received(metaTx ? from : msg.sender, from, to, id, data), \"ERC721: transfer rejected by to\");\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer",
            "     * @param from The sender of the token",
            "     * @param to The recipient of the token",
            "     * @param id The id of the token",
            "     * @param data Additional data",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     * @param data Additional data\n     */\n",
        "@notice": "Transfer a token between 2 addresses letting the receiver knows of the transfer",
        "@param1": "from The sender of the token",
        "@param2": "to The recipient of the token",
        "@param3": "id The id of the token",
        "@param4": "data Additional data",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "safeTransferFrom",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) external {\n        safeTransferFrom(from, to, id, \"\");\n    }",
        "comments": [
            "/**",
            "     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer",
            "     * @param from The send of the token",
            "     * @param to The recipient of the token",
            "     * @param id The id of the token",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\n     * @param from The send of the token\n     * @param to The recipient of the token\n     * @param id The id of the token\n     */\n",
        "@notice": "Transfer a token between 2 addresses letting the receiver knows of the transfer",
        "@param1": "from The send of the token",
        "@param2": "to The recipient of the token",
        "@param3": "id The id of the token",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "batchTransferFrom",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "ids",
                "type": "uint256[] calldata"
            },
            {
                "name": "data",
                "type": "bytes calldata"
            }
        ],
        "func": "function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external {\n        _batchTransferFrom(from, to, ids, data, false);\n    }",
        "comments": [
            "/**",
            "     * @notice Transfer many tokens between 2 addresses",
            "     * @param from The sender of the token",
            "     * @param to The recipient of the token",
            "     * @param ids The ids of the tokens",
            "     * @param data additional data",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfer many tokens between 2 addresses\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param ids The ids of the tokens\n     * @param data additional data\n     */\n",
        "@notice": "Transfer many tokens between 2 addresses",
        "@param1": "from The sender of the token",
        "@param2": "to The recipient of the token",
        "@param3": "ids The ids of the tokens",
        "@param4": "data additional data",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "safeBatchTransferFrom",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "ids",
                "type": "uint256[] calldata"
            },
            {
                "name": "data",
                "type": "bytes calldata"
            }
        ],
        "func": "function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        bytes calldata data\n    ) external {\n        _batchTransferFrom(from, to, ids, data, true);\n    }",
        "comments": [
            "/**",
            "     * @notice Transfer many tokens between 2 addresses ensuring the receiving contract has a receiver method",
            "     * @param from The sender of the token",
            "     * @param to The recipient of the token",
            "     * @param ids The ids of the tokens",
            "     * @param data additional data",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfer many tokens between 2 addresses ensuring the receiving contract has a receiver method\n     * @param from The sender of the token\n     * @param to The recipient of the token\n     * @param ids The ids of the tokens\n     * @param data additional data\n     */\n",
        "@notice": "Transfer many tokens between 2 addresses ensuring the receiving contract has a receiver method",
        "@param1": "from The sender of the token",
        "@param2": "to The recipient of the token",
        "@param3": "ids The ids of the tokens",
        "@param4": "data additional data",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "supportsInterface",
        "visibility": "public",
        "args": [
            {
                "name": "id",
                "type": "bytes4"
            }
        ],
        "func": "function supportsInterface(bytes4 id) public virtual pure returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\n    }",
        "comments": [
            "/**",
            "     * @notice Check if the contract supports an interface",
            "     * 0x01ffc9a7 is ERC-165",
            "     * 0x80ac58cd is ERC-721",
            "     * @param id The id of the interface",
            "     * @return True if the interface is supported",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Check if the contract supports an interface\n     * 0x01ffc9a7 is ERC-165\n     * 0x80ac58cd is ERC-721\n     * @param id The id of the interface\n     * @return True if the interface is supported\n     */\n",
        "@notice": "Check if the contract supports an interface * 0x01ffc9a7 is ERC-165 * 0x80ac58cd is ERC-721",
        "@param1": "id The id of the interface",
        "@return1": "True if the interface is supported",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setApprovalForAllFor",
        "visibility": "external",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "approved",
                "type": "bool"
            }
        ],
        "func": "function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) external {\n        require(sender != address(0), \"Invalid sender address\");\n        require(msg.sender == sender || _metaTransactionContracts[msg.sender] || _superOperators[msg.sender], \"not authorized to approve for all\");\n\n        _setApprovalForAll(sender, operator, approved);\n    }",
        "comments": [
            "/**",
            "     * @notice Set the approval for an operator to manage all the tokens of the sender",
            "     * @param sender The address giving the approval",
            "     * @param operator The address receiving the approval",
            "     * @param approved The determination of the approval",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param sender The address giving the approval\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n",
        "@notice": "Set the approval for an operator to manage all the tokens of the sender",
        "@param1": "sender The address giving the approval",
        "@param2": "operator The address receiving the approval",
        "@param3": "approved The determination of the approval",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setApprovalForAll",
        "visibility": "external",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "approved",
                "type": "bool"
            }
        ],
        "func": "function setApprovalForAll(address operator, bool approved) external {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }",
        "comments": [
            "/**",
            "     * @notice Set the approval for an operator to manage all the tokens of the sender",
            "     * @param operator The address receiving the approval",
            "     * @param approved The determination of the approval",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Set the approval for an operator to manage all the tokens of the sender\n     * @param operator The address receiving the approval\n     * @param approved The determination of the approval\n     */\n",
        "@notice": "Set the approval for an operator to manage all the tokens of the sender",
        "@param1": "operator The address receiving the approval",
        "@param2": "approved The determination of the approval",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isApprovedForAll",
        "visibility": "external",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function isApprovedForAll(address owner, address operator) external view returns (bool isOperator) {\n        return _operatorsForAll[owner][operator] || _superOperators[operator];\n    }",
        "comments": [
            "/**",
            "     * @notice Check if the sender approved the operator",
            "     * @param owner The address of the owner",
            "     * @param operator The address of the operator",
            "     * @return isOperator The status of the approval",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Check if the sender approved the operator\n     * @param owner The address of the owner\n     * @param operator The address of the operator\n     * @return isOperator The status of the approval\n     */\n",
        "@notice": "Check if the sender approved the operator",
        "@param1": "owner The address of the owner",
        "@param2": "operator The address of the operator",
        "@return1": "isOperator The status of the approval",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function burn(uint256 id) external virtual {\n        _burn(msg.sender, _ownerOf(id), id);\n    }",
        "comments": [
            "",
            "    /// @notice Burns token `id`.",
            "    /// @param id token which will be burnt.",
            "    "
        ],
        "comt": "\n    /// @notice Burns token `id`.\n    /// @param id token which will be burnt.\n    ",
        "@notice": "Burns token `id`.",
        "@param1": "id token which will be burnt.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burnFrom",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function burnFrom(address from, uint256 id) external virtual {\n        require(from != address(0), \"Invalid sender address\");\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(\n            msg.sender == from ||\n                _metaTransactionContracts[msg.sender] ||\n                (operatorEnabled && _operators[id] == msg.sender) ||\n                _superOperators[msg.sender] ||\n                _operatorsForAll[from][msg.sender],\n            \"not authorized to burn\"\n        );\n        _burn(from, owner, id);\n    }",
        "comments": [
            "",
            "    /// @notice Burn token`id` from `from`.",
            "    /// @param from address whose token is to be burnt.",
            "    /// @param id token which will be burnt.",
            "    "
        ],
        "comt": "\n    /// @notice Burn token`id` from `from`.\n    /// @param from address whose token is to be burnt.\n    /// @param id token which will be burnt.\n    ",
        "@notice": "Burn token`id` from `from`.",
        "@param1": "from address whose token is to be burnt.",
        "@param2": "id token which will be burnt.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "safeTransferFrom",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            },
            {
                "name": "value",
                "type": "uint256"
            },
            {
                "name": "data",
                "type": "bytes calldata"
            }
        ],
        "func": "function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external override {\n        bool metaTx = _transferFrom(from, to, id, value);\n        require(_checkERC1155AndCallSafeTransfer(metaTx ? from : msg.sender, from, to, id, value, data), \"erc1155 transfer rejected\");\n    }",
        "comments": [
            "    /// @notice Transfers `value` tokens of type `id` from  `from` to `to`  (with safety call).",
            "    /// @param from address from which tokens are transfered.",
            "    /// @param to address to which the token will be transfered.",
            "    /// @param id the token type transfered.",
            "    /// @param value amount of token transfered.",
            "    /// @param data aditional data accompanying the transfer.",
            "    "
        ],
        "comt": "    /// @notice Transfers `value` tokens of type `id` from  `from` to `to`  (with safety call).\n    /// @param from address from which tokens are transfered.\n    /// @param to address to which the token will be transfered.\n    /// @param id the token type transfered.\n    /// @param value amount of token transfered.\n    /// @param data aditional data accompanying the transfer.\n    ",
        "@notice": "Transfers `value` tokens of type `id` from `from` to `to` (with safety call).",
        "@param1": "from address from which tokens are transfered.",
        "@param2": "to address to which the token will be transfered.",
        "@param3": "id the token type transfered.",
        "@param4": "value amount of token transfered.",
        "@param5": "data aditional data accompanying the transfer.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "safeBatchTransferFrom",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "ids",
                "type": "uint256[] calldata"
            },
            {
                "name": "values",
                "type": "uint256[] calldata"
            },
            {
                "name": "data",
                "type": "bytes calldata"
            }
        ],
        "func": "function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external override {\n        require(ids.length == values.length, \"Inconsistent array length between args\");\n        require(to != address(0), \"destination is zero address\");\n        require(from != address(0), \"from is zero address\");\n        bool metaTx = _metaTransactionContracts[msg.sender];\n        require(from == msg.sender || metaTx || _superOperators[msg.sender] || _operatorsForAll[from][msg.sender], \"not authorized\");\n\n        _batchTransferFrom(from, to, ids, values);\n        emit TransferBatch(metaTx ? from : msg.sender, from, to, ids, values);\n        require(_checkERC1155AndCallSafeBatchTransfer(metaTx ? from : msg.sender, from, to, ids, values, data), \"erc1155 transfer rejected\");\n    }",
        "comments": [
            "",
            "    /// @notice Transfers `values` tokens of type `ids` from  `from` to `to` (with safety call).",
            "    /// @dev call data should be optimized to order ids so packedBalance can be used efficiently.",
            "    /// @param from address from which tokens are transfered.",
            "    /// @param to address to which the token will be transfered.",
            "    /// @param ids ids of each token type transfered.",
            "    /// @param values amount of each token type transfered.",
            "    /// @param data aditional data accompanying the transfer.",
            "    "
        ],
        "comt": "\n    /// @notice Transfers `values` tokens of type `ids` from  `from` to `to` (with safety call).\n    /// @dev call data should be optimized to order ids so packedBalance can be used efficiently.\n    /// @param from address from which tokens are transfered.\n    /// @param to address to which the token will be transfered.\n    /// @param ids ids of each token type transfered.\n    /// @param values amount of each token type transfered.\n    /// @param data aditional data accompanying the transfer.\n    ",
        "@notice": "Transfers `values` tokens of type `ids` from `from` to `to` (with safety call).",
        "@dev": "call data should be optimized to order ids so packedBalance can be used efficiently.",
        "@param1": "from address from which tokens are transfered.",
        "@param2": "to address to which the token will be transfered.",
        "@param3": "ids ids of each token type transfered.",
        "@param4": "values amount of each token type transfered.",
        "@param5": "data aditional data accompanying the transfer.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function balanceOf(address owner, uint256 id) public override view returns (uint256) {\n        // do not check for existence, balance is zero if never minted\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        return _packedTokenBalance[owner][bin].getValueInBin(index);\n    }",
        "comments": [
            "",
            "    /// @notice Get the balance of `owner` for the token type `id`.",
            "    /// @param owner The address of the token holder.",
            "    /// @param id the token type of which to get the balance of.",
            "    /// @return the balance of `owner` for the token type `id`.",
            "    "
        ],
        "comt": "\n    /// @notice Get the balance of `owner` for the token type `id`.\n    /// @param owner The address of the token holder.\n    /// @param id the token type of which to get the balance of.\n    /// @return the balance of `owner` for the token type `id`.\n    ",
        "@notice": "Get the balance of `owner` for the token type `id`.",
        "@param1": "owner The address of the token holder.",
        "@param2": "id the token type of which to get the balance of.",
        "@return1": "the balance of `owner` for the token type `id`.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOfBatch",
        "visibility": "external",
        "args": [
            {
                "name": "owners",
                "type": "address[] calldata"
            },
            {
                "name": "ids",
                "type": "uint256[] calldata"
            }
        ],
        "func": "function balanceOfBatch(address[] calldata owners, uint256[] calldata ids) external override view returns (uint256[] memory) {\n        require(owners.length == ids.length, \"Inconsistent array length between args\");\n        uint256[] memory balances = new uint256[](ids.length);\n        for (uint256 i = 0; i < ids.length; i++) {\n            balances[i] = balanceOf(owners[i], ids[i]);\n        }\n        return balances;\n    }",
        "comments": [
            "",
            "    /// @notice Get the balance of `owners` for each token type `ids`.",
            "    /// @param owners the addresses of the token holders queried.",
            "    /// @param ids ids of each token type to query.",
            "    /// @return the balance of each `owners` for each token type `ids`.",
            "    "
        ],
        "comt": "\n    /// @notice Get the balance of `owners` for each token type `ids`.\n    /// @param owners the addresses of the token holders queried.\n    /// @param ids ids of each token type to query.\n    /// @return the balance of each `owners` for each token type `ids`.\n    ",
        "@notice": "Get the balance of `owners` for each token type `ids`.",
        "@param1": "owners the addresses of the token holders queried.",
        "@param2": "ids ids of each token type to query.",
        "@return1": "the balance of each `owners` for each token type `ids`.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setApprovalForAllFor",
        "visibility": "external",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "approved",
                "type": "bool"
            }
        ],
        "func": "function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) external {\n        require(msg.sender == sender || _metaTransactionContracts[msg.sender] || _superOperators[msg.sender], \"require meta approval\");\n        _setApprovalForAll(sender, operator, approved);\n    }",
        "comments": [
            "",
            "    /// @notice Enable or disable approval for `operator` to manage all `sender`'s tokens.",
            "    /// @dev used for Meta Transaction (from metaTransactionContract).",
            "    /// @param sender address which grant approval.",
            "    /// @param operator address which will be granted rights to transfer all token owned by `sender`.",
            "    /// @param approved whether to approve or revoke.",
            "    "
        ],
        "comt": "\n    /// @notice Enable or disable approval for `operator` to manage all `sender`'s tokens.\n    /// @dev used for Meta Transaction (from metaTransactionContract).\n    /// @param sender address which grant approval.\n    /// @param operator address which will be granted rights to transfer all token owned by `sender`.\n    /// @param approved whether to approve or revoke.\n    ",
        "@notice": "Enable or disable approval for `operator` to manage all `sender`'s tokens.",
        "@dev": "used for Meta Transaction (from metaTransactionContract).",
        "@param1": "sender address which grant approval.",
        "@param2": "operator address which will be granted rights to transfer all token owned by `sender`.",
        "@param3": "approved whether to approve or revoke.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setApprovalForAll",
        "visibility": "external",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "approved",
                "type": "bool"
            }
        ],
        "func": "function setApprovalForAll(address operator, bool approved) external override {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }",
        "comments": [
            "",
            "    /// @notice Enable or disable approval for `operator` to manage all of the caller's tokens.",
            "    /// @param operator address which will be granted rights to transfer all tokens of the caller.",
            "    /// @param approved whether to approve or revoke",
            "    "
        ],
        "comt": "\n    /// @notice Enable or disable approval for `operator` to manage all of the caller's tokens.\n    /// @param operator address which will be granted rights to transfer all tokens of the caller.\n    /// @param approved whether to approve or revoke\n    ",
        "@notice": "Enable or disable approval for `operator` to manage all of the caller's tokens.",
        "@param1": "operator address which will be granted rights to transfer all tokens of the caller.",
        "@param2": "approved whether to approve or revoke",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isApprovedForAll",
        "visibility": "external",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function isApprovedForAll(address owner, address operator) external override view returns (bool isOperator) {\n        require(owner != address(0), \"owner is zero address\");\n        require(operator != address(0), \"operator is zero address\");\n        return _operatorsForAll[owner][operator] || _superOperators[operator];\n    }",
        "comments": [
            "",
            "    /// @notice Queries the approval status of `operator` for owner `owner`.",
            "    /// @param owner the owner of the tokens.",
            "    /// @param operator address of authorized operator.",
            "    /// @return isOperator true if the operator is approved, false if not.",
            "    "
        ],
        "comt": "\n    /// @notice Queries the approval status of `operator` for owner `owner`.\n    /// @param owner the owner of the tokens.\n    /// @param operator address of authorized operator.\n    /// @return isOperator true if the operator is approved, false if not.\n    ",
        "@notice": "Queries the approval status of `operator` for owner `owner`.",
        "@param1": "owner the owner of the tokens.",
        "@param2": "operator address of authorized operator.",
        "@return1": "isOperator true if the operator is approved, false if not.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "supportsInterface",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "bytes4"
            }
        ],
        "func": "function supportsInterface(bytes4 id) external pure returns (bool) {\n        return\n            id == ERC165ID || //ERC165\n            id == 0xd9b67a26; // ERC1155\n    }",
        "comments": [
            "",
            "    /// @notice Query if a contract implements interface `id`.",
            "    /// @param id the interface identifier, as specified in ERC-165.",
            "    /// @return `true` if the contract implements `id`.",
            "    "
        ],
        "comt": "\n    /// @notice Query if a contract implements interface `id`.\n    /// @param id the interface identifier, as specified in ERC-165.\n    /// @return `true` if the contract implements `id`.\n    ",
        "@notice": "Query if a contract implements interface `id`.",
        "@param1": "id the interface identifier, as specified in ERC-165.",
        "@return1": "`true` if the contract implements `id`.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "batchBurnFrom",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "ids",
                "type": "uint256[] calldata"
            },
            {
                "name": "amounts",
                "type": "uint256[] calldata"
            }
        ],
        "func": "function batchBurnFrom(\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external {\n        require(from != address(0), \"from is zero address\");\n        bool metaTx = _metaTransactionContracts[msg.sender];\n        require(from == msg.sender || metaTx || _superOperators[msg.sender] || _operatorsForAll[from][msg.sender], \"not authorized\");\n\n        uint256 balFrom;\n\n        uint256 lastBin = ~uint256(0);\n        for (uint256 i = 0; i < ids.length; i++) {\n            if (amounts[i] > 0) {\n                (uint256 bin, uint256 index) = ids[i].getTokenBinIndex();\n                if (lastBin == ~uint256(0)) {\n                    lastBin = bin;\n                    balFrom = ObjectLib32.updateTokenBalance(_packedTokenBalance[from][bin], index, amounts[i], ObjectLib32.Operations.SUB);\n                } else {\n                    if (bin != lastBin) {\n                        _packedTokenBalance[from][lastBin] = balFrom;\n                        balFrom = _packedTokenBalance[from][bin];\n                        lastBin = bin;\n                    }\n\n                    balFrom = balFrom.updateTokenBalance(index, amounts[i], ObjectLib32.Operations.SUB);\n                }\n            }\n        }\n        if (lastBin != ~uint256(0)) {\n            _packedTokenBalance[from][lastBin] = balFrom;\n        }\n        emit TransferBatch(metaTx ? from : msg.sender, from, address(0), ids, amounts);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint256"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function burn(uint256 id, uint256 amount) external {\n        _burn(msg.sender, msg.sender, id, amount);\n    }",
        "comments": [
            "",
            "    /// @notice Burns `amount` tokens of type `id`.",
            "    /// @param id token type which will be burnt.",
            "    /// @param amount amount of token to burn.",
            "    "
        ],
        "comt": "\n    /// @notice Burns `amount` tokens of type `id`.\n    /// @param id token type which will be burnt.\n    /// @param amount amount of token to burn.\n    ",
        "@notice": "Burns `amount` tokens of type `id`.",
        "@param1": "id token type which will be burnt.",
        "@param2": "amount amount of token to burn.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burnFrom",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function burnFrom(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) external {\n        require(from != address(0), \"from is zero address\");\n        bool metaTx = _metaTransactionContracts[msg.sender];\n        require(from == msg.sender || metaTx || _superOperators[msg.sender] || _operatorsForAll[from][msg.sender], \"not authorized\");\n        _burn(metaTx ? from : msg.sender, from, id, amount);\n    }",
        "comments": [
            "",
            "    /// @notice Burns `amount` tokens of type `id` from `from`.",
            "    /// @param from address whose token is to be burnt.",
            "    /// @param id token type which will be burnt.",
            "    /// @param amount amount of token to burn.",
            "    "
        ],
        "comt": "\n    /// @notice Burns `amount` tokens of type `id` from `from`.\n    /// @param from address whose token is to be burnt.\n    /// @param id token type which will be burnt.\n    /// @param amount amount of token to burn.\n    ",
        "@notice": "Burns `amount` tokens of type `id` from `from`.",
        "@param1": "from address whose token is to be burnt.",
        "@param2": "id token type which will be burnt.",
        "@param3": "amount amount of token to burn.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "name",
        "visibility": "external",
        "args": [],
        "func": "function name() external view returns (string memory) {\n        return string(abi.encodePacked(_name));\n    }",
        "comments": [
            "",
            "    /// @notice A descriptive name for the tokens",
            "    /// @return name of the tokens",
            "    "
        ],
        "comt": "\n    /// @notice A descriptive name for the tokens\n    /// @return name of the tokens\n    ",
        "@notice": "A descriptive name for the tokens",
        "@return1": "name of the tokens",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "symbol",
        "visibility": "external",
        "args": [],
        "func": "function symbol() external view returns (string memory) {\n        return string(abi.encodePacked(_symbol));\n    }",
        "comments": [
            "",
            "    /// @notice An abbreviated name for the tokens",
            "    /// @return symbol of the tokens",
            "    "
        ],
        "comt": "\n    /// @notice An abbreviated name for the tokens\n    /// @return symbol of the tokens\n    ",
        "@notice": "An abbreviated name for the tokens",
        "@return1": "symbol of the tokens",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "external",
        "args": [],
        "func": "function totalSupply() external override view returns (uint256) {\n        return _totalSupply;\n    }",
        "comments": [
            "",
            "    /// @notice Gets the total number of tokens in existence.",
            "    /// @return the total number of tokens in existence.",
            "    "
        ],
        "comt": "\n    /// @notice Gets the total number of tokens in existence.\n    /// @return the total number of tokens in existence.\n    ",
        "@notice": "Gets the total number of tokens in existence.",
        "@return1": "the total number of tokens in existence.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "external",
        "args": [
            {
                "name": "owner",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address owner) external override view returns (uint256) {\n        return _balances[owner];\n    }",
        "comments": [
            "",
            "    /// @notice Gets the balance of `owner`.",
            "    /// @param owner The address to query the balance of.",
            "    /// @return The amount owned by `owner`.",
            "    "
        ],
        "comt": "\n    /// @notice Gets the balance of `owner`.\n    /// @param owner The address to query the balance of.\n    /// @return The amount owned by `owner`.\n    ",
        "@notice": "Gets the balance of `owner`.",
        "@param1": "owner The address to query the balance of.",
        "@return1": "The amount owned by `owner`.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allowance",
        "visibility": "external",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            }
        ],
        "func": "function allowance(address owner, address spender) external override view returns (uint256 remaining) {\n        return _allowances[owner][spender];\n    }",
        "comments": [
            "",
            "    /// @notice gets allowance of `spender` for `owner`'s tokens.",
            "    /// @param owner address whose token is allowed.",
            "    /// @param spender address allowed to transfer.",
            "    /// @return remaining the amount of token `spender` is allowed to transfer on behalf of `owner`.",
            "    "
        ],
        "comt": "\n    /// @notice gets allowance of `spender` for `owner`'s tokens.\n    /// @param owner address whose token is allowed.\n    /// @param spender address allowed to transfer.\n    /// @return remaining the amount of token `spender` is allowed to transfer on behalf of `owner`.\n    ",
        "@notice": "gets allowance of `spender` for `owner`'s tokens.",
        "@param1": "owner address whose token is allowed.",
        "@param2": "spender address allowed to transfer.",
        "@return1": "remaining the amount of token `spender` is allowed to transfer on behalf of `owner`.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decimals",
        "visibility": "external",
        "args": [],
        "func": "function decimals() external virtual pure returns (uint8) {\n        return uint8(18);\n    }",
        "comments": [
            "",
            "    /// @notice returns the number of decimals for that token.",
            "    /// @return the number of decimals.",
            "    "
        ],
        "comt": "\n    /// @notice returns the number of decimals for that token.\n    /// @return the number of decimals.\n    ",
        "@notice": "returns the number of decimals for that token.",
        "@return1": "the number of decimals.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address to, uint256 amount) external override returns (bool success) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }",
        "comments": [
            "",
            "    /// @notice Transfer `amount` tokens to `to`.",
            "    /// @param to the recipient address of the tokens transfered.",
            "    /// @param amount the number of tokens transfered.",
            "    /// @return success true if success.",
            "    "
        ],
        "comt": "\n    /// @notice Transfer `amount` tokens to `to`.\n    /// @param to the recipient address of the tokens transfered.\n    /// @param amount the number of tokens transfered.\n    /// @return success true if success.\n    ",
        "@notice": "Transfer `amount` tokens to `to`.",
        "@param1": "to the recipient address of the tokens transfered.",
        "@param2": "amount the number of tokens transfered.",
        "@return1": "success true if success.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool success) {\n        if (msg.sender != from && !_superOperators[msg.sender]) {\n            uint256 currentAllowance = _allowances[from][msg.sender];\n            if (currentAllowance != ~uint256(0)) {\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n                require(currentAllowance >= amount, \"NOT_AUTHOIZED_ALLOWANCE\");\n                _allowances[from][msg.sender] = currentAllowance - amount;\n            }\n        }\n        _transfer(from, to, amount);\n        return true;\n    }",
        "comments": [
            "",
            "    /// @notice Transfer `amount` tokens from `from` to `to`.",
            "    /// @param from whose token it is transferring from.",
            "    /// @param to the recipient address of the tokens transfered.",
            "    /// @param amount the number of tokens transfered.",
            "    /// @return success true if success.",
            "    "
        ],
        "comt": "\n    /// @notice Transfer `amount` tokens from `from` to `to`.\n    /// @param from whose token it is transferring from.\n    /// @param to the recipient address of the tokens transfered.\n    /// @param amount the number of tokens transfered.\n    /// @return success true if success.\n    ",
        "@notice": "Transfer `amount` tokens from `from` to `to`.",
        "@param1": "from whose token it is transferring from.",
        "@param2": "to the recipient address of the tokens transfered.",
        "@param3": "amount the number of tokens transfered.",
        "@return1": "success true if success.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function burn(uint256 amount) external override {\n        _burn(msg.sender, amount);\n    }",
        "comments": [
            "",
            "    /// @notice burn `amount` tokens.",
            "    /// @param amount the number of tokens to burn.",
            "    "
        ],
        "comt": "\n    /// @notice burn `amount` tokens.\n    /// @param amount the number of tokens to burn.\n    ",
        "@notice": "burn `amount` tokens.",
        "@param1": "amount the number of tokens to burn.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burnFor",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function burnFor(address from, uint256 amount) external override {\n        if (msg.sender != from && !_superOperators[msg.sender]) {\n            uint256 currentAllowance = _allowances[from][msg.sender];\n            if (currentAllowance != ~uint256(0)) {\n                require(currentAllowance >= amount, \"NOT_AUTHOIZED_ALLOWANCE\");\n                _allowances[from][msg.sender] = currentAllowance - amount;\n            }\n        }\n        _burn(from, amount);\n    }",
        "comments": [
            "",
            "    /// @notice burn `amount` tokens from `owner`.",
            "    /// @param from address whose token is to burn.",
            "    /// @param amount the number of token to burn.",
            "    "
        ],
        "comt": "\n    /// @notice burn `amount` tokens from `owner`.\n    /// @param from address whose token is to burn.\n    /// @param amount the number of token to burn.\n    ",
        "@notice": "burn `amount` tokens from `owner`.",
        "@param1": "from address whose token is to burn.",
        "@param2": "amount the number of token to burn.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "external",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function approve(address spender, uint256 amount) external override returns (bool success) {\n        _approveFor(msg.sender, spender, amount);\n        return true;\n    }",
        "comments": [
            "",
            "    /// @notice approve `spender` to transfer `amount` tokens.",
            "    /// @param spender address to be given rights to transfer.",
            "    /// @param amount the number of tokens allowed.",
            "    /// @return success true if success.",
            "    "
        ],
        "comt": "\n    /// @notice approve `spender` to transfer `amount` tokens.\n    /// @param spender address to be given rights to transfer.\n    /// @param amount the number of tokens allowed.\n    /// @return success true if success.\n    ",
        "@notice": "approve `spender` to transfer `amount` tokens.",
        "@param1": "spender address to be given rights to transfer.",
        "@param2": "amount the number of tokens allowed.",
        "@return1": "success true if success.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approveFor",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function approveFor(\n        address owner,\n        address spender,\n        uint256 amount\n    ) public returns (bool success) {\n        require(msg.sender == owner || _superOperators[msg.sender], \"NOT_AUTHORIZED\"); // TODO metatx\n        _approveFor(owner, spender, amount);\n        return true;\n    }",
        "comments": [
            "",
            "    /// @notice approve `spender` to transfer `amount` tokens from `owner`.",
            "    /// @param owner address whose token is allowed.",
            "    /// @param spender  address to be given rights to transfer.",
            "    /// @param amount the number of tokens allowed.",
            "    /// @return success true if success.",
            "    "
        ],
        "comt": "\n    /// @notice approve `spender` to transfer `amount` tokens from `owner`.\n    /// @param owner address whose token is allowed.\n    /// @param spender  address to be given rights to transfer.\n    /// @param amount the number of tokens allowed.\n    /// @return success true if success.\n    ",
        "@notice": "approve `spender` to transfer `amount` tokens from `owner`.",
        "@param1": "owner address whose token is allowed.",
        "@param2": "spender address to be given rights to transfer.",
        "@param3": "amount the number of tokens allowed.",
        "@return1": "success true if success.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addAllowanceIfNeeded",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "amountNeeded",
                "type": "uint256"
            }
        ],
        "func": "function addAllowanceIfNeeded(\n        address owner,\n        address spender,\n        uint256 amountNeeded\n    ) public returns (bool success) {\n        require(msg.sender == owner || _superOperators[msg.sender], \"msg.sender != owner && !superOperator\");\n        _addAllowanceIfNeeded(owner, spender, amountNeeded);\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_firstBytes32",
        "visibility": "public",
        "args": [
            {
                "name": "src",
                "type": "bytes memory"
            }
        ],
        "func": "function _firstBytes32(bytes memory src) public pure returns (bytes32 output) {\n        assembly {\n            output := mload(add(src, 32))\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setMinter",
        "visibility": "external",
        "args": [
            {
                "name": "minter",
                "type": "address"
            },
            {
                "name": "enabled",
                "type": "bool"
            }
        ],
        "func": "function setMinter(address minter, bool enabled) external {\n        require(msg.sender == _admin, \"only admin is allowed to add minters\");\n        _setMinter(minter, enabled);\n    }",
        "comments": [
            "",
            "    /// @notice Enable or disable the ability of `minter` to mint tokens",
            "    /// @param minter address that will be given/removed minter right.",
            "    /// @param enabled set whether the minter is enabled or disabled.",
            "    "
        ],
        "comt": "\n    /// @notice Enable or disable the ability of `minter` to mint tokens\n    /// @param minter address that will be given/removed minter right.\n    /// @param enabled set whether the minter is enabled or disabled.\n    ",
        "@notice": "Enable or disable the ability of `minter` to mint tokens",
        "@param1": "minter address that will be given/removed minter right.",
        "@param2": "enabled set whether the minter is enabled or disabled.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isMinter",
        "visibility": "public",
        "args": [
            {
                "name": "who",
                "type": "address"
            }
        ],
        "func": "function isMinter(address who) public view returns (bool) {\n        return _minters[who];\n    }",
        "comments": [
            "",
            "    /// @notice check whether address `who` is given minter rights.",
            "    /// @param who The address to query.",
            "    /// @return whether the address has minter rights.",
            "    "
        ],
        "comt": "\n    /// @notice check whether address `who` is given minter rights.\n    /// @param who The address to query.\n    /// @return whether the address has minter rights.\n    ",
        "@notice": "check whether address `who` is given minter rights.",
        "@param1": "who The address to query.",
        "@return1": "whether the address has minter rights.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function mint(\n        address to,\n        uint256 id,\n        uint256 amount\n    ) external {\n        require(_minters[msg.sender], \"only minter allowed to mint\");\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        _packedTokenBalance[to][bin] = ObjectLib32.updateTokenBalance(_packedTokenBalance[to][bin], index, amount, ObjectLib32.Operations.ADD);\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "batchMint",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "ids",
                "type": "uint256[] calldata"
            },
            {
                "name": "amounts",
                "type": "uint256[] calldata"
            }
        ],
        "func": "function batchMint(\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external {\n        require(_minters[msg.sender], \"only minter allowed to mint\");\n        require(to != address(0), \"to is zero address\");\n\n        uint256 balTo;\n\n        uint256 lastBin = ~uint256(0);\n        for (uint256 i = 0; i < ids.length; i++) {\n            if (amounts[i] > 0) {\n                (uint256 bin, uint256 index) = ids[i].getTokenBinIndex();\n                if (lastBin == ~uint256(0)) {\n                    lastBin = bin;\n                    balTo = ObjectLib32.updateTokenBalance(_packedTokenBalance[to][bin], index, amounts[i], ObjectLib32.Operations.ADD);\n                } else {\n                    if (bin != lastBin) {\n                        _packedTokenBalance[to][lastBin] = balTo;\n                        balTo = _packedTokenBalance[to][bin];\n                        lastBin = bin;\n                    }\n\n                    balTo = balTo.updateTokenBalance(index, amounts[i], ObjectLib32.Operations.ADD);\n                }\n            }\n        }\n        if (lastBin != ~uint256(0)) {\n            _packedTokenBalance[to][lastBin] = balTo;\n        }\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getValues",
        "visibility": "external",
        "args": [
            {
                "name": "catalystId",
                "type": "uint256"
            },
            {
                "name": "seed",
                "type": "uint256"
            },
            {
                "name": "events",
                "type": "GemEvent[] calldata"
            },
            {
                "name": "totalNumberOfGemTypes",
                "type": "uint32"
            }
        ],
        "func": "function getValues(\n        uint256 catalystId,\n        uint256 seed,\n        GemEvent[] calldata events,\n        uint32 totalNumberOfGemTypes\n    ) external override view returns (uint32[] memory values) {\n        CatalystValue valueOverride = _valueOverrides[catalystId];\n        if (address(valueOverride) != address(0)) {\n            return valueOverride.getValues(catalystId, seed, events, totalNumberOfGemTypes);\n        }\n        values = new uint32[](totalNumberOfGemTypes);\n\n        uint32 numGems;\n        for (uint256 i = 0; i < events.length; i++) {\n            numGems += uint32(events[i].gemIds.length);\n        }\n        require(numGems <= MAX_UINT32, \"TOO_MANY_GEMS\");\n        uint32 minValue = (numGems - 1) * 5 + 1;\n\n        uint256 numGemsSoFar = 0;\n        for (uint256 i = 0; i < events.length; i++) {\n            numGemsSoFar += events[i].gemIds.length;\n            for (uint256 j = 0; j < events[i].gemIds.length; j++) {\n                uint256 gemId = events[i].gemIds[j];\n                uint256 slotIndex = numGemsSoFar - events[i].gemIds.length + j;\n                if (values[gemId] == 0) {\n                    // first gem : value = roll between ((numGemsSoFar-1)*5+1) and 25\n                    values[gemId] = _computeValue(seed, gemId, events[i].blockHash, slotIndex, (uint32(numGemsSoFar) - 1) * 5 + 1);\n                    // bump previous values:\n                    if (values[gemId] < minValue) {\n                        values[gemId] = minValue;\n                    }\n                } else {\n                    // further gem, previous roll are overriden with 25 and new roll between 1 and 25\n                    uint32 newRoll = _computeValue(seed, gemId, events[i].blockHash, slotIndex, 1);\n                    values[gemId] = (((values[gemId] - 1) / 25) + 1) * 25 + newRoll;\n                }\n            }\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMintData",
        "visibility": "external",
        "args": [
            {
                "name": "catalystId",
                "type": "uint256"
            }
        ],
        "func": "function getMintData(uint256 catalystId)\n        external\n        view\n        returns (\n            uint16 maxGems,\n            uint16 minQuantity,\n            uint16 maxQuantity,\n            uint256 sandMintingFee,\n            uint256 sandUpdateFee\n        )\n    {\n        maxGems = _data[catalystId].maxGems;\n        minQuantity = _data[catalystId].minQuantity;\n        maxQuantity = _data[catalystId].maxQuantity;\n        sandMintingFee = _data[catalystId].sandMintingFee;\n        sandUpdateFee = _data[catalystId].sandUpdateFee;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addCatalysts",
        "visibility": "public",
        "args": [
            {
                "name": "catalysts",
                "type": "ERC20SubToken[] memory"
            },
            {
                "name": "mintData",
                "type": "MintData[] memory"
            },
            {
                "name": "valueOverrides",
                "type": "CatalystValue[] memory"
            }
        ],
        "func": "function addCatalysts(\n        ERC20SubToken[] memory catalysts,\n        MintData[] memory mintData,\n        CatalystValue[] memory valueOverrides\n    ) public {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        require(catalysts.length == mintData.length, \"INVALID_INCONSISTENT_LENGTH\");\n        for (uint256 i = 0; i < mintData.length; i++) {\n            uint256 id = _addSubToken(catalysts[i]);\n            _setMintData(id, mintData[i]);\n            if (valueOverrides.length > i) {\n                _setValueOverride(id, valueOverrides[i]);\n            }\n        }\n    }",
        "comments": [
            "    /// @dev add Catalyst, if one of the catalyst to be added in the batch need to have a value override, all catalyst added in that batch need to have override",
            "    /// if this is not desired, they can be added in a separated batch",
            "    /// if no override are needed, the valueOverrides can be left emopty",
            "    "
        ],
        "comt": "    /// @dev add Catalyst, if one of the catalyst to be added in the batch need to have a value override, all catalyst added in that batch need to have override\n    /// if this is not desired, they can be added in a separated batch\n    /// if no override are needed, the valueOverrides can be left emopty\n    ",
        "@dev": "add Catalyst, if one of the catalyst to be added in the batch need to have a value override, all catalyst added in that batch need to have override /// if this is not desired, they can be added in a separated batch /// if no override are needed, the valueOverrides can be left emopty",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addCatalyst",
        "visibility": "public",
        "args": [
            {
                "name": "catalyst",
                "type": "ERC20SubToken"
            },
            {
                "name": "mintData",
                "type": "MintData memory"
            },
            {
                "name": "valueOverride",
                "type": "CatalystValue"
            }
        ],
        "func": "function addCatalyst(\n        ERC20SubToken catalyst,\n        MintData memory mintData,\n        CatalystValue valueOverride\n    ) public {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        uint256 id = _addSubToken(catalyst);\n        _setMintData(id, mintData);\n        _setValueOverride(id, valueOverride);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setConfiguration",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint256"
            },
            {
                "name": "minQuantity",
                "type": "uint16"
            },
            {
                "name": "maxQuantity",
                "type": "uint16"
            },
            {
                "name": "sandMintingFee",
                "type": "uint256"
            },
            {
                "name": "sandUpdateFee",
                "type": "uint256"
            }
        ],
        "func": "function setConfiguration(\n        uint256 id,\n        uint16 minQuantity,\n        uint16 maxQuantity,\n        uint256 sandMintingFee,\n        uint256 sandUpdateFee\n    ) external {\n        // CatalystMinter hardcode the value for efficiency purpose, so a change here would require a new deployment of CatalystMinter\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        _setConfiguration(id, minQuantity, maxQuantity, sandMintingFee, sandUpdateFee);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addGems",
        "visibility": "external",
        "args": [
            {
                "name": "catalysts",
                "type": "ERC20SubToken[] calldata"
            }
        ],
        "func": "function addGems(ERC20SubToken[] calldata catalysts) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        for (uint256 i = 0; i < catalysts.length; i++) {\n            _addSubToken(catalysts[i]);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addCatalysts",
        "visibility": "public",
        "args": [
            {
                "name": "names",
                "type": "string[] memory"
            },
            {
                "name": "data",
                "type": "MintData[] memory"
            }
        ],
        "func": "function addCatalysts(string[] memory names, MintData[] memory data) public {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        require(names.length == data.length, \"INVALID_INCONSISTENT_LENGTH\");\n        uint256 count = _count;\n        for (uint256 i = 0; i < data.length; i++) {\n            _names[count + i] = names[i];\n            _data[count + i] = data[i];\n        }\n        _count = count + data.length;\n        // TODO event\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addCatalyst",
        "visibility": "public",
        "args": [
            {
                "name": "name",
                "type": "string memory"
            },
            {
                "name": "data",
                "type": "MintData memory"
            }
        ],
        "func": "function addCatalyst(string memory name, MintData memory data) public {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        uint256 count = _count;\n        _names[count] = name;\n        _data[count] = data;\n        _count++;\n        // TODO event\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addGems",
        "visibility": "public",
        "args": [
            {
                "name": "names",
                "type": "string[] memory"
            }
        ],
        "func": "function addGems(string[] memory names) public {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        _addGems(names);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setFeeCollector",
        "visibility": "external",
        "args": [
            {
                "name": "newCollector",
                "type": "address"
            }
        ],
        "func": "function setFeeCollector(address newCollector) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        _setFeeCollector(newCollector);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setGemAdditionFee",
        "visibility": "external",
        "args": [
            {
                "name": "newFee",
                "type": "uint256"
            }
        ],
        "func": "function setGemAdditionFee(uint256 newFee) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        _setGemAdditionFee(newFee);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "packId",
                "type": "uint40"
            },
            {
                "name": "metadataHash",
                "type": "bytes32"
            },
            {
                "name": "catalystId",
                "type": "uint256"
            },
            {
                "name": "gemIds",
                "type": "uint256[] calldata"
            },
            {
                "name": "quantity",
                "type": "uint256"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "data",
                "type": "bytes calldata"
            }
        ],
        "func": "function mint(\n        address from,\n        uint40 packId,\n        bytes32 metadataHash,\n        uint256 catalystId,\n        uint256[] calldata gemIds,\n        uint256 quantity,\n        address to,\n        bytes calldata data\n    ) external returns (uint256) {\n        _checkAuthorization(from, to);\n        _burnCatalyst(from, catalystId);\n        uint16 maxGems = _checkQuantityAndBurnSandAndGems(from, catalystId, gemIds, quantity);\n        uint256 id = _asset.mint(from, packId, metadataHash, quantity, 0, to, data);\n        _catalystRegistry.setCatalyst(id, catalystId, maxGems, gemIds);\n        return id;\n    }",
        "comments": [
            "",
            "    /// @notice mint one Asset token.",
            "    /// @param from address creating the Asset, need to be the tx sender or meta tx signer.",
            "    /// @param packId unused packId that will let you predict the resulting tokenId.",
            "    /// @param metadataHash cidv1 ipfs hash of the folder where 0.json file contains the metadata.",
            "    /// @param catalystId address of the Catalyst ERC20 token to burn.",
            "    /// @param gemIds list of gem ids to burn in the catalyst.",
            "    /// @param quantity asset supply to mint",
            "    /// @param to destination address receiving the minted tokens.",
            "    /// @param data extra data.",
            "    "
        ],
        "comt": "\n    /// @notice mint one Asset token.\n    /// @param from address creating the Asset, need to be the tx sender or meta tx signer.\n    /// @param packId unused packId that will let you predict the resulting tokenId.\n    /// @param metadataHash cidv1 ipfs hash of the folder where 0.json file contains the metadata.\n    /// @param catalystId address of the Catalyst ERC20 token to burn.\n    /// @param gemIds list of gem ids to burn in the catalyst.\n    /// @param quantity asset supply to mint\n    /// @param to destination address receiving the minted tokens.\n    /// @param data extra data.\n    ",
        "@notice": "mint one Asset token.",
        "@param1": "from address creating the Asset, need to be the tx sender or meta tx signer.",
        "@param2": "packId unused packId that will let you predict the resulting tokenId.",
        "@param3": "metadataHash cidv1 ipfs hash of the folder where 0.json file contains the metadata.",
        "@param4": "catalystId address of the Catalyst ERC20 token to burn.",
        "@param5": "gemIds list of gem ids to burn in the catalyst.",
        "@param6": "quantity asset supply to mint",
        "@param7": "to destination address receiving the minted tokens.",
        "@param8": "data extra data.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "extractAndChangeCatalyst",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "assetId",
                "type": "uint256"
            },
            {
                "name": "catalystId",
                "type": "uint256"
            },
            {
                "name": "gemIds",
                "type": "uint256[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            }
        ],
        "func": "function extractAndChangeCatalyst(\n        address from,\n        uint256 assetId,\n        uint256 catalystId,\n        uint256[] calldata gemIds,\n        address to\n    ) external returns (uint256 tokenId) {\n        _checkAuthorization(from, to);\n        tokenId = _asset.extractERC721From(from, assetId, from);\n        _changeCatalyst(from, tokenId, catalystId, gemIds, to);\n    }",
        "comments": [
            "",
            "    /// @notice associate a catalyst to a fungible Asset token by extracting it as ERC721 first.",
            "    /// @param from address from which the Asset token belongs to.",
            "    /// @param assetId tokenId of the Asset being extracted.",
            "    /// @param catalystId address of the catalyst token to use and burn.",
            "    /// @param gemIds list of gems to socket into the catalyst (burned).",
            "    /// @param to destination address receiving the extracted and upgraded ERC721 Asset token.",
            "    "
        ],
        "comt": "\n    /// @notice associate a catalyst to a fungible Asset token by extracting it as ERC721 first.\n    /// @param from address from which the Asset token belongs to.\n    /// @param assetId tokenId of the Asset being extracted.\n    /// @param catalystId address of the catalyst token to use and burn.\n    /// @param gemIds list of gems to socket into the catalyst (burned).\n    /// @param to destination address receiving the extracted and upgraded ERC721 Asset token.\n    ",
        "@notice": "associate a catalyst to a fungible Asset token by extracting it as ERC721 first.",
        "@param1": "from address from which the Asset token belongs to.",
        "@param2": "assetId tokenId of the Asset being extracted.",
        "@param3": "catalystId address of the catalyst token to use and burn.",
        "@param4": "gemIds list of gems to socket into the catalyst (burned).",
        "@param5": "to destination address receiving the extracted and upgraded ERC721 Asset token.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeCatalyst",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "assetId",
                "type": "uint256"
            },
            {
                "name": "catalystId",
                "type": "uint256"
            },
            {
                "name": "gemIds",
                "type": "uint256[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            }
        ],
        "func": "function changeCatalyst(\n        address from,\n        uint256 assetId,\n        uint256 catalystId,\n        uint256[] calldata gemIds,\n        address to\n    ) external returns (uint256 tokenId) {\n        _checkAuthorization(from, to);\n        _changeCatalyst(from, assetId, catalystId, gemIds, to);\n        return assetId;\n    }",
        "comments": [
            "",
            "    /// @notice associate a new catalyst to a non-fungible Asset token.",
            "    /// @param from address from which the Asset token belongs to.",
            "    /// @param assetId tokenId of the Asset being updated.",
            "    /// @param catalystId address of the catalyst token to use and burn.",
            "    /// @param gemIds list of gems to socket into the catalyst (burned).",
            "    /// @param to destination address receiving the Asset token.",
            "    "
        ],
        "comt": "\n    /// @notice associate a new catalyst to a non-fungible Asset token.\n    /// @param from address from which the Asset token belongs to.\n    /// @param assetId tokenId of the Asset being updated.\n    /// @param catalystId address of the catalyst token to use and burn.\n    /// @param gemIds list of gems to socket into the catalyst (burned).\n    /// @param to destination address receiving the Asset token.\n    ",
        "@notice": "associate a new catalyst to a non-fungible Asset token.",
        "@param1": "from address from which the Asset token belongs to.",
        "@param2": "assetId tokenId of the Asset being updated.",
        "@param3": "catalystId address of the catalyst token to use and burn.",
        "@param4": "gemIds list of gems to socket into the catalyst (burned).",
        "@param5": "to destination address receiving the Asset token.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "extractAndAddGems",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "assetId",
                "type": "uint256"
            },
            {
                "name": "gemIds",
                "type": "uint256[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            }
        ],
        "func": "function extractAndAddGems(\n        address from,\n        uint256 assetId,\n        uint256[] calldata gemIds,\n        address to\n    ) external returns (uint256 tokenId) {\n        _checkAuthorization(from, to);\n        tokenId = _asset.extractERC721From(from, assetId, from);\n        _addGems(from, tokenId, gemIds, to);\n    }",
        "comments": [
            "",
            "    /// @notice add gems to a fungible Asset token by extracting it as ERC721 first.",
            "    /// @param from address from which the Asset token belongs to.",
            "    /// @param assetId tokenId of the Asset being extracted.",
            "    /// @param gemIds list of gems to socket into the existing catalyst (burned).",
            "    /// @param to destination address receiving the extracted and upgraded ERC721 Asset token.",
            "    "
        ],
        "comt": "\n    /// @notice add gems to a fungible Asset token by extracting it as ERC721 first.\n    /// @param from address from which the Asset token belongs to.\n    /// @param assetId tokenId of the Asset being extracted.\n    /// @param gemIds list of gems to socket into the existing catalyst (burned).\n    /// @param to destination address receiving the extracted and upgraded ERC721 Asset token.\n    ",
        "@notice": "add gems to a fungible Asset token by extracting it as ERC721 first.",
        "@param1": "from address from which the Asset token belongs to.",
        "@param2": "assetId tokenId of the Asset being extracted.",
        "@param3": "gemIds list of gems to socket into the existing catalyst (burned).",
        "@param4": "to destination address receiving the extracted and upgraded ERC721 Asset token.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addGems",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "assetId",
                "type": "uint256"
            },
            {
                "name": "gemIds",
                "type": "uint256[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            }
        ],
        "func": "function addGems(\n        address from,\n        uint256 assetId,\n        uint256[] calldata gemIds,\n        address to\n    ) external {\n        _checkAuthorization(from, to);\n        _addGems(from, assetId, gemIds, to);\n    }",
        "comments": [
            "",
            "    /// @notice add gems to a non-fungible Asset token.",
            "    /// @param from address from which the Asset token belongs to.",
            "    /// @param assetId tokenId of the Asset to which the gems will be added to.",
            "    /// @param gemIds list of gems to socket into the existing catalyst (burned).",
            "    /// @param to destination address receiving the extracted and upgraded ERC721 Asset token.",
            "    "
        ],
        "comt": "\n    /// @notice add gems to a non-fungible Asset token.\n    /// @param from address from which the Asset token belongs to.\n    /// @param assetId tokenId of the Asset to which the gems will be added to.\n    /// @param gemIds list of gems to socket into the existing catalyst (burned).\n    /// @param to destination address receiving the extracted and upgraded ERC721 Asset token.\n    ",
        "@notice": "add gems to a non-fungible Asset token.",
        "@param1": "from address from which the Asset token belongs to.",
        "@param2": "assetId tokenId of the Asset to which the gems will be added to.",
        "@param3": "gemIds list of gems to socket into the existing catalyst (burned).",
        "@param4": "to destination address receiving the extracted and upgraded ERC721 Asset token.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mintMultiple",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "packId",
                "type": "uint40"
            },
            {
                "name": "metadataHash",
                "type": "bytes32"
            },
            {
                "name": "gemsQuantities",
                "type": "uint256[] memory"
            },
            {
                "name": "catalystsQuantities",
                "type": "uint256[] memory"
            },
            {
                "name": "assets",
                "type": "AssetData[] memory"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "data",
                "type": "bytes memory"
            }
        ],
        "func": "function mintMultiple(\n        address from,\n        uint40 packId,\n        bytes32 metadataHash,\n        uint256[] memory gemsQuantities,\n        uint256[] memory catalystsQuantities,\n        AssetData[] memory assets,\n        address to,\n        bytes memory data\n    ) public returns (uint256[] memory ids) {\n        require(assets.length != 0, \"INVALID_0_ASSETS\");\n        _checkAuthorization(from, to);\n        return _mintMultiple(from, packId, metadataHash, gemsQuantities, catalystsQuantities, assets, to, data);\n    }",
        "comments": [
            "",
            "    /// @notice mint multiple Asset tokens.",
            "    /// @param from address creating the Asset, need to be the tx sender or meta tx signer.",
            "    /// @param packId unused packId that will let you predict the resulting tokenId.",
            "    /// @param metadataHash cidv1 ipfs hash of the folder where 0.json file contains the metadata.",
            "    /// @param gemsQuantities quantities of gems to be used for each id in order",
            "    /// @param catalystsQuantities quantities of catalyst to be used for each id in order",
            "    /// @param assets contains the data to associate catalyst and gems to the assets.",
            "    /// @param to destination address receiving the minted tokens.",
            "    /// @param data extra data.",
            "    "
        ],
        "comt": "\n    /// @notice mint multiple Asset tokens.\n    /// @param from address creating the Asset, need to be the tx sender or meta tx signer.\n    /// @param packId unused packId that will let you predict the resulting tokenId.\n    /// @param metadataHash cidv1 ipfs hash of the folder where 0.json file contains the metadata.\n    /// @param gemsQuantities quantities of gems to be used for each id in order\n    /// @param catalystsQuantities quantities of catalyst to be used for each id in order\n    /// @param assets contains the data to associate catalyst and gems to the assets.\n    /// @param to destination address receiving the minted tokens.\n    /// @param data extra data.\n    ",
        "@notice": "mint multiple Asset tokens.",
        "@param1": "from address creating the Asset, need to be the tx sender or meta tx signer.",
        "@param2": "packId unused packId that will let you predict the resulting tokenId.",
        "@param3": "metadataHash cidv1 ipfs hash of the folder where 0.json file contains the metadata.",
        "@param4": "gemsQuantities quantities of gems to be used for each id in order",
        "@param5": "catalystsQuantities quantities of catalyst to be used for each id in order",
        "@param6": "assets contains the data to associate catalyst and gems to the assets.",
        "@param7": "to destination address receiving the minted tokens.",
        "@param8": "data extra data.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCatalyst",
        "visibility": "external",
        "args": [
            {
                "name": "assetId",
                "type": "uint256"
            }
        ],
        "func": "function getCatalyst(uint256 assetId) external view returns (bool exists, uint256 catalystId) {\n        CatalystStored memory catalyst = _catalysts[assetId];\n        if (catalyst.set != 0) {\n            return (true, catalyst.catalystId);\n        }\n        if (assetId & IS_NFT != 0) {\n            catalyst = _catalysts[_getCollectionId(assetId)];\n            return (catalyst.set != 0, catalyst.catalystId);\n        }\n        return (false, 0);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setCatalyst",
        "visibility": "external",
        "args": [
            {
                "name": "assetId",
                "type": "uint256"
            },
            {
                "name": "catalystId",
                "type": "uint256"
            },
            {
                "name": "maxGems",
                "type": "uint256"
            },
            {
                "name": "gemIds",
                "type": "uint256[] calldata"
            }
        ],
        "func": "function setCatalyst(\n        uint256 assetId,\n        uint256 catalystId,\n        uint256 maxGems,\n        uint256[] calldata gemIds\n    ) external {\n        require(msg.sender == _minter, \"NOT_AUTHORIZED_MINTER\");\n        require(gemIds.length <= maxGems, \"INVALID_GEMS_TOO_MANY\");\n        uint256 emptySockets = maxGems - gemIds.length;\n        _catalysts[assetId] = CatalystStored(uint64(emptySockets), uint64(catalystId), 1);\n        uint64 blockNumber = _getBlockNumber();\n        emit CatalystApplied(assetId, catalystId, assetId, gemIds, blockNumber);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addGems",
        "visibility": "external",
        "args": [
            {
                "name": "assetId",
                "type": "uint256"
            },
            {
                "name": "gemIds",
                "type": "uint256[] calldata"
            }
        ],
        "func": "function addGems(uint256 assetId, uint256[] calldata gemIds) external {\n        require(msg.sender == _minter, \"NOT_AUTHORIZED_MINTER\");\n        require(assetId & IS_NFT != 0, \"INVALID_NOT_NFT\");\n        require(gemIds.length != 0, \"INVALID_GEMS_0\");\n        (uint256 emptySockets, uint256 seed) = _getSocketData(assetId);\n        require(emptySockets >= gemIds.length, \"INVALID_GEMS_TOO_MANY\");\n        emptySockets -= gemIds.length;\n        _catalysts[assetId].emptySockets = uint64(emptySockets);\n        uint64 blockNumber = _getBlockNumber();\n        emit GemsAdded(assetId, seed, gemIds, blockNumber);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setMinter",
        "visibility": "external",
        "args": [
            {
                "name": "minter",
                "type": "address"
            }
        ],
        "func": "function setMinter(address minter) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        require(minter != _minter, \"INVALID_MINTER_SAME_ALREADY_SET\");\n        _minter = minter;\n        emit Minter(minter);\n    }",
        "comments": [
            "",
            "    /// @dev Set the Minter that will be the only address able to create Estate",
            "    /// @param minter address of the minter",
            "    "
        ],
        "comt": "\n    /// @dev Set the Minter that will be the only address able to create Estate\n    /// @param minter address of the minter\n    ",
        "@dev": "Set the Minter that will be the only address able to create Estate",
        "@param1": "minter address of the minter",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMinter",
        "visibility": "external",
        "args": [],
        "func": "function getMinter() external view returns (address) {\n        return _minter;\n    }",
        "comments": [
            "",
            "    /// @dev return the current minter",
            "    "
        ],
        "comt": "\n    /// @dev return the current minter\n    ",
        "@dev": "return the current minter",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getValues",
        "visibility": "external",
        "args": [
            {
                "name": "catalystId",
                "type": "uint256"
            },
            {
                "name": "seed",
                "type": "uint256"
            },
            {
                "name": "events",
                "type": "GemEvent[] calldata"
            },
            {
                "name": "totalNumberOfGemTypes",
                "type": "uint32"
            }
        ],
        "func": "function getValues(\n        uint256 catalystId,\n        uint256 seed,\n        GemEvent[] calldata events,\n        uint32 totalNumberOfGemTypes\n    ) external override view returns (uint32[] memory values) {\n        return _catalystValue.getValues(catalystId, seed, events, totalNumberOfGemTypes);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "renounceOwnership",
        "visibility": "public",
        "args": [],
        "func": "function renounceOwnership() public onlyOwner {\n    //     emit OwnershipRenounced(owner);\n    //     owner = address(0);\n    // }",
        "comments": [
            "",
            "    // /**",
            "    // * @dev Allows the current owner to relinquish control of the contract.",
            "    // * @notice Renouncing to ownership will leave the contract without an owner.",
            "    // * It will not be possible to call the functions with the `onlyOwner`",
            "    // * modifier anymore.",
            "    // */",
            "    // "
        ],
        "comt": "\n    // /**\n    // * @dev Allows the current owner to relinquish control of the contract.\n    // * @notice Renouncing to ownership will leave the contract without an owner.\n    // * It will not be possible to call the functions with the `onlyOwner`\n    // * modifier anymore.\n    // */\n    // ",
        "@dev": "Allows the current owner to relinquish control of the contract.",
        "@notice": "Renouncing to ownership will leave the contract without an owner. // * It will not be possible to call the functions with the `onlyOwner` // * modifier anymore.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferOwnership",
        "visibility": "public",
        "args": [
            {
                "name": "_newOwner",
                "type": "address payable"
            }
        ],
        "func": "function transferOwnership(address payable _newOwner) public onlyOwner {\n        _transferOwnership(_newOwner);\n    }",
        "comments": [
            "/**",
            "     * @dev Allows the current owner to transfer control of the contract to a newOwner.",
            "     * @param _newOwner The address to transfer ownership to.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param _newOwner The address to transfer ownership to.\n     */\n",
        "@dev": "Allows the current owner to transfer control of the contract to a newOwner.",
        "@param1": "_newOwner The address to transfer ownership to.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "pause",
        "visibility": "public",
        "args": [],
        "func": "function pause() public onlyOwner whenNotPaused {\n        paused = true;\n        emit Pause();\n    }",
        "comments": [
            "/**",
            "     * @dev called by the owner to pause, triggers stopped state",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n",
        "@dev": "called by the owner to pause, triggers stopped state",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unpause",
        "visibility": "public",
        "args": [],
        "func": "function unpause() public onlyOwner whenPaused {\n        paused = false;\n        emit Unpause();\n    }",
        "comments": [
            "/**",
            "     * @dev called by the owner to unpause, returns to normal state",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n",
        "@dev": "called by the owner to unpause, returns to normal state",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setDefaultReferral",
        "visibility": "public",
        "args": [
            {
                "name": "_defaultReferralPercentage",
                "type": "uint256"
            }
        ],
        "func": "function setDefaultReferral(uint256 _defaultReferralPercentage) public onlyOwner {\n        require(_defaultReferralPercentage < 10000, \"Referral must be less than 100 percent\");\n        require(_defaultReferralPercentage != defaultReferralPercentage, \"New referral must be different from the previous\");\n        defaultReferralPercentage = _defaultReferralPercentage;\n        emit DefaultReferralSet(_defaultReferralPercentage);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setCustomReferral",
        "visibility": "public",
        "args": [
            {
                "name": "_referrer",
                "type": "address"
            },
            {
                "name": "_customReferralPercentage",
                "type": "uint256"
            }
        ],
        "func": "function setCustomReferral(address _referrer, uint256 _customReferralPercentage) public onlyOwner {\n        require(_customReferralPercentage < 10000, \"Referral must be less than 100 percent\");\n        require(_customReferralPercentage != customReferralPercentages[_referrer], \"New referral must be different from the previous\");\n        customReferralPercentages[_referrer] = _customReferralPercentage;\n        emit CustomReferralSet(_referrer, _customReferralPercentage);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawEther",
        "visibility": "external",
        "args": [
            {
                "name": "_destination",
                "type": "address payable"
            }
        ],
        "func": "function withdrawEther(address payable _destination) external onlyOwner {\n        _destination.transfer(address(this).balance);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawToken",
        "visibility": "external",
        "args": [
            {
                "name": "_token",
                "type": "ERC20"
            },
            {
                "name": "_destination",
                "type": "address"
            }
        ],
        "func": "function withdrawToken(ERC20 _token, address _destination) external onlyOwner {\n        require(_token.transfer(_destination, _token.balanceOf(address(this))), \"Transfer failed\");\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "admin",
        "visibility": "external",
        "args": [],
        "func": "function admin() external ifAdmin returns (address) {\n        return _admin();\n    }",
        "comments": [
            "/**",
            "     * @return The address of the proxy admin.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @return The address of the proxy admin.\n     */\n",
        "@return1": "The address of the proxy admin.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "implementation",
        "visibility": "external",
        "args": [],
        "func": "function implementation() external ifAdmin returns (address) {\n        return _implementation();\n    }",
        "comments": [
            "/**",
            "     * @return The address of the implementation.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @return The address of the implementation.\n     */\n",
        "@return1": "The address of the implementation.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeAdmin",
        "visibility": "external",
        "args": [
            {
                "name": "newAdmin",
                "type": "address"
            }
        ],
        "func": "function changeAdmin(address newAdmin) external ifAdmin {\n        require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n        emit AdminChanged(_admin(), newAdmin);\n        _setAdmin(newAdmin);\n    }",
        "comments": [
            "/**",
            "     * @dev Changes the admin of the proxy.",
            "     * Only the current admin can call this function.",
            "     * @param newAdmin Address to transfer proxy administration to.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Changes the admin of the proxy.\n     * Only the current admin can call this function.\n     * @param newAdmin Address to transfer proxy administration to.\n     */\n",
        "@dev": "Changes the admin of the proxy. * Only the current admin can call this function.",
        "@param1": "newAdmin Address to transfer proxy administration to.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "upgradeTo",
        "visibility": "external",
        "args": [
            {
                "name": "newImplementation",
                "type": "address"
            }
        ],
        "func": "function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeTo(newImplementation);\n    }",
        "comments": [
            "/**",
            "     * @dev Upgrade the backing implementation of the proxy.",
            "     * Only the admin can call this function.",
            "     * @param newImplementation Address of the new implementation.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Upgrade the backing implementation of the proxy.\n     * Only the admin can call this function.\n     * @param newImplementation Address of the new implementation.\n     */\n",
        "@dev": "Upgrade the backing implementation of the proxy. * Only the admin can call this function.",
        "@param1": "newImplementation Address of the new implementation.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "upgradeToAndCall",
        "visibility": "external",
        "args": [
            {
                "name": "newImplementation",
                "type": "address"
            },
            {
                "name": "data",
                "type": "bytes calldata"
            }
        ],
        "func": "function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeTo(newImplementation);\n        (bool success, ) = newImplementation.delegatecall(data);\n        require(success, \"failed to call newImplementation\");\n    }",
        "comments": [
            "/**",
            "     * @dev Upgrade the backing implementation of the proxy and call a function",
            "     * on the new implementation.",
            "     * This is useful to initialize the proxied contract.",
            "     * @param newImplementation Address of the new implementation.",
            "     * @param data Data to send as msg.data in the low level call.",
            "     * It should include the signature and the parameters of the function to be called, as described in",
            "     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Upgrade the backing implementation of the proxy and call a function\n     * on the new implementation.\n     * This is useful to initialize the proxied contract.\n     * @param newImplementation Address of the new implementation.\n     * @param data Data to send as msg.data in the low level call.\n     * It should include the signature and the parameters of the function to be called, as described in\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n     */\n",
        "@dev": "Upgrade the backing implementation of the proxy and call a function * on the new implementation. * This is useful to initialize the proxied contract.",
        "@param1": "newImplementation Address of the new implementation.",
        "@param2": "data Data to send as msg.data in the low level call. * It should include the signature and the parameters of the function to be called, as described in * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "proxyAddress",
        "visibility": "public",
        "args": [],
        "func": "function proxyAddress() public view returns (address) {\n        return address(proxy);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "admin",
        "visibility": "public",
        "args": [],
        "func": "function admin() public returns (address) {\n        return proxy.admin();\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeAdmin",
        "visibility": "public",
        "args": [
            {
                "name": "newAdmin",
                "type": "address"
            }
        ],
        "func": "function changeAdmin(address newAdmin) public onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "upgradeTo",
        "visibility": "public",
        "args": [
            {
                "name": "implementation",
                "type": "address"
            }
        ],
        "func": "function upgradeTo(address implementation) public onlyOwner {\n        proxy.upgradeTo(implementation);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "upgradeToAndCall",
        "visibility": "public",
        "args": [
            {
                "name": "implementation",
                "type": "address"
            },
            {
                "name": "data",
                "type": "bytes memory"
            }
        ],
        "func": "function upgradeToAndCall(address implementation, bytes memory data) public payable onlyOwner {\n        // prettier-ignore\n        proxy.upgradeToAndCall{value:msg.value}(implementation, data);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setReceivingWallet",
        "visibility": "external",
        "args": [
            {
                "name": "newWallet",
                "type": "address payable"
            }
        ],
        "func": "function setReceivingWallet(address payable newWallet) external {\n        require(newWallet != address(0), \"ZERO_ADDRESS\");\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _wallet = newWallet;\n    }",
        "comments": [
            "",
            "    /// @notice set the wallet receiving the proceeds",
            "    /// @param newWallet address of the new receiving wallet",
            "    "
        ],
        "comt": "\n    /// @notice set the wallet receiving the proceeds\n    /// @param newWallet address of the new receiving wallet\n    ",
        "@notice": "set the wallet receiving the proceeds",
        "@param1": "newWallet address of the new receiving wallet",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "rebalanceSand",
        "visibility": "external",
        "args": [
            {
                "name": "newMultiplier",
                "type": "uint256"
            }
        ],
        "func": "function rebalanceSand(uint256 newMultiplier) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _multiplier = newMultiplier;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getSandMultiplier",
        "visibility": "external",
        "args": [],
        "func": "function getSandMultiplier() external view returns (uint256) {\n        return _multiplier;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "buyLandWithSand",
        "visibility": "external",
        "args": [
            {
                "name": "buyer",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "reserved",
                "type": "address"
            },
            {
                "name": "x",
                "type": "uint256"
            },
            {
                "name": "y",
                "type": "uint256"
            },
            {
                "name": "size",
                "type": "uint256"
            },
            {
                "name": "priceInSand",
                "type": "uint256"
            },
            {
                "name": "adjustedPriceInSand",
                "type": "uint256"
            },
            {
                "name": "salt",
                "type": "bytes32"
            },
            {
                "name": "assetIds",
                "type": "uint256[] calldata"
            },
            {
                "name": "proof",
                "type": "bytes32[] calldata"
            },
            {
                "name": "referral",
                "type": "bytes calldata"
            }
        ],
        "func": "function buyLandWithSand(\n        address buyer,\n        address to,\n        address reserved,\n        uint256 x,\n        uint256 y,\n        uint256 size,\n        uint256 priceInSand,\n        uint256 adjustedPriceInSand,\n        bytes32 salt,\n        uint256[] calldata assetIds,\n        bytes32[] calldata proof,\n        bytes calldata referral\n    ) external {\n        _checkPrices(priceInSand, adjustedPriceInSand);\n        _checkValidity(buyer, reserved, x, y, size, priceInSand, salt, assetIds, proof);\n        _handleFeeAndReferral(buyer, adjustedPriceInSand, referral);\n        _mint(buyer, to, x, y, size, adjustedPriceInSand, address(_sand), adjustedPriceInSand);\n        _sendAssets(to, assetIds);\n    }",
        "comments": [
            "",
            "    /// @notice buy Land with SAND using the merkle proof associated with it",
            "    /// @param buyer address that perform the payment",
            "    /// @param to address that will own the purchased Land",
            "    /// @param reserved the reserved address (if any)",
            "    /// @param x x coordinate of the Land",
            "    /// @param y y coordinate of the Land",
            "    /// @param size size of the pack of Land to purchase",
            "    /// @param priceInSand price in SAND to purchase that Land",
            "    /// @param proof merkleProof for that particular Land",
            "    "
        ],
        "comt": "\n    /// @notice buy Land with SAND using the merkle proof associated with it\n    /// @param buyer address that perform the payment\n    /// @param to address that will own the purchased Land\n    /// @param reserved the reserved address (if any)\n    /// @param x x coordinate of the Land\n    /// @param y y coordinate of the Land\n    /// @param size size of the pack of Land to purchase\n    /// @param priceInSand price in SAND to purchase that Land\n    /// @param proof merkleProof for that particular Land\n    ",
        "@notice": "buy Land with SAND using the merkle proof associated with it",
        "@param1": "buyer address that perform the payment",
        "@param2": "to address that will own the purchased Land",
        "@param3": "reserved the reserved address (if any)",
        "@param4": "x x coordinate of the Land",
        "@param5": "y y coordinate of the Land",
        "@param6": "size size of the pack of Land to purchase",
        "@param7": "priceInSand price in SAND to purchase that Land",
        "@param8": "proof merkleProof for that particular Land",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getExpiryTime",
        "visibility": "external",
        "args": [],
        "func": "function getExpiryTime() external view returns (uint256) {\n        return _expiryTime;\n    }",
        "comments": [
            "",
            "    /// @notice Gets the expiry time for the current sale",
            "    /// @return The expiry time, as a unix epoch",
            "    "
        ],
        "comt": "\n    /// @notice Gets the expiry time for the current sale\n    /// @return The expiry time, as a unix epoch\n    ",
        "@notice": "Gets the expiry time for the current sale",
        "@return1": "The expiry time, as a unix epoch",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMerkleRoot",
        "visibility": "external",
        "args": [],
        "func": "function getMerkleRoot() external view returns (bytes32) {\n        return _merkleRoot;\n    }",
        "comments": [
            "",
            "    /// @notice Gets the Merkle root associated with the current sale",
            "    /// @return The Merkle root, as a bytes32 hash",
            "    "
        ],
        "comt": "\n    /// @notice Gets the Merkle root associated with the current sale\n    /// @return The Merkle root, as a bytes32 hash\n    ",
        "@notice": "Gets the Merkle root associated with the current sale",
        "@return1": "The Merkle root, as a bytes32 hash",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawAssets",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "assetIds",
                "type": "uint256[] calldata"
            },
            {
                "name": "values",
                "type": "uint256[] calldata"
            }
        ],
        "func": "function withdrawAssets(\n        address to,\n        uint256[] calldata assetIds,\n        uint256[] calldata values\n    ) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        require(block.timestamp > _expiryTime, \"SALE_NOT_OVER\");\n        _asset.safeBatchTransferFrom(address(this), to, assetIds, values, \"\");\n    }",
        "comments": [
            "",
            "    /// @notice enable Admin to withdraw remaining assets from EstateSaleWithFee contract",
            "    /// @param to intended recipient of the asset tokens",
            "    /// @param assetIds the assetIds to be transferred",
            "    /// @param values the quantities of the assetIds to be transferred",
            "    "
        ],
        "comt": "\n    /// @notice enable Admin to withdraw remaining assets from EstateSaleWithFee contract\n    /// @param to intended recipient of the asset tokens\n    /// @param assetIds the assetIds to be transferred\n    /// @param values the quantities of the assetIds to be transferred\n    ",
        "@notice": "enable Admin to withdraw remaining assets from EstateSaleWithFee contract",
        "@param1": "to intended recipient of the asset tokens",
        "@param2": "assetIds the assetIds to be transferred",
        "@param3": "values the quantities of the assetIds to be transferred",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "onERC1155Received",
        "visibility": "external",
        "args": [
            {
                "name": "address",
                "type": "address"
            },
            {
                "name": "address",
                "type": "/*operator*/\n       "
            },
            {
                "name": "uint256",
                "type": "/*from*/\n       "
            },
            {
                "name": "uint256",
                "type": "/*id*/\n       "
            },
            {
                "name": "/*data*/",
                "type": "/*value*/\n        bytes calldata"
            }
        ],
        "func": "function onERC1155Received(\n        address, /*operator*/\n        address, /*from*/\n        uint256, /*id*/\n        uint256, /*value*/\n        bytes calldata /*data*/\n    ) external pure returns (bytes4) {\n        return 0xf23a6e61;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "onERC1155BatchReceived",
        "visibility": "external",
        "args": [
            {
                "name": "address",
                "type": "address"
            },
            {
                "name": "address",
                "type": "/*operator*/\n       "
            },
            {
                "name": "calldata",
                "type": "/*from*/\n        uint256[]"
            },
            {
                "name": "calldata",
                "type": "/*ids*/\n        uint256[]"
            },
            {
                "name": "/*data*/",
                "type": "/*values*/\n        bytes calldata"
            }
        ],
        "func": "function onERC1155BatchReceived(\n        address, /*operator*/\n        address, /*from*/\n        uint256[] calldata, /*ids*/\n        uint256[] calldata, /*values*/\n        bytes calldata /*data*/\n    ) external pure returns (bytes4) {\n        return 0xbc197c81;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateSigningWallet",
        "visibility": "external",
        "args": [
            {
                "name": "newSigningWallet",
                "type": "address"
            }
        ],
        "func": "function updateSigningWallet(address newSigningWallet) external {\n        require(_admin == msg.sender, \"Sender not admin\");\n        _previousSigningWallets[_signingWallet] = now + _previousSigningDelay;\n        _signingWallet = newSigningWallet;\n    }",
        "comments": [
            "/**",
            "     * @dev Update the signing wallet",
            "     * @param newSigningWallet The new address of the signing wallet",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Update the signing wallet\n     * @param newSigningWallet The new address of the signing wallet\n     */\n",
        "@dev": "Update the signing wallet",
        "@param1": "newSigningWallet The new address of the signing wallet",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getSigningWallet",
        "visibility": "external",
        "args": [],
        "func": "function getSigningWallet() external view returns (address) {\n        return _signingWallet;\n    }",
        "comments": [
            "/**",
            "     * @dev signing wallet authorized for referral",
            "     * @return the address of the signing wallet",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev signing wallet authorized for referral\n     * @return the address of the signing wallet\n     */\n",
        "@dev": "signing wallet authorized for referral",
        "@return1": "the address of the signing wallet",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMaxCommisionRate",
        "visibility": "external",
        "args": [],
        "func": "function getMaxCommisionRate() external view returns (uint256) {\n        return _maxCommissionRate;\n    }",
        "comments": [
            "/**",
            "     * @notice the max commision rate",
            "     * @return the maximum commision rate that a referral can give",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice the max commision rate\n     * @return the maximum commision rate that a referral can give\n     */\n",
        "@notice": "the max commision rate",
        "@return1": "the maximum commision rate that a referral can give",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateMaxCommissionRate",
        "visibility": "external",
        "args": [
            {
                "name": "newMaxCommissionRate",
                "type": "uint256"
            }
        ],
        "func": "function updateMaxCommissionRate(uint256 newMaxCommissionRate) external {\n        require(_admin == msg.sender, \"Sender not admin\");\n        _maxCommissionRate = newMaxCommissionRate;\n    }",
        "comments": [
            "/**",
            "     * @dev Update the maximum commission rate",
            "     * @param newMaxCommissionRate The new maximum commission rate",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Update the maximum commission rate\n     * @param newMaxCommissionRate The new maximum commission rate\n     */\n",
        "@dev": "Update the maximum commission rate",
        "@param1": "newMaxCommissionRate The new maximum commission rate",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isReferralValid",
        "visibility": "public",
        "args": [
            {
                "name": "signature",
                "type": "bytes memory"
            },
            {
                "name": "referrer",
                "type": "address"
            },
            {
                "name": "referee",
                "type": "address"
            },
            {
                "name": "expiryTime",
                "type": "uint256"
            },
            {
                "name": "commissionRate",
                "type": "uint256"
            }
        ],
        "func": "function isReferralValid(\n        bytes memory signature,\n        address referrer,\n        address referee,\n        uint256 expiryTime,\n        uint256 commissionRate\n    ) public view returns (bool) {\n        if (commissionRate > _maxCommissionRate || referrer == referee || now > expiryTime) {\n            return false;\n        }\n\n        bytes32 hashedData = keccak256(abi.encodePacked(referrer, referee, expiryTime, commissionRate));\n\n        address signer = SigUtil.recover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hashedData)), signature);\n\n        if (_previousSigningWallets[signer] >= now) {\n            return true;\n        }\n\n        return _signingWallet == signer;\n    }",
        "comments": [
            "/**",
            "     * @notice Check if a referral is valid",
            "     * @param signature The signature to check (signed referral)",
            "     * @param referrer The address of the referrer",
            "     * @param referee The address of the referee",
            "     * @param expiryTime The expiry time of the referral",
            "     * @param commissionRate The commissionRate of the referral",
            "     * @return True if the referral is valid",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Check if a referral is valid\n     * @param signature The signature to check (signed referral)\n     * @param referrer The address of the referrer\n     * @param referee The address of the referee\n     * @param expiryTime The expiry time of the referral\n     * @param commissionRate The commissionRate of the referral\n     * @return True if the referral is valid\n     */\n",
        "@notice": "Check if a referral is valid",
        "@param1": "signature The signature to check (signed referral)",
        "@param2": "referrer The address of the referrer",
        "@param3": "referee The address of the referee",
        "@param4": "expiryTime The expiry time of the referral",
        "@param5": "commissionRate The commissionRate of the referral",
        "@return1": "True if the referral is valid",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decodeReferral",
        "visibility": "public",
        "args": [
            {
                "name": "referral",
                "type": "bytes memory"
            }
        ],
        "func": "function decodeReferral(bytes memory referral)\n        public\n        pure\n        returns (\n            bytes memory,\n            address,\n            address,\n            uint256,\n            uint256\n        )\n    {\n        (bytes memory signature, address referrer, address referee, uint256 expiryTime, uint256 commissionRate) = abi.decode(\n            referral,\n            (bytes, address, address, uint256, uint256)\n        );\n\n        return (signature, referrer, referee, expiryTime, commissionRate);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "IERC20"
            },
            {
                "name": "beneficiary",
                "type": "address payable"
            }
        ],
        "func": "function withdraw(IERC20 token, address payable beneficiary) external returns (uint256 amount) {\n        if (address(token) == address(0)) {\n            amount = _etherWithdrawal(beneficiary);\n        } else {\n            amount = _tokenWithdrawal(token, beneficiary);\n        }\n        if (amount != 0) {\n            emit Withdrawal(token, msg.sender, amount);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Enables fee holder to withdraw its share",
            "    /// @notice Zero address reserved for ether withdrawal",
            "    /// @param token the token that fee should be distributed in",
            "    /// @param beneficiary the address that will receive fees",
            "    /// @return amount had withdrawn",
            "    "
        ],
        "comt": "\n    /// @notice Enables fee holder to withdraw its share\n    /// @notice Zero address reserved for ether withdrawal\n    /// @param token the token that fee should be distributed in\n    /// @param beneficiary the address that will receive fees\n    /// @return amount had withdrawn\n    ",
        "@notice": "Enables fee holder to withdraw its share * Zero address reserved for ether withdrawal",
        "@param1": "token the token that fee should be distributed in",
        "@param2": "beneficiary the address that will receive fees",
        "@return1": "amount had withdrawn",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sync",
        "visibility": "external",
        "args": [],
        "func": "function sync() external returns (uint256) {\n        uint256 timestamp = now;\n        uint256 day = ((timestamp - _startTime) / 1 days);\n        uint256 amount = feeDistributor.withdraw(_sandToken, address(this));\n        accumulatedAmountPerDay[day] = accumulatedAmountPerDay[_lastDaySaved].add(amount);\n        _lastDaySaved = day;\n        return amount;\n    }",
        "comments": [
            "",
            "    /// @notice Updates the total amount of fees collected alongside with the due date",
            "    "
        ],
        "comt": "\n    /// @notice Updates the total amount of fees collected alongside with the due date\n    ",
        "@notice": "Updates the total amount of fees collected alongside with the due date",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "external",
        "args": [
            {
                "name": "beneficiary",
                "type": "address payable"
            }
        ],
        "func": "function withdraw(address payable beneficiary) external onlyOwner returns (uint256) {\n        uint256 day = ((now - _startTime) / 1 days);\n        uint256 lockPeriod = _lockPeriod;\n        uint256 amount = lockPeriod > day ? 0 : accumulatedAmountPerDay[day - lockPeriod];\n        if (amount != 0) {\n            uint256 withdrawnAmount = _withdrawnAmount;\n            amount = amount.sub(withdrawnAmount);\n            _withdrawnAmount = withdrawnAmount.add(amount);\n            _sandToken.safeTransfer(beneficiary, amount);\n        }\n        return amount;\n    }",
        "comments": [
            "",
            "    /// @notice Enables fee holder to withdraw its share after lock period expired",
            "    /// @param beneficiary the address that will receive fees",
            "    "
        ],
        "comt": "\n    /// @notice Enables fee holder to withdraw its share after lock period expired\n    /// @param beneficiary the address that will receive fees\n    ",
        "@notice": "Enables fee holder to withdraw its share after lock period expired",
        "@param1": "beneficiary the address that will receive fees",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawNoTimeLock",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "IERC20"
            },
            {
                "name": "beneficiary",
                "type": "address payable"
            }
        ],
        "func": "function withdrawNoTimeLock(IERC20 token, address payable beneficiary) external onlyOwner returns (uint256) {\n        require(token != _sandToken, \"SAND_TOKEN_WITHDRWAL_NOT_ALLOWED\");\n        uint256 amount = feeDistributor.withdraw(token, beneficiary);\n        return amount;\n    }",
        "comments": [
            "",
            "    /// @notice Enables fee holder to withdraw token fees with no time-lock for tokens other than SAND",
            "    /// @param token the token that fees are collected in",
            "    /// @param beneficiary the address that will receive fees",
            "    "
        ],
        "comt": "\n    /// @notice Enables fee holder to withdraw token fees with no time-lock for tokens other than SAND\n    /// @param token the token that fees are collected in\n    /// @param beneficiary the address that will receive fees\n    ",
        "@notice": "Enables fee holder to withdraw token fees with no time-lock for tokens other than SAND",
        "@param1": "token the token that fees are collected in",
        "@param2": "beneficiary the address that will receive fees",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setFeeDistributor",
        "visibility": "external",
        "args": [
            {
                "name": "_feeDistributor",
                "type": "FeeDistributor"
            }
        ],
        "func": "function setFeeDistributor(FeeDistributor _feeDistributor) external onlyOwner {\n        require(address(feeDistributor) == address(0), \"FEE_DISTRIBUTOR_ALREADY_SET\");\n        require(address(_feeDistributor) != address(0), \"FEE_DISTRIBUTOR_ZERO_ADDRESS\");\n        feeDistributor = _feeDistributor;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stake",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function stake(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        _uniTest.safeTransferFrom(msg.sender, address(this), amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function withdraw(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        _uniTest.safeTransfer(msg.sender, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lastTimeRewardApplicable",
        "visibility": "public",
        "args": [],
        "func": "function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "rewardPerToken",
        "visibility": "public",
        "args": [],
        "func": "function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return rewardPerTokenStored.add(lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(totalSupply()));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "earned",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function earned(address account) public view returns (uint256) {\n        return balanceOf(account).mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stake",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function stake(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot stake 0\");\n        super.stake(amount);\n        emit Staked(msg.sender, amount);\n    }",
        "comments": [
            "",
            "    // stake visibility is public as overriding LPTokenWrapper's stake() function",
            "    "
        ],
        "comt": "\n    // stake visibility is public as overriding LPTokenWrapper's stake() function\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function withdraw(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        super.withdraw(amount);\n        emit Withdrawn(msg.sender, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "exit",
        "visibility": "external",
        "args": [],
        "func": "function exit() external {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getReward",
        "visibility": "public",
        "args": [],
        "func": "function getReward() public updateReward(msg.sender) {\n        uint256 reward = earned(msg.sender);\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            sand.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "notifyRewardAmount",
        "visibility": "external",
        "args": [
            {
                "name": "reward",
                "type": "uint256"
            }
        ],
        "func": "function notifyRewardAmount(uint256 reward) external override onlyRewardDistribution updateReward(address(0)) {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(DURATION);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(DURATION);\n        }\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(DURATION);\n        emit RewardAdded(reward);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "owner",
        "visibility": "public",
        "args": [],
        "func": "function owner() public view returns (address) {\n        return _owner;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the address of the current owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the address of the current owner.\n     */\n",
        "@dev": "Returns the address of the current owner.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "renounceOwnership",
        "visibility": "public",
        "args": [],
        "func": "function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }",
        "comments": [
            "/**",
            "     * @dev Leaves the contract without owner. It will not be possible to call",
            "     * `onlyOwner` functions anymore. Can only be called by the current owner.",
            "     *",
            "     * NOTE: Renouncing ownership will leave the contract without an owner,",
            "     * thereby removing any functionality that is only available to the owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n",
        "@dev": "Leaves the contract without owner. It will not be possible to call * `onlyOwner` functions anymore. Can only be called by the current owner. * * NOTE: Renouncing ownership will leave the contract without an owner, * thereby removing any functionality that is only available to the owner.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferOwnership",
        "visibility": "public",
        "args": [
            {
                "name": "newOwner",
                "type": "address"
            }
        ],
        "func": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }",
        "comments": [
            "/**",
            "     * @dev Transfers ownership of the contract to a new account (`newOwner`).",
            "     * Can only be called by the current owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n",
        "@dev": "Transfers ownership of the contract to a new account (`newOwner`). * Can only be called by the current owner.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setRewardDistribution",
        "visibility": "external",
        "args": [
            {
                "name": "_rewardDistribution",
                "type": "address"
            }
        ],
        "func": "function setRewardDistribution(address _rewardDistribution) external onlyOwner {\n        rewardDistribution = _rewardDistribution;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stake",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function stake(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        _stakeToken.safeTransferFrom(msg.sender, address(this), amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function withdraw(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        _stakeToken.safeTransfer(msg.sender, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalContributions",
        "visibility": "public",
        "args": [],
        "func": "function totalContributions() public view returns (uint256) {\n        return _totalContributions;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "contributionOf",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function contributionOf(address account) public view returns (uint256) {\n        return _contributions[account];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lastTimeRewardApplicable",
        "visibility": "public",
        "args": [],
        "func": "function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "rewardPerToken",
        "visibility": "public",
        "args": [],
        "func": "function rewardPerToken() public view returns (uint256) {\n        if (totalContributions() == 0) {\n            return rewardPerTokenStored;\n        }\n        return rewardPerTokenStored.add(lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e24).div(totalContributions()));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "earned",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function earned(address account) public view returns (uint256) {\n        return contributionOf(account).mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e24).add(rewards[account]);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "computeContribution",
        "visibility": "public",
        "args": [
            {
                "name": "amountStaked",
                "type": "uint256"
            },
            {
                "name": "numLands",
                "type": "uint256"
            }
        ],
        "func": "function computeContribution(uint256 amountStaked, uint256 numLands) public pure returns (uint256) {\n        if (numLands == 0) {\n            return amountStaked;\n        }\n        uint256 nftContrib = NFT_FACTOR_6.mul(NFT_CONSTANT_3.add(numLands.sub(1).mul(ROOT3_FACTOR).add(1).cbrt3()));\n        if (nftContrib > MIDPOINT_9) {\n            nftContrib = MIDPOINT_9.add(nftContrib.sub(MIDPOINT_9).div(10));\n        }\n        return amountStaked.add(amountStaked.mul(nftContrib).div(DECIMALS_9));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stake",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function stake(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot stake 0\");\n        uint256 contribution = computeContribution(amount, _multiplierNFToken.balanceOf(msg.sender));\n        _totalContributions = _totalContributions.add(contribution);\n        _contributions[msg.sender] = _contributions[msg.sender].add(contribution);\n        super.stake(amount);\n        emit Staked(msg.sender, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function withdraw(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        uint256 balance = balanceOf(msg.sender);\n        uint256 ratio = amount.mul(DECIMALS_18).div(balance);\n        uint256 currentContribution = contributionOf(msg.sender);\n        uint256 contributionReduction = currentContribution.mul(ratio).div(DECIMALS_18);\n        _contributions[msg.sender] = currentContribution.sub(contributionReduction);\n        _totalContributions = _totalContributions.sub(contributionReduction);\n        super.withdraw(amount);\n        emit Withdrawn(msg.sender, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "exit",
        "visibility": "external",
        "args": [],
        "func": "function exit() external {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getReward",
        "visibility": "public",
        "args": [],
        "func": "function getReward() public updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            _rewardToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "notifyRewardAmount",
        "visibility": "external",
        "args": [
            {
                "name": "reward",
                "type": "uint256"
            }
        ],
        "func": "function notifyRewardAmount(uint256 reward) external override onlyRewardDistribution updateReward(address(0)) {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(duration);\n        }\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }",
        "comments": [
            "",
            "    ///@notice to be called after the amount of reward tokens (specified by the reward parameter) has been sent to the contract",
            "    // Note that the reward should be divisible by the duration to avoid reward token lost",
            "    ///@param reward number of token to be distributed over the duration",
            "    "
        ],
        "comt": "\n    ///@notice to be called after the amount of reward tokens (specified by the reward parameter) has been sent to the contract\n    // Note that the reward should be divisible by the duration to avoid reward token lost\n    ///@param reward number of token to be distributed over the duration\n    ",
        "@notice": "to be called after the amount of reward tokens (specified by the reward parameter) has been sent to the contract // Note that the reward should be divisible by the duration to avoid reward token lost",
        "@param1": "reward number of token to be distributed over the duration",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stake",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function stake(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        uni.safeTransferFrom(msg.sender, address(this), amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function withdraw(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        uni.safeTransfer(msg.sender, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lastTimeRewardApplicable",
        "visibility": "public",
        "args": [],
        "func": "function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "rewardPerToken",
        "visibility": "public",
        "args": [],
        "func": "function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return rewardPerTokenStored.add(lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(totalSupply()));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "earned",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function earned(address account) public view returns (uint256) {\n        return balanceOf(account).mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stake",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function stake(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot stake 0\");\n        super.stake(amount);\n        emit Staked(msg.sender, amount);\n    }",
        "comments": [
            "",
            "    // stake visibility is public as overriding LPTokenWrapper's stake() function",
            "    "
        ],
        "comt": "\n    // stake visibility is public as overriding LPTokenWrapper's stake() function\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function withdraw(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        super.withdraw(amount);\n        emit Withdrawn(msg.sender, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "exit",
        "visibility": "external",
        "args": [],
        "func": "function exit() external {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getReward",
        "visibility": "public",
        "args": [],
        "func": "function getReward() public updateReward(msg.sender) {\n        uint256 reward = earned(msg.sender);\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            sand.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "notifyRewardAmount",
        "visibility": "external",
        "args": [
            {
                "name": "reward",
                "type": "uint256"
            }
        ],
        "func": "function notifyRewardAmount(uint256 reward) external override onlyRewardDistribution updateReward(address(0)) {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(DURATION);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(DURATION);\n        }\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(DURATION);\n        emit RewardAdded(reward);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stake",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function stake(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        _uniTest.safeTransferFrom(msg.sender, address(this), amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function withdraw(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        _uniTest.safeTransfer(msg.sender, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lastTimeRewardApplicable",
        "visibility": "public",
        "args": [],
        "func": "function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "rewardPerToken",
        "visibility": "public",
        "args": [],
        "func": "function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return rewardPerTokenStored.add(lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(totalSupply()));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "earned",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function earned(address account) public view returns (uint256) {\n        return balanceOf(account).mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stake",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function stake(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot stake 0\");\n        super.stake(amount);\n        emit Staked(msg.sender, amount);\n    }",
        "comments": [
            "",
            "    // stake visibility is public as overriding LPTokenWrapper's stake() function",
            "    "
        ],
        "comt": "\n    // stake visibility is public as overriding LPTokenWrapper's stake() function\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function withdraw(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        super.withdraw(amount);\n        emit Withdrawn(msg.sender, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "exit",
        "visibility": "external",
        "args": [],
        "func": "function exit() external {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getReward",
        "visibility": "public",
        "args": [],
        "func": "function getReward() public updateReward(msg.sender) {\n        uint256 reward = earned(msg.sender);\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            sand.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "notifyRewardAmount",
        "visibility": "external",
        "args": [
            {
                "name": "reward",
                "type": "uint256"
            }
        ],
        "func": "function notifyRewardAmount(uint256 reward) external override onlyRewardDistribution updateReward(address(0)) {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(DURATION);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(DURATION);\n        }\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(DURATION);\n        emit RewardAdded(reward);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isTrustedForwarder",
        "visibility": "public",
        "args": [
            {
                "name": "forwarder",
                "type": "address"
            }
        ],
        "func": "function isTrustedForwarder(address forwarder) public view returns (bool) {\n        return forwarder == trustedForwarder;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getNonce",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            }
        ],
        "func": "function getNonce(address from) public override view returns (uint256) {\n        return nonces[from];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "verify",
        "visibility": "public",
        "args": [
            {
                "name": "req",
                "type": "ForwardRequest memory"
            },
            {
                "name": "domainSeparator",
                "type": "bytes32"
            },
            {
                "name": "requestTypeHash",
                "type": "bytes32"
            },
            {
                "name": "suffixData",
                "type": "bytes memory"
            },
            {
                "name": "sig",
                "type": "bytes memory"
            }
        ],
        "func": "function verify(\n        ForwardRequest memory req,\n        bytes32 domainSeparator,\n        bytes32 requestTypeHash,\n        bytes memory suffixData,\n        bytes memory sig\n    ) public override view {\n        _verifyNonce(req);\n        _verifySig(req, domainSeparator, requestTypeHash, suffixData, sig);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "execute",
        "visibility": "public",
        "args": [
            {
                "name": "req",
                "type": "ForwardRequest memory"
            },
            {
                "name": "domainSeparator",
                "type": "bytes32"
            },
            {
                "name": "requestTypeHash",
                "type": "bytes32"
            },
            {
                "name": "suffixData",
                "type": "bytes memory"
            },
            {
                "name": "sig",
                "type": "bytes memory"
            }
        ],
        "func": "function execute(\n        ForwardRequest memory req,\n        bytes32 domainSeparator,\n        bytes32 requestTypeHash,\n        bytes memory suffixData,\n        bytes memory sig\n    ) public override payable returns (bool success, bytes memory ret) {\n        _verifyNonce(req);\n        _verifySig(req, domainSeparator, requestTypeHash, suffixData, sig);\n        _updateNonce(req);\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (success, ret) = req.to.call{gas: req.gas, value: req.value}(abi.encodePacked(req.data, req.from));\n        if (address(this).balance > 0) {\n            //can't fail: req.from signed (off-chain) the request, so it must be an EOA...\n            payable(req.from).transfer(address(this).balance);\n        }\n        return (success, ret);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "registerRequestType",
        "visibility": "external",
        "args": [
            {
                "name": "typeName",
                "type": "string calldata"
            },
            {
                "name": "typeSuffix",
                "type": "string calldata"
            }
        ],
        "func": "function registerRequestType(string calldata typeName, string calldata typeSuffix) external override {\n        for (uint256 i = 0; i < bytes(typeName).length; i++) {\n            bytes1 c = bytes(typeName)[i];\n            require(c != \"(\" && c != \")\", \"invalid typename\");\n        }\n\n        string memory requestType = string(abi.encodePacked(typeName, \"(\", GENERIC_PARAMS, \",\", typeSuffix));\n        registerRequestTypeInternal(requestType);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_getEncoded",
        "visibility": "public",
        "args": [
            {
                "name": "req",
                "type": "ForwardRequest memory"
            },
            {
                "name": "requestTypeHash",
                "type": "bytes32"
            },
            {
                "name": "suffixData",
                "type": "bytes memory"
            }
        ],
        "func": "function _getEncoded(\n        ForwardRequest memory req,\n        bytes32 requestTypeHash,\n        bytes memory suffixData\n    ) public pure returns (bytes memory) {\n        return abi.encodePacked(requestTypeHash, abi.encode(req.from, req.to, req.value, req.gas, req.nonce, keccak256(req.data)), suffixData);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setFee",
        "visibility": "external",
        "args": [
            {
                "name": "feeCollector",
                "type": "address"
            },
            {
                "name": "fee",
                "type": "uint256"
            }
        ],
        "func": "function setFee(address feeCollector, uint256 fee) external {\n        require(msg.sender == _admin, \"Sender not admin\");\n        _feeCollector = feeCollector;\n        _fee = fee;\n        emit FeeSetup(feeCollector, fee);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "claimSellerOffer",
        "visibility": "external",
        "args": [
            {
                "name": "buyer",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "auction",
                "type": "Auction calldata"
            },
            {
                "name": "signature",
                "type": "bytes calldata"
            },
            {
                "name": "signatureType",
                "type": "SignatureType"
            },
            {
                "name": "eip712",
                "type": "bool"
            }
        ],
        "func": "function claimSellerOffer(\n        address buyer,\n        address to,\n        Auction calldata auction,\n        bytes calldata signature,\n        SignatureType signatureType,\n        bool eip712\n    ) external {\n        _verifyParameters(buyer, auction);\n        _ensureCorrectSigner(auction, signature, signatureType, eip712);\n        _executeDeal(auction, buyer, to);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cancelSellerOffer",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function cancelSellerOffer(uint256 id) external {\n        claimed[msg.sender][id] = MAX_UINT256;\n        emit OfferCancelled(msg.sender, id);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getNonceByBuyer",
        "visibility": "external",
        "args": [
            {
                "name": "_buyer",
                "type": "address"
            },
            {
                "name": "_queueId",
                "type": "uint128"
            }
        ],
        "func": "function getNonceByBuyer(address _buyer, uint128 _queueId) external view returns (uint128) {\n        return queuedNonces[_buyer][_queueId];\n    }",
        "comments": [
            "",
            "    /// @notice Function to get the nonce for a given address and queue ID",
            "    /// @param _buyer The address of the starterPack purchaser",
            "    /// @param _queueId The ID of the nonce queue for the given address.",
            "    /// The default is queueID=0, and the max is queueID=2**128-1",
            "    /// @return uint128 representing the requestied nonce",
            "    "
        ],
        "comt": "\n    /// @notice Function to get the nonce for a given address and queue ID\n    /// @param _buyer The address of the starterPack purchaser\n    /// @param _queueId The ID of the nonce queue for the given address.\n    /// The default is queueID=0, and the max is queueID=2**128-1\n    /// @return uint128 representing the requestied nonce\n    ",
        "@notice": "Function to get the nonce for a given address and queue ID",
        "@param1": "_buyer The address of the starterPack purchaser",
        "@param2": "_queueId The ID of the nonce queue for the given address. /// The default is queueID=0, and the max is queueID=2**128-1",
        "@return1": "uint128 representing the requestied nonce",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isPurchaseValid",
        "visibility": "public",
        "args": [
            {
                "name": "buyer",
                "type": "address"
            },
            {
                "name": "catalystIds",
                "type": "uint256[] memory"
            },
            {
                "name": "catalystQuantities",
                "type": "uint256[] memory"
            },
            {
                "name": "gemIds",
                "type": "uint256[] memory"
            },
            {
                "name": "gemQuantities",
                "type": "uint256[] memory"
            },
            {
                "name": "nonce",
                "type": "uint256"
            },
            {
                "name": "signature",
                "type": "bytes memory"
            }
        ],
        "func": "function isPurchaseValid(\n        address buyer,\n        uint256[] memory catalystIds,\n        uint256[] memory catalystQuantities,\n        uint256[] memory gemIds,\n        uint256[] memory gemQuantities,\n        uint256 nonce,\n        bytes memory signature\n    ) public returns (bool) {\n        require(_checkAndUpdateNonce(buyer, nonce), \"INVALID_NONCE\");\n        bytes32 hashedData = keccak256(abi.encodePacked(catalystIds, catalystQuantities, gemIds, gemQuantities, buyer, nonce));\n\n        address signer = SigUtil.recover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hashedData)), signature);\n        return signer == _signingWallet;\n    }",
        "comments": [
            "",
            "    /// @notice Check if a purchase message is valid",
            "    /// @param buyer The address paying for the purchase & receiving tokens",
            "    /// @param catalystIds The catalyst IDs to be purchased",
            "    /// @param catalystQuantities The quantities of the catalysts to be purchased",
            "    /// @param gemIds The gem IDs to be purchased",
            "    /// @param gemQuantities The quantities of the gems to be purchased",
            "    /// @param nonce The current nonce for the user. This is represented as a",
            "    /// uint256 value, but is actually 2 packed uint128's (queueId + nonce)",
            "    /// @param signature A signed message specifying tx details",
            "    /// @return True if the purchase is valid",
            "    "
        ],
        "comt": "\n    /// @notice Check if a purchase message is valid\n    /// @param buyer The address paying for the purchase & receiving tokens\n    /// @param catalystIds The catalyst IDs to be purchased\n    /// @param catalystQuantities The quantities of the catalysts to be purchased\n    /// @param gemIds The gem IDs to be purchased\n    /// @param gemQuantities The quantities of the gems to be purchased\n    /// @param nonce The current nonce for the user. This is represented as a\n    /// uint256 value, but is actually 2 packed uint128's (queueId + nonce)\n    /// @param signature A signed message specifying tx details\n    /// @return True if the purchase is valid\n    ",
        "@notice": "Check if a purchase message is valid",
        "@param1": "buyer The address paying for the purchase & receiving tokens",
        "@param2": "catalystIds The catalyst IDs to be purchased",
        "@param3": "catalystQuantities The quantities of the catalysts to be purchased",
        "@param4": "gemIds The gem IDs to be purchased",
        "@param5": "gemQuantities The quantities of the gems to be purchased",
        "@param6": "nonce The current nonce for the user. This is represented as a /// uint256 value, but is actually 2 packed uint128's (queueId + nonce)",
        "@param7": "signature A signed message specifying tx details",
        "@return1": "True if the purchase is valid",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getSigningWallet",
        "visibility": "external",
        "args": [],
        "func": "function getSigningWallet() external view returns (address) {\n        return _signingWallet;\n    }",
        "comments": [
            "",
            "    /// @notice Get the wallet authorized for signing purchase-messages.",
            "    /// @return the address of the signing wallet",
            "    "
        ],
        "comt": "\n    /// @notice Get the wallet authorized for signing purchase-messages.\n    /// @return the address of the signing wallet\n    ",
        "@notice": "Get the wallet authorized for signing purchase-messages.",
        "@return1": "the address of the signing wallet",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateSigningWallet",
        "visibility": "external",
        "args": [
            {
                "name": "newSigningWallet",
                "type": "address"
            }
        ],
        "func": "function updateSigningWallet(address newSigningWallet) external {\n        require(_admin == msg.sender, \"SENDER_NOT_ADMIN\");\n        _signingWallet = newSigningWallet;\n    }",
        "comments": [
            "",
            "    /// @notice Update the signing wallet address",
            "    /// @param newSigningWallet The new address of the signing wallet",
            "    "
        ],
        "comt": "\n    /// @notice Update the signing wallet address\n    /// @param newSigningWallet The new address of the signing wallet\n    ",
        "@notice": "Update the signing wallet address",
        "@param1": "newSigningWallet The new address of the signing wallet",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setReceivingWallet",
        "visibility": "external",
        "args": [
            {
                "name": "newWallet",
                "type": "address payable"
            }
        ],
        "func": "function setReceivingWallet(address payable newWallet) external {\n        require(newWallet != address(0), \"WALLET_ZERO_ADDRESS\");\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _wallet = newWallet;\n    }",
        "comments": [
            "",
            "    // ////////////////////////// Functions ////////////////////////",
            "",
            "    /// @notice Set the wallet receiving the proceeds",
            "    /// @param newWallet Address of the new receiving wallet",
            "    "
        ],
        "comt": "\n    // ////////////////////////// Functions ////////////////////////\n\n    /// @notice Set the wallet receiving the proceeds\n    /// @param newWallet Address of the new receiving wallet\n    ",
        "@notice": "Set the wallet receiving the proceeds",
        "@param1": "newWallet Address of the new receiving wallet",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setDAIEnabled",
        "visibility": "external",
        "args": [
            {
                "name": "enabled",
                "type": "bool"
            }
        ],
        "func": "function setDAIEnabled(bool enabled) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _daiEnabled = enabled;\n    }",
        "comments": [
            "",
            "    /// @notice Enable / disable DAI payment for StarterPacks",
            "    /// @param enabled Whether to enable or disable",
            "    "
        ],
        "comt": "\n    /// @notice Enable / disable DAI payment for StarterPacks\n    /// @param enabled Whether to enable or disable\n    ",
        "@notice": "Enable / disable DAI payment for StarterPacks",
        "@param1": "enabled Whether to enable or disable",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isDAIEnabled",
        "visibility": "external",
        "args": [],
        "func": "function isDAIEnabled() external view returns (bool) {\n        return _daiEnabled;\n    }",
        "comments": [
            "",
            "    /// @notice Return whether DAI payments are enabled",
            "    /// @return Whether DAI payments are enabled",
            "    "
        ],
        "comt": "\n    /// @notice Return whether DAI payments are enabled\n    /// @return Whether DAI payments are enabled\n    ",
        "@notice": "Return whether DAI payments are enabled",
        "@return1": "Whether DAI payments are enabled",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setETHEnabled",
        "visibility": "external",
        "args": [
            {
                "name": "enabled",
                "type": "bool"
            }
        ],
        "func": "function setETHEnabled(bool enabled) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _etherEnabled = enabled;\n    }",
        "comments": [
            "",
            "    /// @notice Enable / disable ETH payment for StarterPacks",
            "    /// @param enabled Whether to enable or disable",
            "    "
        ],
        "comt": "\n    /// @notice Enable / disable ETH payment for StarterPacks\n    /// @param enabled Whether to enable or disable\n    ",
        "@notice": "Enable / disable ETH payment for StarterPacks",
        "@param1": "enabled Whether to enable or disable",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isETHEnabled",
        "visibility": "external",
        "args": [],
        "func": "function isETHEnabled() external view returns (bool) {\n        return _etherEnabled;\n    }",
        "comments": [
            "",
            "    /// @notice Return whether ETH payments are enabled",
            "    /// @return Whether ETH payments are enabled",
            "    "
        ],
        "comt": "\n    /// @notice Return whether ETH payments are enabled\n    /// @return Whether ETH payments are enabled\n    ",
        "@notice": "Return whether ETH payments are enabled",
        "@return1": "Whether ETH payments are enabled",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setSANDEnabled",
        "visibility": "external",
        "args": [
            {
                "name": "enabled",
                "type": "bool"
            }
        ],
        "func": "function setSANDEnabled(bool enabled) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _sandEnabled = enabled;\n    }",
        "comments": [
            "",
            "    /// @dev Enable / disable the specific SAND payment for StarterPacks",
            "    /// @param enabled Whether to enable or disable",
            "    "
        ],
        "comt": "\n    /// @dev Enable / disable the specific SAND payment for StarterPacks\n    /// @param enabled Whether to enable or disable\n    ",
        "@dev": "Enable / disable the specific SAND payment for StarterPacks",
        "@param1": "enabled Whether to enable or disable",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isSANDEnabled",
        "visibility": "external",
        "args": [],
        "func": "function isSANDEnabled() external view returns (bool) {\n        return _sandEnabled;\n    }",
        "comments": [
            "",
            "    /// @notice Return whether SAND payments are enabled",
            "    /// @return Whether SAND payments are enabled",
            "    "
        ],
        "comt": "\n    /// @notice Return whether SAND payments are enabled\n    /// @return Whether SAND payments are enabled\n    ",
        "@notice": "Return whether SAND payments are enabled",
        "@return1": "Whether SAND payments are enabled",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "purchaseWithSand",
        "visibility": "external",
        "args": [
            {
                "name": "buyer",
                "type": "address"
            },
            {
                "name": "message",
                "type": "Message calldata"
            },
            {
                "name": "signature",
                "type": "bytes calldata"
            }
        ],
        "func": "function purchaseWithSand(\n        address buyer,\n        Message calldata message,\n        bytes calldata signature\n    ) external {\n        require(msg.sender == buyer || _metaTransactionContracts[msg.sender], \"INVALID_SENDER\");\n        require(_sandEnabled, \"SAND_IS_NOT_ENABLED\");\n        require(buyer != address(0), \"DESTINATION_ZERO_ADDRESS\");\n        require(\n            isPurchaseValid(buyer, message.catalystIds, message.catalystQuantities, message.gemIds, message.gemQuantities, message.nonce, signature),\n            \"INVALID_PURCHASE\"\n        );\n\n        uint256 amountInSand = _calculateTotalPriceInSand(message.catalystIds, message.catalystQuantities, message.gemQuantities);\n        _handlePurchaseWithERC20(buyer, _wallet, address(_sand), amountInSand);\n        _erc20GroupCatalyst.batchTransferFrom(address(this), buyer, message.catalystIds, message.catalystQuantities);\n        _erc20GroupGem.batchTransferFrom(address(this), buyer, message.gemIds, message.gemQuantities);\n        emit Purchase(buyer, message, amountInSand, address(_sand), amountInSand);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "purchaseWithETH",
        "visibility": "external",
        "args": [
            {
                "name": "buyer",
                "type": "address"
            },
            {
                "name": "message",
                "type": "Message calldata"
            },
            {
                "name": "signature",
                "type": "bytes calldata"
            }
        ],
        "func": "function purchaseWithETH(\n        address buyer,\n        Message calldata message,\n        bytes calldata signature\n    ) external payable {\n        require(msg.sender == buyer || _metaTransactionContracts[msg.sender], \"INVALID_SENDER\");\n        require(_etherEnabled, \"ETHER_IS_NOT_ENABLED\");\n        require(buyer != address(0), \"DESTINATION_ZERO_ADDRESS\");\n        require(buyer != address(this), \"DESTINATION_STARTERPACKV1_CONTRACT\");\n        require(\n            isPurchaseValid(buyer, message.catalystIds, message.catalystQuantities, message.gemIds, message.gemQuantities, message.nonce, signature),\n            \"INVALID_PURCHASE\"\n        );\n\n        uint256 amountInSand = _calculateTotalPriceInSand(message.catalystIds, message.catalystQuantities, message.gemQuantities);\n        uint256 ETHRequired = getEtherAmountWithSAND(amountInSand);\n        require(msg.value >= ETHRequired, \"NOT_ENOUGH_ETHER_SENT\");\n\n        _wallet.transfer(ETHRequired);\n        _erc20GroupCatalyst.batchTransferFrom(address(this), buyer, message.catalystIds, message.catalystQuantities);\n        _erc20GroupGem.batchTransferFrom(address(this), buyer, message.gemIds, message.gemQuantities);\n        emit Purchase(buyer, message, amountInSand, address(0), ETHRequired);\n\n        if (msg.value - ETHRequired > 0) {\n            // refund extra\n            (bool success, ) = msg.sender.call{value: msg.value - ETHRequired}(\"\");\n            require(success, \"REFUND_FAILED\");\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "purchaseWithDAI",
        "visibility": "external",
        "args": [
            {
                "name": "buyer",
                "type": "address"
            },
            {
                "name": "message",
                "type": "Message calldata"
            },
            {
                "name": "signature",
                "type": "bytes calldata"
            }
        ],
        "func": "function purchaseWithDAI(\n        address buyer,\n        Message calldata message,\n        bytes calldata signature\n    ) external {\n        require(msg.sender == buyer || _metaTransactionContracts[msg.sender], \"INVALID_SENDER\");\n        require(_daiEnabled, \"DAI_IS_NOT_ENABLED\");\n        require(buyer != address(0), \"DESTINATION_ZERO_ADDRESS\");\n        require(buyer != address(this), \"DESTINATION_STARTERPACKV1_CONTRACT\");\n        require(\n            isPurchaseValid(buyer, message.catalystIds, message.catalystQuantities, message.gemIds, message.gemQuantities, message.nonce, signature),\n            \"INVALID_PURCHASE\"\n        );\n\n        uint256 amountInSand = _calculateTotalPriceInSand(message.catalystIds, message.catalystQuantities, message.gemQuantities);\n        uint256 DAIRequired = amountInSand.mul(DAI_PRICE).div(DECIMAL_PLACES);\n        _handlePurchaseWithERC20(buyer, _wallet, address(_dai), DAIRequired);\n        _erc20GroupCatalyst.batchTransferFrom(address(this), buyer, message.catalystIds, message.catalystQuantities);\n        _erc20GroupGem.batchTransferFrom(address(this), buyer, message.gemIds, message.gemQuantities);\n        emit Purchase(buyer, message, amountInSand, address(_dai), DAIRequired);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawAll",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "catalystIds",
                "type": "uint256[] calldata"
            },
            {
                "name": "gemIds",
                "type": "uint256[] calldata"
            }
        ],
        "func": "function withdrawAll(\n        address to,\n        uint256[] calldata catalystIds,\n        uint256[] calldata gemIds\n    ) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n\n        address[] memory catalystAddresses = new address[](catalystIds.length);\n        for (uint256 i = 0; i < catalystIds.length; i++) {\n            catalystAddresses[i] = address(this);\n        }\n        address[] memory gemAddresses = new address[](gemIds.length);\n        for (uint256 i = 0; i < gemIds.length; i++) {\n            gemAddresses[i] = address(this);\n        }\n        uint256[] memory unsoldCatalystQuantities = _erc20GroupCatalyst.balanceOfBatch(catalystAddresses, catalystIds);\n        uint256[] memory unsoldGemQuantities = _erc20GroupGem.balanceOfBatch(gemAddresses, gemIds);\n\n        _erc20GroupCatalyst.batchTransferFrom(address(this), to, catalystIds, unsoldCatalystQuantities);\n        _erc20GroupGem.batchTransferFrom(address(this), to, gemIds, unsoldGemQuantities);\n    }",
        "comments": [
            "",
            "    /// @notice Enables admin to withdraw all remaining tokens",
            "    /// @param to The destination address for the purchased Catalysts and Gems",
            "    /// @param catalystIds The IDs of the catalysts to be transferred",
            "    /// @param gemIds The IDs of the gems to be transferred",
            "    "
        ],
        "comt": "\n    /// @notice Enables admin to withdraw all remaining tokens\n    /// @param to The destination address for the purchased Catalysts and Gems\n    /// @param catalystIds The IDs of the catalysts to be transferred\n    /// @param gemIds The IDs of the gems to be transferred\n    ",
        "@notice": "Enables admin to withdraw all remaining tokens",
        "@param1": "to The destination address for the purchased Catalysts and Gems",
        "@param2": "catalystIds The IDs of the catalysts to be transferred",
        "@param3": "gemIds The IDs of the gems to be transferred",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setPrices",
        "visibility": "external",
        "args": [
            {
                "name": "prices",
                "type": "uint256[] calldata"
            },
            {
                "name": "gemPrice",
                "type": "uint256"
            }
        ],
        "func": "function setPrices(uint256[] calldata prices, uint256 gemPrice) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _previousStarterPackPrices = _starterPackPrices;\n        _starterPackPrices = prices;\n        _previousGemPrice = _gemPrice;\n        _gemPrice = gemPrice;\n        _priceChangeTimestamp = now;\n        emit SetPrices(prices, gemPrice);\n    }",
        "comments": [
            "",
            "    /// @notice Enables admin to change the prices of the StarterPack bundles",
            "    /// @param prices Array of new prices that will take effect after a delay period",
            "    /// @param gemPrice New price for gems that will take effect after a delay period",
            "",
            "    "
        ],
        "comt": "\n    /// @notice Enables admin to change the prices of the StarterPack bundles\n    /// @param prices Array of new prices that will take effect after a delay period\n    /// @param gemPrice New price for gems that will take effect after a delay period\n\n    ",
        "@notice": "Enables admin to change the prices of the StarterPack bundles",
        "@param1": "prices Array of new prices that will take effect after a delay period",
        "@param2": "gemPrice New price for gems that will take effect after a delay period",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPrices",
        "visibility": "external",
        "args": [],
        "func": "function getPrices()\n        external\n        view\n        returns (\n            uint256[] memory pricesBeforeSwitch,\n            uint256[] memory pricesAfterSwitch,\n            uint256 gemPriceBeforeSwitch,\n            uint256 gemPriceAfterSwitch,\n            uint256 switchTime\n        )\n    {\n        switchTime = 0;\n        if (_priceChangeTimestamp != 0) {\n            switchTime = _priceChangeTimestamp + PRICE_CHANGE_DELAY;\n        }\n        return (_previousStarterPackPrices, _starterPackPrices, _previousGemPrice, _gemPrice, switchTime);\n    }",
        "comments": [
            "",
            "    /// @notice Get current StarterPack prices",
            "    /// @return pricesBeforeSwitch Array of prices before price change",
            "    /// @return pricesAfterSwitch Array of prices after price change",
            "    /// @return gemPriceBeforeSwitch Gem price before price change",
            "    /// @return gemPriceAfterSwitch Gem price after price change",
            "    /// @return switchTime The time the latest price change will take effect, being the time of the price change plus the price change delay",
            "",
            "    "
        ],
        "comt": "\n    /// @notice Get current StarterPack prices\n    /// @return pricesBeforeSwitch Array of prices before price change\n    /// @return pricesAfterSwitch Array of prices after price change\n    /// @return gemPriceBeforeSwitch Gem price before price change\n    /// @return gemPriceAfterSwitch Gem price after price change\n    /// @return switchTime The time the latest price change will take effect, being the time of the price change plus the price change delay\n\n    ",
        "@notice": "Get current StarterPack prices",
        "@return1": "pricesBeforeSwitch Array of prices before price change",
        "@return2": "pricesAfterSwitch Array of prices after price change",
        "@return3": "gemPriceBeforeSwitch Gem price before price change",
        "@return4": "gemPriceAfterSwitch Gem price after price change",
        "@return5": "switchTime The time the latest price change will take effect, being the time of the price change plus the price change delay",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getEtherAmountWithSAND",
        "visibility": "public",
        "args": [
            {
                "name": "sandAmount",
                "type": "uint256"
            }
        ],
        "func": "function getEtherAmountWithSAND(uint256 sandAmount) public view returns (uint256) {\n        uint256 ethUsdPair = _getEthUsdPair();\n        return sandAmount.mul(DAI_PRICE).div(ethUsdPair);\n    }",
        "comments": [
            "",
            "    /// @notice Returns the amount of ETH for a specific amount of SAND",
            "    /// @param sandAmount An amount of SAND",
            "    /// @return The amount of ETH",
            "    "
        ],
        "comt": "\n    /// @notice Returns the amount of ETH for a specific amount of SAND\n    /// @param sandAmount An amount of SAND\n    /// @return The amount of ETH\n    ",
        "@notice": "Returns the amount of ETH for a specific amount of SAND",
        "@param1": "sandAmount An amount of SAND",
        "@return1": "The amount of ETH",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public override view returns (uint256) {\n        return _totalSupply;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address account) public override view returns (uint256) {\n        return _balances[account];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allowance",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            }
        ],
        "func": "function allowance(address owner, address spender) public override view returns (uint256) {\n        return _allowances[owner][spender];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function mint(address account, uint256 amount) public onlyOwner {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address owner) public override view returns (uint256) {\n        require(owner != address(0), \"owner is zero address\");\n        return _numNFTPerAddress[owner];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "ownerOf",
        "visibility": "public",
        "args": [
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function ownerOf(uint256 id) public override view returns (address owner) {\n        // TODO: does not return owner\n        owner = _ownerOf(id);\n        require(owner != address(0), \"token does not exist\");\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approveFor",
        "visibility": "public",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function approveFor(\n        address sender,\n        address operator,\n        uint256 id\n    ) public {\n        address owner = _ownerOf(id);\n        require(sender != address(0), \"sender is zero address\");\n        require(\n            msg.sender == sender || _metaTransactionContracts[msg.sender] || _superOperators[msg.sender] || _operatorsForAll[sender][msg.sender],\n            \"not authorized to approve\"\n        );\n        require(owner == sender, \"owner != sender\");\n        _approveFor(owner, operator, id);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function approve(address operator, uint256 id) public override {\n        address owner = _ownerOf(id);\n        require(owner != address(0), \"token does not exist\");\n        require(owner == msg.sender || _superOperators[msg.sender] || _operatorsForAll[owner][msg.sender], \"not authorized to approve\");\n        _approveFor(owner, operator, id);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getApproved",
        "visibility": "public",
        "args": [
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function getApproved(uint256 id) public override view returns (address) {\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(owner != address(0), \"token does not exist\");\n        if (operatorEnabled) {\n            return _operators[id];\n        } else {\n            return address(0);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override {\n        bool metaTx = _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\n            require(_checkOnERC721Received(metaTx ? from : msg.sender, from, to, id, \"\"), \"erc721 transfer rejected by to\");\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "safeTransferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            },
            {
                "name": "data",
                "type": "bytes memory"
            }
        ],
        "func": "function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public override {\n        bool metaTx = _checkTransfer(from, to, id);\n        _transferFrom(from, to, id);\n        if (to.isContract()) {\n            require(_checkOnERC721Received(metaTx ? from : msg.sender, from, to, id, data), \"ERC721: transfer rejected by to\");\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "safeTransferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override {\n        safeTransferFrom(from, to, id, \"\");\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "batchTransferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "ids",
                "type": "uint256[] memory"
            },
            {
                "name": "data",
                "type": "bytes memory"
            }
        ],
        "func": "function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        bytes memory data\n    ) public {\n        _batchTransferFrom(from, to, ids, data, false);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "safeBatchTransferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "ids",
                "type": "uint256[] memory"
            },
            {
                "name": "data",
                "type": "bytes memory"
            }
        ],
        "func": "function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        bytes memory data\n    ) public {\n        _batchTransferFrom(from, to, ids, data, true);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "supportsInterface",
        "visibility": "public",
        "args": [
            {
                "name": "id",
                "type": "bytes4"
            }
        ],
        "func": "function supportsInterface(bytes4 id) public override view returns (bool) {\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setApprovalForAllFor",
        "visibility": "public",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "approved",
                "type": "bool"
            }
        ],
        "func": "function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) public {\n        require(sender != address(0), \"Invalid sender address\");\n        require(msg.sender == sender || _metaTransactionContracts[msg.sender] || _superOperators[msg.sender], \"not authorized to approve for all\");\n\n        _setApprovalForAll(sender, operator, approved);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setApprovalForAll",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "approved",
                "type": "bool"
            }
        ],
        "func": "function setApprovalForAll(address operator, bool approved) public override {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isApprovedForAll",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function isApprovedForAll(address owner, address operator) public override view returns (bool isOperator) {\n        return _operatorsForAll[owner][operator] || _superOperators[operator];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_burn",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function _burn(\n        address from,\n        address owner,\n        uint256 id\n    ) public {\n        require(from == owner, \"not owner\");\n        _owners[id] = 2**160; // cannot mint it again\n        _numNFTPerAddress[from]--;\n        emit Transfer(from, address(0), id);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "public",
        "args": [
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function burn(uint256 id) public {\n        _burn(msg.sender, _ownerOf(id), id);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burnFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function burnFrom(address from, uint256 id) public {\n        require(from != address(0), \"Invalid sender address\");\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\n        require(\n            msg.sender == from ||\n                _metaTransactionContracts[msg.sender] ||\n                (operatorEnabled && _operators[id] == msg.sender) ||\n                _superOperators[msg.sender] ||\n                _operatorsForAll[from][msg.sender],\n            \"not authorized to burn\"\n        );\n        _burn(from, owner, id);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "public",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function mint(address to, uint256 tokenId) public {\n        require(to != address(0), \"to is zero address\");\n        require(_owners[tokenId] == 0, \"Already minted\");\n        emit Transfer(address(0), to, tokenId);\n        _owners[tokenId] = uint256(to);\n        _numNFTPerAddress[to] += 1;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "name",
        "visibility": "external",
        "args": [],
        "func": "function name() external pure returns (string memory) {\n        return \"Mock LANDs\";\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "symbol",
        "visibility": "external",
        "args": [],
        "func": "function symbol() external pure returns (string memory) {\n        return \"MOCKLAND\";\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    }
]