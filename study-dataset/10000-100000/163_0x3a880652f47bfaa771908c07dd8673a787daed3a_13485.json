[
    {
        "transactions": 13485,
        "function_num": 163
    },
    {
        "name": "diamondCut",
        "visibility": "external",
        "args": [
            {
                "name": "_diamondCut",
                "type": "FacetCut[] calldata"
            },
            {
                "name": "_init",
                "type": "address"
            },
            {
                "name": "_calldata",
                "type": "bytes calldata"
            }
        ],
        "func": "function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external override {\n        LibDiamondStorageDerivaDEX.DiamondStorageDerivaDEX storage dsDerivaDEX =\n            LibDiamondStorageDerivaDEX.diamondStorageDerivaDEX();\n        require(msg.sender == dsDerivaDEX.admin, \"DiamondFacet: Must own the contract\");\n        require(_diamondCut.length > 0, \"DiamondFacet: No facets to cut\");\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            LibDiamondCut.addReplaceRemoveFacetSelectors(\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        LibDiamondCut.initializeDiamondCut(_init, _calldata);\n    }",
        "comments": [
            "    // Standard diamondCut external function",
            "    /// @notice Add/replace/remove any number of functions and optionally execute",
            "    ///         a function with delegatecall",
            "    /// @param _diamondCut Contains the facet addresses and function selectors",
            "    /// @param _init The address of the contract or facet to execute _calldata",
            "    /// @param _calldata A function call, including function selector and arguments",
            "    ///                  _calldata is executed with delegatecall on _init",
            "    "
        ],
        "comt": "    // Standard diamondCut external function\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    ",
        "@notice": "Add/replace/remove any number of functions and optionally execute /// a function with delegatecall",
        "@param1": "_diamondCut Contains the facet addresses and function selectors",
        "@param2": "_init The address of the contract or facet to execute _calldata",
        "@param3": "_calldata A function call, including function selector and arguments /// _calldata is executed with delegatecall on _init",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "facets",
        "visibility": "external",
        "args": [],
        "func": "function facets() external view override returns (Facet[] memory facets_) {\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n        uint256 numFacets = ds.facetAddresses.length;\n        facets_ = new Facet[](numFacets);\n        for (uint256 i; i < numFacets; i++) {\n            address facetAddress_ = ds.facetAddresses[i];\n            facets_[i].facetAddress = facetAddress_;\n            facets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress_].functionSelectors;\n        }\n    }",
        "comments": [
            "    //",
            "    /// @notice Gets all facets and their selectors.",
            "    /// @return facets_ Facet",
            "    "
        ],
        "comt": "    //\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    ",
        "@notice": "Gets all facets and their selectors.",
        "@return1": "facets_ Facet",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "facetFunctionSelectors",
        "visibility": "external",
        "args": [
            {
                "name": "_facet",
                "type": "address"
            }
        ],
        "func": "function facetFunctionSelectors(address _facet)\n        external\n        view\n        override\n        returns (bytes4[] memory facetFunctionSelectors_)\n    {\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n        facetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;\n    }",
        "comments": [
            "",
            "    /// @notice Gets all the function selectors provided by a facet.",
            "    /// @param _facet The facet address.",
            "    /// @return facetFunctionSelectors_",
            "    "
        ],
        "comt": "\n    /// @notice Gets all the function selectors provided by a facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    ",
        "@notice": "Gets all the function selectors provided by a facet.",
        "@param1": "_facet The facet address.",
        "@return1": "facetFunctionSelectors_",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "facetAddresses",
        "visibility": "external",
        "args": [],
        "func": "function facetAddresses() external view override returns (address[] memory facetAddresses_) {\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n        facetAddresses_ = ds.facetAddresses;\n    }",
        "comments": [
            "",
            "    /// @notice Get all the facet addresses used by a diamond.",
            "    /// @return facetAddresses_",
            "    "
        ],
        "comt": "\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    ",
        "@notice": "Get all the facet addresses used by a diamond.",
        "@return1": "facetAddresses_",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "facetAddress",
        "visibility": "external",
        "args": [
            {
                "name": "_functionSelector",
                "type": "bytes4"
            }
        ],
        "func": "function facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n        facetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;\n    }",
        "comments": [
            "",
            "    /// @notice Gets the facet that supports the given selector.",
            "    /// @dev If facet is not found return address(0).",
            "    /// @param _functionSelector The function selector.",
            "    /// @return facetAddress_ The facet address.",
            "    "
        ],
        "comt": "\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    ",
        "@notice": "Gets the facet that supports the given selector.",
        "@dev": "If facet is not found return address(0).",
        "@param1": "_functionSelector The function selector.",
        "@return1": "facetAddress_ The facet address.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "supportsInterface",
        "visibility": "external",
        "args": [
            {
                "name": "_interfaceId",
                "type": "bytes4"
            }
        ],
        "func": "function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n        return ds.supportedInterfaces[_interfaceId];\n    }",
        "comments": [
            "",
            "    // This implements ERC-165.",
            "    "
        ],
        "comt": "\n    // This implements ERC-165.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferOwnershipToSelf",
        "visibility": "external",
        "args": [],
        "func": "function transferOwnershipToSelf() external {\n        LibDiamondStorageDerivaDEX.DiamondStorageDerivaDEX storage dsDerivaDEX =\n            LibDiamondStorageDerivaDEX.diamondStorageDerivaDEX();\n        require(msg.sender == dsDerivaDEX.admin, \"Not authorized\");\n        dsDerivaDEX.admin = address(this);\n\n        emit OwnershipTransferred(msg.sender, address(this));\n    }",
        "comments": [
            "/**",
            "     * @notice This function transfers ownership to self. This is done",
            "     *         so that we can ensure upgrades (using diamondCut) and",
            "     *         various other critical parameter changing scenarios",
            "     *         can only be done via governance (a facet).",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function transfers ownership to self. This is done\n     *         so that we can ensure upgrades (using diamondCut) and\n     *         various other critical parameter changing scenarios\n     *         can only be done via governance (a facet).\n     */\n",
        "@notice": "This function transfers ownership to self. This is done * so that we can ensure upgrades (using diamondCut) and * various other critical parameter changing scenarios * can only be done via governance (a facet).",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "getAdmin",
        "visibility": "external",
        "args": [],
        "func": "function getAdmin() external view returns (address) {\n        LibDiamondStorageDerivaDEX.DiamondStorageDerivaDEX storage dsDerivaDEX =\n            LibDiamondStorageDerivaDEX.diamondStorageDerivaDEX();\n        return dsDerivaDEX.admin;\n    }",
        "comments": [
            "/**",
            "     * @notice This gets the admin for the diamond.",
            "     * @return Admin address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This gets the admin for the diamond.\n     * @return Admin address.\n     */\n",
        "@notice": "This gets the admin for the diamond.",
        "@return1": "Admin address.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "initialize",
        "visibility": "external",
        "args": [
            {
                "name": "_trader",
                "type": "address"
            },
            {
                "name": "_ddxToken",
                "type": "IDDX"
            },
            {
                "name": "_derivaDEX",
                "type": "address"
            }
        ],
        "func": "function initialize(\n        address _trader,\n        IDDX _ddxToken,\n        address _derivaDEX\n    ) external {\n        // Prevent initializing more than once\n        require(!initialized, \"DDXWalletCloneable: already init.\");\n        initialized = true;\n\n        // Automatically delegate the holdings of this contract/wallet\n        // back to the trader.\n        _ddxToken.delegate(_trader);\n\n        // Approve the DerivaDEX Proxy contract for unlimited transfers\n        _ddxToken.approve(_derivaDEX, uint96(-1));\n    }",
        "comments": [
            "/**",
            "     * @notice This function initializes the on-chain DDX wallet",
            "     *         for a given trader.",
            "     * @param _trader Trader address.",
            "     * @param _ddxToken DDX token address.",
            "     * @param _derivaDEX DerivaDEX Proxy address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function initializes the on-chain DDX wallet\n     *         for a given trader.\n     * @param _trader Trader address.\n     * @param _ddxToken DDX token address.\n     * @param _derivaDEX DerivaDEX Proxy address.\n     */\n",
        "@notice": "This function initializes the on-chain DDX wallet * for a given trader.",
        "@param1": "_trader Trader address.",
        "@param2": "_ddxToken DDX token address.",
        "@param3": "_derivaDEX DerivaDEX Proxy address.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "initialize",
        "visibility": "external",
        "args": [
            {
                "name": "_ddxWalletCloneable",
                "type": "IDDXWalletCloneable"
            }
        ],
        "func": "function initialize(IDDXWalletCloneable _ddxWalletCloneable) external onlyAdmin {\n        LibDiamondStorageTrader.DiamondStorageTrader storage dsTrader = LibDiamondStorageTrader.diamondStorageTrader();\n\n        // Set the on-chain DDX wallet cloneable contract address\n        dsTrader.ddxWalletCloneable = _ddxWalletCloneable;\n    }",
        "comments": [
            "/**",
            "     * @notice This function initializes the state with some critical",
            "     *         information, including the on-chain wallet cloneable",
            "     *         contract address. This can only be called via governance.",
            "     * @dev This function is best called as a parameter to the",
            "     *      diamond cut function. This is removed prior to the selectors",
            "     *      being added to the diamond, meaning it cannot be called",
            "     *      again.",
            "     * @dev This function is best called as a parameter to the",
            "     *      diamond cut function. This is removed prior to the selectors",
            "     *      being added to the diamond, meaning it cannot be called",
            "     *      again.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function initializes the state with some critical\n     *         information, including the on-chain wallet cloneable\n     *         contract address. This can only be called via governance.\n     * @dev This function is best called as a parameter to the\n     *      diamond cut function. This is removed prior to the selectors\n     *      being added to the diamond, meaning it cannot be called\n     *      again.\n     * @dev This function is best called as a parameter to the\n     *      diamond cut function. This is removed prior to the selectors\n     *      being added to the diamond, meaning it cannot be called\n     *      again.\n     */\n",
        "@notice": "This function initializes the state with some critical * information, including the on-chain wallet cloneable * contract address. This can only be called via governance.",
        "@dev": "This function is best called as a parameter to the * diamond cut function. This is removed prior to the selectors * being added to the diamond, meaning it cannot be called * again. * This function is best called as a parameter to the * diamond cut function. This is removed prior to the selectors * being added to the diamond, meaning it cannot be called * again.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setRewardCliff",
        "visibility": "external",
        "args": [
            {
                "name": "_rewardCliff",
                "type": "bool"
            }
        ],
        "func": "function setRewardCliff(bool _rewardCliff) external onlyAdmin {\n        LibDiamondStorageTrader.DiamondStorageTrader storage dsTrader = LibDiamondStorageTrader.diamondStorageTrader();\n\n        // Set the reward cliff (boolean value)\n        dsTrader.rewardCliff = _rewardCliff;\n\n        emit RewardCliffSet(_rewardCliff);\n    }",
        "comments": [
            "/**",
            "     * @notice This function sets the reward cliff.",
            "     * @param _rewardCliff Reward cliff.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function sets the reward cliff.\n     * @param _rewardCliff Reward cliff.\n     */\n",
        "@notice": "This function sets the reward cliff.",
        "@param1": "_rewardCliff Reward cliff.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "issueDDXReward",
        "visibility": "external",
        "args": [
            {
                "name": "_amount",
                "type": "uint96"
            },
            {
                "name": "_trader",
                "type": "address"
            }
        ],
        "func": "function issueDDXReward(uint96 _amount, address _trader) external onlyAdmin {\n        // Call the internal function to issue DDX rewards. This\n        // internal function is shareable with other facets that import\n        // the LibTraderInternal library.\n        LibTraderInternal.issueDDXReward(_amount, _trader);\n    }",
        "comments": [
            "/**",
            "     * @notice This function issues DDX rewards to a trader. It can",
            "     *         only be called via governance.",
            "     * @param _amount DDX tokens to be rewarded.",
            "     * @param _trader Trader recipient address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function issues DDX rewards to a trader. It can\n     *         only be called via governance.\n     * @param _amount DDX tokens to be rewarded.\n     * @param _trader Trader recipient address.\n     */\n",
        "@notice": "This function issues DDX rewards to a trader. It can * only be called via governance.",
        "@param1": "_amount DDX tokens to be rewarded.",
        "@param2": "_trader Trader recipient address.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "issueDDXToRecipient",
        "visibility": "external",
        "args": [
            {
                "name": "_amount",
                "type": "uint96"
            },
            {
                "name": "_recipient",
                "type": "address"
            }
        ],
        "func": "function issueDDXToRecipient(uint96 _amount, address _recipient) external onlyAdmin {\n        LibDiamondStorageDerivaDEX.DiamondStorageDerivaDEX storage dsDerivaDEX =\n            LibDiamondStorageDerivaDEX.diamondStorageDerivaDEX();\n\n        // Transfer DDX from trader to trader's on-chain wallet\n        dsDerivaDEX.ddxToken.mint(_recipient, _amount);\n\n        emit DDXRewardIssued(_recipient, _amount);\n    }",
        "comments": [
            "/**",
            "     * @notice This function issues DDX rewards to an external address.",
            "     *         It can only be called via governance.",
            "     * @param _amount DDX tokens to be rewarded.",
            "     * @param _recipient External recipient address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function issues DDX rewards to an external address.\n     *         It can only be called via governance.\n     * @param _amount DDX tokens to be rewarded.\n     * @param _recipient External recipient address.\n     */\n",
        "@notice": "This function issues DDX rewards to an external address. * It can only be called via governance.",
        "@param1": "_amount DDX tokens to be rewarded.",
        "@param2": "_recipient External recipient address.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stakeDDXFromTrader",
        "visibility": "external",
        "args": [
            {
                "name": "_amount",
                "type": "uint96"
            }
        ],
        "func": "function stakeDDXFromTrader(uint96 _amount) external {\n        transferDDXToWallet(msg.sender, _amount);\n    }",
        "comments": [
            "/**",
            "     * @notice This function lets traders take DDX from their wallet",
            "     *         into their on-chain DDX wallet. It's important to note",
            "     *         that any DDX staked from the trader to this wallet",
            "     *         delegates the voting rights of that stake back to the",
            "     *         user. To be more explicit, if Alice's personal wallet is",
            "     *         delegating to Bob, and she now stakes a portion of her",
            "     *         DDX into this on-chain DDX wallet of hers, those tokens",
            "     *         will now count towards her voting power, not Bob's, since",
            "     *         her on-chain wallet is automatically delegating back to",
            "     *         her.",
            "     * @param _amount The DDX tokens to be staked.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function lets traders take DDX from their wallet\n     *         into their on-chain DDX wallet. It's important to note\n     *         that any DDX staked from the trader to this wallet\n     *         delegates the voting rights of that stake back to the\n     *         user. To be more explicit, if Alice's personal wallet is\n     *         delegating to Bob, and she now stakes a portion of her\n     *         DDX into this on-chain DDX wallet of hers, those tokens\n     *         will now count towards her voting power, not Bob's, since\n     *         her on-chain wallet is automatically delegating back to\n     *         her.\n     * @param _amount The DDX tokens to be staked.\n     */\n",
        "@notice": "This function lets traders take DDX from their wallet * into their on-chain DDX wallet. It's important to note * that any DDX staked from the trader to this wallet * delegates the voting rights of that stake back to the * user. To be more explicit, if Alice's personal wallet is * delegating to Bob, and she now stakes a portion of her * DDX into this on-chain DDX wallet of hers, those tokens * will now count towards her voting power, not Bob's, since * her on-chain wallet is automatically delegating back to * her.",
        "@param1": "_amount The DDX tokens to be staked.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "sendDDXFromTraderToTraderWallet",
        "visibility": "external",
        "args": [
            {
                "name": "_trader",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint96"
            }
        ],
        "func": "function sendDDXFromTraderToTraderWallet(address _trader, uint96 _amount) external {\n        transferDDXToWallet(_trader, _amount);\n    }",
        "comments": [
            "/**",
            "     * @notice This function lets traders send DDX from their wallet",
            "     *         into another trader's on-chain DDX wallet. It's",
            "     *         important to note that any DDX staked to this wallet",
            "     *         delegates the voting rights of that stake back to the",
            "     *         user.",
            "     * @param _trader Trader address to receive DDX (inside their",
            "     *        wallet, which will be created if it does not already",
            "     *        exist).",
            "     * @param _amount The DDX tokens to be staked.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function lets traders send DDX from their wallet\n     *         into another trader's on-chain DDX wallet. It's\n     *         important to note that any DDX staked to this wallet\n     *         delegates the voting rights of that stake back to the\n     *         user.\n     * @param _trader Trader address to receive DDX (inside their\n     *        wallet, which will be created if it does not already\n     *        exist).\n     * @param _amount The DDX tokens to be staked.\n     */\n",
        "@notice": "This function lets traders send DDX from their wallet * into another trader's on-chain DDX wallet. It's * important to note that any DDX staked to this wallet * delegates the voting rights of that stake back to the * user.",
        "@param1": "_trader Trader address to receive DDX (inside their * wallet, which will be created if it does not already * exist).",
        "@param2": "_amount The DDX tokens to be staked.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawDDXToTrader",
        "visibility": "external",
        "args": [
            {
                "name": "_amount",
                "type": "uint96"
            }
        ],
        "func": "function withdrawDDXToTrader(uint96 _amount) external postRewardCliff {\n        LibDiamondStorageTrader.DiamondStorageTrader storage dsTrader = LibDiamondStorageTrader.diamondStorageTrader();\n\n        TraderDefs.Trader storage trader = dsTrader.traders[msg.sender];\n\n        LibDiamondStorageDerivaDEX.DiamondStorageDerivaDEX storage dsDerivaDEX =\n            LibDiamondStorageDerivaDEX.diamondStorageDerivaDEX();\n\n        // Subtract trader's DDX balance in the contract\n        trader.ddxBalance = trader.ddxBalance.sub96(_amount);\n\n        // Transfer DDX from trader's on-chain wallet to the trader\n        dsDerivaDEX.ddxToken.transferFrom(trader.ddxWalletContract, msg.sender, _amount);\n    }",
        "comments": [
            "/**",
            "     * @notice This function lets traders withdraw DDX from their",
            "     *         on-chain DDX wallet to their personal wallet. It's",
            "     *         important to note that the voting rights for any DDX",
            "     *         withdrawn are returned back to the delegatee of the",
            "     *         user's personal wallet. To be more explicit, if Alice is",
            "     *         personal wallet is delegating to Bob, and she now",
            "     *         withdraws a portion of her DDX from this on-chain DDX",
            "     *         wallet of hers, those tokens will now count towards Bob's",
            "     *         voting power, not her's, since her on-chain wallet is",
            "     *         automatically delegating back to her, but her personal",
            "     *         wallet is delegating to Bob. Withdrawals can only happen",
            "     *         when the governance cliff is lifted.",
            "     * @param _amount The DDX tokens to be withdrawn.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function lets traders withdraw DDX from their\n     *         on-chain DDX wallet to their personal wallet. It's\n     *         important to note that the voting rights for any DDX\n     *         withdrawn are returned back to the delegatee of the\n     *         user's personal wallet. To be more explicit, if Alice is\n     *         personal wallet is delegating to Bob, and she now\n     *         withdraws a portion of her DDX from this on-chain DDX\n     *         wallet of hers, those tokens will now count towards Bob's\n     *         voting power, not her's, since her on-chain wallet is\n     *         automatically delegating back to her, but her personal\n     *         wallet is delegating to Bob. Withdrawals can only happen\n     *         when the governance cliff is lifted.\n     * @param _amount The DDX tokens to be withdrawn.\n     */\n",
        "@notice": "This function lets traders withdraw DDX from their * on-chain DDX wallet to their personal wallet. It's * important to note that the voting rights for any DDX * withdrawn are returned back to the delegatee of the * user's personal wallet. To be more explicit, if Alice is * personal wallet is delegating to Bob, and she now * withdraws a portion of her DDX from this on-chain DDX * wallet of hers, those tokens will now count towards Bob's * voting power, not her's, since her on-chain wallet is * automatically delegating back to her, but her personal * wallet is delegating to Bob. Withdrawals can only happen * when the governance cliff is lifted.",
        "@param1": "_amount The DDX tokens to be withdrawn.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "getTrader",
        "visibility": "external",
        "args": [
            {
                "name": "_trader",
                "type": "address"
            }
        ],
        "func": "function getTrader(address _trader) external view returns (TraderDefs.Trader memory) {\n        LibDiamondStorageTrader.DiamondStorageTrader storage dsTrader = LibDiamondStorageTrader.diamondStorageTrader();\n\n        return dsTrader.traders[_trader];\n    }",
        "comments": [
            "/**",
            "     * @notice This function gets the attributes for a given trader.",
            "     * @param _trader Trader address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function gets the attributes for a given trader.\n     * @param _trader Trader address.\n     */\n",
        "@notice": "This function gets the attributes for a given trader.",
        "@param1": "_trader Trader address.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "initialize",
        "visibility": "external",
        "args": [
            {
                "name": "_interval",
                "type": "uint32"
            },
            {
                "name": "_withdrawalFactor",
                "type": "uint32"
            },
            {
                "name": "_mineRatePerBlock",
                "type": "uint96"
            },
            {
                "name": "_advanceIntervalReward",
                "type": "uint96"
            },
            {
                "name": "_insuranceMiningLength",
                "type": "uint256"
            },
            {
                "name": "_diFundTokenFactory",
                "type": "IDIFundTokenFactory"
            }
        ],
        "func": "function initialize(\n        uint32 _interval,\n        uint32 _withdrawalFactor,\n        uint96 _mineRatePerBlock,\n        uint96 _advanceIntervalReward,\n        uint256 _insuranceMiningLength,\n        IDIFundTokenFactory _diFundTokenFactory\n    ) external onlyAdmin {\n        LibDiamondStorageInsuranceFund.DiamondStorageInsuranceFund storage dsInsuranceFund =\n            LibDiamondStorageInsuranceFund.diamondStorageInsuranceFund();\n\n        // Set the interval for other rewards claiming checkpoints\n        // (i.e. COMP and aTokens that accrue to the contract)\n        // (e.g. 40320 ~ 1 week = 7 * 24 * 60 * 60 / 15 blocks)\n        dsInsuranceFund.interval = _interval;\n\n        // Keep track of the block number for other rewards checkpoint,\n        // which is initialized to the block number the insurance fund\n        // facet is added to the diamond\n        dsInsuranceFund.otherRewardsCheckpointBlock = block.number;\n\n        // Set the withdrawal factor, capped at 1000, implying 0% fee\n        require(_withdrawalFactor <= 1000, \"IFund: withdrawal fee too high.\");\n        // Set withdrawal ratio, which will be used with a 1e3 scaling\n        // factor, meaning a value of 995 implies a withdrawal fee of\n        // 0.5% since 995/1e3 => 0.995\n        dsInsuranceFund.withdrawalFactor = _withdrawalFactor;\n\n        // Set the insurance mine rate per block.\n        // (e.g. 1.189e18 ~ 5% liquidity mine (50mm tokens))\n        dsInsuranceFund.mineRatePerBlock = _mineRatePerBlock;\n\n        // Incentive to advance the other rewards interval\n        // (e.g. 100e18 = 100 DDX)\n        dsInsuranceFund.advanceIntervalReward = _advanceIntervalReward;\n\n        // Set the final block number for insurance mining\n        dsInsuranceFund.miningFinalBlockNumber = block.number.add(_insuranceMiningLength);\n\n        // DIFundToken factory to deploy DerivaDEX Insurance Fund token\n        // contracts pertaining to each supported collateral\n        dsInsuranceFund.diFundTokenFactory = _diFundTokenFactory;\n\n        // Initialize the DDX market state index and block. These values\n        // are critical for computing the DDX continuously issued per\n        // block\n        dsInsuranceFund.ddxMarketState.index = 1e36;\n        dsInsuranceFund.ddxMarketState.block = block.number.safe32(\"IFund: exceeds 32 bits\");\n\n        emit InsuranceFundInitialized(\n            _interval,\n            _withdrawalFactor,\n            _mineRatePerBlock,\n            _advanceIntervalReward,\n            dsInsuranceFund.miningFinalBlockNumber\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice This function initializes the state with some critical",
            "     *         information. This can only be called via governance.",
            "     * @dev This function is best called as a parameter to the",
            "     *      diamond cut function. This is removed prior to the selectors",
            "     *      being added to the diamond, meaning it cannot be called",
            "     *      again.",
            "     * @param _interval The interval length (blocks) for other rewards",
            "     *        claiming checkpoints (i.e. COMP and extra aTokens).",
            "     * @param _withdrawalFactor Specifies the withdrawal fee if users",
            "     *        redeem their insurance tokens.",
            "     * @param _mineRatePerBlock The DDX tokens to be mined each interval",
            "     *        for insurance mining.",
            "     * @param _advanceIntervalReward DDX reward for participant who",
            "     *        advances the insurance mining interval.",
            "     * @param _insuranceMiningLength Insurance mining length (blocks).",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function initializes the state with some critical\n     *         information. This can only be called via governance.\n     * @dev This function is best called as a parameter to the\n     *      diamond cut function. This is removed prior to the selectors\n     *      being added to the diamond, meaning it cannot be called\n     *      again.\n     * @param _interval The interval length (blocks) for other rewards\n     *        claiming checkpoints (i.e. COMP and extra aTokens).\n     * @param _withdrawalFactor Specifies the withdrawal fee if users\n     *        redeem their insurance tokens.\n     * @param _mineRatePerBlock The DDX tokens to be mined each interval\n     *        for insurance mining.\n     * @param _advanceIntervalReward DDX reward for participant who\n     *        advances the insurance mining interval.\n     * @param _insuranceMiningLength Insurance mining length (blocks).\n     */\n",
        "@notice": "This function initializes the state with some critical * information. This can only be called via governance.",
        "@dev": "This function is best called as a parameter to the * diamond cut function. This is removed prior to the selectors * being added to the diamond, meaning it cannot be called * again.",
        "@param1": "_interval The interval length (blocks) for other rewards * claiming checkpoints (i.e. COMP and extra aTokens).",
        "@param2": "_withdrawalFactor Specifies the withdrawal fee if users * redeem their insurance tokens.",
        "@param3": "_mineRatePerBlock The DDX tokens to be mined each interval * for insurance mining.",
        "@param4": "_advanceIntervalReward DDX reward for participant who * advances the insurance mining interval.",
        "@param5": "_insuranceMiningLength Insurance mining length (blocks).",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setMineRatePerBlock",
        "visibility": "external",
        "args": [
            {
                "name": "_mineRatePerBlock",
                "type": "uint96"
            }
        ],
        "func": "function setMineRatePerBlock(uint96 _mineRatePerBlock) external onlyAdmin insuranceMiningOngoing isNotPaused {\n        LibDiamondStorageInsuranceFund.DiamondStorageInsuranceFund storage dsInsuranceFund =\n            LibDiamondStorageInsuranceFund.diamondStorageInsuranceFund();\n\n        // NOTE(jalextowle): We must update the DDX Market State prior to\n        // changing the mine rate per block in order to lock in earned rewards\n        // for insurance mining participants.\n        updateDDXMarketState(dsInsuranceFund);\n\n        require(_mineRatePerBlock != dsInsuranceFund.mineRatePerBlock, \"IFund: same as current value.\");\n        // Set the insurance mine rate per block.\n        // (e.g. 1.189e18 ~ 5% liquidity mine (50mm tokens))\n        dsInsuranceFund.mineRatePerBlock = _mineRatePerBlock;\n\n        emit MineRatePerBlockSet(_mineRatePerBlock);\n    }",
        "comments": [
            "/**",
            "     * @notice This function sets the DDX mine rate per block.",
            "     * @param _mineRatePerBlock The DDX tokens mine rate per block.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function sets the DDX mine rate per block.\n     * @param _mineRatePerBlock The DDX tokens mine rate per block.\n     */\n",
        "@notice": "This function sets the DDX mine rate per block.",
        "@param1": "_mineRatePerBlock The DDX tokens mine rate per block.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setAdvanceIntervalReward",
        "visibility": "external",
        "args": [
            {
                "name": "_advanceIntervalReward",
                "type": "uint96"
            }
        ],
        "func": "function setAdvanceIntervalReward(uint96 _advanceIntervalReward)\n        external\n        onlyAdmin\n        insuranceMiningOngoing\n        isNotPaused\n    {\n        LibDiamondStorageInsuranceFund.DiamondStorageInsuranceFund storage dsInsuranceFund =\n            LibDiamondStorageInsuranceFund.diamondStorageInsuranceFund();\n\n        require(_advanceIntervalReward != dsInsuranceFund.advanceIntervalReward, \"IFund: same as current value.\");\n        // Set the advance interval reward\n        dsInsuranceFund.advanceIntervalReward = _advanceIntervalReward;\n\n        emit AdvanceIntervalRewardSet(_advanceIntervalReward);\n    }",
        "comments": [
            "/**",
            "     * @notice This function sets the advance interval reward.",
            "     * @param _advanceIntervalReward DDX reward for advancing interval.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function sets the advance interval reward.\n     * @param _advanceIntervalReward DDX reward for advancing interval.\n     */\n",
        "@notice": "This function sets the advance interval reward.",
        "@param1": "_advanceIntervalReward DDX reward for advancing interval.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setWithdrawalFactor",
        "visibility": "external",
        "args": [
            {
                "name": "_withdrawalFactor",
                "type": "uint32"
            }
        ],
        "func": "function setWithdrawalFactor(uint32 _withdrawalFactor) external onlyAdmin insuranceMiningOngoing isNotPaused {\n        LibDiamondStorageInsuranceFund.DiamondStorageInsuranceFund storage dsInsuranceFund =\n            LibDiamondStorageInsuranceFund.diamondStorageInsuranceFund();\n\n        require(_withdrawalFactor != dsInsuranceFund.withdrawalFactor, \"IFund: same as current value.\");\n        // Set the withdrawal factor, capped at 1000, implying 0% fee\n        require(dsInsuranceFund.withdrawalFactor <= 1000, \"IFund: withdrawal fee too high.\");\n        dsInsuranceFund.withdrawalFactor = _withdrawalFactor;\n\n        emit WithdrawalFactorSet(_withdrawalFactor);\n    }",
        "comments": [
            "/**",
            "     * @notice This function sets the withdrawal factor.",
            "     * @param _withdrawalFactor Withdrawal factor.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function sets the withdrawal factor.\n     * @param _withdrawalFactor Withdrawal factor.\n     */\n",
        "@notice": "This function sets the withdrawal factor.",
        "@param1": "_withdrawalFactor Withdrawal factor.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "extendInsuranceMining",
        "visibility": "external",
        "args": [
            {
                "name": "_insuranceMiningExtension",
                "type": "uint256"
            }
        ],
        "func": "function extendInsuranceMining(uint256 _insuranceMiningExtension)\n        external\n        onlyAdmin\n        insuranceMiningOngoing\n        isNotPaused\n    {\n        LibDiamondStorageInsuranceFund.DiamondStorageInsuranceFund storage dsInsuranceFund =\n            LibDiamondStorageInsuranceFund.diamondStorageInsuranceFund();\n\n        require(_insuranceMiningExtension != 0, \"IFund: invalid extension.\");\n        // Extend the mining final block number\n        dsInsuranceFund.miningFinalBlockNumber = dsInsuranceFund.miningFinalBlockNumber.add(_insuranceMiningExtension);\n\n        emit InsuranceMiningExtended(dsInsuranceFund.miningFinalBlockNumber);\n    }",
        "comments": [
            "/**",
            "     * @notice This function extends insurance mining.",
            "     * @param _insuranceMiningExtension Insurance mining extension",
            "     *         (blocks).",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function extends insurance mining.\n     * @param _insuranceMiningExtension Insurance mining extension\n     *         (blocks).\n     */\n",
        "@notice": "This function extends insurance mining.",
        "@param1": "_insuranceMiningExtension Insurance mining extension * (blocks).",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addInsuranceFundCollateral",
        "visibility": "external",
        "args": [
            {
                "name": "_collateralName",
                "type": "string memory"
            },
            {
                "name": "_collateralSymbol",
                "type": "string memory"
            },
            {
                "name": "_underlyingToken",
                "type": "address"
            },
            {
                "name": "_collateralToken",
                "type": "address"
            },
            {
                "name": "_flavor",
                "type": "InsuranceFundDefs.Flavor"
            }
        ],
        "func": "function addInsuranceFundCollateral(\n        string memory _collateralName,\n        string memory _collateralSymbol,\n        address _underlyingToken,\n        address _collateralToken,\n        InsuranceFundDefs.Flavor _flavor\n    ) external onlyAdmin insuranceMiningOngoing isNotPaused {\n        LibDiamondStorageInsuranceFund.DiamondStorageInsuranceFund storage dsInsuranceFund =\n            LibDiamondStorageInsuranceFund.diamondStorageInsuranceFund();\n\n        // Obtain bytes32 representation of collateral name\n        bytes32 result;\n        assembly {\n            result := mload(add(_collateralName, 32))\n        }\n\n        // Ensure collateral has not already been added\n        require(\n            dsInsuranceFund.stakeCollaterals[result].collateralToken == address(0),\n            \"IFund: collateral already added.\"\n        );\n\n        require(_collateralToken != address(0), \"IFund: collateral address must be non-zero.\");\n        require(!isCollateralTokenPresent(_collateralToken), \"IFund: collateral token already present.\");\n        require(_underlyingToken != _collateralToken, \"IFund: token addresses are same.\");\n        if (_flavor == InsuranceFundDefs.Flavor.Vanilla) {\n            // If collateral is of vanilla flavor, there should only be\n            // a value for collateral token, and underlying token should\n            // be empty\n            require(_underlyingToken == address(0), \"IFund: underlying address non-zero for Vanilla.\");\n        }\n\n        // Add collateral type to storage, including its underlying\n        // token and collateral token addresses, and its flavor\n        dsInsuranceFund.stakeCollaterals[result].underlyingToken = _underlyingToken;\n        dsInsuranceFund.stakeCollaterals[result].collateralToken = _collateralToken;\n        dsInsuranceFund.stakeCollaterals[result].flavor = _flavor;\n\n        // Create a DerivaDEX Insurance Fund token contract associated\n        // with this supported collateral\n        dsInsuranceFund.stakeCollaterals[result].diFundToken = IDIFundToken(\n            dsInsuranceFund.diFundTokenFactory.createNewDIFundToken(\n                _collateralName,\n                _collateralSymbol,\n                IERCCustom(_collateralToken).decimals()\n            )\n        );\n        dsInsuranceFund.collateralNames.push(result);\n\n        emit InsuranceFundCollateralAdded(result, _underlyingToken, _collateralToken, _flavor);\n    }",
        "comments": [
            "/**",
            "     * @notice This function adds a new supported collateral type that",
            "     *         can be staked to the insurance fund. It can only",
            "     *         be called via governance.",
            "     * @dev For vanilla contracts (e.g. USDT, USDC, etc.), the",
            "     *      underlying token equals address(0).",
            "     * @param _collateralName Name of collateral.",
            "     * @param _collateralSymbol Symbol of collateral.",
            "     * @param _underlyingToken Deployed address of underlying token.",
            "     * @param _collateralToken Deployed address of collateral token.",
            "     * @param _flavor Collateral flavor (Vanilla, Compound, Aave, etc.).",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function adds a new supported collateral type that\n     *         can be staked to the insurance fund. It can only\n     *         be called via governance.\n     * @dev For vanilla contracts (e.g. USDT, USDC, etc.), the\n     *      underlying token equals address(0).\n     * @param _collateralName Name of collateral.\n     * @param _collateralSymbol Symbol of collateral.\n     * @param _underlyingToken Deployed address of underlying token.\n     * @param _collateralToken Deployed address of collateral token.\n     * @param _flavor Collateral flavor (Vanilla, Compound, Aave, etc.).\n     */\n",
        "@notice": "This function adds a new supported collateral type that * can be staked to the insurance fund. It can only * be called via governance.",
        "@dev": "For vanilla contracts (e.g. USDT, USDC, etc.), the * underlying token equals address(0).",
        "@param1": "_collateralName Name of collateral.",
        "@param2": "_collateralSymbol Symbol of collateral.",
        "@param3": "_underlyingToken Deployed address of underlying token.",
        "@param4": "_collateralToken Deployed address of collateral token.",
        "@param5": "_flavor Collateral flavor (Vanilla, Compound, Aave, etc.).",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stakeToInsuranceFund",
        "visibility": "external",
        "args": [
            {
                "name": "_collateralName",
                "type": "bytes32"
            },
            {
                "name": "_amount",
                "type": "uint96"
            }
        ],
        "func": "function stakeToInsuranceFund(bytes32 _collateralName, uint96 _amount) external insuranceMiningOngoing isNotPaused {\n        LibDiamondStorageInsuranceFund.DiamondStorageInsuranceFund storage dsInsuranceFund =\n            LibDiamondStorageInsuranceFund.diamondStorageInsuranceFund();\n\n        // Obtain the collateral struct for the collateral type\n        // participant is staking\n        InsuranceFundDefs.StakeCollateral storage stakeCollateral = dsInsuranceFund.stakeCollaterals[_collateralName];\n\n        // Ensure this is a supported collateral type and that the user\n        // has approved the proxy contract for transfer\n        require(stakeCollateral.collateralToken != address(0), \"IFund: invalid collateral.\");\n\n        // Ensure non-zero stake amount\n        require(_amount > 0, \"IFund: non-zero amount.\");\n\n        // Claim DDX for staking user. We do this prior to the stake\n        // taking effect, thereby preventing someone from being rewarded\n        // instantly for the stake.\n        claimDDXFromInsuranceMining(msg.sender);\n\n        // Increment the underlying capitalization\n        stakeCollateral.cap = stakeCollateral.cap.add96(_amount);\n\n        // Transfer collateral amount from user to proxy contract\n        IERC20(stakeCollateral.collateralToken).safeTransferFrom(msg.sender, address(this), _amount);\n\n        // Mint DIFund tokens to user\n        stakeCollateral.diFundToken.mint(msg.sender, _amount);\n\n        emit StakedToInsuranceFund(msg.sender, _amount, _collateralName);\n    }",
        "comments": [
            "/**",
            "     * @notice This function allows participants to stake a supported",
            "     *         collateral type to the insurance fund.",
            "     * @param _collateralName Name of collateral.",
            "     * @param _amount Amount to stake.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function allows participants to stake a supported\n     *         collateral type to the insurance fund.\n     * @param _collateralName Name of collateral.\n     * @param _amount Amount to stake.\n     */\n",
        "@notice": "This function allows participants to stake a supported * collateral type to the insurance fund.",
        "@param1": "_collateralName Name of collateral.",
        "@param2": "_amount Amount to stake.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawFromInsuranceFund",
        "visibility": "external",
        "args": [
            {
                "name": "_collateralName",
                "type": "bytes32"
            },
            {
                "name": "_amount",
                "type": "uint96"
            }
        ],
        "func": "function withdrawFromInsuranceFund(bytes32 _collateralName, uint96 _amount) external isNotPaused {\n        LibDiamondStorageInsuranceFund.DiamondStorageInsuranceFund storage dsInsuranceFund =\n            LibDiamondStorageInsuranceFund.diamondStorageInsuranceFund();\n\n        // Obtain the collateral struct for the collateral type\n        // participant is staking\n        InsuranceFundDefs.StakeCollateral storage stakeCollateral = dsInsuranceFund.stakeCollaterals[_collateralName];\n\n        // Ensure this is a supported collateral type and that the user\n        // has approved the proxy contract for transfer\n        require(stakeCollateral.collateralToken != address(0), \"IFund: invalid collateral.\");\n\n        // Ensure non-zero withdraw amount\n        require(_amount > 0, \"IFund: non-zero amount.\");\n\n        // Claim DDX for withdrawing user. We do this prior to the\n        // redeem taking effect.\n        claimDDXFromInsuranceMining(msg.sender);\n\n        // Determine underlying to transfer based on how much underlying\n        // can be redeemed given the current underlying capitalization\n        // and how many DIFund tokens are globally available. This\n        // theoretically fails in the scenario where globally there are\n        // 0 insurance fund tokens, however that would mean the user\n        // also has 0 tokens in their possession, and thus would have\n        // nothing to be redeemed anyways.\n        uint96 underlyingToTransferNoFee =\n            _amount.proportion96(stakeCollateral.cap, stakeCollateral.diFundToken.totalSupply());\n        uint96 underlyingToTransfer = underlyingToTransferNoFee.proportion96(dsInsuranceFund.withdrawalFactor, 1e3);\n\n        // Decrement the capitalization\n        stakeCollateral.cap = stakeCollateral.cap.sub96(underlyingToTransferNoFee);\n\n        // Increment the withdrawal fee cap\n        stakeCollateral.withdrawalFeeCap = stakeCollateral.withdrawalFeeCap.add96(\n            underlyingToTransferNoFee.sub96(underlyingToTransfer)\n        );\n\n        // Transfer collateral amount from proxy contract to user\n        IERC20(stakeCollateral.collateralToken).safeTransfer(msg.sender, underlyingToTransfer);\n\n        // Burn DIFund tokens being redeemed from user\n        stakeCollateral.diFundToken.burnFrom(msg.sender, _amount);\n\n        emit WithdrawnFromInsuranceFund(msg.sender, _amount, _collateralName);\n    }",
        "comments": [
            "/**",
            "     * @notice This function allows participants to withdraw a supported",
            "     *         collateral type from the insurance fund.",
            "     * @param _collateralName Name of collateral.",
            "     * @param _amount Amount to stake.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function allows participants to withdraw a supported\n     *         collateral type from the insurance fund.\n     * @param _collateralName Name of collateral.\n     * @param _amount Amount to stake.\n     */\n",
        "@notice": "This function allows participants to withdraw a supported * collateral type from the insurance fund.",
        "@param1": "_collateralName Name of collateral.",
        "@param2": "_amount Amount to stake.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "advanceOtherRewardsInterval",
        "visibility": "external",
        "args": [],
        "func": "function advanceOtherRewardsInterval() external otherRewardsOngoing isNotPaused {\n        LibDiamondStorageInsuranceFund.DiamondStorageInsuranceFund storage dsInsuranceFund =\n            LibDiamondStorageInsuranceFund.diamondStorageInsuranceFund();\n\n        // Check if the current block has exceeded the interval bounds,\n        // allowing for a new other rewards interval to be checkpointed\n        require(\n            block.number >= dsInsuranceFund.otherRewardsCheckpointBlock.add(dsInsuranceFund.interval),\n            \"IFund: advance too soon.\"\n        );\n\n        // Maintain the USD-denominated sum of all Compound-flavor\n        // assets. This needs to be stored separately than the rest\n        // due to the way COMP tokens are rewarded to the contract in\n        // order to properly disseminate to the user.\n        uint96 normalizedCapCheckpointSumCompound;\n\n        // Loop through each of the supported collateral types\n        for (uint256 i = 0; i < dsInsuranceFund.collateralNames.length; i++) {\n            // Obtain collateral struct under consideration\n            InsuranceFundDefs.StakeCollateral storage stakeCollateral =\n                dsInsuranceFund.stakeCollaterals[dsInsuranceFund.collateralNames[i]];\n            if (stakeCollateral.flavor == InsuranceFundDefs.Flavor.Compound) {\n                // If collateral is of type Compound, set the exchange\n                // rate at this point in time. We do this so later on,\n                // when claiming rewards, we know the exchange rate\n                // checkpointed balances should be converted to\n                // determine the USD-denominated value of holdings\n                // needed to compute fair share of DDX rewards.\n                stakeCollateral.exchangeRate = ICToken(stakeCollateral.collateralToken).exchangeRateStored().safe96(\n                    \"IFund: amount exceeds 96 bits\"\n                );\n\n                // Set checkpoint cap for this Compound flavor\n                // collateral to handle COMP distribution lookbacks\n                stakeCollateral.checkpointCap = stakeCollateral.cap;\n\n                // Increment the normalized Compound checkpoint cap\n                // with the USD-denominated value\n                normalizedCapCheckpointSumCompound = normalizedCapCheckpointSumCompound.add96(\n                    getUnderlyingTokenAmountForCompound(stakeCollateral.cap, stakeCollateral.exchangeRate)\n                );\n            } else if (stakeCollateral.flavor == InsuranceFundDefs.Flavor.Aave) {\n                // If collateral is of type Aave, we need to do some\n                // custom Aave aToken reward distribution. We first\n                // determine the contract's aToken balance for this\n                // collateral type and subtract the underlying\n                // aToken capitalization that are due to users. This\n                // leaves us with the excess that has been rewarded\n                // to the contract due to Aave's mechanisms, but\n                // belong to the users.\n                uint96 myATokenBalance =\n                    uint96(IAToken(stakeCollateral.collateralToken).balanceOf(address(this)).sub(stakeCollateral.cap));\n\n                // Store the aToken yield information\n                dsInsuranceFund.aTokenYields[dsInsuranceFund.collateralNames[i]] = InsuranceFundDefs\n                    .ExternalYieldCheckpoint({ accrued: myATokenBalance, totalNormalizedCap: 0 });\n            }\n        }\n\n        // Ensure that the normalized cap sum is non-zero\n        if (normalizedCapCheckpointSumCompound > 0) {\n            // If there's Compound-type asset capitalization in the\n            // system, claim COMP accrued to this contract. This COMP is\n            // a result of holding all the cToken deposits from users.\n            // We claim COMP via Compound's Comptroller contract.\n            COMPTROLLER.claimComp(address(this));\n\n            // Obtain contract's balance of COMP\n            uint96 myCompBalance = COMP_TOKEN.balanceOf(address(this)).safe96(\"IFund: amount exceeds 96 bits.\");\n\n            // Store the updated value as the checkpointed COMP yield owed\n            // for this interval\n            dsInsuranceFund.compYields = InsuranceFundDefs.ExternalYieldCheckpoint({\n                accrued: myCompBalance,\n                totalNormalizedCap: normalizedCapCheckpointSumCompound\n            });\n        }\n\n        // Set other rewards checkpoint block to current block\n        dsInsuranceFund.otherRewardsCheckpointBlock = block.number;\n\n        // Issue DDX reward to trader's on-chain DDX wallet as an\n        // incentive to users calling this function\n        LibTraderInternal.issueDDXReward(dsInsuranceFund.advanceIntervalReward, msg.sender);\n\n        emit AdvancedOtherRewards(msg.sender, dsInsuranceFund.advanceIntervalReward);\n    }",
        "comments": [
            "/**",
            "     * @notice Advance other rewards interval",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Advance other rewards interval\n     */\n",
        "@notice": "Advance other rewards interval",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getInsuranceMineInfo",
        "visibility": "external",
        "args": [],
        "func": "function getInsuranceMineInfo()\n        external\n        view\n        returns (\n            uint32,\n            uint32,\n            uint96,\n            uint96,\n            uint96,\n            uint256,\n            InsuranceFundDefs.DDXMarketState memory,\n            bytes32[] memory\n        )\n    {\n        LibDiamondStorageInsuranceFund.DiamondStorageInsuranceFund storage dsInsuranceFund =\n            LibDiamondStorageInsuranceFund.diamondStorageInsuranceFund();\n        return (\n            dsInsuranceFund.interval,\n            dsInsuranceFund.withdrawalFactor,\n            dsInsuranceFund.advanceIntervalReward,\n            dsInsuranceFund.minedAmount,\n            dsInsuranceFund.mineRatePerBlock,\n            dsInsuranceFund.miningFinalBlockNumber,\n            dsInsuranceFund.ddxMarketState,\n            dsInsuranceFund.collateralNames\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice This function gets some high level insurance mining",
            "     *         details.",
            "     * @return The interval length (blocks) for other rewards",
            "     *         claiming checkpoints (i.e. COMP and extra aTokens).",
            "     * @return Current insurance mine withdrawal factor.",
            "     * @return DDX reward for advancing interval.",
            "     * @return Total global insurance mined amount in DDX.",
            "     * @return Current insurance mine rate per block.",
            "     * @return Insurance mining final block number.",
            "     * @return DDX market state used for continuous DDX payouts.",
            "     * @return Supported collateral names supported.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function gets some high level insurance mining\n     *         details.\n     * @return The interval length (blocks) for other rewards\n     *         claiming checkpoints (i.e. COMP and extra aTokens).\n     * @return Current insurance mine withdrawal factor.\n     * @return DDX reward for advancing interval.\n     * @return Total global insurance mined amount in DDX.\n     * @return Current insurance mine rate per block.\n     * @return Insurance mining final block number.\n     * @return DDX market state used for continuous DDX payouts.\n     * @return Supported collateral names supported.\n     */\n",
        "@notice": "This function gets some high level insurance mining * details.",
        "@return1": "The interval length (blocks) for other rewards * claiming checkpoints (i.e. COMP and extra aTokens).",
        "@return2": "Current insurance mine withdrawal factor.",
        "@return3": "DDX reward for advancing interval.",
        "@return4": "Total global insurance mined amount in DDX.",
        "@return5": "Current insurance mine rate per block.",
        "@return6": "Insurance mining final block number.",
        "@return7": "DDX market state used for continuous DDX payouts.",
        "@return8": "Supported collateral names supported.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getDDXClaimantState",
        "visibility": "external",
        "args": [
            {
                "name": "_claimant",
                "type": "address"
            }
        ],
        "func": "function getDDXClaimantState(address _claimant) external view returns (InsuranceFundDefs.DDXClaimantState memory) {\n        LibDiamondStorageInsuranceFund.DiamondStorageInsuranceFund storage dsInsuranceFund =\n            LibDiamondStorageInsuranceFund.diamondStorageInsuranceFund();\n        return dsInsuranceFund.ddxClaimantState[_claimant];\n    }",
        "comments": [
            "/**",
            "     * @notice This function gets the current claimant state for a user.",
            "     * @param _claimant Claimant address.",
            "     * @return Claimant state.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function gets the current claimant state for a user.\n     * @param _claimant Claimant address.\n     * @return Claimant state.\n     */\n",
        "@notice": "This function gets the current claimant state for a user.",
        "@param1": "_claimant Claimant address.",
        "@return1": "Claimant state.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getStakeCollateralByCollateralName",
        "visibility": "external",
        "args": [
            {
                "name": "_collateralName",
                "type": "bytes32"
            }
        ],
        "func": "function getStakeCollateralByCollateralName(bytes32 _collateralName)\n        external\n        view\n        returns (InsuranceFundDefs.StakeCollateral memory)\n    {\n        LibDiamondStorageInsuranceFund.DiamondStorageInsuranceFund storage dsInsuranceFund =\n            LibDiamondStorageInsuranceFund.diamondStorageInsuranceFund();\n        return dsInsuranceFund.stakeCollaterals[_collateralName];\n    }",
        "comments": [
            "/**",
            "     * @notice This function gets a supported collateral type's data,",
            "     *         including collateral's token addresses, collateral",
            "     *         flavor/type, current cap and withdrawal amounts, the",
            "     *         latest checkpointed cap, and exchange rate (for cTokens).",
            "     *         An interface for the DerivaDEX Insurance Fund token",
            "     *         corresponding to this collateral is also maintained.",
            "     * @param _collateralName Name of collateral.",
            "     * @return Stake collateral.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function gets a supported collateral type's data,\n     *         including collateral's token addresses, collateral\n     *         flavor/type, current cap and withdrawal amounts, the\n     *         latest checkpointed cap, and exchange rate (for cTokens).\n     *         An interface for the DerivaDEX Insurance Fund token\n     *         corresponding to this collateral is also maintained.\n     * @param _collateralName Name of collateral.\n     * @return Stake collateral.\n     */\n",
        "@notice": "This function gets a supported collateral type's data, * including collateral's token addresses, collateral * flavor/type, current cap and withdrawal amounts, the * latest checkpointed cap, and exchange rate (for cTokens). * An interface for the DerivaDEX Insurance Fund token * corresponding to this collateral is also maintained.",
        "@param1": "_collateralName Name of collateral.",
        "@return1": "Stake collateral.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "getUnclaimedDDXRewards",
        "visibility": "external",
        "args": [
            {
                "name": "_claimant",
                "type": "address"
            }
        ],
        "func": "function getUnclaimedDDXRewards(address _claimant) external view returns (uint96) {\n        LibDiamondStorageInsuranceFund.DiamondStorageInsuranceFund storage dsInsuranceFund =\n            LibDiamondStorageInsuranceFund.diamondStorageInsuranceFund();\n\n        // Number of blocks that have elapsed from the last protocol\n        // interaction resulting in DDX accrual. If insurance mining\n        // has ended, we use this as the reference point, so deltaBlocks\n        // will be 0 from the second time onwards.\n        uint256 deltaBlocks =\n            Math.min(block.number, dsInsuranceFund.miningFinalBlockNumber).sub(dsInsuranceFund.ddxMarketState.block);\n\n        // Save off last index value\n        uint256 index = dsInsuranceFund.ddxMarketState.index;\n\n        // If number of blocks elapsed and mine rate per block are\n        // non-zero\n        if (deltaBlocks > 0 && dsInsuranceFund.mineRatePerBlock > 0) {\n            // Maintain a running total of USDT-normalized claim tokens\n            // (i.e. 1e6 multiplier)\n            uint256 claimTokens;\n\n            // Loop through each of the supported collateral types\n            for (uint256 i = 0; i < dsInsuranceFund.collateralNames.length; i++) {\n                // Obtain the collateral struct for the collateral type\n                // participant is staking\n                InsuranceFundDefs.StakeCollateral storage stakeCollateral =\n                    dsInsuranceFund.stakeCollaterals[dsInsuranceFund.collateralNames[i]];\n\n                // Increment the USDT-normalized claim tokens count with\n                // the current total supply\n                claimTokens = claimTokens.add(\n                    getNormalizedCollateralValue(\n                        dsInsuranceFund.collateralNames[i],\n                        stakeCollateral.diFundToken.totalSupply().safe96(\"IFund: exceeds 96 bits\")\n                    )\n                );\n            }\n\n            // Compute DDX accrued during the time elapsed and the\n            // number of tokens accrued per claim token outstanding\n            uint256 ddxAccrued = deltaBlocks.mul(dsInsuranceFund.mineRatePerBlock);\n            uint256 ratio = claimTokens > 0 ? ddxAccrued.mul(1e36).div(claimTokens) : 0;\n\n            // Increment the index\n            index = index.add(ratio);\n        }\n\n        // Obtain the most recent claimant index\n        uint256 ddxClaimantIndex = dsInsuranceFund.ddxClaimantState[_claimant].index;\n\n        // If the claimant index is 0, i.e. it's the user's first time\n        // interacting with the protocol, initialize it to this starting\n        // value\n        if ((ddxClaimantIndex == 0) && (index > 0)) {\n            ddxClaimantIndex = 1e36;\n        }\n\n        // Maintain a running total of USDT-normalized claimant tokens\n        // (i.e. 1e6 multiplier)\n        uint256 claimantTokens;\n\n        // Loop through each of the supported collateral types\n        for (uint256 i = 0; i < dsInsuranceFund.collateralNames.length; i++) {\n            // Obtain the collateral struct for the collateral type\n            // participant is staking\n            InsuranceFundDefs.StakeCollateral storage stakeCollateral =\n                dsInsuranceFund.stakeCollaterals[dsInsuranceFund.collateralNames[i]];\n\n            // Increment the USDT-normalized claimant tokens count with\n            // the current balance\n            claimantTokens = claimantTokens.add(\n                getNormalizedCollateralValue(\n                    dsInsuranceFund.collateralNames[i],\n                    stakeCollateral.diFundToken.balanceOf(_claimant).safe96(\"IFund: exceeds 96 bits\")\n                )\n            );\n        }\n\n        // Compute the unclaimed DDX based on the number of claimant\n        // tokens and the difference between the user's index and the\n        // claimant index computed above\n        return claimantTokens.mul(index.sub(ddxClaimantIndex)).div(1e36).safe96(\"IFund: exceeds 96 bits\");\n    }",
        "comments": [
            "/**",
            "     * @notice This function gets unclaimed DDX rewards for a claimant.",
            "     * @param _claimant Claimant address.",
            "     * @return Unclaimed DDX rewards.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function gets unclaimed DDX rewards for a claimant.\n     * @param _claimant Claimant address.\n     * @return Unclaimed DDX rewards.\n     */\n",
        "@notice": "This function gets unclaimed DDX rewards for a claimant.",
        "@param1": "_claimant Claimant address.",
        "@return1": "Unclaimed DDX rewards.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "claimDDXFromInsuranceMining",
        "visibility": "public",
        "args": [
            {
                "name": "_claimant",
                "type": "address"
            }
        ],
        "func": "function claimDDXFromInsuranceMining(address _claimant) public {\n        LibDiamondStorageInsuranceFund.DiamondStorageInsuranceFund storage dsInsuranceFund =\n            LibDiamondStorageInsuranceFund.diamondStorageInsuranceFund();\n\n        // Update the DDX Market State in order to determine the amount of\n        // rewards that should be paid to the claimant.\n        updateDDXMarketState(dsInsuranceFund);\n\n        // Obtain the most recent claimant index\n        uint256 ddxClaimantIndex = dsInsuranceFund.ddxClaimantState[_claimant].index;\n        dsInsuranceFund.ddxClaimantState[_claimant].index = dsInsuranceFund.ddxMarketState.index;\n\n        // If the claimant index is 0, i.e. it's the user's first time\n        // interacting with the protocol, initialize it to this starting\n        // value\n        if ((ddxClaimantIndex == 0) && (dsInsuranceFund.ddxMarketState.index > 0)) {\n            ddxClaimantIndex = 1e36;\n        }\n\n        // Compute the difference between the latest DDX market state\n        // index and the claimant's index\n        uint256 deltaIndex = uint256(dsInsuranceFund.ddxMarketState.index).sub(ddxClaimantIndex);\n\n        // Maintain a running total of USDT-normalized claimant tokens\n        // (i.e. 1e6 multiplier)\n        uint256 claimantTokens;\n\n        // Loop through each of the supported collateral types\n        for (uint256 i = 0; i < dsInsuranceFund.collateralNames.length; i++) {\n            // Obtain the collateral struct for the collateral type\n            // participant is staking\n            InsuranceFundDefs.StakeCollateral storage stakeCollateral =\n                dsInsuranceFund.stakeCollaterals[dsInsuranceFund.collateralNames[i]];\n\n            // Increment the USDT-normalized claimant tokens count with\n            // the current balance\n            claimantTokens = claimantTokens.add(\n                getNormalizedCollateralValue(\n                    dsInsuranceFund.collateralNames[i],\n                    stakeCollateral.diFundToken.balanceOf(_claimant).safe96(\"IFund: exceeds 96 bits\")\n                )\n            );\n        }\n\n        // Compute the claimed DDX based on the number of claimant\n        // tokens and the difference between the user's index and the\n        // claimant index computed above\n        uint96 claimantDelta = claimantTokens.mul(deltaIndex).div(1e36).safe96(\"IFund: exceeds 96 bits\");\n\n        if (claimantDelta != 0) {\n            // Adjust insurance mined amount\n            dsInsuranceFund.minedAmount = dsInsuranceFund.minedAmount.add96(claimantDelta);\n\n            // Increment the insurance mined claimed DDX for claimant\n            dsInsuranceFund.ddxClaimantState[_claimant].claimedDDX = dsInsuranceFund.ddxClaimantState[_claimant]\n                .claimedDDX\n                .add96(claimantDelta);\n\n            // Mint the DDX governance/operational token claimed reward\n            // from the proxy contract to the participant\n            LibTraderInternal.issueDDXReward(claimantDelta, _claimant);\n        }\n\n        // Check if COMP or aTokens have not already been claimed\n        if (dsInsuranceFund.stakerToOtherRewardsClaims[_claimant] < dsInsuranceFund.otherRewardsCheckpointBlock) {\n            // Record the current block number preventing a user from\n            // reclaiming the COMP reward unfairly\n            dsInsuranceFund.stakerToOtherRewardsClaims[_claimant] = block.number;\n\n            // Claim COMP and extra aTokens\n            claimOtherRewardsFromInsuranceMining(_claimant);\n        }\n\n        emit InsuranceMineRewardsClaimed(_claimant, claimantDelta);\n    }",
        "comments": [
            "/**",
            "     * @notice Calculate DDX accrued by a claimant and possibly transfer",
            "     *         it to them.",
            "     * @param _claimant The address of the claimant.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Calculate DDX accrued by a claimant and possibly transfer\n     *         it to them.\n     * @param _claimant The address of the claimant.\n     */\n",
        "@notice": "Calculate DDX accrued by a claimant and possibly transfer * it to them.",
        "@param1": "_claimant The address of the claimant.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getNormalizedCollateralValue",
        "visibility": "public",
        "args": [
            {
                "name": "_collateralName",
                "type": "bytes32"
            },
            {
                "name": "_value",
                "type": "uint96"
            }
        ],
        "func": "function getNormalizedCollateralValue(bytes32 _collateralName, uint96 _value) public view returns (uint96) {\n        LibDiamondStorageInsuranceFund.DiamondStorageInsuranceFund storage dsInsuranceFund =\n            LibDiamondStorageInsuranceFund.diamondStorageInsuranceFund();\n        InsuranceFundDefs.StakeCollateral storage stakeCollateral = dsInsuranceFund.stakeCollaterals[_collateralName];\n\n        return\n            (stakeCollateral.flavor != InsuranceFundDefs.Flavor.Compound)\n                ? getUnderlyingTokenAmountForVanilla(_value, stakeCollateral.collateralToken)\n                : getUnderlyingTokenAmountForCompound(\n                    _value,\n                    ICToken(stakeCollateral.collateralToken).exchangeRateStored()\n                );\n    }",
        "comments": [
            "/**",
            "     * @notice Get USDT-normalized collateral token amount.",
            "     * @param _collateralName The collateral name.",
            "     * @param _value The number of tokens.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Get USDT-normalized collateral token amount.\n     * @param _collateralName The collateral name.\n     * @param _value The number of tokens.\n     */\n",
        "@notice": "Get USDT-normalized collateral token amount.",
        "@param1": "_collateralName The collateral name.",
        "@param2": "_value The number of tokens.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentTotalStakes",
        "visibility": "public",
        "args": [
            {
                "name": "_staker",
                "type": "address"
            }
        ],
        "func": "function getCurrentTotalStakes(address _staker) public view returns (uint96, uint96) {\n        LibDiamondStorageInsuranceFund.DiamondStorageInsuranceFund storage dsInsuranceFund =\n            LibDiamondStorageInsuranceFund.diamondStorageInsuranceFund();\n\n        // Maintain running totals\n        uint96 normalizedStakerStakeSum;\n        uint96 normalizedGlobalCapSum;\n\n        // Loop through each supported collateral\n        for (uint256 i = 0; i < dsInsuranceFund.collateralNames.length; i++) {\n            (, , uint96 normalizedStakerStake, uint96 normalizedGlobalCap) =\n                getCurrentStakeByCollateralNameAndStaker(dsInsuranceFund.collateralNames[i], _staker);\n            normalizedStakerStakeSum = normalizedStakerStakeSum.add96(normalizedStakerStake);\n            normalizedGlobalCapSum = normalizedGlobalCapSum.add96(normalizedGlobalCap);\n        }\n\n        return (normalizedStakerStakeSum, normalizedGlobalCapSum);\n    }",
        "comments": [
            "/**",
            "     * @notice This function gets a participant's current",
            "     *         USD-normalized/denominated stake and global",
            "     *         USD-normalized/denominated stake across all supported",
            "     *         collateral types.",
            "     * @param _staker Participant's address.",
            "     * @return Current USD redemption value of DIFund tokens staked.",
            "     * @return Current USD global cap.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function gets a participant's current\n     *         USD-normalized/denominated stake and global\n     *         USD-normalized/denominated stake across all supported\n     *         collateral types.\n     * @param _staker Participant's address.\n     * @return Current USD redemption value of DIFund tokens staked.\n     * @return Current USD global cap.\n     */\n",
        "@notice": "This function gets a participant's current * USD-normalized/denominated stake and global * USD-normalized/denominated stake across all supported * collateral types.",
        "@param1": "_staker Participant's address.",
        "@return1": "Current USD redemption value of DIFund tokens staked.",
        "@return2": "Current USD global cap.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentStakeByCollateralNameAndStaker",
        "visibility": "public",
        "args": [
            {
                "name": "_collateralName",
                "type": "bytes32"
            },
            {
                "name": "_staker",
                "type": "address"
            }
        ],
        "func": "function getCurrentStakeByCollateralNameAndStaker(bytes32 _collateralName, address _staker)\n        public\n        view\n        returns (\n            uint96,\n            uint96,\n            uint96,\n            uint96\n        )\n    {\n        LibDiamondStorageInsuranceFund.DiamondStorageInsuranceFund storage dsInsuranceFund =\n            LibDiamondStorageInsuranceFund.diamondStorageInsuranceFund();\n        InsuranceFundDefs.StakeCollateral storage stakeCollateral = dsInsuranceFund.stakeCollaterals[_collateralName];\n\n        // Get DIFund tokens for staker\n        uint96 stakerStake = stakeCollateral.diFundToken.balanceOf(_staker).safe96(\"IFund: exceeds 96 bits.\");\n\n        // Get DIFund tokens globally\n        uint96 globalCap = stakeCollateral.diFundToken.totalSupply().safe96(\"IFund: exceeds 96 bits.\");\n\n        // Compute global USD-denominated stake capitalization. This is\n        // is straightforward for non-Compound assets, but requires\n        // exchange rate conversion for Compound assets.\n        uint96 normalizedGlobalCap =\n            (stakeCollateral.flavor != InsuranceFundDefs.Flavor.Compound)\n                ? getUnderlyingTokenAmountForVanilla(stakeCollateral.cap, stakeCollateral.collateralToken)\n                : getUnderlyingTokenAmountForCompound(\n                    stakeCollateral.cap,\n                    ICToken(stakeCollateral.collateralToken).exchangeRateStored()\n                );\n\n        // Compute the redemption value (USD-normalized) for staker\n        // given DIFund token holdings\n        uint96 normalizedStakerStake = globalCap > 0 ? normalizedGlobalCap.proportion96(stakerStake, globalCap) : 0;\n        return (stakerStake, globalCap, normalizedStakerStake, normalizedGlobalCap);\n    }",
        "comments": [
            "/**",
            "     * @notice This function gets a participant's current DIFund token",
            "     *         holdings and global DIFund token holdings for a",
            "     *         collateral type and staker, in addition to the",
            "     *         USD-normalized collateral in the system and the",
            "     *         redemption value for the staker.",
            "     * @param _collateralName Name of collateral.",
            "     * @param _staker Participant's address.",
            "     * @return DIFund tokens for staker.",
            "     * @return DIFund tokens globally.",
            "     * @return Redemption value for staker (USD-denominated).",
            "     * @return Underlying collateral (USD-denominated) in staking system.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function gets a participant's current DIFund token\n     *         holdings and global DIFund token holdings for a\n     *         collateral type and staker, in addition to the\n     *         USD-normalized collateral in the system and the\n     *         redemption value for the staker.\n     * @param _collateralName Name of collateral.\n     * @param _staker Participant's address.\n     * @return DIFund tokens for staker.\n     * @return DIFund tokens globally.\n     * @return Redemption value for staker (USD-denominated).\n     * @return Underlying collateral (USD-denominated) in staking system.\n     */\n",
        "@notice": "This function gets a participant's current DIFund token * holdings and global DIFund token holdings for a * collateral type and staker, in addition to the * USD-normalized collateral in the system and the * redemption value for the staker.",
        "@param1": "_collateralName Name of collateral.",
        "@param2": "_staker Participant's address.",
        "@return1": "DIFund tokens for staker.",
        "@return2": "DIFund tokens globally.",
        "@return3": "Redemption value for staker (USD-denominated).",
        "@return4": "Underlying collateral (USD-denominated) in staking system.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "getOtherRewardsStakeByCollateralNameAndStaker",
        "visibility": "public",
        "args": [
            {
                "name": "_collateralName",
                "type": "bytes32"
            },
            {
                "name": "_staker",
                "type": "address"
            }
        ],
        "func": "function getOtherRewardsStakeByCollateralNameAndStaker(bytes32 _collateralName, address _staker)\n        public\n        view\n        returns (\n            uint96,\n            uint96,\n            uint96,\n            uint96\n        )\n    {\n        LibDiamondStorageInsuranceFund.DiamondStorageInsuranceFund storage dsInsuranceFund =\n            LibDiamondStorageInsuranceFund.diamondStorageInsuranceFund();\n        InsuranceFundDefs.StakeCollateral storage stakeCollateral = dsInsuranceFund.stakeCollaterals[_collateralName];\n\n        // Get DIFund tokens for staker as of the checkpointed block\n        uint96 stakerStake =\n            stakeCollateral.diFundToken.getPriorValues(_staker, dsInsuranceFund.otherRewardsCheckpointBlock.sub(1));\n\n        // Get DIFund tokens globally as of the checkpointed block\n        uint96 globalCap =\n            stakeCollateral.diFundToken.getTotalPriorValues(dsInsuranceFund.otherRewardsCheckpointBlock.sub(1));\n\n        // If Aave, don't worry about the normalized values since 1-1\n        if (stakeCollateral.flavor == InsuranceFundDefs.Flavor.Aave) {\n            return (stakerStake, globalCap, 0, 0);\n        }\n\n        // Compute global USD-denominated stake capitalization. This is\n        // is straightforward for non-Compound assets, but requires\n        // exchange rate conversion for Compound assets.\n        uint96 normalizedGlobalCap =\n            getUnderlyingTokenAmountForCompound(stakeCollateral.checkpointCap, stakeCollateral.exchangeRate);\n\n        // Compute the redemption value (USD-normalized) for staker\n        // given DIFund token holdings\n        uint96 normalizedStakerStake = globalCap > 0 ? normalizedGlobalCap.proportion96(stakerStake, globalCap) : 0;\n        return (stakerStake, globalCap, normalizedStakerStake, normalizedGlobalCap);\n    }",
        "comments": [
            "/**",
            "     * @notice This function gets a participant's DIFund token",
            "     *         holdings and global DIFund token holdings for Compound",
            "     *         and Aave tokens for a collateral type and staker as of",
            "     *         the checkpointed block, in addition to the",
            "     *         USD-normalized collateral in the system and the",
            "     *         redemption value for the staker.",
            "     * @param _collateralName Name of collateral.",
            "     * @param _staker Participant's address.",
            "     * @return DIFund tokens for staker.",
            "     * @return DIFund tokens globally.",
            "     * @return Redemption value for staker (USD-denominated).",
            "     * @return Underlying collateral (USD-denominated) in staking system.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function gets a participant's DIFund token\n     *         holdings and global DIFund token holdings for Compound\n     *         and Aave tokens for a collateral type and staker as of\n     *         the checkpointed block, in addition to the\n     *         USD-normalized collateral in the system and the\n     *         redemption value for the staker.\n     * @param _collateralName Name of collateral.\n     * @param _staker Participant's address.\n     * @return DIFund tokens for staker.\n     * @return DIFund tokens globally.\n     * @return Redemption value for staker (USD-denominated).\n     * @return Underlying collateral (USD-denominated) in staking system.\n     */\n",
        "@notice": "This function gets a participant's DIFund token * holdings and global DIFund token holdings for Compound * and Aave tokens for a collateral type and staker as of * the checkpointed block, in addition to the * USD-normalized collateral in the system and the * redemption value for the staker.",
        "@param1": "_collateralName Name of collateral.",
        "@param2": "_staker Participant's address.",
        "@return1": "DIFund tokens for staker.",
        "@return2": "DIFund tokens globally.",
        "@return3": "Redemption value for staker (USD-denominated).",
        "@return4": "Underlying collateral (USD-denominated) in staking system.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "name",
        "visibility": "public",
        "args": [],
        "func": "function name() public view returns (string memory) {\n        return _name;\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the name of the token.",
            "     * @return Name of the token.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the name of the token.\n     * @return Name of the token.\n     */\n",
        "@notice": "Returns the name of the token.",
        "@return1": "Name of the token.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "symbol",
        "visibility": "public",
        "args": [],
        "func": "function symbol() public view returns (string memory) {\n        return _symbol;\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the symbol of the token.",
            "     * @return Symbol of the token.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the symbol of the token.\n     * @return Symbol of the token.\n     */\n",
        "@notice": "Returns the symbol of the token.",
        "@return1": "Symbol of the token.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decimals",
        "visibility": "public",
        "args": [],
        "func": "function decimals() public view returns (uint8) {\n        return _decimals;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the number of decimals used to get its user representation.",
            "     * For example, if `decimals` equals `2`, a balance of `505` tokens should",
            "     * be displayed to a user as `5,05` (`505 / 10 ** 2`).",
            "     *",
            "     * Tokens usually opt for a value of 18, imitating the relationship between",
            "     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is",
            "     * called.",
            "     *",
            "     * NOTE: This information is only used for _display_ purposes: it in",
            "     * no way affects any of the arithmetic of the contract, including",
            "     * {IERC20-balanceOf} and {IERC20-transfer}.",
            "     * @return Number of decimals.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     * @return Number of decimals.\n     */\n",
        "@dev": "Returns the number of decimals used to get its user representation. * For example, if `decimals` equals `2`, a balance of `505` tokens should * be displayed to a user as `5,05` (`505 / 10 ** 2`). * * Tokens usually opt for a value of 18, imitating the relationship between * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is * called. * * NOTE: This information is only used for _display_ purposes: it in * no way affects any of the arithmetic of the contract, including * {IERC20-balanceOf} and {IERC20-transfer}.",
        "@return1": "Number of decimals.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "external",
        "args": [
            {
                "name": "_spender",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function approve(address _spender, uint256 _amount) external returns (bool) {\n        require(_spender != address(0), \"DIFT: approve to the zero address.\");\n\n        // Convert amount to uint96\n        uint96 amount;\n        if (_amount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_amount, \"DIFT: amount exceeds 96 bits.\");\n        }\n\n        // Set allowance\n        allowances[msg.sender][_spender] = amount;\n\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @notice Approve `spender` to transfer up to `amount` from `src`",
            "     * @dev This will overwrite the approval amount for `spender`",
            "     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)",
            "     * @param _spender The address of the account which may transfer tokens",
            "     * @param _amount The number of tokens that are approved (2^256-1 means infinite)",
            "     * @return Whether or not the approval succeeded",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param _spender The address of the account which may transfer tokens\n     * @param _amount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n",
        "@notice": "Approve `spender` to transfer up to `amount` from `src`",
        "@dev": "This will overwrite the approval amount for `spender` * and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)",
        "@param1": "_spender The address of the account which may transfer tokens",
        "@param2": "_amount The number of tokens that are approved (2^256-1 means infinite)",
        "@return1": "Whether or not the approval succeeded",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "increaseAllowance",
        "visibility": "external",
        "args": [
            {
                "name": "_spender",
                "type": "address"
            },
            {
                "name": "_addedValue",
                "type": "uint256"
            }
        ],
        "func": "function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        require(_spender != address(0), \"DIFT: approve to the zero address.\");\n\n        // Convert amount to uint96\n        uint96 amount;\n        if (_addedValue == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_addedValue, \"DIFT: amount exceeds 96 bits.\");\n        }\n\n        // Increase allowance\n        allowances[msg.sender][_spender] = allowances[msg.sender][_spender].add96(amount);\n\n        emit Approval(msg.sender, _spender, allowances[msg.sender][_spender]);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Atomically increases the allowance granted to `spender` by the caller.",
            "     * This is an alternative to {approve} that can be used as a mitigation for",
            "     * problems described in {IERC20-approve}.",
            "     * Emits an {Approval} event indicating the updated allowance.",
            "     * Requirements:",
            "     * - `spender` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     * Emits an {Approval} event indicating the updated allowance.\n     * Requirements:\n     * - `spender` cannot be the zero address.\n     */\n",
        "@dev": "Atomically increases the allowance granted to `spender` by the caller. * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * Emits an {Approval} event indicating the updated allowance. * Requirements: * - `spender` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decreaseAllowance",
        "visibility": "external",
        "args": [
            {
                "name": "_spender",
                "type": "address"
            },
            {
                "name": "_subtractedValue",
                "type": "uint256"
            }
        ],
        "func": "function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        require(_spender != address(0), \"DIFT: approve to the zero address.\");\n\n        // Convert amount to uint96\n        uint96 amount;\n        if (_subtractedValue == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_subtractedValue, \"DIFT: amount exceeds 96 bits.\");\n        }\n\n        // Decrease allowance\n        allowances[msg.sender][_spender] = allowances[msg.sender][_spender].sub96(\n            amount,\n            \"DIFT: decreased allowance below zero.\"\n        );\n\n        emit Approval(msg.sender, _spender, allowances[msg.sender][_spender]);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Atomically decreases the allowance granted to `spender` by the caller.",
            "     * This is an alternative to {approve} that can be used as a mitigation for",
            "     * problems described in {IERC20-approve}.",
            "     * Emits an {Approval} event indicating the updated allowance.",
            "     * Requirements:",
            "     * - `spender` cannot be the zero address.",
            "     * - `spender` must have allowance for the caller of at least",
            "     * `subtractedValue`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     * Emits an {Approval} event indicating the updated allowance.\n     * Requirements:\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n",
        "@dev": "Atomically decreases the allowance granted to `spender` by the caller. * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * Emits an {Approval} event indicating the updated allowance. * Requirements: * - `spender` cannot be the zero address. * - `spender` must have allowance for the caller of at least * `subtractedValue`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "external",
        "args": [
            {
                "name": "_account",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address _account) external view returns (uint256) {\n        return balances[_account];\n    }",
        "comments": [
            "/**",
            "     * @notice Get the number of tokens held by the `account`",
            "     * @param _account The address of the account to get the balance of",
            "     * @return The number of tokens held",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Get the number of tokens held by the `account`\n     * @param _account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n",
        "@notice": "Get the number of tokens held by the `account`",
        "@param1": "_account The address of the account to get the balance of",
        "@return1": "The number of tokens held",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "external",
        "args": [
            {
                "name": "_recipient",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        // Convert amount to uint96\n        uint96 amount;\n        if (_amount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_amount, \"DIFT: amount exceeds 96 bits.\");\n        }\n\n        // Claim DDX rewards on behalf of the sender\n        IInsuranceFund(issuer).claimDDXFromInsuranceMining(msg.sender);\n\n        // Claim DDX rewards on behalf of the recipient\n        IInsuranceFund(issuer).claimDDXFromInsuranceMining(_recipient);\n\n        // Transfer tokens from sender to recipient\n        _transferTokens(msg.sender, _recipient, amount);\n\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @notice Transfer `amount` tokens from `msg.sender` to `dst`",
            "     * @param _recipient The address of the destination account",
            "     * @param _amount The number of tokens to transfer",
            "     * @return Whether or not the transfer succeeded",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param _recipient The address of the destination account\n     * @param _amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n",
        "@notice": "Transfer `amount` tokens from `msg.sender` to `dst`",
        "@param1": "_recipient The address of the destination account",
        "@param2": "_amount The number of tokens to transfer",
        "@return1": "Whether or not the transfer succeeded",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "external",
        "args": [
            {
                "name": "_sender",
                "type": "address"
            },
            {
                "name": "_recipient",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) external returns (bool) {\n        uint96 spenderAllowance = allowances[_sender][msg.sender];\n\n        // Convert amount to uint96\n        uint96 amount;\n        if (_amount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_amount, \"DIFT: amount exceeds 96 bits.\");\n        }\n\n        if (msg.sender != _sender && spenderAllowance != uint96(-1)) {\n            // Tx sender is not the same as transfer sender and doesn't\n            // have unlimited allowance.\n            // Reduce allowance by amount being transferred\n            uint96 newAllowance = spenderAllowance.sub96(amount);\n            allowances[_sender][msg.sender] = newAllowance;\n\n            emit Approval(_sender, msg.sender, newAllowance);\n        }\n\n        // Claim DDX rewards on behalf of the sender\n        IInsuranceFund(issuer).claimDDXFromInsuranceMining(_sender);\n\n        // Claim DDX rewards on behalf of the recipient\n        IInsuranceFund(issuer).claimDDXFromInsuranceMining(_recipient);\n\n        // Transfer tokens from sender to recipient\n        _transferTokens(_sender, _recipient, amount);\n\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @notice Transfer `amount` tokens from `src` to `dst`",
            "     * @param _sender The address of the source account",
            "     * @param _recipient The address of the destination account",
            "     * @param _amount The number of tokens to transfer",
            "     * @return Whether or not the transfer succeeded",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param _sender The address of the source account\n     * @param _recipient The address of the destination account\n     * @param _amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n",
        "@notice": "Transfer `amount` tokens from `src` to `dst`",
        "@param1": "_sender The address of the source account",
        "@param2": "_recipient The address of the destination account",
        "@param3": "_amount The number of tokens to transfer",
        "@return1": "Whether or not the transfer succeeded",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "external",
        "args": [
            {
                "name": "_recipient",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function mint(address _recipient, uint256 _amount) external {\n        require(msg.sender == issuer, \"DIFT: unauthorized mint.\");\n\n        // Convert amount to uint96\n        uint96 amount;\n        if (_amount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_amount, \"DIFT: amount exceeds 96 bits.\");\n        }\n\n        // Mint tokens to recipient\n        _transferTokensMint(_recipient, amount);\n    }",
        "comments": [
            "/**",
            "     * @dev Creates `amount` tokens and assigns them to `account`, increasing",
            "     *      the total supply.",
            "     *",
            "     * Emits a {Transfer} event with `from` set to the zero address.",
            "     *",
            "     * Requirements",
            "     *",
            "     * - `to` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     *      the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n",
        "@dev": "Creates `amount` tokens and assigns them to `account`, increasing * the total supply. * * Emits a {Transfer} event with `from` set to the zero address. * * Requirements * * - `to` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "external",
        "args": [
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function burn(uint256 _amount) external {\n        // Convert amount to uint96\n        uint96 amount;\n        if (_amount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_amount, \"DIFT: amount exceeds 96 bits.\");\n        }\n\n        // Burn tokens from sender\n        _transferTokensBurn(msg.sender, amount);\n    }",
        "comments": [
            "/**",
            "     * @dev Creates `amount` tokens and assigns them to `account`, decreasing",
            "     *      the total supply.",
            "     *",
            "     * Emits a {Transfer} event with `from` set to the zero address.",
            "     *",
            "     * Requirements",
            "     *",
            "     * - `to` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Creates `amount` tokens and assigns them to `account`, decreasing\n     *      the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n",
        "@dev": "Creates `amount` tokens and assigns them to `account`, decreasing * the total supply. * * Emits a {Transfer} event with `from` set to the zero address. * * Requirements * * - `to` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burnFrom",
        "visibility": "external",
        "args": [
            {
                "name": "_account",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function burnFrom(address _account, uint256 _amount) external {\n        uint96 spenderAllowance = allowances[_account][msg.sender];\n\n        // Convert amount to uint96\n        uint96 amount;\n        if (_amount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_amount, \"DIFT: amount exceeds 96 bits.\");\n        }\n\n        if (msg.sender != _account && spenderAllowance != uint96(-1) && msg.sender != issuer) {\n            // Tx sender is not the same as burn account and doesn't\n            // have unlimited allowance.\n            // Reduce allowance by amount being transferred\n            uint96 newAllowance = spenderAllowance.sub96(amount, \"DIFT: burn amount exceeds allowance.\");\n            allowances[_account][msg.sender] = newAllowance;\n\n            emit Approval(_account, msg.sender, newAllowance);\n        }\n\n        // Burn tokens from account\n        _transferTokensBurn(_account, amount);\n    }",
        "comments": [
            "/**",
            "     * @dev Creates `amount` tokens and assigns them to `account`, increasing",
            "     *      the total supply.",
            "     *",
            "     * Emits a {Transfer} event with `from` set to the zero address.",
            "     *",
            "     * Requirements",
            "     *",
            "     * - `to` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     *      the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n",
        "@dev": "Creates `amount` tokens and assigns them to `account`, increasing * the total supply. * * Emits a {Transfer} event with `from` set to the zero address. * * Requirements * * - `to` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "permit",
        "visibility": "external",
        "args": [
            {
                "name": "_spender",
                "type": "address"
            },
            {
                "name": "_value",
                "type": "uint256"
            },
            {
                "name": "_nonce",
                "type": "uint256"
            },
            {
                "name": "_expiry",
                "type": "uint256"
            },
            {
                "name": "_signature",
                "type": "bytes memory"
            }
        ],
        "func": "function permit(\n        address _spender,\n        uint256 _value,\n        uint256 _nonce,\n        uint256 _expiry,\n        bytes memory _signature\n    ) external {\n        // Perform EIP712 hashing logic\n        bytes32 eip712OrderParamsDomainHash = LibEIP712.hashEIP712Domain(_name, _version, getChainId(), address(this));\n        bytes32 permitHash =\n            LibPermit.getPermitHash(\n                LibPermit.Permit({ spender: _spender, value: _value, nonce: _nonce, expiry: _expiry }),\n                eip712OrderParamsDomainHash\n            );\n\n        // Perform sig recovery\n        uint8 v = uint8(_signature[0]);\n        bytes32 r = _signature.readBytes32(1);\n        bytes32 s = _signature.readBytes32(33);\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n\n        if (v != 27 && v != 28) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n\n        address recovered = ecrecover(permitHash, v, r, s);\n\n        require(recovered != address(0), \"DIFT: invalid signature.\");\n        require(_nonce == nonces[recovered]++, \"DIFT: invalid nonce.\");\n        require(block.timestamp <= _expiry, \"DIFT: signature expired.\");\n\n        // Convert amount to uint96\n        uint96 amount;\n        if (_value == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_value, \"DIFT: amount exceeds 96 bits.\");\n        }\n\n        // Set allowance\n        allowances[recovered][_spender] = amount;\n        emit Approval(recovered, _spender, _value);\n    }",
        "comments": [
            "/**",
            "     * @notice Permits allowance from signatory to `spender`",
            "     * @param _spender The spender being approved",
            "     * @param _value The value being approved",
            "     * @param _nonce The contract state required to match the signature",
            "     * @param _expiry The time at which to expire the signature",
            "     * @param _signature Signature",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Permits allowance from signatory to `spender`\n     * @param _spender The spender being approved\n     * @param _value The value being approved\n     * @param _nonce The contract state required to match the signature\n     * @param _expiry The time at which to expire the signature\n     * @param _signature Signature\n     */\n",
        "@notice": "Permits allowance from signatory to `spender`",
        "@param1": "_spender The spender being approved",
        "@param2": "_value The value being approved",
        "@param3": "_nonce The contract state required to match the signature",
        "@param4": "_expiry The time at which to expire the signature",
        "@param5": "_signature Signature",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allowance",
        "visibility": "external",
        "args": [
            {
                "name": "_account",
                "type": "address"
            },
            {
                "name": "_spender",
                "type": "address"
            }
        ],
        "func": "function allowance(address _account, address _spender) external view returns (uint256) {\n        return allowances[_account][_spender];\n    }",
        "comments": [
            "/**",
            "     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`",
            "     * @param _account The address of the account holding the funds",
            "     * @param _spender The address of the account spending the funds",
            "     * @return The number of tokens approved",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param _account The address of the account holding the funds\n     * @param _spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n",
        "@notice": "Get the number of tokens `spender` is approved to spend on behalf of `account`",
        "@param1": "_account The address of the account holding the funds",
        "@param2": "_spender The address of the account spending the funds",
        "@return1": "The number of tokens approved",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "external",
        "args": [],
        "func": "function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }",
        "comments": [
            "/**",
            "     * @notice Get the total max supply of DDX tokens",
            "     * @return The total max supply of DDX",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Get the total max supply of DDX tokens\n     * @return The total max supply of DDX\n     */\n",
        "@notice": "Get the total max supply of DDX tokens",
        "@return1": "The total max supply of DDX",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPriorValues",
        "visibility": "external",
        "args": [
            {
                "name": "_account",
                "type": "address"
            },
            {
                "name": "_blockNumber",
                "type": "uint256"
            }
        ],
        "func": "function getPriorValues(address _account, uint256 _blockNumber) external view returns (uint96) {\n        require(_blockNumber < block.number, \"DIFT: block not yet determined.\");\n\n        uint256 numCheckpointsAccount = numCheckpoints[_account];\n        if (numCheckpointsAccount == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[_account][numCheckpointsAccount - 1].id <= _blockNumber) {\n            return checkpoints[_account][numCheckpointsAccount - 1].values;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[_account][0].id > _blockNumber) {\n            return 0;\n        }\n\n        // Perform binary search to find the most recent token holdings\n        uint256 lower = 0;\n        uint256 upper = numCheckpointsAccount - 1;\n        while (upper > lower) {\n            // ceil, avoiding overflow\n            uint256 center = upper - (upper - lower) / 2;\n            Checkpoint memory cp = checkpoints[_account][center];\n            if (cp.id == _blockNumber) {\n                return cp.values;\n            } else if (cp.id < _blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[_account][lower].values;\n    }",
        "comments": [
            "/**",
            "     * @notice Determine the prior number of values for an account as of a block number",
            "     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.",
            "     * @param _account The address of the account to check",
            "     * @param _blockNumber The block number to get the vote balance at",
            "     * @return The number of values the account had as of the given block",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Determine the prior number of values for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param _account The address of the account to check\n     * @param _blockNumber The block number to get the vote balance at\n     * @return The number of values the account had as of the given block\n     */\n",
        "@notice": "Determine the prior number of values for an account as of a block number",
        "@dev": "Block number must be a finalized block or else this function will revert to prevent misinformation.",
        "@param1": "_account The address of the account to check",
        "@param2": "_blockNumber The block number to get the vote balance at",
        "@return1": "The number of values the account had as of the given block",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getTotalPriorValues",
        "visibility": "external",
        "args": [
            {
                "name": "_blockNumber",
                "type": "uint256"
            }
        ],
        "func": "function getTotalPriorValues(uint256 _blockNumber) external view returns (uint96) {\n        require(_blockNumber < block.number, \"DIFT: block not yet determined.\");\n\n        if (numTotalCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (totalCheckpoints[numTotalCheckpoints - 1].id <= _blockNumber) {\n            return totalCheckpoints[numTotalCheckpoints - 1].values;\n        }\n\n        // Next check implicit zero balance\n        if (totalCheckpoints[0].id > _blockNumber) {\n            return 0;\n        }\n\n        // Perform binary search to find the most recent token holdings\n        // leading to a measure of voting power\n        uint256 lower = 0;\n        uint256 upper = numTotalCheckpoints - 1;\n        while (upper > lower) {\n            // ceil, avoiding overflow\n            uint256 center = upper - (upper - lower) / 2;\n            Checkpoint memory cp = totalCheckpoints[center];\n            if (cp.id == _blockNumber) {\n                return cp.values;\n            } else if (cp.id < _blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return totalCheckpoints[lower].values;\n    }",
        "comments": [
            "/**",
            "     * @notice Determine the prior number of values for an account as of a block number",
            "     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.",
            "     * @param _blockNumber The block number to get the vote balance at",
            "     * @return The number of values the account had as of the given block",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Determine the prior number of values for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param _blockNumber The block number to get the vote balance at\n     * @return The number of values the account had as of the given block\n     */\n",
        "@notice": "Determine the prior number of values for an account as of a block number",
        "@dev": "Block number must be a finalized block or else this function will revert to prevent misinformation.",
        "@param1": "_blockNumber The block number to get the vote balance at",
        "@return1": "The number of values the account had as of the given block",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createNewDIFundToken",
        "visibility": "external",
        "args": [
            {
                "name": "_name",
                "type": "string calldata"
            },
            {
                "name": "_symbol",
                "type": "string calldata"
            },
            {
                "name": "_decimals",
                "type": "uint8"
            }
        ],
        "func": "function createNewDIFundToken(\n        string calldata _name,\n        string calldata _symbol,\n        uint8 _decimals\n    ) external returns (address) {\n        require(msg.sender == issuer, \"DIFTF: unauthorized.\");\n        DIFundToken diFundToken = new DIFundToken(_name, _symbol, _decimals, issuer);\n        diFundTokens.push(diFundToken);\n        return address(diFundToken);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getDIFundTokens",
        "visibility": "external",
        "args": [],
        "func": "function getDIFundTokens() external view returns (DIFundToken[] memory) {\n        return diFundTokens;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getDIFundTokensLength",
        "visibility": "external",
        "args": [],
        "func": "function getDIFundTokensLength() external view returns (uint256) {\n        return diFundTokens.length;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferOwnershipToDerivaDEXProxy",
        "visibility": "external",
        "args": [
            {
                "name": "_derivaDEXProxy",
                "type": "address"
            }
        ],
        "func": "function transferOwnershipToDerivaDEXProxy(address _derivaDEXProxy) external {\n        // Ensure deploying address is calling this, destination is not\n        // the zero address, and that ownership has never been\n        // transferred thus far\n        require(msg.sender == issuer, \"DDX: unauthorized transfer of ownership.\");\n        require(_derivaDEXProxy != address(0), \"DDX: transferring to zero address.\");\n        require(!ownershipTransferred, \"DDX: ownership already transferred.\");\n\n        // Set ownership transferred boolean flag and the new authorized\n        // issuer\n        ownershipTransferred = true;\n        issuer = _derivaDEXProxy;\n    }",
        "comments": [
            "/**",
            "     * @notice Transfer ownership of DDX token from the deploying",
            "     *         address to the DerivaDEX Proxy/DAO",
            "     * @param _derivaDEXProxy DerivaDEX Proxy address",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfer ownership of DDX token from the deploying\n     *         address to the DerivaDEX Proxy/DAO\n     * @param _derivaDEXProxy DerivaDEX Proxy address\n     */\n",
        "@notice": "Transfer ownership of DDX token from the deploying * address to the DerivaDEX Proxy/DAO",
        "@param1": "_derivaDEXProxy DerivaDEX Proxy address",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "external",
        "args": [
            {
                "name": "_spender",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function approve(address _spender, uint256 _amount) external returns (bool) {\n        require(_spender != address(0), \"DDX: approve to the zero address.\");\n\n        // Convert amount to uint96\n        uint96 amount;\n        if (_amount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_amount, \"DDX: amount exceeds 96 bits.\");\n        }\n\n        // Set allowance\n        allowances[msg.sender][_spender] = amount;\n\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @notice Approve `spender` to transfer up to `amount` from `src`",
            "     * @dev This will overwrite the approval amount for `spender`",
            "     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)",
            "     * @param _spender The address of the account which may transfer tokens",
            "     * @param _amount The number of tokens that are approved (2^256-1 means infinite)",
            "     * @return Whether or not the approval succeeded",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param _spender The address of the account which may transfer tokens\n     * @param _amount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n",
        "@notice": "Approve `spender` to transfer up to `amount` from `src`",
        "@dev": "This will overwrite the approval amount for `spender` * and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)",
        "@param1": "_spender The address of the account which may transfer tokens",
        "@param2": "_amount The number of tokens that are approved (2^256-1 means infinite)",
        "@return1": "Whether or not the approval succeeded",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "increaseAllowance",
        "visibility": "external",
        "args": [
            {
                "name": "_spender",
                "type": "address"
            },
            {
                "name": "_addedValue",
                "type": "uint256"
            }
        ],
        "func": "function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        require(_spender != address(0), \"DDX: approve to the zero address.\");\n\n        // Convert amount to uint96\n        uint96 amount;\n        if (_addedValue == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_addedValue, \"DDX: amount exceeds 96 bits.\");\n        }\n\n        // Increase allowance\n        allowances[msg.sender][_spender] = allowances[msg.sender][_spender].add96(amount);\n\n        emit Approval(msg.sender, _spender, allowances[msg.sender][_spender]);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Atomically increases the allowance granted to `spender` by the caller.",
            "     * This is an alternative to {approve} that can be used as a mitigation for",
            "     * problems described in {IERC20-approve}.",
            "     * Emits an {Approval} event indicating the updated allowance.",
            "     * Requirements:",
            "     * - `spender` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     * Emits an {Approval} event indicating the updated allowance.\n     * Requirements:\n     * - `spender` cannot be the zero address.\n     */\n",
        "@dev": "Atomically increases the allowance granted to `spender` by the caller. * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * Emits an {Approval} event indicating the updated allowance. * Requirements: * - `spender` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decreaseAllowance",
        "visibility": "external",
        "args": [
            {
                "name": "_spender",
                "type": "address"
            },
            {
                "name": "_subtractedValue",
                "type": "uint256"
            }
        ],
        "func": "function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        require(_spender != address(0), \"DDX: approve to the zero address.\");\n\n        // Convert amount to uint96\n        uint96 amount;\n        if (_subtractedValue == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_subtractedValue, \"DDX: amount exceeds 96 bits.\");\n        }\n\n        // Decrease allowance\n        allowances[msg.sender][_spender] = allowances[msg.sender][_spender].sub96(\n            amount,\n            \"DDX: decreased allowance below zero.\"\n        );\n\n        emit Approval(msg.sender, _spender, allowances[msg.sender][_spender]);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Atomically decreases the allowance granted to `spender` by the caller.",
            "     * This is an alternative to {approve} that can be used as a mitigation for",
            "     * problems described in {IERC20-approve}.",
            "     * Emits an {Approval} event indicating the updated allowance.",
            "     * Requirements:",
            "     * - `spender` cannot be the zero address.",
            "     * - `spender` must have allowance for the caller of at least",
            "     * `subtractedValue`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     * Emits an {Approval} event indicating the updated allowance.\n     * Requirements:\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n",
        "@dev": "Atomically decreases the allowance granted to `spender` by the caller. * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * Emits an {Approval} event indicating the updated allowance. * Requirements: * - `spender` cannot be the zero address. * - `spender` must have allowance for the caller of at least * `subtractedValue`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "external",
        "args": [
            {
                "name": "_account",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address _account) external view returns (uint256) {\n        return balances[_account];\n    }",
        "comments": [
            "/**",
            "     * @notice Get the number of tokens held by the `account`",
            "     * @param _account The address of the account to get the balance of",
            "     * @return The number of tokens held",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Get the number of tokens held by the `account`\n     * @param _account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n",
        "@notice": "Get the number of tokens held by the `account`",
        "@param1": "_account The address of the account to get the balance of",
        "@return1": "The number of tokens held",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "external",
        "args": [
            {
                "name": "_recipient",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        // Convert amount to uint96\n        uint96 amount;\n        if (_amount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_amount, \"DDX: amount exceeds 96 bits.\");\n        }\n\n        // Transfer tokens from sender to recipient\n        _transferTokens(msg.sender, _recipient, amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @notice Transfer `amount` tokens from `msg.sender` to `dst`",
            "     * @param _recipient The address of the destination account",
            "     * @param _amount The number of tokens to transfer",
            "     * @return Whether or not the transfer succeeded",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param _recipient The address of the destination account\n     * @param _amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n",
        "@notice": "Transfer `amount` tokens from `msg.sender` to `dst`",
        "@param1": "_recipient The address of the destination account",
        "@param2": "_amount The number of tokens to transfer",
        "@return1": "Whether or not the transfer succeeded",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "external",
        "args": [
            {
                "name": "_from",
                "type": "address"
            },
            {
                "name": "_recipient",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(\n        address _from,\n        address _recipient,\n        uint256 _amount\n    ) external returns (bool) {\n        uint96 spenderAllowance = allowances[_from][msg.sender];\n\n        // Convert amount to uint96\n        uint96 amount;\n        if (_amount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_amount, \"DDX: amount exceeds 96 bits.\");\n        }\n\n        if (msg.sender != _from && spenderAllowance != uint96(-1)) {\n            // Tx sender is not the same as transfer sender and doesn't\n            // have unlimited allowance.\n            // Reduce allowance by amount being transferred\n            uint96 newAllowance = spenderAllowance.sub96(amount);\n            allowances[_from][msg.sender] = newAllowance;\n\n            emit Approval(_from, msg.sender, newAllowance);\n        }\n\n        // Transfer tokens from sender to recipient\n        _transferTokens(_from, _recipient, amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @notice Transfer `amount` tokens from `src` to `dst`",
            "     * @param _from The address of the source account",
            "     * @param _recipient The address of the destination account",
            "     * @param _amount The number of tokens to transfer",
            "     * @return Whether or not the transfer succeeded",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param _from The address of the source account\n     * @param _recipient The address of the destination account\n     * @param _amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n",
        "@notice": "Transfer `amount` tokens from `src` to `dst`",
        "@param1": "_from The address of the source account",
        "@param2": "_recipient The address of the destination account",
        "@param3": "_amount The number of tokens to transfer",
        "@return1": "Whether or not the transfer succeeded",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "external",
        "args": [
            {
                "name": "_recipient",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function mint(address _recipient, uint256 _amount) external {\n        require(msg.sender == issuer, \"DDX: unauthorized mint.\");\n\n        // Convert amount to uint96\n        uint96 amount;\n        if (_amount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_amount, \"DDX: amount exceeds 96 bits.\");\n        }\n\n        // Ensure the mint doesn't cause the issued supply to exceed\n        // the total supply that could ever be issued\n        require(issuedSupply.add96(amount) <= MAX_SUPPLY, \"DDX: cap exceeded.\");\n\n        // Mint tokens to recipient\n        _transferTokensMint(_recipient, amount);\n    }",
        "comments": [
            "/**",
            "     * @dev Creates `amount` tokens and assigns them to `account`, increasing",
            "     *      the total supply.",
            "     *",
            "     * Emits a {Transfer} event with `from` set to the zero address.",
            "     *",
            "     * Requirements",
            "     *",
            "     * - `to` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     *      the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n",
        "@dev": "Creates `amount` tokens and assigns them to `account`, increasing * the total supply. * * Emits a {Transfer} event with `from` set to the zero address. * * Requirements * * - `to` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "external",
        "args": [
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function burn(uint256 _amount) external {\n        // Convert amount to uint96\n        uint96 amount;\n        if (_amount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_amount, \"DDX: amount exceeds 96 bits.\");\n        }\n\n        // Burn tokens from sender\n        _transferTokensBurn(msg.sender, amount);\n    }",
        "comments": [
            "/**",
            "     * @dev Creates `amount` tokens and assigns them to `account`, decreasing",
            "     *      the total supply.",
            "     *",
            "     * Emits a {Transfer} event with `from` set to the zero address.",
            "     *",
            "     * Requirements",
            "     *",
            "     * - `to` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Creates `amount` tokens and assigns them to `account`, decreasing\n     *      the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n",
        "@dev": "Creates `amount` tokens and assigns them to `account`, decreasing * the total supply. * * Emits a {Transfer} event with `from` set to the zero address. * * Requirements * * - `to` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burnFrom",
        "visibility": "external",
        "args": [
            {
                "name": "_account",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function burnFrom(address _account, uint256 _amount) external {\n        uint96 spenderAllowance = allowances[_account][msg.sender];\n\n        // Convert amount to uint96\n        uint96 amount;\n        if (_amount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_amount, \"DDX: amount exceeds 96 bits.\");\n        }\n\n        if (msg.sender != _account && spenderAllowance != uint96(-1)) {\n            // Tx sender is not the same as burn account and doesn't\n            // have unlimited allowance.\n            // Reduce allowance by amount being transferred\n            uint96 newAllowance = spenderAllowance.sub96(amount, \"DDX: burn amount exceeds allowance.\");\n            allowances[_account][msg.sender] = newAllowance;\n\n            emit Approval(_account, msg.sender, newAllowance);\n        }\n\n        // Burn tokens from account\n        _transferTokensBurn(_account, amount);\n    }",
        "comments": [
            "/**",
            "     * @dev Creates `amount` tokens and assigns them to `account`, increasing",
            "     *      the total supply.",
            "     *",
            "     * Emits a {Transfer} event with `from` set to the zero address.",
            "     *",
            "     * Requirements",
            "     *",
            "     * - `to` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     *      the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n",
        "@dev": "Creates `amount` tokens and assigns them to `account`, increasing * the total supply. * * Emits a {Transfer} event with `from` set to the zero address. * * Requirements * * - `to` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "delegate",
        "visibility": "external",
        "args": [
            {
                "name": "_delegatee",
                "type": "address"
            }
        ],
        "func": "function delegate(address _delegatee) external {\n        _delegate(msg.sender, _delegatee);\n    }",
        "comments": [
            "/**",
            "     * @notice Delegate votes from `msg.sender` to `delegatee`",
            "     * @param _delegatee The address to delegate votes to",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param _delegatee The address to delegate votes to\n     */\n",
        "@notice": "Delegate votes from `msg.sender` to `delegatee`",
        "@param1": "_delegatee The address to delegate votes to",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "delegateBySig",
        "visibility": "external",
        "args": [
            {
                "name": "_delegatee",
                "type": "address"
            },
            {
                "name": "_nonce",
                "type": "uint256"
            },
            {
                "name": "_expiry",
                "type": "uint256"
            },
            {
                "name": "_signature",
                "type": "bytes memory"
            }
        ],
        "func": "function delegateBySig(\n        address _delegatee,\n        uint256 _nonce,\n        uint256 _expiry,\n        bytes memory _signature\n    ) external {\n        // Perform EIP712 hashing logic\n        bytes32 eip712OrderParamsDomainHash = LibEIP712.hashEIP712Domain(name, version, getChainId(), address(this));\n        bytes32 delegationHash =\n            LibDelegation.getDelegationHash(\n                LibDelegation.Delegation({ delegatee: _delegatee, nonce: _nonce, expiry: _expiry }),\n                eip712OrderParamsDomainHash\n            );\n\n        // Perform sig recovery\n        uint8 v = uint8(_signature[0]);\n        bytes32 r = _signature.readBytes32(1);\n        bytes32 s = _signature.readBytes32(33);\n        address recovered = ecrecover(delegationHash, v, r, s);\n\n        require(recovered != address(0), \"DDX: invalid signature.\");\n        require(_nonce == nonces[recovered]++, \"DDX: invalid nonce.\");\n        require(block.timestamp <= _expiry, \"DDX: signature expired.\");\n\n        // Delegate votes from recovered address to delegatee\n        _delegate(recovered, _delegatee);\n    }",
        "comments": [
            "/**",
            "     * @notice Delegates votes from signatory to `delegatee`",
            "     * @param _delegatee The address to delegate votes to",
            "     * @param _nonce The contract state required to match the signature",
            "     * @param _expiry The time at which to expire the signature",
            "     * @param _signature Signature",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param _delegatee The address to delegate votes to\n     * @param _nonce The contract state required to match the signature\n     * @param _expiry The time at which to expire the signature\n     * @param _signature Signature\n     */\n",
        "@notice": "Delegates votes from signatory to `delegatee`",
        "@param1": "_delegatee The address to delegate votes to",
        "@param2": "_nonce The contract state required to match the signature",
        "@param3": "_expiry The time at which to expire the signature",
        "@param4": "_signature Signature",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "permit",
        "visibility": "external",
        "args": [
            {
                "name": "_spender",
                "type": "address"
            },
            {
                "name": "_value",
                "type": "uint256"
            },
            {
                "name": "_nonce",
                "type": "uint256"
            },
            {
                "name": "_expiry",
                "type": "uint256"
            },
            {
                "name": "_signature",
                "type": "bytes memory"
            }
        ],
        "func": "function permit(\n        address _spender,\n        uint256 _value,\n        uint256 _nonce,\n        uint256 _expiry,\n        bytes memory _signature\n    ) external {\n        // Perform EIP712 hashing logic\n        bytes32 eip712OrderParamsDomainHash = LibEIP712.hashEIP712Domain(name, version, getChainId(), address(this));\n        bytes32 permitHash =\n            LibPermit.getPermitHash(\n                LibPermit.Permit({ spender: _spender, value: _value, nonce: _nonce, expiry: _expiry }),\n                eip712OrderParamsDomainHash\n            );\n\n        // Perform sig recovery\n        uint8 v = uint8(_signature[0]);\n        bytes32 r = _signature.readBytes32(1);\n        bytes32 s = _signature.readBytes32(33);\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n\n        if (v != 27 && v != 28) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n\n        address recovered = ecrecover(permitHash, v, r, s);\n\n        require(recovered != address(0), \"DDX: invalid signature.\");\n        require(_nonce == nonces[recovered]++, \"DDX: invalid nonce.\");\n        require(block.timestamp <= _expiry, \"DDX: signature expired.\");\n\n        // Convert amount to uint96\n        uint96 amount;\n        if (_value == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_value, \"DDX: amount exceeds 96 bits.\");\n        }\n\n        // Set allowance\n        allowances[recovered][_spender] = amount;\n        emit Approval(recovered, _spender, _value);\n    }",
        "comments": [
            "/**",
            "     * @notice Permits allowance from signatory to `spender`",
            "     * @param _spender The spender being approved",
            "     * @param _value The value being approved",
            "     * @param _nonce The contract state required to match the signature",
            "     * @param _expiry The time at which to expire the signature",
            "     * @param _signature Signature",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Permits allowance from signatory to `spender`\n     * @param _spender The spender being approved\n     * @param _value The value being approved\n     * @param _nonce The contract state required to match the signature\n     * @param _expiry The time at which to expire the signature\n     * @param _signature Signature\n     */\n",
        "@notice": "Permits allowance from signatory to `spender`",
        "@param1": "_spender The spender being approved",
        "@param2": "_value The value being approved",
        "@param3": "_nonce The contract state required to match the signature",
        "@param4": "_expiry The time at which to expire the signature",
        "@param5": "_signature Signature",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allowance",
        "visibility": "external",
        "args": [
            {
                "name": "_account",
                "type": "address"
            },
            {
                "name": "_spender",
                "type": "address"
            }
        ],
        "func": "function allowance(address _account, address _spender) external view returns (uint256) {\n        return allowances[_account][_spender];\n    }",
        "comments": [
            "/**",
            "     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`",
            "     * @param _account The address of the account holding the funds",
            "     * @param _spender The address of the account spending the funds",
            "     * @return The number of tokens approved",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param _account The address of the account holding the funds\n     * @param _spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n",
        "@notice": "Get the number of tokens `spender` is approved to spend on behalf of `account`",
        "@param1": "_account The address of the account holding the funds",
        "@param2": "_spender The address of the account spending the funds",
        "@return1": "The number of tokens approved",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentVotes",
        "visibility": "external",
        "args": [
            {
                "name": "_account",
                "type": "address"
            }
        ],
        "func": "function getCurrentVotes(address _account) external view returns (uint96) {\n        uint256 numCheckpointsAccount = numCheckpoints[_account];\n        return numCheckpointsAccount > 0 ? checkpoints[_account][numCheckpointsAccount - 1].votes : 0;\n    }",
        "comments": [
            "/**",
            "     * @notice Gets the current votes balance.",
            "     * @param _account The address to get votes balance.",
            "     * @return The number of current votes.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets the current votes balance.\n     * @param _account The address to get votes balance.\n     * @return The number of current votes.\n     */\n",
        "@notice": "Gets the current votes balance.",
        "@param1": "_account The address to get votes balance.",
        "@return1": "The number of current votes.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPriorVotes",
        "visibility": "external",
        "args": [
            {
                "name": "_account",
                "type": "address"
            },
            {
                "name": "_blockNumber",
                "type": "uint256"
            }
        ],
        "func": "function getPriorVotes(address _account, uint256 _blockNumber) external view returns (uint96) {\n        require(_blockNumber < block.number, \"DDX: block not yet determined.\");\n\n        uint256 numCheckpointsAccount = numCheckpoints[_account];\n        if (numCheckpointsAccount == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[_account][numCheckpointsAccount - 1].id <= _blockNumber) {\n            return checkpoints[_account][numCheckpointsAccount - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[_account][0].id > _blockNumber) {\n            return 0;\n        }\n\n        // Perform binary search to find the most recent token holdings\n        // leading to a measure of voting power\n        uint256 lower = 0;\n        uint256 upper = numCheckpointsAccount - 1;\n        while (upper > lower) {\n            // ceil, avoiding overflow\n            uint256 center = upper - (upper - lower) / 2;\n            Checkpoint memory cp = checkpoints[_account][center];\n            if (cp.id == _blockNumber) {\n                return cp.votes;\n            } else if (cp.id < _blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[_account][lower].votes;\n    }",
        "comments": [
            "/**",
            "     * @notice Determine the prior number of votes for an account as of a block number",
            "     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.",
            "     * @param _account The address of the account to check",
            "     * @param _blockNumber The block number to get the vote balance at",
            "     * @return The number of votes the account had as of the given block",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param _account The address of the account to check\n     * @param _blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n",
        "@notice": "Determine the prior number of votes for an account as of a block number",
        "@dev": "Block number must be a finalized block or else this function will revert to prevent misinformation.",
        "@param1": "_account The address of the account to check",
        "@param2": "_blockNumber The block number to get the vote balance at",
        "@return1": "The number of votes the account had as of the given block",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "initialize",
        "visibility": "external",
        "args": [
            {
                "name": "_proposalMaxOperations",
                "type": "uint32"
            },
            {
                "name": "_votingDelay",
                "type": "uint32"
            },
            {
                "name": "_votingPeriod",
                "type": "uint32"
            },
            {
                "name": "_gracePeriod",
                "type": "uint32"
            },
            {
                "name": "_timelockDelay",
                "type": "uint32"
            },
            {
                "name": "_quorumVotes",
                "type": "uint32"
            },
            {
                "name": "_proposalThreshold",
                "type": "uint32"
            },
            {
                "name": "_skipRemainingVotingThreshold",
                "type": "uint32"
            }
        ],
        "func": "function initialize(\n        uint32 _proposalMaxOperations,\n        uint32 _votingDelay,\n        uint32 _votingPeriod,\n        uint32 _gracePeriod,\n        uint32 _timelockDelay,\n        uint32 _quorumVotes,\n        uint32 _proposalThreshold,\n        uint32 _skipRemainingVotingThreshold\n    ) external onlyAdmin {\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n\n        // Ensure state variable comparisons are valid\n        requireValidSkipRemainingVotingThreshold(_skipRemainingVotingThreshold);\n        requireSkipRemainingVotingThresholdGtQuorumVotes(_skipRemainingVotingThreshold, _quorumVotes);\n\n        // Set initial variable values\n        dsGovernance.proposalMaxOperations = _proposalMaxOperations;\n        dsGovernance.votingDelay = _votingDelay;\n        dsGovernance.votingPeriod = _votingPeriod;\n        dsGovernance.gracePeriod = _gracePeriod;\n        dsGovernance.timelockDelay = _timelockDelay;\n        dsGovernance.quorumVotes = _quorumVotes;\n        dsGovernance.proposalThreshold = _proposalThreshold;\n        dsGovernance.skipRemainingVotingThreshold = _skipRemainingVotingThreshold;\n        dsGovernance.fastPathFunctionSignatures[\"setIsPaused(bool)\"] = true;\n    }",
        "comments": [
            "/**",
            "     * @notice This function initializes the state with some critical",
            "     *         information. This can only be called once and must be",
            "     *         done via governance.",
            "     * @dev This function is best called as a parameter to the",
            "     *      diamond cut function. This is removed prior to the selectors",
            "     *      being added to the diamond, meaning it cannot be called",
            "     *      again.",
            "     * @param _quorumVotes Minimum number of for votes required, even",
            "     *        if there's a majority in favor.",
            "     * @param _proposalThreshold Minimum DDX token holdings required",
            "     *        to create a proposal",
            "     * @param _proposalMaxOperations Max number of operations/actions a",
            "     *        proposal can have",
            "     * @param _votingDelay Number of blocks after a proposal is made",
            "     *        that voting begins.",
            "     * @param _votingPeriod Number of blocks voting will be held.",
            "     * @param _skipRemainingVotingThreshold Number of for or against",
            "     *        votes that are necessary to skip the remainder of the",
            "     *        voting period.",
            "     * @param _gracePeriod Period in which a successful proposal must be",
            "     *        executed, otherwise will be expired.",
            "     * @param _timelockDelay Time (s) in which a successful proposal",
            "     *        must be in the queue before it can be executed.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function initializes the state with some critical\n     *         information. This can only be called once and must be\n     *         done via governance.\n     * @dev This function is best called as a parameter to the\n     *      diamond cut function. This is removed prior to the selectors\n     *      being added to the diamond, meaning it cannot be called\n     *      again.\n     * @param _quorumVotes Minimum number of for votes required, even\n     *        if there's a majority in favor.\n     * @param _proposalThreshold Minimum DDX token holdings required\n     *        to create a proposal\n     * @param _proposalMaxOperations Max number of operations/actions a\n     *        proposal can have\n     * @param _votingDelay Number of blocks after a proposal is made\n     *        that voting begins.\n     * @param _votingPeriod Number of blocks voting will be held.\n     * @param _skipRemainingVotingThreshold Number of for or against\n     *        votes that are necessary to skip the remainder of the\n     *        voting period.\n     * @param _gracePeriod Period in which a successful proposal must be\n     *        executed, otherwise will be expired.\n     * @param _timelockDelay Time (s) in which a successful proposal\n     *        must be in the queue before it can be executed.\n     */\n",
        "@notice": "This function initializes the state with some critical * information. This can only be called once and must be * done via governance.",
        "@dev": "This function is best called as a parameter to the * diamond cut function. This is removed prior to the selectors * being added to the diamond, meaning it cannot be called * again.",
        "@param1": "_quorumVotes Minimum number of for votes required, even * if there's a majority in favor.",
        "@param2": "_proposalThreshold Minimum DDX token holdings required * to create a proposal",
        "@param3": "_proposalMaxOperations Max number of operations/actions a * proposal can have",
        "@param4": "_votingDelay Number of blocks after a proposal is made * that voting begins.",
        "@param5": "_votingPeriod Number of blocks voting will be held.",
        "@param6": "_skipRemainingVotingThreshold Number of for or against * votes that are necessary to skip the remainder of the * voting period.",
        "@param7": "_gracePeriod Period in which a successful proposal must be * executed, otherwise will be expired.",
        "@param8": "_timelockDelay Time (s) in which a successful proposal * must be in the queue before it can be executed.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "propose",
        "visibility": "external",
        "args": [
            {
                "name": "_targets",
                "type": "address[] memory"
            },
            {
                "name": "_values",
                "type": "uint256[] memory"
            },
            {
                "name": "_signatures",
                "type": "string[] memory"
            },
            {
                "name": "_calldatas",
                "type": "bytes[] memory"
            },
            {
                "name": "_description",
                "type": "string memory"
            }
        ],
        "func": "function propose(\n        address[] memory _targets,\n        uint256[] memory _values,\n        string[] memory _signatures,\n        bytes[] memory _calldatas,\n        string memory _description\n    ) external returns (uint128) {\n        LibDiamondStorageDerivaDEX.DiamondStorageDerivaDEX storage dsDerivaDEX =\n            LibDiamondStorageDerivaDEX.diamondStorageDerivaDEX();\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n\n        // Ensure proposer has sufficient token holdings to propose\n        require(\n            dsDerivaDEX.ddxToken.getPriorVotes(msg.sender, block.number.sub(1)) >= getProposerThresholdCount(),\n            \"Governance: proposer votes below proposal threshold.\"\n        );\n        require(\n            _targets.length == _values.length &&\n                _targets.length == _signatures.length &&\n                _targets.length == _calldatas.length,\n            \"Governance: proposal function information parity mismatch.\"\n        );\n        require(_targets.length != 0, \"Governance: must provide actions.\");\n        require(_targets.length <= dsGovernance.proposalMaxOperations, \"Governance: too many actions.\");\n\n        if (dsGovernance.latestProposalIds[msg.sender] != 0) {\n            // Ensure proposer doesn't already have one active/pending\n            GovernanceDefs.ProposalState proposersLatestProposalState =\n                state(dsGovernance.latestProposalIds[msg.sender]);\n            require(\n                proposersLatestProposalState != GovernanceDefs.ProposalState.Active,\n                \"Governance: one live proposal per proposer, found an already active proposal.\"\n            );\n            require(\n                proposersLatestProposalState != GovernanceDefs.ProposalState.Pending,\n                \"Governance: one live proposal per proposer, found an already pending proposal.\"\n            );\n        }\n\n        // Proposal voting starts votingDelay after proposal is made\n        uint256 startBlock = block.number.add(dsGovernance.votingDelay);\n\n        // Increment count of proposals\n        dsGovernance.proposalCount++;\n\n        // Create new proposal struct and add to mapping\n        GovernanceDefs.Proposal memory newProposal =\n            GovernanceDefs.Proposal({\n                id: dsGovernance.proposalCount,\n                proposer: msg.sender,\n                delay: getTimelockDelayForSignatures(_signatures),\n                eta: 0,\n                targets: _targets,\n                values: _values,\n                signatures: _signatures,\n                calldatas: _calldatas,\n                startBlock: startBlock,\n                endBlock: startBlock.add(dsGovernance.votingPeriod),\n                forVotes: 0,\n                againstVotes: 0,\n                canceled: false,\n                executed: false\n            });\n\n        dsGovernance.proposals[newProposal.id] = newProposal;\n\n        // Update proposer's latest proposal\n        dsGovernance.latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            _targets,\n            _values,\n            _signatures,\n            _calldatas,\n            startBlock,\n            startBlock.add(dsGovernance.votingPeriod),\n            _description\n        );\n        return newProposal.id;\n    }",
        "comments": [
            "/**",
            "     * @notice This function allows participants who have sufficient",
            "     *         DDX holdings to create new proposals up for vote. The",
            "     *         proposals contain the ordered lists of on-chain",
            "     *         executable calldata.",
            "     * @param _targets Addresses of contracts involved.",
            "     * @param _values Values to be passed along with the calls.",
            "     * @param _signatures Function signatures.",
            "     * @param _calldatas Calldata passed to the function.",
            "     * @param _description Text description of proposal.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function allows participants who have sufficient\n     *         DDX holdings to create new proposals up for vote. The\n     *         proposals contain the ordered lists of on-chain\n     *         executable calldata.\n     * @param _targets Addresses of contracts involved.\n     * @param _values Values to be passed along with the calls.\n     * @param _signatures Function signatures.\n     * @param _calldatas Calldata passed to the function.\n     * @param _description Text description of proposal.\n     */\n",
        "@notice": "This function allows participants who have sufficient * DDX holdings to create new proposals up for vote. The * proposals contain the ordered lists of on-chain * executable calldata.",
        "@param1": "_targets Addresses of contracts involved.",
        "@param2": "_values Values to be passed along with the calls.",
        "@param3": "_signatures Function signatures.",
        "@param4": "_calldatas Calldata passed to the function.",
        "@param5": "_description Text description of proposal.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "queue",
        "visibility": "external",
        "args": [
            {
                "name": "_proposalId",
                "type": "uint128"
            }
        ],
        "func": "function queue(uint128 _proposalId) external {\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n\n        // Ensure proposal has succeeded (i.e. it has either enough for\n        // votes to skip the remainder of the voting period or the\n        // voting period has ended and there is a simple majority in\n        // favor and also above the quorum\n        require(\n            state(_proposalId) == GovernanceDefs.ProposalState.Succeeded,\n            \"Governance: proposal can only be queued if it is succeeded.\"\n        );\n        GovernanceDefs.Proposal storage proposal = dsGovernance.proposals[_proposalId];\n\n        // Establish eta of execution, which is a number of seconds\n        // after queuing at which point proposal can actually execute\n        uint256 eta = block.timestamp.add(proposal.delay);\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            // Ensure proposal action is not already in the queue\n            bytes32 txHash =\n                keccak256(\n                    abi.encode(\n                        proposal.targets[i],\n                        proposal.values[i],\n                        proposal.signatures[i],\n                        proposal.calldatas[i],\n                        eta\n                    )\n                );\n            require(!dsGovernance.queuedTransactions[txHash], \"Governance: proposal action already queued at eta.\");\n            dsGovernance.queuedTransactions[txHash] = true;\n            emit QueueTransaction(\n                txHash,\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta\n            );\n        }\n        // Set proposal eta timestamp after which it can be executed\n        proposal.eta = eta;\n        emit ProposalQueued(_proposalId, eta);\n    }",
        "comments": [
            "/**",
            "     * @notice This function allows any participant to queue a",
            "     *         successful proposal for execution. Proposals are deemed",
            "     *         successful if at any point the number of for votes has",
            "     *         exceeded the skip remaining voting threshold or if there",
            "     *         is a simple majority (and more for votes than the",
            "     *         minimum quorum) at the end of voting.",
            "     * @param _proposalId Proposal id.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function allows any participant to queue a\n     *         successful proposal for execution. Proposals are deemed\n     *         successful if at any point the number of for votes has\n     *         exceeded the skip remaining voting threshold or if there\n     *         is a simple majority (and more for votes than the\n     *         minimum quorum) at the end of voting.\n     * @param _proposalId Proposal id.\n     */\n",
        "@notice": "This function allows any participant to queue a * successful proposal for execution. Proposals are deemed * successful if at any point the number of for votes has * exceeded the skip remaining voting threshold or if there * is a simple majority (and more for votes than the * minimum quorum) at the end of voting.",
        "@param1": "_proposalId Proposal id.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "execute",
        "visibility": "external",
        "args": [
            {
                "name": "_proposalId",
                "type": "uint128"
            }
        ],
        "func": "function execute(uint128 _proposalId) external payable {\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n        // Ensure proposal is queued\n        require(\n            state(_proposalId) == GovernanceDefs.ProposalState.Queued,\n            \"Governance: proposal can only be executed if it is queued.\"\n        );\n        GovernanceDefs.Proposal storage proposal = dsGovernance.proposals[_proposalId];\n        // Ensure proposal has been in the queue long enough\n        require(block.timestamp >= proposal.eta, \"Governance: proposal hasn't finished queue time length.\");\n\n        // Ensure proposal hasn't been in the queue for too long\n        require(block.timestamp <= proposal.eta.add(dsGovernance.gracePeriod), \"Governance: transaction is stale.\");\n\n        proposal.executed = true;\n\n        // Loop through each of the actions in the proposal\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            bytes32 txHash =\n                keccak256(\n                    abi.encode(\n                        proposal.targets[i],\n                        proposal.values[i],\n                        proposal.signatures[i],\n                        proposal.calldatas[i],\n                        proposal.eta\n                    )\n                );\n            require(dsGovernance.queuedTransactions[txHash], \"Governance: transaction hasn't been queued.\");\n\n            dsGovernance.queuedTransactions[txHash] = false;\n\n            // Execute action\n            bytes memory callData;\n            require(bytes(proposal.signatures[i]).length != 0, \"Governance: Invalid function signature.\");\n            callData = abi.encodePacked(bytes4(keccak256(bytes(proposal.signatures[i]))), proposal.calldatas[i]);\n            // solium-disable-next-line security/no-call-value\n            (bool success, ) = proposal.targets[i].call{ value: proposal.values[i] }(callData);\n\n            require(success, \"Governance: transaction execution reverted.\");\n\n            emit ExecuteTransaction(\n                txHash,\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(_proposalId);\n    }",
        "comments": [
            "/**",
            "     * @notice This function allows any participant to execute a",
            "     *         queued proposal. A proposal in the queue must be in the",
            "     *         queue for the delay period it was proposed with prior to",
            "     *         executing, allowing the community to position itself",
            "     *         accordingly.",
            "     * @param _proposalId Proposal id.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function allows any participant to execute a\n     *         queued proposal. A proposal in the queue must be in the\n     *         queue for the delay period it was proposed with prior to\n     *         executing, allowing the community to position itself\n     *         accordingly.\n     * @param _proposalId Proposal id.\n     */\n",
        "@notice": "This function allows any participant to execute a * queued proposal. A proposal in the queue must be in the * queue for the delay period it was proposed with prior to * executing, allowing the community to position itself * accordingly.",
        "@param1": "_proposalId Proposal id.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "cancel",
        "visibility": "external",
        "args": [
            {
                "name": "_proposalId",
                "type": "uint128"
            }
        ],
        "func": "function cancel(uint128 _proposalId) external {\n        LibDiamondStorageDerivaDEX.DiamondStorageDerivaDEX storage dsDerivaDEX =\n            LibDiamondStorageDerivaDEX.diamondStorageDerivaDEX();\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n        GovernanceDefs.ProposalState state = state(_proposalId);\n\n        // Ensure proposal hasn't executed\n        require(state != GovernanceDefs.ProposalState.Executed, \"Governance: cannot cancel executed proposal.\");\n\n        GovernanceDefs.Proposal storage proposal = dsGovernance.proposals[_proposalId];\n\n        // Ensure proposer's token holdings has dipped below the\n        // proposer threshold, leaving their proposal subject to\n        // cancellation\n        require(\n            dsDerivaDEX.ddxToken.getPriorVotes(proposal.proposer, block.number.sub(1)) < getProposerThresholdCount(),\n            \"Governance: proposer above threshold.\"\n        );\n\n        proposal.canceled = true;\n\n        // Loop through each of the proposal's actions\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            bytes32 txHash =\n                keccak256(\n                    abi.encode(\n                        proposal.targets[i],\n                        proposal.values[i],\n                        proposal.signatures[i],\n                        proposal.calldatas[i],\n                        proposal.eta\n                    )\n                );\n            dsGovernance.queuedTransactions[txHash] = false;\n            emit CancelTransaction(\n                txHash,\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(_proposalId);\n    }",
        "comments": [
            "/**",
            "     * @notice This function allows any participant to cancel any non-",
            "     *         executed proposal. It can be canceled if the proposer's",
            "     *         token holdings has dipped below the proposal threshold",
            "     *         at the time of cancellation.",
            "     * @param _proposalId Proposal id.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function allows any participant to cancel any non-\n     *         executed proposal. It can be canceled if the proposer's\n     *         token holdings has dipped below the proposal threshold\n     *         at the time of cancellation.\n     * @param _proposalId Proposal id.\n     */\n",
        "@notice": "This function allows any participant to cancel any non- * executed proposal. It can be canceled if the proposer's * token holdings has dipped below the proposal threshold * at the time of cancellation.",
        "@param1": "_proposalId Proposal id.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "castVote",
        "visibility": "external",
        "args": [
            {
                "name": "_proposalId",
                "type": "uint128"
            },
            {
                "name": "_support",
                "type": "bool"
            }
        ],
        "func": "function castVote(uint128 _proposalId, bool _support) external {\n        return _castVote(msg.sender, _proposalId, _support);\n    }",
        "comments": [
            "/**",
            "     * @notice This function allows participants to cast either in",
            "     *         favor or against a particular proposal.",
            "     * @param _proposalId Proposal id.",
            "     * @param _support In favor (true) or against (false).",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function allows participants to cast either in\n     *         favor or against a particular proposal.\n     * @param _proposalId Proposal id.\n     * @param _support In favor (true) or against (false).\n     */\n",
        "@notice": "This function allows participants to cast either in * favor or against a particular proposal.",
        "@param1": "_proposalId Proposal id.",
        "@param2": "_support In favor (true) or against (false).",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "castVoteBySig",
        "visibility": "external",
        "args": [
            {
                "name": "_proposalId",
                "type": "uint128"
            },
            {
                "name": "_support",
                "type": "bool"
            },
            {
                "name": "_signature",
                "type": "bytes memory"
            }
        ],
        "func": "function castVoteBySig(\n        uint128 _proposalId,\n        bool _support,\n        bytes memory _signature\n    ) external {\n        // EIP712 hashing logic\n        bytes32 eip712OrderParamsDomainHash = LibEIP712.hashEIP712Domain(name, version, getChainId(), address(this));\n        bytes32 voteCastHash =\n            LibVoteCast.getVoteCastHash(\n                LibVoteCast.VoteCast({ proposalId: _proposalId, support: _support }),\n                eip712OrderParamsDomainHash\n            );\n\n        // Recover the signature and EIP712 hash\n        uint8 v = uint8(_signature[0]);\n        bytes32 r = _signature.readBytes32(1);\n        bytes32 s = _signature.readBytes32(33);\n        address recovered = ecrecover(voteCastHash, v, r, s);\n\n        require(recovered != address(0), \"Governance: invalid signature.\");\n        return _castVote(recovered, _proposalId, _support);\n    }",
        "comments": [
            "/**",
            "     * @notice This function allows participants to cast votes with",
            "     *         offline signatures in favor or against a particular",
            "     *         proposal.",
            "     * @param _proposalId Proposal id.",
            "     * @param _support In favor (true) or against (false).",
            "     * @param _signature Signature",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function allows participants to cast votes with\n     *         offline signatures in favor or against a particular\n     *         proposal.\n     * @param _proposalId Proposal id.\n     * @param _support In favor (true) or against (false).\n     * @param _signature Signature\n     */\n",
        "@notice": "This function allows participants to cast votes with * offline signatures in favor or against a particular * proposal.",
        "@param1": "_proposalId Proposal id.",
        "@param2": "_support In favor (true) or against (false).",
        "@param3": "_signature Signature",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setQuorumVotes",
        "visibility": "external",
        "args": [
            {
                "name": "_quorumVotes",
                "type": "uint32"
            }
        ],
        "func": "function setQuorumVotes(uint32 _quorumVotes) external onlyAdmin {\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n        requireSkipRemainingVotingThresholdGtQuorumVotes(dsGovernance.skipRemainingVotingThreshold, _quorumVotes);\n        dsGovernance.quorumVotes = _quorumVotes;\n    }",
        "comments": [
            "/**",
            "     * @notice This function sets the quorum votes required for a",
            "     *         proposal to pass. It must be called via",
            "     *         governance.",
            "     * @param _quorumVotes Quorum votes threshold.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function sets the quorum votes required for a\n     *         proposal to pass. It must be called via\n     *         governance.\n     * @param _quorumVotes Quorum votes threshold.\n     */\n",
        "@notice": "This function sets the quorum votes required for a * proposal to pass. It must be called via * governance.",
        "@param1": "_quorumVotes Quorum votes threshold.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setProposalThreshold",
        "visibility": "external",
        "args": [
            {
                "name": "_proposalThreshold",
                "type": "uint32"
            }
        ],
        "func": "function setProposalThreshold(uint32 _proposalThreshold) external onlyAdmin {\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n        dsGovernance.proposalThreshold = _proposalThreshold;\n    }",
        "comments": [
            "/**",
            "     * @notice This function sets the token holdings threshold required",
            "     *         to propose something. It must be called via",
            "     *         governance.",
            "     * @param _proposalThreshold Proposal threshold.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function sets the token holdings threshold required\n     *         to propose something. It must be called via\n     *         governance.\n     * @param _proposalThreshold Proposal threshold.\n     */\n",
        "@notice": "This function sets the token holdings threshold required * to propose something. It must be called via * governance.",
        "@param1": "_proposalThreshold Proposal threshold.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setProposalMaxOperations",
        "visibility": "external",
        "args": [
            {
                "name": "_proposalMaxOperations",
                "type": "uint32"
            }
        ],
        "func": "function setProposalMaxOperations(uint32 _proposalMaxOperations) external onlyAdmin {\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n        dsGovernance.proposalMaxOperations = _proposalMaxOperations;\n    }",
        "comments": [
            "/**",
            "     * @notice This function sets the max operations a proposal can",
            "     *         carry out. It must be called via governance.",
            "     * @param _proposalMaxOperations Proposal's max operations.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function sets the max operations a proposal can\n     *         carry out. It must be called via governance.\n     * @param _proposalMaxOperations Proposal's max operations.\n     */\n",
        "@notice": "This function sets the max operations a proposal can * carry out. It must be called via governance.",
        "@param1": "_proposalMaxOperations Proposal's max operations.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setVotingDelay",
        "visibility": "external",
        "args": [
            {
                "name": "_votingDelay",
                "type": "uint32"
            }
        ],
        "func": "function setVotingDelay(uint32 _votingDelay) external onlyAdmin {\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n        dsGovernance.votingDelay = _votingDelay;\n    }",
        "comments": [
            "/**",
            "     * @notice This function sets the voting delay in blocks from when",
            "     *         a proposal is made and voting begins. It must be called",
            "     *         via governance.",
            "     * @param _votingDelay Voting delay (blocks).",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function sets the voting delay in blocks from when\n     *         a proposal is made and voting begins. It must be called\n     *         via governance.\n     * @param _votingDelay Voting delay (blocks).\n     */\n",
        "@notice": "This function sets the voting delay in blocks from when * a proposal is made and voting begins. It must be called * via governance.",
        "@param1": "_votingDelay Voting delay (blocks).",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setVotingPeriod",
        "visibility": "external",
        "args": [
            {
                "name": "_votingPeriod",
                "type": "uint32"
            }
        ],
        "func": "function setVotingPeriod(uint32 _votingPeriod) external onlyAdmin {\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n        dsGovernance.votingPeriod = _votingPeriod;\n    }",
        "comments": [
            "/**",
            "     * @notice This function sets the voting period in blocks that a",
            "     *         vote will last. It must be called via",
            "     *         governance.",
            "     * @param _votingPeriod Voting period (blocks).",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function sets the voting period in blocks that a\n     *         vote will last. It must be called via\n     *         governance.\n     * @param _votingPeriod Voting period (blocks).\n     */\n",
        "@notice": "This function sets the voting period in blocks that a * vote will last. It must be called via * governance.",
        "@param1": "_votingPeriod Voting period (blocks).",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setSkipRemainingVotingThreshold",
        "visibility": "external",
        "args": [
            {
                "name": "_skipRemainingVotingThreshold",
                "type": "uint32"
            }
        ],
        "func": "function setSkipRemainingVotingThreshold(uint32 _skipRemainingVotingThreshold) external onlyAdmin {\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n        requireValidSkipRemainingVotingThreshold(_skipRemainingVotingThreshold);\n        requireSkipRemainingVotingThresholdGtQuorumVotes(_skipRemainingVotingThreshold, dsGovernance.quorumVotes);\n        dsGovernance.skipRemainingVotingThreshold = _skipRemainingVotingThreshold;\n    }",
        "comments": [
            "/**",
            "     * @notice This function sets the threshold at which a proposal can",
            "     *         immediately be deemed successful or rejected if the for",
            "     *         or against votes exceeds this threshold, even if the",
            "     *         voting period is still ongoing. It must be called",
            "     *         governance.",
            "     * @param _skipRemainingVotingThreshold Threshold for or against",
            "     *        votes must reach to skip remainder of voting period.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function sets the threshold at which a proposal can\n     *         immediately be deemed successful or rejected if the for\n     *         or against votes exceeds this threshold, even if the\n     *         voting period is still ongoing. It must be called\n     *         governance.\n     * @param _skipRemainingVotingThreshold Threshold for or against\n     *        votes must reach to skip remainder of voting period.\n     */\n",
        "@notice": "This function sets the threshold at which a proposal can * immediately be deemed successful or rejected if the for * or against votes exceeds this threshold, even if the * voting period is still ongoing. It must be called * governance.",
        "@param1": "_skipRemainingVotingThreshold Threshold for or against * votes must reach to skip remainder of voting period.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "setGracePeriod",
        "visibility": "external",
        "args": [
            {
                "name": "_gracePeriod",
                "type": "uint32"
            }
        ],
        "func": "function setGracePeriod(uint32 _gracePeriod) external onlyAdmin {\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n        dsGovernance.gracePeriod = _gracePeriod;\n    }",
        "comments": [
            "/**",
            "     * @notice This function sets the grace period in seconds that a",
            "     *         queued proposal can last before expiring. It must be",
            "     *         called via governance.",
            "     * @param _gracePeriod Grace period (seconds).",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function sets the grace period in seconds that a\n     *         queued proposal can last before expiring. It must be\n     *         called via governance.\n     * @param _gracePeriod Grace period (seconds).\n     */\n",
        "@notice": "This function sets the grace period in seconds that a * queued proposal can last before expiring. It must be * called via governance.",
        "@param1": "_gracePeriod Grace period (seconds).",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setTimelockDelay",
        "visibility": "external",
        "args": [
            {
                "name": "_timelockDelay",
                "type": "uint32"
            }
        ],
        "func": "function setTimelockDelay(uint32 _timelockDelay) external onlyAdmin {\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n        dsGovernance.timelockDelay = _timelockDelay;\n    }",
        "comments": [
            "/**",
            "     * @notice This function sets the timelock delay (s) a proposal",
            "     *         must be queued before execution.",
            "     * @param _timelockDelay Timelock delay (seconds).",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function sets the timelock delay (s) a proposal\n     *         must be queued before execution.\n     * @param _timelockDelay Timelock delay (seconds).\n     */\n",
        "@notice": "This function sets the timelock delay (s) a proposal * must be queued before execution.",
        "@param1": "_timelockDelay Timelock delay (seconds).",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getActions",
        "visibility": "external",
        "args": [
            {
                "name": "_proposalId",
                "type": "uint128"
            }
        ],
        "func": "function getActions(uint128 _proposalId)\n        external\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n        GovernanceDefs.Proposal storage p = dsGovernance.proposals[_proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }",
        "comments": [
            "/**",
            "     * @notice This function allows any participant to retrieve",
            "     *         the actions involved in a given proposal.",
            "     * @param _proposalId Proposal id.",
            "     * @return targets Addresses of contracts involved.",
            "     * @return values Values to be passed along with the calls.",
            "     * @return signatures Function signatures.",
            "     * @return calldatas Calldata passed to the function.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function allows any participant to retrieve\n     *         the actions involved in a given proposal.\n     * @param _proposalId Proposal id.\n     * @return targets Addresses of contracts involved.\n     * @return values Values to be passed along with the calls.\n     * @return signatures Function signatures.\n     * @return calldatas Calldata passed to the function.\n     */\n",
        "@notice": "This function allows any participant to retrieve * the actions involved in a given proposal.",
        "@param1": "_proposalId Proposal id.",
        "@return1": "targets Addresses of contracts involved.",
        "@return2": "values Values to be passed along with the calls.",
        "@return3": "signatures Function signatures.",
        "@return4": "calldatas Calldata passed to the function.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getReceipt",
        "visibility": "external",
        "args": [
            {
                "name": "_proposalId",
                "type": "uint128"
            },
            {
                "name": "_voter",
                "type": "address"
            }
        ],
        "func": "function getReceipt(uint128 _proposalId, address _voter) external view returns (GovernanceDefs.Receipt memory) {\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n        return dsGovernance.proposals[_proposalId].receipts[_voter];\n    }",
        "comments": [
            "/**",
            "     * @notice This function allows any participant to retrieve",
            "     *         the receipt for a given proposal and voter.",
            "     * @param _proposalId Proposal id.",
            "     * @param _voter Voter address.",
            "     * @return Voter receipt.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function allows any participant to retrieve\n     *         the receipt for a given proposal and voter.\n     * @param _proposalId Proposal id.\n     * @param _voter Voter address.\n     * @return Voter receipt.\n     */\n",
        "@notice": "This function allows any participant to retrieve * the receipt for a given proposal and voter.",
        "@param1": "_proposalId Proposal id.",
        "@param2": "_voter Voter address.",
        "@return1": "Voter receipt.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getProposal",
        "visibility": "external",
        "args": [
            {
                "name": "_proposalId",
                "type": "uint128"
            }
        ],
        "func": "function getProposal(uint128 _proposalId)\n        external\n        view\n        returns (\n            bool,\n            bool,\n            address,\n            uint32,\n            uint96,\n            uint96,\n            uint128,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n        GovernanceDefs.Proposal memory proposal = dsGovernance.proposals[_proposalId];\n        return (\n            proposal.canceled,\n            proposal.executed,\n            proposal.proposer,\n            proposal.delay,\n            proposal.forVotes,\n            proposal.againstVotes,\n            proposal.id,\n            proposal.eta,\n            proposal.startBlock,\n            proposal.endBlock\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice This function gets a proposal from an ID.",
            "     * @param _proposalId Proposal id.",
            "     * @return Proposal attributes.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function gets a proposal from an ID.\n     * @param _proposalId Proposal id.\n     * @return Proposal attributes.\n     */\n",
        "@notice": "This function gets a proposal from an ID.",
        "@param1": "_proposalId Proposal id.",
        "@return1": "Proposal attributes.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getIsQueuedTransaction",
        "visibility": "external",
        "args": [
            {
                "name": "_txHash",
                "type": "bytes32"
            }
        ],
        "func": "function getIsQueuedTransaction(bytes32 _txHash) external view returns (bool) {\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n        return dsGovernance.queuedTransactions[_txHash];\n    }",
        "comments": [
            "/**",
            "     * @notice This function gets whether a proposal action transaction",
            "     *         hash is queued or not.",
            "     * @param _txHash Proposal action tx hash.",
            "     * @return Is proposal action transaction hash queued or not.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function gets whether a proposal action transaction\n     *         hash is queued or not.\n     * @param _txHash Proposal action tx hash.\n     * @return Is proposal action transaction hash queued or not.\n     */\n",
        "@notice": "This function gets whether a proposal action transaction * hash is queued or not.",
        "@param1": "_txHash Proposal action tx hash.",
        "@return1": "Is proposal action transaction hash queued or not.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getGovernanceParameters",
        "visibility": "external",
        "args": [],
        "func": "function getGovernanceParameters()\n        external\n        view\n        returns (\n            uint32,\n            uint32,\n            uint32,\n            uint32,\n            uint32,\n            uint32,\n            uint32,\n            uint32\n        )\n    {\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n        return (\n            dsGovernance.proposalMaxOperations,\n            dsGovernance.votingDelay,\n            dsGovernance.votingPeriod,\n            dsGovernance.gracePeriod,\n            dsGovernance.timelockDelay,\n            dsGovernance.quorumVotes,\n            dsGovernance.proposalThreshold,\n            dsGovernance.skipRemainingVotingThreshold\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice This function gets the Governance facet's current",
            "     *         parameters.",
            "     * @return Proposal max operations.",
            "     * @return Voting delay.",
            "     * @return Voting period.",
            "     * @return Grace period.",
            "     * @return Timelock delay.",
            "     * @return Quorum votes threshold.",
            "     * @return Proposal threshold.",
            "     * @return Skip remaining voting threshold.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function gets the Governance facet's current\n     *         parameters.\n     * @return Proposal max operations.\n     * @return Voting delay.\n     * @return Voting period.\n     * @return Grace period.\n     * @return Timelock delay.\n     * @return Quorum votes threshold.\n     * @return Proposal threshold.\n     * @return Skip remaining voting threshold.\n     */\n",
        "@notice": "This function gets the Governance facet's current * parameters.",
        "@return1": "Proposal max operations.",
        "@return2": "Voting delay.",
        "@return3": "Voting period.",
        "@return4": "Grace period.",
        "@return5": "Timelock delay.",
        "@return6": "Quorum votes threshold.",
        "@return7": "Proposal threshold.",
        "@return8": "Skip remaining voting threshold.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getProposalCount",
        "visibility": "external",
        "args": [],
        "func": "function getProposalCount() external view returns (uint128) {\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n        return dsGovernance.proposalCount;\n    }",
        "comments": [
            "/**",
            "     * @notice This function gets the proposal count.",
            "     * @return Proposal count.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function gets the proposal count.\n     * @return Proposal count.\n     */\n",
        "@notice": "This function gets the proposal count.",
        "@return1": "Proposal count.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getLatestProposalId",
        "visibility": "external",
        "args": [
            {
                "name": "_proposer",
                "type": "address"
            }
        ],
        "func": "function getLatestProposalId(address _proposer) external view returns (uint128) {\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n        return dsGovernance.latestProposalIds[_proposer];\n    }",
        "comments": [
            "/**",
            "     * @notice This function gets the latest proposal ID for a user.",
            "     * @param _proposer Proposer's address.",
            "     * @return Proposal ID.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function gets the latest proposal ID for a user.\n     * @param _proposer Proposer's address.\n     * @return Proposal ID.\n     */\n",
        "@notice": "This function gets the latest proposal ID for a user.",
        "@param1": "_proposer Proposer's address.",
        "@return1": "Proposal ID.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getQuorumVoteCount",
        "visibility": "public",
        "args": [],
        "func": "function getQuorumVoteCount() public view returns (uint96) {\n        LibDiamondStorageDerivaDEX.DiamondStorageDerivaDEX storage dsDerivaDEX =\n            LibDiamondStorageDerivaDEX.diamondStorageDerivaDEX();\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n\n        uint96 totalSupply = dsDerivaDEX.ddxToken.totalSupply().safe96(\"Governance: amount exceeds 96 bits\");\n        return totalSupply.proportion96(dsGovernance.quorumVotes, 100);\n    }",
        "comments": [
            "/**",
            "     * @notice This function gets the quorum vote count given the",
            "     *         quorum vote percentage relative to the total DDX supply.",
            "     * @return Quorum vote count.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function gets the quorum vote count given the\n     *         quorum vote percentage relative to the total DDX supply.\n     * @return Quorum vote count.\n     */\n",
        "@notice": "This function gets the quorum vote count given the * quorum vote percentage relative to the total DDX supply.",
        "@return1": "Quorum vote count.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getProposerThresholdCount",
        "visibility": "public",
        "args": [],
        "func": "function getProposerThresholdCount() public view returns (uint96) {\n        LibDiamondStorageDerivaDEX.DiamondStorageDerivaDEX storage dsDerivaDEX =\n            LibDiamondStorageDerivaDEX.diamondStorageDerivaDEX();\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n\n        uint96 totalSupply = dsDerivaDEX.ddxToken.totalSupply().safe96(\"Governance: amount exceeds 96 bits\");\n        return totalSupply.proportion96(dsGovernance.proposalThreshold, 100);\n    }",
        "comments": [
            "/**",
            "     * @notice This function gets the quorum vote count given the",
            "     *         quorum vote percentage relative to the total DDX supply.",
            "     * @return Quorum vote count.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function gets the quorum vote count given the\n     *         quorum vote percentage relative to the total DDX supply.\n     * @return Quorum vote count.\n     */\n",
        "@notice": "This function gets the quorum vote count given the * quorum vote percentage relative to the total DDX supply.",
        "@return1": "Quorum vote count.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getSkipRemainingVotingThresholdCount",
        "visibility": "public",
        "args": [],
        "func": "function getSkipRemainingVotingThresholdCount() public view returns (uint96) {\n        LibDiamondStorageDerivaDEX.DiamondStorageDerivaDEX storage dsDerivaDEX =\n            LibDiamondStorageDerivaDEX.diamondStorageDerivaDEX();\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n\n        uint96 totalSupply = dsDerivaDEX.ddxToken.totalSupply().safe96(\"Governance: amount exceeds 96 bits\");\n        return totalSupply.proportion96(dsGovernance.skipRemainingVotingThreshold, 100);\n    }",
        "comments": [
            "/**",
            "     * @notice This function gets the quorum vote count given the",
            "     *         quorum vote percentage relative to the total DDX supply.",
            "     * @return Quorum vote count.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function gets the quorum vote count given the\n     *         quorum vote percentage relative to the total DDX supply.\n     * @return Quorum vote count.\n     */\n",
        "@notice": "This function gets the quorum vote count given the * quorum vote percentage relative to the total DDX supply.",
        "@return1": "Quorum vote count.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "state",
        "visibility": "public",
        "args": [
            {
                "name": "_proposalId",
                "type": "uint128"
            }
        ],
        "func": "function state(uint128 _proposalId) public view returns (GovernanceDefs.ProposalState) {\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n        require(dsGovernance.proposalCount >= _proposalId && _proposalId > 0, \"Governance: invalid proposal id.\");\n        GovernanceDefs.Proposal storage proposal = dsGovernance.proposals[_proposalId];\n\n        // Note the 3rd conditional where we can escape out of the vote\n        // phase if the for or against votes exceeds the skip remaining\n        // voting threshold\n        if (proposal.canceled) {\n            return GovernanceDefs.ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return GovernanceDefs.ProposalState.Pending;\n        } else if (\n            (block.number <= proposal.endBlock) &&\n            (proposal.forVotes < getSkipRemainingVotingThresholdCount()) &&\n            (proposal.againstVotes < getSkipRemainingVotingThresholdCount())\n        ) {\n            return GovernanceDefs.ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < getQuorumVoteCount()) {\n            return GovernanceDefs.ProposalState.Defeated;\n        } else if (proposal.eta == 0) {\n            return GovernanceDefs.ProposalState.Succeeded;\n        } else if (proposal.executed) {\n            return GovernanceDefs.ProposalState.Executed;\n        } else if (block.timestamp >= proposal.eta.add(dsGovernance.gracePeriod)) {\n            return GovernanceDefs.ProposalState.Expired;\n        } else {\n            return GovernanceDefs.ProposalState.Queued;\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice This function retrieves the status for any given",
            "     *         proposal.",
            "     * @param _proposalId Proposal id.",
            "     * @return Status of proposal.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function retrieves the status for any given\n     *         proposal.\n     * @param _proposalId Proposal id.\n     * @return Status of proposal.\n     */\n",
        "@notice": "This function retrieves the status for any given * proposal.",
        "@param1": "_proposalId Proposal id.",
        "@return1": "Status of proposal.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "initialize",
        "visibility": "external",
        "args": [],
        "func": "function initialize() external onlyAdmin {\n        emit PauseInitialized();\n    }",
        "comments": [
            "/**",
            "     * @notice This function initializes the facet.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function initializes the facet.\n     */\n",
        "@notice": "This function initializes the facet.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setIsPaused",
        "visibility": "external",
        "args": [
            {
                "name": "_isPaused",
                "type": "bool"
            }
        ],
        "func": "function setIsPaused(bool _isPaused) external onlyAdmin {\n        LibDiamondStoragePause.DiamondStoragePause storage dsPause = LibDiamondStoragePause.diamondStoragePause();\n\n        dsPause.isPaused = _isPaused;\n\n        emit IsPausedSet(_isPaused);\n    }",
        "comments": [
            "/**",
            "     * @notice This function sets the paused status.",
            "     * @param _isPaused Whether contracts are paused or not.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function sets the paused status.\n     * @param _isPaused Whether contracts are paused or not.\n     */\n",
        "@notice": "This function sets the paused status.",
        "@param1": "_isPaused Whether contracts are paused or not.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getIsPaused",
        "visibility": "public",
        "args": [],
        "func": "function getIsPaused() public view returns (bool) {\n        LibDiamondStoragePause.DiamondStoragePause storage dsPause = LibDiamondStoragePause.diamondStoragePause();\n\n        return dsPause.isPaused;\n    }",
        "comments": [
            "/**",
            "     * @notice This function gets whether the contract ecosystem is",
            "     *         currently paused.",
            "     * @return Whether contracts are paused or not.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This function gets whether the contract ecosystem is\n     *         currently paused.\n     * @return Whether contracts are paused or not.\n     */\n",
        "@notice": "This function gets whether the contract ecosystem is * currently paused.",
        "@return1": "Whether contracts are paused or not.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isPauser",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function isPauser(address account) public view returns (bool) {\n        return _pausers.has(account);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addPauser",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function addPauser(address account) public onlyOwner {\n        _addPauser(account);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removePauser",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function removePauser(address account) public onlyOwner {\n        _removePauser(account);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "renouncePauser",
        "visibility": "public",
        "args": [],
        "func": "function renouncePauser() public {\n        _removePauser(msg.sender);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "paused",
        "visibility": "public",
        "args": [],
        "func": "function paused() public view returns (bool) {\n        return _paused;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "pause",
        "visibility": "public",
        "args": [],
        "func": "function pause() public onlyPauser whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unpause",
        "visibility": "public",
        "args": [],
        "func": "function unpause() public onlyPauser whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allowance",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            }
        ],
        "func": "function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint256"
            }
        ],
        "func": "function approve(address spender, uint256 value) public virtual override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "increaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "addedValue",
                "type": "uint256"
            }
        ],
        "func": "function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decreaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "subtractedValue",
                "type": "uint256"
            }
        ],
        "func": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address to, uint256 value) public virtual override whenNotPaused returns (bool) {\n        return super.transfer(to, value);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) public virtual override whenNotPaused returns (bool) {\n        return super.transferFrom(from, to, value);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint256"
            }
        ],
        "func": "function approve(address spender, uint256 value) public virtual override whenNotPaused returns (bool) {\n        return super.approve(spender, value);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "increaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "addedValue",
                "type": "uint256"
            }
        ],
        "func": "function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        override\n        whenNotPaused\n        returns (bool)\n    {\n        return super.increaseAllowance(spender, addedValue);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decreaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "subtractedValue",
                "type": "uint256"
            }
        ],
        "func": "function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        override\n        whenNotPaused\n        returns (bool)\n    {\n        return super.decreaseAllowance(spender, subtractedValue);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isCoinFactoryAdmin",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function isCoinFactoryAdmin(address account) public view returns (bool) {\n        return _coinFactoryAdmins.has(account);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addCoinFactoryAdmin",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function addCoinFactoryAdmin(address account) public onlyOwner {\n        _addCoinFactoryAdmin(account);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeCoinFactoryAdmin",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function removeCoinFactoryAdmin(address account) public onlyOwner {\n        _removeCoinFactoryAdmin(account);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "renounceCoinFactoryAdmin",
        "visibility": "public",
        "args": [],
        "func": "function renounceCoinFactoryAdmin() public {\n        _removeCoinFactoryAdmin(msg.sender);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "issue",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function issue(address account, uint256 amount) public onlyCoinFactoryAdmin returns (bool) {\n        _issue(account, amount);\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "redeem",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function redeem(address account, uint256 amount) public onlyCoinFactoryAdmin returns (bool) {\n        _redeem(account, amount);\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isBlacklistAdmin",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function isBlacklistAdmin(address account) public view returns (bool) {\n        return _blacklistAdmins.has(account);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addBlacklistAdmin",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function addBlacklistAdmin(address account) public onlyOwner {\n        _addBlacklistAdmin(account);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeBlacklistAdmin",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function removeBlacklistAdmin(address account) public onlyOwner {\n        _removeBlacklistAdmin(account);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "renounceBlacklistAdmin",
        "visibility": "public",
        "args": [],
        "func": "function renounceBlacklistAdmin() public {\n        _removeBlacklistAdmin(msg.sender);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addBlacklist",
        "visibility": "public",
        "args": [
            {
                "name": "accounts",
                "type": "address[] memory"
            }
        ],
        "func": "function addBlacklist(address[] memory accounts) public onlyBlacklistAdmin returns (bool) {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            _addBlacklist(accounts[i]);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeBlacklist",
        "visibility": "public",
        "args": [
            {
                "name": "accounts",
                "type": "address[] memory"
            }
        ],
        "func": "function removeBlacklist(address[] memory accounts) public onlyBlacklistAdmin returns (bool) {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            _removeBlacklist(accounts[i]);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isBlacklist",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function isBlacklist(address account) public view returns (bool) {\n        return _blacklist[account];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address to, uint256 value) public override(ERC20, ERC20Pausable) whenNotPaused returns (bool) {\n        require(!isBlacklist(msg.sender), \"HDUMToken: caller in blacklist can't transfer\");\n        require(!isBlacklist(to), \"HDUMToken: not allow to transfer to recipient address in blacklist\");\n        return super.transfer(to, value);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) public override(ERC20, ERC20Pausable) whenNotPaused returns (bool) {\n        require(!isBlacklist(msg.sender), \"HDUMToken: caller in blacklist can't transferFrom\");\n        require(!isBlacklist(from), \"HDUMToken: from in blacklist can't transfer\");\n        require(!isBlacklist(to), \"HDUMToken: not allow to transfer to recipient address in blacklist\");\n        return super.transferFrom(from, to, value);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint256"
            }
        ],
        "func": "function approve(address spender, uint256 value) public virtual override(ERC20, ERC20Pausable) returns (bool) {\n        return super.approve(spender, value);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "increaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "addedValue",
                "type": "uint256"
            }
        ],
        "func": "function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        override(ERC20, ERC20Pausable)\n        returns (bool)\n    {\n        return super.increaseAllowance(spender, addedValue);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decreaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "subtractedValue",
                "type": "uint256"
            }
        ],
        "func": "function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        override(ERC20, ERC20Pausable)\n        returns (bool)\n    {\n        return super.decreaseAllowance(spender, subtractedValue);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "owner",
        "visibility": "public",
        "args": [],
        "func": "function owner() public view returns (address) {\n        return _owner;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the address of the current owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the address of the current owner.\n     */\n",
        "@dev": "Returns the address of the current owner.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "renounceOwnership",
        "visibility": "public",
        "args": [],
        "func": "function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }",
        "comments": [
            "/**",
            "     * @dev Leaves the contract without owner. It will not be possible to call",
            "     * `onlyOwner` functions anymore. Can only be called by the current owner.",
            "     *",
            "     * NOTE: Renouncing ownership will leave the contract without an owner,",
            "     * thereby removing any functionality that is only available to the owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n",
        "@dev": "Leaves the contract without owner. It will not be possible to call * `onlyOwner` functions anymore. Can only be called by the current owner. * * NOTE: Renouncing ownership will leave the contract without an owner, * thereby removing any functionality that is only available to the owner.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferOwnership",
        "visibility": "public",
        "args": [
            {
                "name": "newOwner",
                "type": "address"
            }
        ],
        "func": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }",
        "comments": [
            "/**",
            "     * @dev Transfers ownership of the contract to a new account (`newOwner`).",
            "     * Can only be called by the current owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n",
        "@dev": "Transfers ownership of the contract to a new account (`newOwner`). * Can only be called by the current owner.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address recipient, uint256 amount) public {\n        _token.safeTransfer(recipient, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public {\n        _token.safeTransferFrom(sender, recipient, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function approve(address spender, uint256 amount) public {\n        _token.safeApprove(spender, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "increaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function increaseAllowance(address spender, uint256 amount) public {\n        _token.safeIncreaseAllowance(spender, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decreaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function decreaseAllowance(address spender, uint256 amount) public {\n        _token.safeDecreaseAllowance(spender, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allowance",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            }
        ],
        "func": "function allowance(address owner, address spender) public view returns (uint256) {\n        return _token.allowance(owner, spender);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address account) public view returns (uint256) {\n        return _token.balanceOf(account);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "name",
        "visibility": "public",
        "args": [],
        "func": "function name() public view returns (string memory) {\n        return _name;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the name of the token.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the name of the token.\n     */\n",
        "@dev": "Returns the name of the token.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "symbol",
        "visibility": "public",
        "args": [],
        "func": "function symbol() public view returns (string memory) {\n        return _symbol;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the symbol of the token, usually a shorter version of the",
            "     * name.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n",
        "@dev": "Returns the symbol of the token, usually a shorter version of the * name.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decimals",
        "visibility": "public",
        "args": [],
        "func": "function decimals() public view returns (uint8) {\n        return _decimals;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the number of decimals used to get its user representation.",
            "     * For example, if `decimals` equals `2`, a balance of `505` tokens should",
            "     * be displayed to a user as `5,05` (`505 / 10 ** 2`).",
            "     *",
            "     * Tokens usually opt for a value of 18, imitating the relationship between",
            "     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is",
            "     * called.",
            "     *",
            "     * NOTE: This information is only used for _display_ purposes: it in",
            "     * no way affects any of the arithmetic of the contract, including",
            "     * {IERC20-balanceOf} and {IERC20-transfer}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n",
        "@dev": "Returns the number of decimals used to get its user representation. * For example, if `decimals` equals `2`, a balance of `505` tokens should * be displayed to a user as `5,05` (`505 / 10 ** 2`). * * Tokens usually opt for a value of 18, imitating the relationship between * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is * called. * * NOTE: This information is only used for _display_ purposes: it in * no way affects any of the arithmetic of the contract, including * {IERC20-balanceOf} and {IERC20-transfer}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-totalSupply}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-totalSupply}.\n     */\n",
        "@dev": "See {IERC20-totalSupply}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-balanceOf}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-balanceOf}.\n     */\n",
        "@dev": "See {IERC20-balanceOf}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-transfer}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `recipient` cannot be the zero address.",
            "     * - the caller must have a balance of at least `amount`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n",
        "@dev": "See {IERC20-transfer}. * * Requirements: * * - `recipient` cannot be the zero address. * - the caller must have a balance of at least `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allowance",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            }
        ],
        "func": "function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-allowance}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-allowance}.\n     */\n",
        "@dev": "See {IERC20-allowance}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-approve}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n",
        "@dev": "See {IERC20-approve}. * * Requirements: * * - `spender` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-transferFrom}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance. This is not",
            "     * required by the EIP. See the note at the beginning of {ERC20};",
            "     *",
            "     * Requirements:",
            "     * - `sender` and `recipient` cannot be the zero address.",
            "     * - `sender` must have a balance of at least `amount`.",
            "     * - the caller must have allowance for ``sender``'s tokens of at least",
            "     * `amount`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n",
        "@dev": "See {IERC20-transferFrom}. * * Emits an {Approval} event indicating the updated allowance. This is not * required by the EIP. See the note at the beginning of {ERC20}; * * Requirements: * - `sender` and `recipient` cannot be the zero address. * - `sender` must have a balance of at least `amount`. * - the caller must have allowance for ``sender``'s tokens of at least * `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "increaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "addedValue",
                "type": "uint256"
            }
        ],
        "func": "function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Atomically increases the allowance granted to `spender` by the caller.",
            "     *",
            "     * This is an alternative to {approve} that can be used as a mitigation for",
            "     * problems described in {IERC20-approve}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n",
        "@dev": "Atomically increases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decreaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "subtractedValue",
                "type": "uint256"
            }
        ],
        "func": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Atomically decreases the allowance granted to `spender` by the caller.",
            "     *",
            "     * This is an alternative to {approve} that can be used as a mitigation for",
            "     * problems described in {IERC20-approve}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     * - `spender` must have allowance for the caller of at least",
            "     * `subtractedValue`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n",
        "@dev": "Atomically decreases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address. * - `spender` must have allowance for the caller of at least * `subtractedValue`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function mint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferInternal",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint256"
            }
        ],
        "func": "function transferInternal(\n        address from,\n        address to,\n        uint256 value\n    ) public {\n        _transfer(from, to, value);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approveInternal",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint256"
            }
        ],
        "func": "function approveInternal(\n        address owner,\n        address spender,\n        uint256 value\n    ) public {\n        _approve(owner, spender, value);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    }
]