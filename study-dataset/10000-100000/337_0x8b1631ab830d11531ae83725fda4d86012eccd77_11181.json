[
    {
        "transactions": 11181,
        "function_num": 337
    },
    {
        "name": "addToWhitelist",
        "visibility": "external",
        "args": [
            {
                "name": "newElement",
                "type": "address"
            }
        ],
        "func": "function addToWhitelist(address newElement) external nonReentrant() onlyOwner {\n        // Ignore if address is already included\n        if (whitelist[newElement] == Status.In) {\n            return;\n        }\n\n        // Only append new addresses to the array, never a duplicate\n        if (whitelist[newElement] == Status.None) {\n            whitelistIndices.push(newElement);\n        }\n\n        whitelist[newElement] = Status.In;\n\n        emit AddedToWhitelist(newElement);\n    }",
        "comments": [
            "/**",
            "     * @notice Adds an address to the whitelist.",
            "     * @param newElement the new address to add.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Adds an address to the whitelist.\n     * @param newElement the new address to add.\n     */\n",
        "@notice": "Adds an address to the whitelist.",
        "@param1": "newElement the new address to add.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeFromWhitelist",
        "visibility": "external",
        "args": [
            {
                "name": "elementToRemove",
                "type": "address"
            }
        ],
        "func": "function removeFromWhitelist(address elementToRemove) external nonReentrant() onlyOwner {\n        if (whitelist[elementToRemove] != Status.Out) {\n            whitelist[elementToRemove] = Status.Out;\n            emit RemovedFromWhitelist(elementToRemove);\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Removes an address from the whitelist.",
            "     * @param elementToRemove the existing address to remove.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Removes an address from the whitelist.\n     * @param elementToRemove the existing address to remove.\n     */\n",
        "@notice": "Removes an address from the whitelist.",
        "@param1": "elementToRemove the existing address to remove.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isOnWhitelist",
        "visibility": "external",
        "args": [
            {
                "name": "elementToCheck",
                "type": "address"
            }
        ],
        "func": "function isOnWhitelist(address elementToCheck) external view nonReentrantView() returns (bool) {\n        return whitelist[elementToCheck] == Status.In;\n    }",
        "comments": [
            "/**",
            "     * @notice Checks whether an address is on the whitelist.",
            "     * @param elementToCheck the address to check.",
            "     * @return True if `elementToCheck` is on the whitelist, or False.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Checks whether an address is on the whitelist.\n     * @param elementToCheck the address to check.\n     * @return True if `elementToCheck` is on the whitelist, or False.\n     */\n",
        "@notice": "Checks whether an address is on the whitelist.",
        "@param1": "elementToCheck the address to check.",
        "@return1": "True if `elementToCheck` is on the whitelist, or False.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getWhitelist",
        "visibility": "external",
        "args": [],
        "func": "function getWhitelist() external view nonReentrantView() returns (address[] memory activeWhitelist) {\n        // Determine size of whitelist first\n        uint256 activeCount = 0;\n        for (uint256 i = 0; i < whitelistIndices.length; i++) {\n            if (whitelist[whitelistIndices[i]] == Status.In) {\n                activeCount++;\n            }\n        }\n\n        // Populate whitelist\n        activeWhitelist = new address[](activeCount);\n        activeCount = 0;\n        for (uint256 i = 0; i < whitelistIndices.length; i++) {\n            address addr = whitelistIndices[i];\n            if (whitelist[addr] == Status.In) {\n                activeWhitelist[activeCount] = addr;\n                activeCount++;\n            }\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Gets all addresses that are currently included in the whitelist.",
            "     * @dev Note: This method skips over, but still iterates through addresses. It is possible for this call to run out",
            "     * of gas if a large number of addresses have been removed. To reduce the likelihood of this unlikely scenario, we",
            "     * can modify the implementation so that when addresses are removed, the last addresses in the array is moved to",
            "     * the empty index.",
            "     * @return activeWhitelist the list of addresses on the whitelist.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets all addresses that are currently included in the whitelist.\n     * @dev Note: This method skips over, but still iterates through addresses. It is possible for this call to run out\n     * of gas if a large number of addresses have been removed. To reduce the likelihood of this unlikely scenario, we\n     * can modify the implementation so that when addresses are removed, the last addresses in the array is moved to\n     * the empty index.\n     * @return activeWhitelist the list of addresses on the whitelist.\n     */\n",
        "@notice": "Gets all addresses that are currently included in the whitelist.",
        "@dev": "Note: This method skips over, but still iterates through addresses. It is possible for this call to run out * of gas if a large number of addresses have been removed. To reduce the likelihood of this unlikely scenario, we * can modify the implementation so that when addresses are removed, the last addresses in the array is moved to * the empty index.",
        "@return1": "activeWhitelist the list of addresses on the whitelist.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "owner",
        "visibility": "public",
        "args": [],
        "func": "function owner() public view returns (address) {\n        return _owner;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the address of the current owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the address of the current owner.\n     */\n",
        "@dev": "Returns the address of the current owner.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "renounceOwnership",
        "visibility": "public",
        "args": [],
        "func": "function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }",
        "comments": [
            "/**",
            "     * @dev Leaves the contract without owner. It will not be possible to call",
            "     * `onlyOwner` functions anymore. Can only be called by the current owner.",
            "     *",
            "     * NOTE: Renouncing ownership will leave the contract without an owner,",
            "     * thereby removing any functionality that is only available to the owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n",
        "@dev": "Leaves the contract without owner. It will not be possible to call * `onlyOwner` functions anymore. Can only be called by the current owner. * * NOTE: Renouncing ownership will leave the contract without an owner, * thereby removing any functionality that is only available to the owner.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferOwnership",
        "visibility": "public",
        "args": [
            {
                "name": "newOwner",
                "type": "address"
            }
        ],
        "func": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }",
        "comments": [
            "/**",
            "     * @dev Transfers ownership of the contract to a new account (`newOwner`).",
            "     * Can only be called by the current owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n",
        "@dev": "Transfers ownership of the contract to a new account (`newOwner`). * Can only be called by the current owner.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "requestPrice",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "timestamp",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            },
            {
                "name": "currency",
                "type": "IERC20"
            },
            {
                "name": "reward",
                "type": "uint256"
            }
        ],
        "func": "function requestPrice(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        IERC20 currency,\n        uint256 reward\n    ) external override nonReentrant() returns (uint256 totalBond) {\n        require(getState(msg.sender, identifier, timestamp, ancillaryData) == State.Invalid, \"requestPrice: Invalid\");\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier), \"Unsupported identifier\");\n        require(_getCollateralWhitelist().isOnWhitelist(address(currency)), \"Unsupported currency\");\n        require(timestamp <= getCurrentTime(), \"Timestamp in future\");\n        require(ancillaryData.length <= ancillaryBytesLimit, \"Invalid ancillary data\");\n        uint256 finalFee = _getStore().computeFinalFee(address(currency)).rawValue;\n        requests[_getId(msg.sender, identifier, timestamp, ancillaryData)] = Request({\n            proposer: address(0),\n            disputer: address(0),\n            currency: currency,\n            settled: false,\n            refundOnDispute: false,\n            proposedPrice: 0,\n            resolvedPrice: 0,\n            expirationTime: 0,\n            reward: reward,\n            finalFee: finalFee,\n            bond: finalFee,\n            customLiveness: 0\n        });\n\n        if (reward > 0) {\n            currency.safeTransferFrom(msg.sender, address(this), reward);\n        }\n\n        emit RequestPrice(msg.sender, identifier, timestamp, ancillaryData, address(currency), reward, finalFee);\n\n        // This function returns the initial proposal bond for this request, which can be customized by calling\n        // setBond() with the same identifier and timestamp.\n        return finalFee.mul(2);\n    }",
        "comments": [
            "/**",
            "     * @notice Requests a new price.",
            "     * @param identifier price identifier being requested.",
            "     * @param timestamp timestamp of the price being requested.",
            "     * @param ancillaryData ancillary data representing additional args being passed with the price request.",
            "     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.",
            "     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,",
            "     *               which could make sense if the contract requests and proposes the value in the same call or",
            "     *               provides its own reward system.",
            "     * @return totalBond default bond (final fee) + final fee that the proposer and disputer will be required to pay.",
            "     * This can be changed with a subsequent call to setBond().",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Requests a new price.\n     * @param identifier price identifier being requested.\n     * @param timestamp timestamp of the price being requested.\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n     *               which could make sense if the contract requests and proposes the value in the same call or\n     *               provides its own reward system.\n     * @return totalBond default bond (final fee) + final fee that the proposer and disputer will be required to pay.\n     * This can be changed with a subsequent call to setBond().\n     */\n",
        "@notice": "Requests a new price.",
        "@param1": "identifier price identifier being requested.",
        "@param2": "timestamp timestamp of the price being requested.",
        "@param3": "ancillaryData ancillary data representing additional args being passed with the price request.",
        "@param4": "currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.",
        "@param5": "reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0, * which could make sense if the contract requests and proposes the value in the same call or * provides its own reward system.",
        "@return1": "totalBond default bond (final fee) + final fee that the proposer and disputer will be required to pay. * This can be changed with a subsequent call to setBond().",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setBond",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "timestamp",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            },
            {
                "name": "bond",
                "type": "uint256"
            }
        ],
        "func": "function setBond(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        uint256 bond\n    ) external override nonReentrant() returns (uint256 totalBond) {\n        require(getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested, \"setBond: Requested\");\n        Request storage request = _getRequest(msg.sender, identifier, timestamp, ancillaryData);\n        request.bond = bond;\n\n        // Total bond is the final fee + the newly set bond.\n        return bond.add(request.finalFee);\n    }",
        "comments": [
            "/**",
            "     * @notice Set the proposal bond associated with a price request.",
            "     * @param identifier price identifier to identify the existing request.",
            "     * @param timestamp timestamp to identify the existing request.",
            "     * @param ancillaryData ancillary data of the price being requested.",
            "     * @param bond custom bond amount to set.",
            "     * @return totalBond new bond + final fee that the proposer and disputer will be required to pay. This can be",
            "     * changed again with a subsequent call to setBond().",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Set the proposal bond associated with a price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param bond custom bond amount to set.\n     * @return totalBond new bond + final fee that the proposer and disputer will be required to pay. This can be\n     * changed again with a subsequent call to setBond().\n     */\n",
        "@notice": "Set the proposal bond associated with a price request.",
        "@param1": "identifier price identifier to identify the existing request.",
        "@param2": "timestamp timestamp to identify the existing request.",
        "@param3": "ancillaryData ancillary data of the price being requested.",
        "@param4": "bond custom bond amount to set.",
        "@return1": "totalBond new bond + final fee that the proposer and disputer will be required to pay. This can be * changed again with a subsequent call to setBond().",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setRefundOnDispute",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "timestamp",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            }
        ],
        "func": "function setRefundOnDispute(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external override nonReentrant() {\n        require(\n            getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested,\n            \"setRefundOnDispute: Requested\"\n        );\n        _getRequest(msg.sender, identifier, timestamp, ancillaryData).refundOnDispute = true;\n    }",
        "comments": [
            "/**",
            "     * @notice Sets the request to refund the reward if the proposal is disputed. This can help to \"hedge\" the caller",
            "     * in the event of a dispute-caused delay. Note: in the event of a dispute, the winner still receives the other's",
            "     * bond, so there is still profit to be made even if the reward is refunded.",
            "     * @param identifier price identifier to identify the existing request.",
            "     * @param timestamp timestamp to identify the existing request.",
            "     * @param ancillaryData ancillary data of the price being requested.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sets the request to refund the reward if the proposal is disputed. This can help to \"hedge\" the caller\n     * in the event of a dispute-caused delay. Note: in the event of a dispute, the winner still receives the other's\n     * bond, so there is still profit to be made even if the reward is refunded.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     */\n",
        "@notice": "Sets the request to refund the reward if the proposal is disputed. This can help to \"hedge\" the caller * in the event of a dispute-caused delay. Note: in the event of a dispute, the winner still receives the other's * bond, so there is still profit to be made even if the reward is refunded.",
        "@param1": "identifier price identifier to identify the existing request.",
        "@param2": "timestamp timestamp to identify the existing request.",
        "@param3": "ancillaryData ancillary data of the price being requested.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "setCustomLiveness",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "timestamp",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            },
            {
                "name": "customLiveness",
                "type": "uint256"
            }
        ],
        "func": "function setCustomLiveness(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        uint256 customLiveness\n    ) external override nonReentrant() {\n        require(\n            getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested,\n            \"setCustomLiveness: Requested\"\n        );\n        _validateLiveness(customLiveness);\n        _getRequest(msg.sender, identifier, timestamp, ancillaryData).customLiveness = customLiveness;\n    }",
        "comments": [
            "/**",
            "     * @notice Sets a custom liveness value for the request. Liveness is the amount of time a proposal must wait before",
            "     * being auto-resolved.",
            "     * @param identifier price identifier to identify the existing request.",
            "     * @param timestamp timestamp to identify the existing request.",
            "     * @param ancillaryData ancillary data of the price being requested.",
            "     * @param customLiveness new custom liveness.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sets a custom liveness value for the request. Liveness is the amount of time a proposal must wait before\n     * being auto-resolved.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param customLiveness new custom liveness.\n     */\n",
        "@notice": "Sets a custom liveness value for the request. Liveness is the amount of time a proposal must wait before * being auto-resolved.",
        "@param1": "identifier price identifier to identify the existing request.",
        "@param2": "timestamp timestamp to identify the existing request.",
        "@param3": "ancillaryData ancillary data of the price being requested.",
        "@param4": "customLiveness new custom liveness.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "proposePriceFor",
        "visibility": "public",
        "args": [
            {
                "name": "proposer",
                "type": "address"
            },
            {
                "name": "requester",
                "type": "address"
            },
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "timestamp",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            },
            {
                "name": "proposedPrice",
                "type": "int256"
            }
        ],
        "func": "function proposePriceFor(\n        address proposer,\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        int256 proposedPrice\n    ) public override nonReentrant() returns (uint256 totalBond) {\n        require(proposer != address(0), \"proposer address must be non 0\");\n        require(\n            getState(requester, identifier, timestamp, ancillaryData) == State.Requested,\n            \"proposePriceFor: Requested\"\n        );\n        Request storage request = _getRequest(requester, identifier, timestamp, ancillaryData);\n        request.proposer = proposer;\n        request.proposedPrice = proposedPrice;\n\n        // If a custom liveness has been set, use it instead of the default.\n        request.expirationTime = getCurrentTime().add(\n            request.customLiveness != 0 ? request.customLiveness : defaultLiveness\n        );\n\n        totalBond = request.bond.add(request.finalFee);\n        if (totalBond > 0) {\n            request.currency.safeTransferFrom(msg.sender, address(this), totalBond);\n        }\n\n        emit ProposePrice(\n            requester,\n            proposer,\n            identifier,\n            timestamp,\n            ancillaryData,\n            proposedPrice,\n            request.expirationTime,\n            address(request.currency)\n        );\n\n        // Callback.\n        if (address(requester).isContract())\n            try OptimisticRequester(requester).priceProposed(identifier, timestamp, ancillaryData) {} catch {}\n    }",
        "comments": [
            "/**",
            "     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come",
            "     * from this proposal. However, any bonds are pulled from the caller.",
            "     * @param proposer address to set as the proposer.",
            "     * @param requester sender of the initial price request.",
            "     * @param identifier price identifier to identify the existing request.",
            "     * @param timestamp timestamp to identify the existing request.",
            "     * @param ancillaryData ancillary data of the price being requested.",
            "     * @param proposedPrice price being proposed.",
            "     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to",
            "     * the proposer once settled if the proposal is correct.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\n     * from this proposal. However, any bonds are pulled from the caller.\n     * @param proposer address to set as the proposer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n",
        "@notice": "Proposes a price value on another address' behalf. Note: this address will receive any rewards that come * from this proposal. However, any bonds are pulled from the caller.",
        "@param1": "proposer address to set as the proposer.",
        "@param2": "requester sender of the initial price request.",
        "@param3": "identifier price identifier to identify the existing request.",
        "@param4": "timestamp timestamp to identify the existing request.",
        "@param5": "ancillaryData ancillary data of the price being requested.",
        "@param6": "proposedPrice price being proposed.",
        "@return1": "totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to * the proposer once settled if the proposal is correct.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "proposePrice",
        "visibility": "external",
        "args": [
            {
                "name": "requester",
                "type": "address"
            },
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "timestamp",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            },
            {
                "name": "proposedPrice",
                "type": "int256"
            }
        ],
        "func": "function proposePrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        int256 proposedPrice\n    ) external override returns (uint256 totalBond) {\n        // Note: re-entrancy guard is done in the inner call.\n        return proposePriceFor(msg.sender, requester, identifier, timestamp, ancillaryData, proposedPrice);\n    }",
        "comments": [
            "/**",
            "     * @notice Proposes a price value for an existing price request.",
            "     * @param requester sender of the initial price request.",
            "     * @param identifier price identifier to identify the existing request.",
            "     * @param timestamp timestamp to identify the existing request.",
            "     * @param ancillaryData ancillary data of the price being requested.",
            "     * @param proposedPrice price being proposed.",
            "     * @return totalBond the amount that's pulled from the proposer's wallet as a bond. The bond will be returned to",
            "     * the proposer once settled if the proposal is correct.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Proposes a price value for an existing price request.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param proposedPrice price being proposed.\n     * @return totalBond the amount that's pulled from the proposer's wallet as a bond. The bond will be returned to\n     * the proposer once settled if the proposal is correct.\n     */\n",
        "@notice": "Proposes a price value for an existing price request.",
        "@param1": "requester sender of the initial price request.",
        "@param2": "identifier price identifier to identify the existing request.",
        "@param3": "timestamp timestamp to identify the existing request.",
        "@param4": "ancillaryData ancillary data of the price being requested.",
        "@param5": "proposedPrice price being proposed.",
        "@return1": "totalBond the amount that's pulled from the proposer's wallet as a bond. The bond will be returned to * the proposer once settled if the proposal is correct.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "disputePriceFor",
        "visibility": "public",
        "args": [
            {
                "name": "disputer",
                "type": "address"
            },
            {
                "name": "requester",
                "type": "address"
            },
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "timestamp",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            }
        ],
        "func": "function disputePriceFor(\n        address disputer,\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public override nonReentrant() returns (uint256 totalBond) {\n        require(disputer != address(0), \"disputer address must be non 0\");\n        require(\n            getState(requester, identifier, timestamp, ancillaryData) == State.Proposed,\n            \"disputePriceFor: Proposed\"\n        );\n        Request storage request = _getRequest(requester, identifier, timestamp, ancillaryData);\n        request.disputer = disputer;\n\n        uint256 finalFee = request.finalFee;\n        uint256 bond = request.bond;\n        totalBond = bond.add(finalFee);\n        if (totalBond > 0) {\n            request.currency.safeTransferFrom(msg.sender, address(this), totalBond);\n        }\n\n        StoreInterface store = _getStore();\n\n        // Avoids stack too deep compilation error.\n        {\n            // Along with the final fee, \"burn\" part of the loser's bond to ensure that a larger bond always makes it\n            // proportionally more expensive to delay the resolution even if the proposer and disputer are the same\n            // party.\n            uint256 burnedBond = _computeBurnedBond(request);\n\n            // The total fee is the burned bond and the final fee added together.\n            uint256 totalFee = finalFee.add(burnedBond);\n\n            if (totalFee > 0) {\n                request.currency.safeIncreaseAllowance(address(store), totalFee);\n                _getStore().payOracleFeesErc20(address(request.currency), FixedPoint.Unsigned(totalFee));\n            }\n        }\n\n        _getOracle().requestPrice(identifier, timestamp, _stampAncillaryData(ancillaryData, requester));\n\n        // Compute refund.\n        uint256 refund = 0;\n        if (request.reward > 0 && request.refundOnDispute) {\n            refund = request.reward;\n            request.reward = 0;\n            request.currency.safeTransfer(requester, refund);\n        }\n\n        emit DisputePrice(\n            requester,\n            request.proposer,\n            disputer,\n            identifier,\n            timestamp,\n            ancillaryData,\n            request.proposedPrice\n        );\n\n        // Callback.\n        if (address(requester).isContract())\n            try OptimisticRequester(requester).priceDisputed(identifier, timestamp, ancillaryData, refund) {} catch {}\n    }",
        "comments": [
            "/**",
            "     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will",
            "     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.",
            "     * @param disputer address to set as the disputer.",
            "     * @param requester sender of the initial price request.",
            "     * @param identifier price identifier to identify the existing request.",
            "     * @param timestamp timestamp to identify the existing request.",
            "     * @param ancillaryData ancillary data of the price being requested.",
            "     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to",
            "     * the disputer once settled if the dispute was valid (the proposal was incorrect).",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\n     * @param disputer address to set as the disputer.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\n     */\n",
        "@notice": "Disputes a price request with an active proposal on another address' behalf. Note: this address will * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.",
        "@param1": "disputer address to set as the disputer.",
        "@param2": "requester sender of the initial price request.",
        "@param3": "identifier price identifier to identify the existing request.",
        "@param4": "timestamp timestamp to identify the existing request.",
        "@param5": "ancillaryData ancillary data of the price being requested.",
        "@return1": "totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to * the disputer once settled if the dispute was valid (the proposal was incorrect).",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "disputePrice",
        "visibility": "external",
        "args": [
            {
                "name": "requester",
                "type": "address"
            },
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "timestamp",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            }
        ],
        "func": "function disputePrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external override returns (uint256 totalBond) {\n        // Note: re-entrancy guard is done in the inner call.\n        return disputePriceFor(msg.sender, requester, identifier, timestamp, ancillaryData);\n    }",
        "comments": [
            "/**",
            "     * @notice Disputes a price value for an existing price request with an active proposal.",
            "     * @param requester sender of the initial price request.",
            "     * @param identifier price identifier to identify the existing request.",
            "     * @param timestamp timestamp to identify the existing request.",
            "     * @param ancillaryData ancillary data of the price being requested.",
            "     * @return totalBond the amount that's pulled from the disputer's wallet as a bond. The bond will be returned to",
            "     * the disputer once settled if the dispute was valid (the proposal was incorrect).",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Disputes a price value for an existing price request with an active proposal.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return totalBond the amount that's pulled from the disputer's wallet as a bond. The bond will be returned to\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\n     */\n",
        "@notice": "Disputes a price value for an existing price request with an active proposal.",
        "@param1": "requester sender of the initial price request.",
        "@param2": "identifier price identifier to identify the existing request.",
        "@param3": "timestamp timestamp to identify the existing request.",
        "@param4": "ancillaryData ancillary data of the price being requested.",
        "@return1": "totalBond the amount that's pulled from the disputer's wallet as a bond. The bond will be returned to * the disputer once settled if the dispute was valid (the proposal was incorrect).",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "settleAndGetPrice",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "timestamp",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            }
        ],
        "func": "function settleAndGetPrice(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external override nonReentrant() returns (int256) {\n        if (getState(msg.sender, identifier, timestamp, ancillaryData) != State.Settled) {\n            _settle(msg.sender, identifier, timestamp, ancillaryData);\n        }\n\n        return _getRequest(msg.sender, identifier, timestamp, ancillaryData).resolvedPrice;\n    }",
        "comments": [
            "/**",
            "     * @notice Retrieves a price that was previously requested by a caller. Reverts if the request is not settled",
            "     * or settleable. Note: this method is not view so that this call may actually settle the price request if it",
            "     * hasn't been settled.",
            "     * @param identifier price identifier to identify the existing request.",
            "     * @param timestamp timestamp to identify the existing request.",
            "     * @param ancillaryData ancillary data of the price being requested.",
            "     * @return resolved price.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Retrieves a price that was previously requested by a caller. Reverts if the request is not settled\n     * or settleable. Note: this method is not view so that this call may actually settle the price request if it\n     * hasn't been settled.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return resolved price.\n     */\n",
        "@notice": "Retrieves a price that was previously requested by a caller. Reverts if the request is not settled * or settleable. Note: this method is not view so that this call may actually settle the price request if it * hasn't been settled.",
        "@param1": "identifier price identifier to identify the existing request.",
        "@param2": "timestamp timestamp to identify the existing request.",
        "@param3": "ancillaryData ancillary data of the price being requested.",
        "@return1": "resolved price.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "settle",
        "visibility": "external",
        "args": [
            {
                "name": "requester",
                "type": "address"
            },
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "timestamp",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            }
        ],
        "func": "function settle(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external override nonReentrant() returns (uint256 payout) {\n        return _settle(requester, identifier, timestamp, ancillaryData);\n    }",
        "comments": [
            "/**",
            "     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.",
            "     * @param requester sender of the initial price request.",
            "     * @param identifier price identifier to identify the existing request.",
            "     * @param timestamp timestamp to identify the existing request.",
            "     * @param ancillaryData ancillary data of the price being requested.",
            "     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes",
            "     * the returned bonds as well as additional rewards.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\n     * the returned bonds as well as additional rewards.\n     */\n",
        "@notice": "Attempts to settle an outstanding price request. Will revert if it isn't settleable.",
        "@param1": "requester sender of the initial price request.",
        "@param2": "identifier price identifier to identify the existing request.",
        "@param3": "timestamp timestamp to identify the existing request.",
        "@param4": "ancillaryData ancillary data of the price being requested.",
        "@return1": "payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes * the returned bonds as well as additional rewards.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getRequest",
        "visibility": "public",
        "args": [
            {
                "name": "requester",
                "type": "address"
            },
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "timestamp",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            }
        ],
        "func": "function getRequest(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public view override returns (Request memory) {\n        return _getRequest(requester, identifier, timestamp, ancillaryData);\n    }",
        "comments": [
            "/**",
            "     * @notice Gets the current data structure containing all information about a price request.",
            "     * @param requester sender of the initial price request.",
            "     * @param identifier price identifier to identify the existing request.",
            "     * @param timestamp timestamp to identify the existing request.",
            "     * @param ancillaryData ancillary data of the price being requested.",
            "     * @return the Request data structure.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets the current data structure containing all information about a price request.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return the Request data structure.\n     */\n",
        "@notice": "Gets the current data structure containing all information about a price request.",
        "@param1": "requester sender of the initial price request.",
        "@param2": "identifier price identifier to identify the existing request.",
        "@param3": "timestamp timestamp to identify the existing request.",
        "@param4": "ancillaryData ancillary data of the price being requested.",
        "@return1": "the Request data structure.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getState",
        "visibility": "public",
        "args": [
            {
                "name": "requester",
                "type": "address"
            },
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "timestamp",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            }
        ],
        "func": "function getState(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public view override returns (State) {\n        Request storage request = _getRequest(requester, identifier, timestamp, ancillaryData);\n\n        if (address(request.currency) == address(0)) {\n            return State.Invalid;\n        }\n\n        if (request.proposer == address(0)) {\n            return State.Requested;\n        }\n\n        if (request.settled) {\n            return State.Settled;\n        }\n\n        if (request.disputer == address(0)) {\n            return request.expirationTime <= getCurrentTime() ? State.Expired : State.Proposed;\n        }\n\n        return\n            _getOracle().hasPrice(identifier, timestamp, _stampAncillaryData(ancillaryData, requester))\n                ? State.Resolved\n                : State.Disputed;\n    }",
        "comments": [
            "/**",
            "     * @notice Computes the current state of a price request. See the State enum for more details.",
            "     * @param requester sender of the initial price request.",
            "     * @param identifier price identifier to identify the existing request.",
            "     * @param timestamp timestamp to identify the existing request.",
            "     * @param ancillaryData ancillary data of the price being requested.",
            "     * @return the State.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Computes the current state of a price request. See the State enum for more details.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return the State.\n     */\n",
        "@notice": "Computes the current state of a price request. See the State enum for more details.",
        "@param1": "requester sender of the initial price request.",
        "@param2": "identifier price identifier to identify the existing request.",
        "@param3": "timestamp timestamp to identify the existing request.",
        "@param4": "ancillaryData ancillary data of the price being requested.",
        "@return1": "the State.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "hasPrice",
        "visibility": "public",
        "args": [
            {
                "name": "requester",
                "type": "address"
            },
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "timestamp",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            }
        ],
        "func": "function hasPrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public view override returns (bool) {\n        State state = getState(requester, identifier, timestamp, ancillaryData);\n        return state == State.Settled || state == State.Resolved || state == State.Expired;\n    }",
        "comments": [
            "/**",
            "     * @notice Checks if a given request has resolved, expired or been settled (i.e the optimistic oracle has a price).",
            "     * @param requester sender of the initial price request.",
            "     * @param identifier price identifier to identify the existing request.",
            "     * @param timestamp timestamp to identify the existing request.",
            "     * @param ancillaryData ancillary data of the price being requested.",
            "     * @return boolean indicating true if price exists and false if not.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Checks if a given request has resolved, expired or been settled (i.e the optimistic oracle has a price).\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return boolean indicating true if price exists and false if not.\n     */\n",
        "@notice": "Checks if a given request has resolved, expired or been settled (i.e the optimistic oracle has a price).",
        "@param1": "requester sender of the initial price request.",
        "@param2": "identifier price identifier to identify the existing request.",
        "@param3": "timestamp timestamp to identify the existing request.",
        "@param4": "ancillaryData ancillary data of the price being requested.",
        "@return1": "boolean indicating true if price exists and false if not.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stampAncillaryData",
        "visibility": "public",
        "args": [
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            },
            {
                "name": "requester",
                "type": "address"
            }
        ],
        "func": "function stampAncillaryData(bytes memory ancillaryData, address requester) public pure returns (bytes memory) {\n        return _stampAncillaryData(ancillaryData, requester);\n    }",
        "comments": [
            "/**",
            "     * @notice Generates stamped ancillary data in the format that it would be used in the case of a price dispute.",
            "     * @param ancillaryData ancillary data of the price being requested.",
            "     * @param requester sender of the initial price request.",
            "     * @return the stampped ancillary bytes.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Generates stamped ancillary data in the format that it would be used in the case of a price dispute.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param requester sender of the initial price request.\n     * @return the stampped ancillary bytes.\n     */\n",
        "@notice": "Generates stamped ancillary data in the format that it would be used in the case of a price dispute.",
        "@param1": "ancillaryData ancillary data of the price being requested.",
        "@param2": "requester sender of the initial price request.",
        "@return1": "the stampped ancillary bytes.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setCurrentTime",
        "visibility": "external",
        "args": [
            {
                "name": "time",
                "type": "uint256"
            }
        ],
        "func": "function setCurrentTime(uint256 time) external onlyIfTest {\n        Timer(timerAddress).setCurrentTime(time);\n    }",
        "comments": [
            "/**",
            "     * @notice Sets the current time.",
            "     * @dev Will revert if not running in test mode.",
            "     * @param time timestamp to set current Testable time to.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sets the current time.\n     * @dev Will revert if not running in test mode.\n     * @param time timestamp to set current Testable time to.\n     */\n",
        "@notice": "Sets the current time.",
        "@dev": "Will revert if not running in test mode.",
        "@param1": "time timestamp to set current Testable time to.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentTime",
        "visibility": "public",
        "args": [],
        "func": "function getCurrentTime() public view returns (uint256) {\n        if (timerAddress != address(0x0)) {\n            return Timer(timerAddress).getCurrentTime();\n        } else {\n            return now; // solhint-disable-line not-rely-on-time\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.",
            "     * Otherwise, it will return the block timestamp.",
            "     * @return uint for the current Testable timestamp.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\n     * Otherwise, it will return the block timestamp.\n     * @return uint for the current Testable timestamp.\n     */\n",
        "@notice": "Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode. * Otherwise, it will return the block timestamp.",
        "@return1": "uint for the current Testable timestamp.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setCurrentTime",
        "visibility": "external",
        "args": [
            {
                "name": "time",
                "type": "uint256"
            }
        ],
        "func": "function setCurrentTime(uint256 time) external {\n        currentTime = time;\n    }",
        "comments": [
            "/**",
            "     * @notice Sets the current time.",
            "     * @dev Will revert if not running in test mode.",
            "     * @param time timestamp to set `currentTime` to.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sets the current time.\n     * @dev Will revert if not running in test mode.\n     * @param time timestamp to set `currentTime` to.\n     */\n",
        "@notice": "Sets the current time.",
        "@dev": "Will revert if not running in test mode.",
        "@param1": "time timestamp to set `currentTime` to.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentTime",
        "visibility": "public",
        "args": [],
        "func": "function getCurrentTime() public view returns (uint256) {\n        return currentTime;\n    }",
        "comments": [
            "/**",
            "     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.",
            "     * Otherwise, it will return the block timestamp.",
            "     * @return uint256 for the current Testable timestamp.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\n     * Otherwise, it will return the block timestamp.\n     * @return uint256 for the current Testable timestamp.\n     */\n",
        "@notice": "Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode. * Otherwise, it will return the block timestamp.",
        "@return1": "uint256 for the current Testable timestamp.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "requestPrice",
        "visibility": "external",
        "args": [
            {
                "name": "_identifier",
                "type": "bytes32"
            },
            {
                "name": "_timestamp",
                "type": "uint256"
            },
            {
                "name": "_ancillaryData",
                "type": "bytes memory"
            },
            {
                "name": "currency",
                "type": "IERC20"
            },
            {
                "name": "reward",
                "type": "uint256"
            }
        ],
        "func": "function requestPrice(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes memory _ancillaryData,\n        IERC20 currency,\n        uint256 reward\n    ) external {\n        currency.approve(address(optimisticOracle), reward);\n        optimisticOracle.requestPrice(_identifier, _timestamp, _ancillaryData, currency, reward);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "settleAndGetPrice",
        "visibility": "external",
        "args": [
            {
                "name": "_identifier",
                "type": "bytes32"
            },
            {
                "name": "_timestamp",
                "type": "uint256"
            },
            {
                "name": "_ancillaryData",
                "type": "bytes memory"
            }
        ],
        "func": "function settleAndGetPrice(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes memory _ancillaryData\n    ) external returns (int256) {\n        return optimisticOracle.settleAndGetPrice(_identifier, _timestamp, _ancillaryData);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setBond",
        "visibility": "external",
        "args": [
            {
                "name": "_identifier",
                "type": "bytes32"
            },
            {
                "name": "_timestamp",
                "type": "uint256"
            },
            {
                "name": "_ancillaryData",
                "type": "bytes memory"
            },
            {
                "name": "bond",
                "type": "uint256"
            }
        ],
        "func": "function setBond(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes memory _ancillaryData,\n        uint256 bond\n    ) external {\n        optimisticOracle.setBond(_identifier, _timestamp, _ancillaryData, bond);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setRefundOnDispute",
        "visibility": "external",
        "args": [
            {
                "name": "_identifier",
                "type": "bytes32"
            },
            {
                "name": "_timestamp",
                "type": "uint256"
            },
            {
                "name": "_ancillaryData",
                "type": "bytes memory"
            }
        ],
        "func": "function setRefundOnDispute(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes memory _ancillaryData\n    ) external {\n        optimisticOracle.setRefundOnDispute(_identifier, _timestamp, _ancillaryData);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setCustomLiveness",
        "visibility": "external",
        "args": [
            {
                "name": "_identifier",
                "type": "bytes32"
            },
            {
                "name": "_timestamp",
                "type": "uint256"
            },
            {
                "name": "_ancillaryData",
                "type": "bytes memory"
            },
            {
                "name": "customLiveness",
                "type": "uint256"
            }
        ],
        "func": "function setCustomLiveness(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes memory _ancillaryData,\n        uint256 customLiveness\n    ) external {\n        optimisticOracle.setCustomLiveness(_identifier, _timestamp, _ancillaryData, customLiveness);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setRevert",
        "visibility": "external",
        "args": [
            {
                "name": "_shouldRevert",
                "type": "bool"
            }
        ],
        "func": "function setRevert(bool _shouldRevert) external {\n        shouldRevert = _shouldRevert;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "clearState",
        "visibility": "external",
        "args": [],
        "func": "function clearState() external {\n        delete identifier;\n        delete timestamp;\n        delete refund;\n        delete price;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "priceProposed",
        "visibility": "external",
        "args": [
            {
                "name": "_identifier",
                "type": "bytes32"
            },
            {
                "name": "_timestamp",
                "type": "uint256"
            },
            {
                "name": "_ancillaryData",
                "type": "bytes memory"
            }
        ],
        "func": "function priceProposed(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes memory _ancillaryData\n    ) external override {\n        require(!shouldRevert);\n        identifier = _identifier;\n        timestamp = _timestamp;\n        ancillaryData = _ancillaryData;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "priceDisputed",
        "visibility": "external",
        "args": [
            {
                "name": "_identifier",
                "type": "bytes32"
            },
            {
                "name": "_timestamp",
                "type": "uint256"
            },
            {
                "name": "_ancillaryData",
                "type": "bytes memory"
            },
            {
                "name": "_refund",
                "type": "uint256"
            }
        ],
        "func": "function priceDisputed(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes memory _ancillaryData,\n        uint256 _refund\n    ) external override {\n        require(!shouldRevert);\n        identifier = _identifier;\n        timestamp = _timestamp;\n        ancillaryData = _ancillaryData;\n        refund = _refund;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "priceSettled",
        "visibility": "external",
        "args": [
            {
                "name": "_identifier",
                "type": "bytes32"
            },
            {
                "name": "_timestamp",
                "type": "uint256"
            },
            {
                "name": "_ancillaryData",
                "type": "bytes memory"
            },
            {
                "name": "_price",
                "type": "int256"
            }
        ],
        "func": "function priceSettled(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes memory _ancillaryData,\n        int256 _price\n    ) external override {\n        require(!shouldRevert);\n        identifier = _identifier;\n        timestamp = _timestamp;\n        ancillaryData = _ancillaryData;\n        price = _price;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "payOracleFees",
        "visibility": "external",
        "args": [],
        "func": "function payOracleFees() external payable override {\n        require(msg.value > 0, \"Value sent can't be zero\");\n    }",
        "comments": [
            "/**",
            "     * @notice Pays Oracle fees in ETH to the store.",
            "     * @dev To be used by contracts whose margin currency is ETH.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Pays Oracle fees in ETH to the store.\n     * @dev To be used by contracts whose margin currency is ETH.\n     */\n",
        "@notice": "Pays Oracle fees in ETH to the store.",
        "@dev": "To be used by contracts whose margin currency is ETH.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "payOracleFeesErc20",
        "visibility": "external",
        "args": [
            {
                "name": "erc20Address",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "FixedPoint.Unsigned calldata"
            }
        ],
        "func": "function payOracleFeesErc20(address erc20Address, FixedPoint.Unsigned calldata amount) external override {\n        IERC20 erc20 = IERC20(erc20Address);\n        require(amount.isGreaterThan(0), \"Amount sent can't be zero\");\n        erc20.safeTransferFrom(msg.sender, address(this), amount.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Pays oracle fees in the margin currency, erc20Address, to the store.",
            "     * @dev To be used if the margin currency is an ERC20 token rather than ETH.",
            "     * @param erc20Address address of the ERC20 token used to pay the fee.",
            "     * @param amount number of tokens to transfer. An approval for at least this amount must exist.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Pays oracle fees in the margin currency, erc20Address, to the store.\n     * @dev To be used if the margin currency is an ERC20 token rather than ETH.\n     * @param erc20Address address of the ERC20 token used to pay the fee.\n     * @param amount number of tokens to transfer. An approval for at least this amount must exist.\n     */\n",
        "@notice": "Pays oracle fees in the margin currency, erc20Address, to the store.",
        "@dev": "To be used if the margin currency is an ERC20 token rather than ETH.",
        "@param1": "erc20Address address of the ERC20 token used to pay the fee.",
        "@param2": "amount number of tokens to transfer. An approval for at least this amount must exist.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "computeRegularFee",
        "visibility": "external",
        "args": [
            {
                "name": "startTime",
                "type": "uint256"
            },
            {
                "name": "endTime",
                "type": "uint256"
            },
            {
                "name": "pfc",
                "type": "FixedPoint.Unsigned calldata"
            }
        ],
        "func": "function computeRegularFee(\n        uint256 startTime,\n        uint256 endTime,\n        FixedPoint.Unsigned calldata pfc\n    ) external view override returns (FixedPoint.Unsigned memory regularFee, FixedPoint.Unsigned memory latePenalty) {\n        uint256 timeDiff = endTime.sub(startTime);\n\n        // Multiply by the unscaled `timeDiff` first, to get more accurate results.\n        regularFee = pfc.mul(timeDiff).mul(fixedOracleFeePerSecondPerPfc);\n\n        // Compute how long ago the start time was to compute the delay penalty.\n        uint256 paymentDelay = getCurrentTime().sub(startTime);\n\n        // Compute the additional percentage (per second) that will be charged because of the penalty.\n        // Note: if less than a week has gone by since the startTime, paymentDelay / SECONDS_PER_WEEK will truncate to\n        // 0, causing no penalty to be charged.\n        FixedPoint.Unsigned memory penaltyPercentagePerSecond =\n            weeklyDelayFeePerSecondPerPfc.mul(paymentDelay.div(SECONDS_PER_WEEK));\n\n        // Apply the penaltyPercentagePerSecond to the payment period.\n        latePenalty = pfc.mul(timeDiff).mul(penaltyPercentagePerSecond);\n    }",
        "comments": [
            "/**",
            "     * @notice Computes the regular oracle fees that a contract should pay for a period.",
            "     * @dev The late penalty is similar to the regular fee in that is is charged per second over the period between",
            "     * startTime and endTime.",
            "     *",
            "     * The late penalty percentage increases over time as follows:",
            "     *",
            "     * - 0-1 week since startTime: no late penalty",
            "     *",
            "     * - 1-2 weeks since startTime: 1x late penalty percentage is applied",
            "     *",
            "     * - 2-3 weeks since startTime: 2x late penalty percentage is applied",
            "     *",
            "     * - ...",
            "     *",
            "     * @param startTime defines the beginning time from which the fee is paid.",
            "     * @param endTime end time until which the fee is paid.",
            "     * @param pfc \"profit from corruption\", or the maximum amount of margin currency that a",
            "     * token sponsor could extract from the contract through corrupting the price feed in their favor.",
            "     * @return regularFee amount owed for the duration from start to end time for the given pfc.",
            "     * @return latePenalty penalty percentage, if any, for paying the fee after the deadline.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Computes the regular oracle fees that a contract should pay for a period.\n     * @dev The late penalty is similar to the regular fee in that is is charged per second over the period between\n     * startTime and endTime.\n     *\n     * The late penalty percentage increases over time as follows:\n     *\n     * - 0-1 week since startTime: no late penalty\n     *\n     * - 1-2 weeks since startTime: 1x late penalty percentage is applied\n     *\n     * - 2-3 weeks since startTime: 2x late penalty percentage is applied\n     *\n     * - ...\n     *\n     * @param startTime defines the beginning time from which the fee is paid.\n     * @param endTime end time until which the fee is paid.\n     * @param pfc \"profit from corruption\", or the maximum amount of margin currency that a\n     * token sponsor could extract from the contract through corrupting the price feed in their favor.\n     * @return regularFee amount owed for the duration from start to end time for the given pfc.\n     * @return latePenalty penalty percentage, if any, for paying the fee after the deadline.\n     */\n",
        "@notice": "Computes the regular oracle fees that a contract should pay for a period.",
        "@dev": "The late penalty is similar to the regular fee in that is is charged per second over the period between * startTime and endTime. * * The late penalty percentage increases over time as follows: * * - 0-1 week since startTime: no late penalty * * - 1-2 weeks since startTime: 1x late penalty percentage is applied * * - 2-3 weeks since startTime: 2x late penalty percentage is applied * * - ...",
        "@param1": "startTime defines the beginning time from which the fee is paid.",
        "@param2": "endTime end time until which the fee is paid.",
        "@param3": "pfc \"profit from corruption\", or the maximum amount of margin currency that a * token sponsor could extract from the contract through corrupting the price feed in their favor.",
        "@return1": "regularFee amount owed for the duration from start to end time for the given pfc.",
        "@return2": "latePenalty penalty percentage, if any, for paying the fee after the deadline.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "computeFinalFee",
        "visibility": "external",
        "args": [
            {
                "name": "currency",
                "type": "address"
            }
        ],
        "func": "function computeFinalFee(address currency) external view override returns (FixedPoint.Unsigned memory) {\n        return finalFees[currency];\n    }",
        "comments": [
            "/**",
            "     * @notice Computes the final oracle fees that a contract should pay at settlement.",
            "     * @param currency token used to pay the final fee.",
            "     * @return finalFee amount due denominated in units of `currency`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Computes the final oracle fees that a contract should pay at settlement.\n     * @param currency token used to pay the final fee.\n     * @return finalFee amount due denominated in units of `currency`.\n     */\n",
        "@notice": "Computes the final oracle fees that a contract should pay at settlement.",
        "@param1": "currency token used to pay the final fee.",
        "@return1": "finalFee amount due denominated in units of `currency`.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setFixedOracleFeePerSecondPerPfc",
        "visibility": "public",
        "args": [
            {
                "name": "newFixedOracleFeePerSecondPerPfc",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function setFixedOracleFeePerSecondPerPfc(FixedPoint.Unsigned memory newFixedOracleFeePerSecondPerPfc)\n        public\n        onlyRoleHolder(uint256(Roles.Owner))\n    {\n        // Oracle fees at or over 100% don't make sense.\n        require(newFixedOracleFeePerSecondPerPfc.isLessThan(1), \"Fee must be < 100% per second.\");\n        fixedOracleFeePerSecondPerPfc = newFixedOracleFeePerSecondPerPfc;\n        emit NewFixedOracleFeePerSecondPerPfc(newFixedOracleFeePerSecondPerPfc);\n    }",
        "comments": [
            "/**",
            "     * @notice Sets a new oracle fee per second.",
            "     * @param newFixedOracleFeePerSecondPerPfc new fee per second charged to use the oracle.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sets a new oracle fee per second.\n     * @param newFixedOracleFeePerSecondPerPfc new fee per second charged to use the oracle.\n     */\n",
        "@notice": "Sets a new oracle fee per second.",
        "@param1": "newFixedOracleFeePerSecondPerPfc new fee per second charged to use the oracle.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setWeeklyDelayFeePerSecondPerPfc",
        "visibility": "public",
        "args": [
            {
                "name": "newWeeklyDelayFeePerSecondPerPfc",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function setWeeklyDelayFeePerSecondPerPfc(FixedPoint.Unsigned memory newWeeklyDelayFeePerSecondPerPfc)\n        public\n        onlyRoleHolder(uint256(Roles.Owner))\n    {\n        require(newWeeklyDelayFeePerSecondPerPfc.isLessThan(1), \"weekly delay fee must be < 100%\");\n        weeklyDelayFeePerSecondPerPfc = newWeeklyDelayFeePerSecondPerPfc;\n        emit NewWeeklyDelayFeePerSecondPerPfc(newWeeklyDelayFeePerSecondPerPfc);\n    }",
        "comments": [
            "/**",
            "     * @notice Sets a new weekly delay fee.",
            "     * @param newWeeklyDelayFeePerSecondPerPfc fee escalation per week of late fee payment.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sets a new weekly delay fee.\n     * @param newWeeklyDelayFeePerSecondPerPfc fee escalation per week of late fee payment.\n     */\n",
        "@notice": "Sets a new weekly delay fee.",
        "@param1": "newWeeklyDelayFeePerSecondPerPfc fee escalation per week of late fee payment.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setFinalFee",
        "visibility": "public",
        "args": [
            {
                "name": "currency",
                "type": "address"
            },
            {
                "name": "newFinalFee",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function setFinalFee(address currency, FixedPoint.Unsigned memory newFinalFee)\n        public\n        onlyRoleHolder(uint256(Roles.Owner))\n    {\n        finalFees[currency] = newFinalFee;\n        emit NewFinalFee(newFinalFee);\n    }",
        "comments": [
            "/**",
            "     * @notice Sets a new final fee for a particular currency.",
            "     * @param currency defines the token currency used to pay the final fee.",
            "     * @param newFinalFee final fee amount.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sets a new final fee for a particular currency.\n     * @param currency defines the token currency used to pay the final fee.\n     * @param newFinalFee final fee amount.\n     */\n",
        "@notice": "Sets a new final fee for a particular currency.",
        "@param1": "currency defines the token currency used to pay the final fee.",
        "@param2": "newFinalFee final fee amount.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "holdsRole",
        "visibility": "public",
        "args": [
            {
                "name": "roleId",
                "type": "uint256"
            },
            {
                "name": "memberToCheck",
                "type": "address"
            }
        ],
        "func": "function holdsRole(uint256 roleId, address memberToCheck) public view returns (bool) {\n        Role storage role = roles[roleId];\n        if (role.roleType == RoleType.Exclusive) {\n            return role.exclusiveRoleMembership.isMember(memberToCheck);\n        } else if (role.roleType == RoleType.Shared) {\n            return role.sharedRoleMembership.isMember(memberToCheck);\n        }\n        revert(\"Invalid roleId\");\n    }",
        "comments": [
            "/**",
            "     * @notice Whether `memberToCheck` is a member of roleId.",
            "     * @dev Reverts if roleId does not correspond to an initialized role.",
            "     * @param roleId the Role to check.",
            "     * @param memberToCheck the address to check.",
            "     * @return True if `memberToCheck` is a member of `roleId`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Whether `memberToCheck` is a member of roleId.\n     * @dev Reverts if roleId does not correspond to an initialized role.\n     * @param roleId the Role to check.\n     * @param memberToCheck the address to check.\n     * @return True if `memberToCheck` is a member of `roleId`.\n     */\n",
        "@notice": "Whether `memberToCheck` is a member of roleId.",
        "@dev": "Reverts if roleId does not correspond to an initialized role.",
        "@param1": "roleId the Role to check.",
        "@param2": "memberToCheck the address to check.",
        "@return1": "True if `memberToCheck` is a member of `roleId`.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "resetMember",
        "visibility": "public",
        "args": [
            {
                "name": "roleId",
                "type": "uint256"
            },
            {
                "name": "newMember",
                "type": "address"
            }
        ],
        "func": "function resetMember(uint256 roleId, address newMember) public onlyExclusive(roleId) onlyRoleManager(roleId) {\n        roles[roleId].exclusiveRoleMembership.resetMember(newMember);\n        emit ResetExclusiveMember(roleId, newMember, msg.sender);\n    }",
        "comments": [
            "/**",
            "     * @notice Changes the exclusive role holder of `roleId` to `newMember`.",
            "     * @dev Reverts if the caller is not a member of the managing role for `roleId` or if `roleId` is not an",
            "     * initialized, ExclusiveRole.",
            "     * @param roleId the ExclusiveRole membership to modify.",
            "     * @param newMember the new ExclusiveRole member.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Changes the exclusive role holder of `roleId` to `newMember`.\n     * @dev Reverts if the caller is not a member of the managing role for `roleId` or if `roleId` is not an\n     * initialized, ExclusiveRole.\n     * @param roleId the ExclusiveRole membership to modify.\n     * @param newMember the new ExclusiveRole member.\n     */\n",
        "@notice": "Changes the exclusive role holder of `roleId` to `newMember`.",
        "@dev": "Reverts if the caller is not a member of the managing role for `roleId` or if `roleId` is not an * initialized, ExclusiveRole.",
        "@param1": "roleId the ExclusiveRole membership to modify.",
        "@param2": "newMember the new ExclusiveRole member.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMember",
        "visibility": "public",
        "args": [
            {
                "name": "roleId",
                "type": "uint256"
            }
        ],
        "func": "function getMember(uint256 roleId) public view onlyExclusive(roleId) returns (address) {\n        return roles[roleId].exclusiveRoleMembership.getMember();\n    }",
        "comments": [
            "/**",
            "     * @notice Gets the current holder of the exclusive role, `roleId`.",
            "     * @dev Reverts if `roleId` does not represent an initialized, exclusive role.",
            "     * @param roleId the ExclusiveRole membership to check.",
            "     * @return the address of the current ExclusiveRole member.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets the current holder of the exclusive role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, exclusive role.\n     * @param roleId the ExclusiveRole membership to check.\n     * @return the address of the current ExclusiveRole member.\n     */\n",
        "@notice": "Gets the current holder of the exclusive role, `roleId`.",
        "@dev": "Reverts if `roleId` does not represent an initialized, exclusive role.",
        "@param1": "roleId the ExclusiveRole membership to check.",
        "@return1": "the address of the current ExclusiveRole member.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addMember",
        "visibility": "public",
        "args": [
            {
                "name": "roleId",
                "type": "uint256"
            },
            {
                "name": "newMember",
                "type": "address"
            }
        ],
        "func": "function addMember(uint256 roleId, address newMember) public onlyShared(roleId) onlyRoleManager(roleId) {\n        roles[roleId].sharedRoleMembership.addMember(newMember);\n        emit AddedSharedMember(roleId, newMember, msg.sender);\n    }",
        "comments": [
            "/**",
            "     * @notice Adds `newMember` to the shared role, `roleId`.",
            "     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the",
            "     * managing role for `roleId`.",
            "     * @param roleId the SharedRole membership to modify.",
            "     * @param newMember the new SharedRole member.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Adds `newMember` to the shared role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\n     * managing role for `roleId`.\n     * @param roleId the SharedRole membership to modify.\n     * @param newMember the new SharedRole member.\n     */\n",
        "@notice": "Adds `newMember` to the shared role, `roleId`.",
        "@dev": "Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the * managing role for `roleId`.",
        "@param1": "roleId the SharedRole membership to modify.",
        "@param2": "newMember the new SharedRole member.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeMember",
        "visibility": "public",
        "args": [
            {
                "name": "roleId",
                "type": "uint256"
            },
            {
                "name": "memberToRemove",
                "type": "address"
            }
        ],
        "func": "function removeMember(uint256 roleId, address memberToRemove) public onlyShared(roleId) onlyRoleManager(roleId) {\n        roles[roleId].sharedRoleMembership.removeMember(memberToRemove);\n        emit RemovedSharedMember(roleId, memberToRemove, msg.sender);\n    }",
        "comments": [
            "/**",
            "     * @notice Removes `memberToRemove` from the shared role, `roleId`.",
            "     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the",
            "     * managing role for `roleId`.",
            "     * @param roleId the SharedRole membership to modify.",
            "     * @param memberToRemove the current SharedRole member to remove.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Removes `memberToRemove` from the shared role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\n     * managing role for `roleId`.\n     * @param roleId the SharedRole membership to modify.\n     * @param memberToRemove the current SharedRole member to remove.\n     */\n",
        "@notice": "Removes `memberToRemove` from the shared role, `roleId`.",
        "@dev": "Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the * managing role for `roleId`.",
        "@param1": "roleId the SharedRole membership to modify.",
        "@param2": "memberToRemove the current SharedRole member to remove.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "renounceMembership",
        "visibility": "public",
        "args": [
            {
                "name": "roleId",
                "type": "uint256"
            }
        ],
        "func": "function renounceMembership(uint256 roleId) public onlyShared(roleId) onlyRoleHolder(roleId) {\n        roles[roleId].sharedRoleMembership.removeMember(msg.sender);\n        emit RemovedSharedMember(roleId, msg.sender, msg.sender);\n    }",
        "comments": [
            "/**",
            "     * @notice Removes caller from the role, `roleId`.",
            "     * @dev Reverts if the caller is not a member of the role for `roleId` or if `roleId` is not an",
            "     * initialized, SharedRole.",
            "     * @param roleId the SharedRole membership to modify.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Removes caller from the role, `roleId`.\n     * @dev Reverts if the caller is not a member of the role for `roleId` or if `roleId` is not an\n     * initialized, SharedRole.\n     * @param roleId the SharedRole membership to modify.\n     */\n",
        "@notice": "Removes caller from the role, `roleId`.",
        "@dev": "Reverts if the caller is not a member of the role for `roleId` or if `roleId` is not an * initialized, SharedRole.",
        "@param1": "roleId the SharedRole membership to modify.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function withdraw(uint256 amount) external onlyRoleHolder(roleId) {\n        Address.sendValue(msg.sender, amount);\n    }",
        "comments": [
            "/**",
            "     * @notice Withdraws ETH from the contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Withdraws ETH from the contract.\n     */\n",
        "@notice": "Withdraws ETH from the contract.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawErc20",
        "visibility": "external",
        "args": [
            {
                "name": "erc20Address",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function withdrawErc20(address erc20Address, uint256 amount) external onlyRoleHolder(roleId) {\n        IERC20 erc20 = IERC20(erc20Address);\n        erc20.safeTransfer(msg.sender, amount);\n    }",
        "comments": [
            "/**",
            "     * @notice Withdraws ERC20 tokens from the contract.",
            "     * @param erc20Address ERC20 token to withdraw.",
            "     * @param amount amount of tokens to withdraw.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Withdraws ERC20 tokens from the contract.\n     * @param erc20Address ERC20 token to withdraw.\n     * @param amount amount of tokens to withdraw.\n     */\n",
        "@notice": "Withdraws ERC20 tokens from the contract.",
        "@param1": "erc20Address ERC20 token to withdraw.",
        "@param2": "amount amount of tokens to withdraw.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "requestPrice",
        "visibility": "public",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            }
        ],
        "func": "function requestPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public override onlyRegisteredContract() {\n        uint256 blockTime = getCurrentTime();\n        require(time <= blockTime, \"Can only request in past\");\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier), \"Unsupported identifier request\");\n        require(ancillaryData.length <= ancillaryBytesLimit, \"Invalid ancillary data\");\n\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time, ancillaryData);\n        PriceRequest storage priceRequest = priceRequests[priceRequestId];\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\n\n        RequestStatus requestStatus = _getRequestStatus(priceRequest, currentRoundId);\n\n        if (requestStatus == RequestStatus.NotRequested) {\n            // Price has never been requested.\n            // Price requests always go in the next round, so add 1 to the computed current round.\n            uint256 nextRoundId = currentRoundId.add(1);\n\n            priceRequests[priceRequestId] = PriceRequest({\n                identifier: identifier,\n                time: time,\n                lastVotingRound: nextRoundId,\n                index: pendingPriceRequests.length,\n                ancillaryData: ancillaryData\n            });\n            pendingPriceRequests.push(priceRequestId);\n            emit PriceRequestAdded(nextRoundId, identifier, time);\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.",
            "     * @dev Time must be in the past and the identifier must be supported. The length of the ancillary data",
            "     * is limited such that this method abides by the EVM transaction gas limit.",
            "     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.",
            "     * @param time unix timestamp for the price request.",
            "     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.\n     * @dev Time must be in the past and the identifier must be supported. The length of the ancillary data\n     * is limited such that this method abides by the EVM transaction gas limit.\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp for the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     */\n",
        "@notice": "Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.",
        "@dev": "Time must be in the past and the identifier must be supported. The length of the ancillary data * is limited such that this method abides by the EVM transaction gas limit.",
        "@param1": "identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.",
        "@param2": "time unix timestamp for the price request.",
        "@param3": "ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "requestPrice",
        "visibility": "public",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            }
        ],
        "func": "function requestPrice(bytes32 identifier, uint256 time) public override {\n        requestPrice(identifier, time, \"\");\n    }",
        "comments": [
            "",
            "    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.",
            "    "
        ],
        "comt": "\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "hasPrice",
        "visibility": "public",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            }
        ],
        "func": "function hasPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view override onlyRegisteredContract() returns (bool) {\n        (bool _hasPrice, , ) = _getPriceOrError(identifier, time, ancillaryData);\n        return _hasPrice;\n    }",
        "comments": [
            "/**",
            "     * @notice Whether the price for `identifier` and `time` is available.",
            "     * @dev Time must be in the past and the identifier must be supported.",
            "     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.",
            "     * @param time unix timestamp of for the price request.",
            "     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.",
            "     * @return _hasPrice bool if the DVM has resolved to a price for the given identifier and timestamp.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Whether the price for `identifier` and `time` is available.\n     * @dev Time must be in the past and the identifier must be supported.\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp of for the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @return _hasPrice bool if the DVM has resolved to a price for the given identifier and timestamp.\n     */\n",
        "@notice": "Whether the price for `identifier` and `time` is available.",
        "@dev": "Time must be in the past and the identifier must be supported.",
        "@param1": "identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.",
        "@param2": "time unix timestamp of for the price request.",
        "@param3": "ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.",
        "@return1": "_hasPrice bool if the DVM has resolved to a price for the given identifier and timestamp.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "hasPrice",
        "visibility": "public",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            }
        ],
        "func": "function hasPrice(bytes32 identifier, uint256 time) public view override returns (bool) {\n        return hasPrice(identifier, time, \"\");\n    }",
        "comments": [
            "",
            "    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.",
            "    "
        ],
        "comt": "\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPrice",
        "visibility": "public",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            }
        ],
        "func": "function getPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view override onlyRegisteredContract() returns (int256) {\n        (bool _hasPrice, int256 price, string memory message) = _getPriceOrError(identifier, time, ancillaryData);\n\n        // If the price wasn't available, revert with the provided message.\n        require(_hasPrice, message);\n        return price;\n    }",
        "comments": [
            "/**",
            "     * @notice Gets the price for `identifier` and `time` if it has already been requested and resolved.",
            "     * @dev If the price is not available, the method reverts.",
            "     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.",
            "     * @param time unix timestamp of for the price request.",
            "     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.",
            "     * @return int256 representing the resolved price for the given identifier and timestamp.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets the price for `identifier` and `time` if it has already been requested and resolved.\n     * @dev If the price is not available, the method reverts.\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp of for the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @return int256 representing the resolved price for the given identifier and timestamp.\n     */\n",
        "@notice": "Gets the price for `identifier` and `time` if it has already been requested and resolved.",
        "@dev": "If the price is not available, the method reverts.",
        "@param1": "identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.",
        "@param2": "time unix timestamp of for the price request.",
        "@param3": "ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.",
        "@return1": "int256 representing the resolved price for the given identifier and timestamp.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPrice",
        "visibility": "public",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            }
        ],
        "func": "function getPrice(bytes32 identifier, uint256 time) public view override returns (int256) {\n        return getPrice(identifier, time, \"\");\n    }",
        "comments": [
            "",
            "    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.",
            "    "
        ],
        "comt": "\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPriceRequestStatuses",
        "visibility": "public",
        "args": [
            {
                "name": "requests",
                "type": "PendingRequestAncillary[] memory"
            }
        ],
        "func": "function getPriceRequestStatuses(PendingRequestAncillary[] memory requests)\n        public\n        view\n        returns (RequestState[] memory)\n    {\n        RequestState[] memory requestStates = new RequestState[](requests.length);\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(getCurrentTime());\n        for (uint256 i = 0; i < requests.length; i++) {\n            PriceRequest storage priceRequest =\n                _getPriceRequest(requests[i].identifier, requests[i].time, requests[i].ancillaryData);\n\n            RequestStatus status = _getRequestStatus(priceRequest, currentRoundId);\n\n            // If it's an active request, its true lastVotingRound is the current one, even if it hasn't been updated.\n            if (status == RequestStatus.Active) {\n                requestStates[i].lastVotingRound = currentRoundId;\n            } else {\n                requestStates[i].lastVotingRound = priceRequest.lastVotingRound;\n            }\n            requestStates[i].status = status;\n        }\n        return requestStates;\n    }",
        "comments": [
            "/**",
            "     * @notice Gets the status of a list of price requests, identified by their identifier and time.",
            "     * @dev If the status for a particular request is NotRequested, the lastVotingRound will always be 0.",
            "     * @param requests array of type PendingRequest which includes an identifier and timestamp for each request.",
            "     * @return requestStates a list, in the same order as the input list, giving the status of each of the specified price requests.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets the status of a list of price requests, identified by their identifier and time.\n     * @dev If the status for a particular request is NotRequested, the lastVotingRound will always be 0.\n     * @param requests array of type PendingRequest which includes an identifier and timestamp for each request.\n     * @return requestStates a list, in the same order as the input list, giving the status of each of the specified price requests.\n     */\n",
        "@notice": "Gets the status of a list of price requests, identified by their identifier and time.",
        "@dev": "If the status for a particular request is NotRequested, the lastVotingRound will always be 0.",
        "@param1": "requests array of type PendingRequest which includes an identifier and timestamp for each request.",
        "@return1": "requestStates a list, in the same order as the input list, giving the status of each of the specified price requests.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPriceRequestStatuses",
        "visibility": "public",
        "args": [
            {
                "name": "requests",
                "type": "PendingRequest[] memory"
            }
        ],
        "func": "function getPriceRequestStatuses(PendingRequest[] memory requests) public view returns (RequestState[] memory) {\n        PendingRequestAncillary[] memory requestsAncillary = new PendingRequestAncillary[](requests.length);\n\n        for (uint256 i = 0; i < requests.length; i++) {\n            requestsAncillary[i].identifier = requests[i].identifier;\n            requestsAncillary[i].time = requests[i].time;\n            requestsAncillary[i].ancillaryData = \"\";\n        }\n        return getPriceRequestStatuses(requestsAncillary);\n    }",
        "comments": [
            "",
            "    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.",
            "    "
        ],
        "comt": "\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "commitVote",
        "visibility": "public",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            },
            {
                "name": "hash",
                "type": "bytes32"
            }
        ],
        "func": "function commitVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bytes32 hash\n    ) public override onlyIfNotMigrated() {\n        require(hash != bytes32(0), \"Invalid provided hash\");\n        // Current time is required for all vote timing queries.\n        uint256 blockTime = getCurrentTime();\n        require(\n            voteTiming.computeCurrentPhase(blockTime) == VotingAncillaryInterface.Phase.Commit,\n            \"Cannot commit in reveal phase\"\n        );\n\n        // At this point, the computed and last updated round ID should be equal.\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\n\n        PriceRequest storage priceRequest = _getPriceRequest(identifier, time, ancillaryData);\n        require(\n            _getRequestStatus(priceRequest, currentRoundId) == RequestStatus.Active,\n            \"Cannot commit inactive request\"\n        );\n\n        priceRequest.lastVotingRound = currentRoundId;\n        VoteInstance storage voteInstance = priceRequest.voteInstances[currentRoundId];\n        voteInstance.voteSubmissions[msg.sender].commit = hash;\n\n        emit VoteCommitted(msg.sender, currentRoundId, identifier, time, ancillaryData);\n    }",
        "comments": [
            "/**",
            "     * @notice Commit a vote for a price request for `identifier` at `time`.",
            "     * @dev `identifier`, `time` must correspond to a price request that's currently in the commit phase.",
            "     * Commits can be changed.",
            "     * @dev Since transaction data is public, the salt will be revealed with the vote. While this is the system\u2019s expected behavior,",
            "     * voters should never reuse salts. If someone else is able to guess the voted price and knows that a salt will be reused, then",
            "     * they can determine the vote pre-reveal.",
            "     * @param identifier uniquely identifies the committed vote. EG BTC/USD price pair.",
            "     * @param time unix timestamp of the price being voted on.",
            "     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.",
            "     * @param hash keccak256 hash of the `price`, `salt`, voter `address`, `time`, current `roundId`, and `identifier`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Commit a vote for a price request for `identifier` at `time`.\n     * @dev `identifier`, `time` must correspond to a price request that's currently in the commit phase.\n     * Commits can be changed.\n     * @dev Since transaction data is public, the salt will be revealed with the vote. While this is the system\u2019s expected behavior,\n     * voters should never reuse salts. If someone else is able to guess the voted price and knows that a salt will be reused, then\n     * they can determine the vote pre-reveal.\n     * @param identifier uniquely identifies the committed vote. EG BTC/USD price pair.\n     * @param time unix timestamp of the price being voted on.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param hash keccak256 hash of the `price`, `salt`, voter `address`, `time`, current `roundId`, and `identifier`.\n     */\n",
        "@notice": "Commit a vote for a price request for `identifier` at `time`.",
        "@dev": "`identifier`, `time` must correspond to a price request that's currently in the commit phase. * Commits can be changed. * Since transaction data is public, the salt will be revealed with the vote. While this is the system\u2019s expected behavior, * voters should never reuse salts. If someone else is able to guess the voted price and knows that a salt will be reused, then * they can determine the vote pre-reveal.",
        "@param1": "identifier uniquely identifies the committed vote. EG BTC/USD price pair.",
        "@param2": "time unix timestamp of the price being voted on.",
        "@param3": "ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.",
        "@param4": "hash keccak256 hash of the `price`, `salt`, voter `address`, `time`, current `roundId`, and `identifier`.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "commitVote",
        "visibility": "public",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            },
            {
                "name": "hash",
                "type": "bytes32"
            }
        ],
        "func": "function commitVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes32 hash\n    ) public override onlyIfNotMigrated() {\n        commitVote(identifier, time, \"\", hash);\n    }",
        "comments": [
            "",
            "    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.",
            "    "
        ],
        "comt": "\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "snapshotCurrentRound",
        "visibility": "external",
        "args": [
            {
                "name": "signature",
                "type": "bytes calldata"
            }
        ],
        "func": "function snapshotCurrentRound(bytes calldata signature)\n        external\n        override(VotingInterface, VotingAncillaryInterface)\n        onlyIfNotMigrated()\n    {\n        uint256 blockTime = getCurrentTime();\n        require(voteTiming.computeCurrentPhase(blockTime) == Phase.Reveal, \"Only snapshot in reveal phase\");\n        // Require public snapshot require signature to ensure caller is an EOA.\n        require(ECDSA.recover(snapshotMessageHash, signature) == msg.sender, \"Signature must match sender\");\n        uint256 roundId = voteTiming.computeCurrentRoundId(blockTime);\n        _freezeRoundVariables(roundId);\n    }",
        "comments": [
            "/**",
            "     * @notice Snapshot the current round's token balances and lock in the inflation rate and GAT.",
            "     * @dev This function can be called multiple times, but only the first call per round into this function or `revealVote`",
            "     * will create the round snapshot. Any later calls will be a no-op. Will revert unless called during reveal period.",
            "     * @param signature  signature required to prove caller is an EOA to prevent flash loans from being included in the",
            "     * snapshot.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Snapshot the current round's token balances and lock in the inflation rate and GAT.\n     * @dev This function can be called multiple times, but only the first call per round into this function or `revealVote`\n     * will create the round snapshot. Any later calls will be a no-op. Will revert unless called during reveal period.\n     * @param signature  signature required to prove caller is an EOA to prevent flash loans from being included in the\n     * snapshot.\n     */\n",
        "@notice": "Snapshot the current round's token balances and lock in the inflation rate and GAT.",
        "@dev": "This function can be called multiple times, but only the first call per round into this function or `revealVote` * will create the round snapshot. Any later calls will be a no-op. Will revert unless called during reveal period.",
        "@param1": "signature signature required to prove caller is an EOA to prevent flash loans from being included in the * snapshot.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "revealVote",
        "visibility": "public",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            },
            {
                "name": "price",
                "type": "int256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            },
            {
                "name": "salt",
                "type": "int256"
            }
        ],
        "func": "function revealVote(\n        bytes32 identifier,\n        uint256 time,\n        int256 price,\n        bytes memory ancillaryData,\n        int256 salt\n    ) public override onlyIfNotMigrated() {\n        require(voteTiming.computeCurrentPhase(getCurrentTime()) == Phase.Reveal, \"Cannot reveal in commit phase\");\n        // Note: computing the current round is required to disallow people from revealing an old commit after the round is over.\n        uint256 roundId = voteTiming.computeCurrentRoundId(getCurrentTime());\n\n        PriceRequest storage priceRequest = _getPriceRequest(identifier, time, ancillaryData);\n        VoteInstance storage voteInstance = priceRequest.voteInstances[roundId];\n        VoteSubmission storage voteSubmission = voteInstance.voteSubmissions[msg.sender];\n\n        // Scoping to get rid of a stack too deep error.\n        {\n            // 0 hashes are disallowed in the commit phase, so they indicate a different error.\n            // Cannot reveal an uncommitted or previously revealed hash\n            require(voteSubmission.commit != bytes32(0), \"Invalid hash reveal\");\n            require(\n                keccak256(abi.encodePacked(price, salt, msg.sender, time, ancillaryData, roundId, identifier)) ==\n                    voteSubmission.commit,\n                \"Revealed data != commit hash\"\n            );\n            // To protect against flash loans, we require snapshot be validated as EOA.\n            require(rounds[roundId].snapshotId != 0, \"Round has no snapshot\");\n        }\n\n        // Get the frozen snapshotId\n        uint256 snapshotId = rounds[roundId].snapshotId;\n\n        delete voteSubmission.commit;\n\n        // Get the voter's snapshotted balance. Since balances are returned pre-scaled by 10**18, we can directly\n        // initialize the Unsigned value with the returned uint.\n        FixedPoint.Unsigned memory balance = FixedPoint.Unsigned(votingToken.balanceOfAt(msg.sender, snapshotId));\n\n        // Set the voter's submission.\n        voteSubmission.revealHash = keccak256(abi.encode(price));\n\n        // Add vote to the results.\n        voteInstance.resultComputation.addVote(price, balance);\n\n        emit VoteRevealed(msg.sender, roundId, identifier, time, price, ancillaryData, balance.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Reveal a previously committed vote for `identifier` at `time`.",
            "     * @dev The revealed `price`, `salt`, `address`, `time`, `roundId`, and `identifier`, must hash to the latest `hash`",
            "     * that `commitVote()` was called with. Only the committer can reveal their vote.",
            "     * @param identifier voted on in the commit phase. EG BTC/USD price pair.",
            "     * @param time specifies the unix timestamp of the price being voted on.",
            "     * @param price voted on during the commit phase.",
            "     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.",
            "     * @param salt value used to hide the commitment price during the commit phase.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Reveal a previously committed vote for `identifier` at `time`.\n     * @dev The revealed `price`, `salt`, `address`, `time`, `roundId`, and `identifier`, must hash to the latest `hash`\n     * that `commitVote()` was called with. Only the committer can reveal their vote.\n     * @param identifier voted on in the commit phase. EG BTC/USD price pair.\n     * @param time specifies the unix timestamp of the price being voted on.\n     * @param price voted on during the commit phase.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param salt value used to hide the commitment price during the commit phase.\n     */\n",
        "@notice": "Reveal a previously committed vote for `identifier` at `time`.",
        "@dev": "The revealed `price`, `salt`, `address`, `time`, `roundId`, and `identifier`, must hash to the latest `hash` * that `commitVote()` was called with. Only the committer can reveal their vote.",
        "@param1": "identifier voted on in the commit phase. EG BTC/USD price pair.",
        "@param2": "time specifies the unix timestamp of the price being voted on.",
        "@param3": "price voted on during the commit phase.",
        "@param4": "ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.",
        "@param5": "salt value used to hide the commitment price during the commit phase.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "revealVote",
        "visibility": "public",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            },
            {
                "name": "price",
                "type": "int256"
            },
            {
                "name": "salt",
                "type": "int256"
            }
        ],
        "func": "function revealVote(\n        bytes32 identifier,\n        uint256 time,\n        int256 price,\n        int256 salt\n    ) public override {\n        revealVote(identifier, time, price, \"\", salt);\n    }",
        "comments": [
            "",
            "    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.",
            "    "
        ],
        "comt": "\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "commitAndEmitEncryptedVote",
        "visibility": "public",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            },
            {
                "name": "hash",
                "type": "bytes32"
            },
            {
                "name": "encryptedVote",
                "type": "bytes memory"
            }
        ],
        "func": "function commitAndEmitEncryptedVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bytes32 hash,\n        bytes memory encryptedVote\n    ) public override {\n        commitVote(identifier, time, ancillaryData, hash);\n\n        uint256 roundId = voteTiming.computeCurrentRoundId(getCurrentTime());\n        emit EncryptedVote(msg.sender, roundId, identifier, time, ancillaryData, encryptedVote);\n    }",
        "comments": [
            "/**",
            "     * @notice commits a vote and logs an event with a data blob, typically an encrypted version of the vote",
            "     * @dev An encrypted version of the vote is emitted in an event `EncryptedVote` to allow off-chain infrastructure to",
            "     * retrieve the commit. The contents of `encryptedVote` are never used on chain: it is purely for convenience.",
            "     * @param identifier unique price pair identifier. Eg: BTC/USD price pair.",
            "     * @param time unix timestamp of for the price request.",
            "     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.",
            "     * @param hash keccak256 hash of the price you want to vote for and a `int256 salt`.",
            "     * @param encryptedVote offchain encrypted blob containing the voters amount, time and salt.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice commits a vote and logs an event with a data blob, typically an encrypted version of the vote\n     * @dev An encrypted version of the vote is emitted in an event `EncryptedVote` to allow off-chain infrastructure to\n     * retrieve the commit. The contents of `encryptedVote` are never used on chain: it is purely for convenience.\n     * @param identifier unique price pair identifier. Eg: BTC/USD price pair.\n     * @param time unix timestamp of for the price request.\n     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n     * @param hash keccak256 hash of the price you want to vote for and a `int256 salt`.\n     * @param encryptedVote offchain encrypted blob containing the voters amount, time and salt.\n     */\n",
        "@notice": "commits a vote and logs an event with a data blob, typically an encrypted version of the vote",
        "@dev": "An encrypted version of the vote is emitted in an event `EncryptedVote` to allow off-chain infrastructure to * retrieve the commit. The contents of `encryptedVote` are never used on chain: it is purely for convenience.",
        "@param1": "identifier unique price pair identifier. Eg: BTC/USD price pair.",
        "@param2": "time unix timestamp of for the price request.",
        "@param3": "ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.",
        "@param4": "hash keccak256 hash of the price you want to vote for and a `int256 salt`.",
        "@param5": "encryptedVote offchain encrypted blob containing the voters amount, time and salt.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "commitAndEmitEncryptedVote",
        "visibility": "public",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            },
            {
                "name": "hash",
                "type": "bytes32"
            },
            {
                "name": "encryptedVote",
                "type": "bytes memory"
            }
        ],
        "func": "function commitAndEmitEncryptedVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes32 hash,\n        bytes memory encryptedVote\n    ) public override {\n        commitVote(identifier, time, \"\", hash);\n\n        commitAndEmitEncryptedVote(identifier, time, \"\", hash, encryptedVote);\n    }",
        "comments": [
            "",
            "    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.",
            "    "
        ],
        "comt": "\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "batchCommit",
        "visibility": "public",
        "args": [
            {
                "name": "commits",
                "type": "CommitmentAncillary[] memory"
            }
        ],
        "func": "function batchCommit(CommitmentAncillary[] memory commits) public override {\n        for (uint256 i = 0; i < commits.length; i++) {\n            if (commits[i].encryptedVote.length == 0) {\n                commitVote(commits[i].identifier, commits[i].time, commits[i].ancillaryData, commits[i].hash);\n            } else {\n                commitAndEmitEncryptedVote(\n                    commits[i].identifier,\n                    commits[i].time,\n                    commits[i].ancillaryData,\n                    commits[i].hash,\n                    commits[i].encryptedVote\n                );\n            }\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Submit a batch of commits in a single transaction.",
            "     * @dev Using `encryptedVote` is optional. If included then commitment is emitted in an event.",
            "     * Look at `project-root/common/Constants.js` for the tested maximum number of",
            "     * commitments that can fit in one transaction.",
            "     * @param commits struct to encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Submit a batch of commits in a single transaction.\n     * @dev Using `encryptedVote` is optional. If included then commitment is emitted in an event.\n     * Look at `project-root/common/Constants.js` for the tested maximum number of\n     * commitments that can fit in one transaction.\n     * @param commits struct to encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.\n     */\n",
        "@notice": "Submit a batch of commits in a single transaction.",
        "@dev": "Using `encryptedVote` is optional. If included then commitment is emitted in an event. * Look at `project-root/common/Constants.js` for the tested maximum number of * commitments that can fit in one transaction.",
        "@param1": "commits struct to encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "batchCommit",
        "visibility": "public",
        "args": [
            {
                "name": "commits",
                "type": "Commitment[] memory"
            }
        ],
        "func": "function batchCommit(Commitment[] memory commits) public override {\n        CommitmentAncillary[] memory commitsAncillary = new CommitmentAncillary[](commits.length);\n\n        for (uint256 i = 0; i < commits.length; i++) {\n            commitsAncillary[i].identifier = commits[i].identifier;\n            commitsAncillary[i].time = commits[i].time;\n            commitsAncillary[i].ancillaryData = \"\";\n            commitsAncillary[i].hash = commits[i].hash;\n            commitsAncillary[i].encryptedVote = commits[i].encryptedVote;\n        }\n        batchCommit(commitsAncillary);\n    }",
        "comments": [
            "",
            "    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.",
            "    "
        ],
        "comt": "\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "batchReveal",
        "visibility": "public",
        "args": [
            {
                "name": "reveals",
                "type": "RevealAncillary[] memory"
            }
        ],
        "func": "function batchReveal(RevealAncillary[] memory reveals) public override {\n        for (uint256 i = 0; i < reveals.length; i++) {\n            revealVote(\n                reveals[i].identifier,\n                reveals[i].time,\n                reveals[i].price,\n                reveals[i].ancillaryData,\n                reveals[i].salt\n            );\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Reveal multiple votes in a single transaction.",
            "     * Look at `project-root/common/Constants.js` for the tested maximum number of reveals.",
            "     * that can fit in one transaction.",
            "     * @dev For more info on reveals, review the comment for `revealVote`.",
            "     * @param reveals array of the Reveal struct which contains an identifier, time, price and salt.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Reveal multiple votes in a single transaction.\n     * Look at `project-root/common/Constants.js` for the tested maximum number of reveals.\n     * that can fit in one transaction.\n     * @dev For more info on reveals, review the comment for `revealVote`.\n     * @param reveals array of the Reveal struct which contains an identifier, time, price and salt.\n     */\n",
        "@notice": "Reveal multiple votes in a single transaction. * Look at `project-root/common/Constants.js` for the tested maximum number of reveals. * that can fit in one transaction.",
        "@dev": "For more info on reveals, review the comment for `revealVote`.",
        "@param1": "reveals array of the Reveal struct which contains an identifier, time, price and salt.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "batchReveal",
        "visibility": "public",
        "args": [
            {
                "name": "reveals",
                "type": "Reveal[] memory"
            }
        ],
        "func": "function batchReveal(Reveal[] memory reveals) public override {\n        RevealAncillary[] memory revealsAncillary = new RevealAncillary[](reveals.length);\n\n        for (uint256 i = 0; i < reveals.length; i++) {\n            revealsAncillary[i].identifier = reveals[i].identifier;\n            revealsAncillary[i].time = reveals[i].time;\n            revealsAncillary[i].price = reveals[i].price;\n            revealsAncillary[i].ancillaryData = \"\";\n            revealsAncillary[i].salt = reveals[i].salt;\n        }\n        batchReveal(revealsAncillary);\n    }",
        "comments": [
            "",
            "    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.",
            "    "
        ],
        "comt": "\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "retrieveRewards",
        "visibility": "public",
        "args": [
            {
                "name": "voterAddress",
                "type": "address"
            },
            {
                "name": "roundId",
                "type": "uint256"
            },
            {
                "name": "toRetrieve",
                "type": "PendingRequestAncillary[] memory"
            }
        ],
        "func": "function retrieveRewards(\n        address voterAddress,\n        uint256 roundId,\n        PendingRequestAncillary[] memory toRetrieve\n    ) public override returns (FixedPoint.Unsigned memory totalRewardToIssue) {\n        if (migratedAddress != address(0)) {\n            require(msg.sender == migratedAddress, \"Can only call from migrated\");\n        }\n        require(roundId < voteTiming.computeCurrentRoundId(getCurrentTime()), \"Invalid roundId\");\n\n        Round storage round = rounds[roundId];\n        bool isExpired = getCurrentTime() > round.rewardsExpirationTime;\n        FixedPoint.Unsigned memory snapshotBalance =\n            FixedPoint.Unsigned(votingToken.balanceOfAt(voterAddress, round.snapshotId));\n\n        // Compute the total amount of reward that will be issued for each of the votes in the round.\n        FixedPoint.Unsigned memory snapshotTotalSupply =\n            FixedPoint.Unsigned(votingToken.totalSupplyAt(round.snapshotId));\n        FixedPoint.Unsigned memory totalRewardPerVote = round.inflationRate.mul(snapshotTotalSupply);\n\n        // Keep track of the voter's accumulated token reward.\n        totalRewardToIssue = FixedPoint.Unsigned(0);\n\n        for (uint256 i = 0; i < toRetrieve.length; i++) {\n            PriceRequest storage priceRequest =\n                _getPriceRequest(toRetrieve[i].identifier, toRetrieve[i].time, toRetrieve[i].ancillaryData);\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\n            // Only retrieve rewards for votes resolved in same round\n            require(priceRequest.lastVotingRound == roundId, \"Retrieve for votes same round\");\n\n            _resolvePriceRequest(priceRequest, voteInstance);\n\n            if (voteInstance.voteSubmissions[voterAddress].revealHash == 0) {\n                continue;\n            } else if (isExpired) {\n                // Emit a 0 token retrieval on expired rewards.\n                emit RewardsRetrieved(\n                    voterAddress,\n                    roundId,\n                    toRetrieve[i].identifier,\n                    toRetrieve[i].time,\n                    toRetrieve[i].ancillaryData,\n                    0\n                );\n            } else if (\n                voteInstance.resultComputation.wasVoteCorrect(voteInstance.voteSubmissions[voterAddress].revealHash)\n            ) {\n                // The price was successfully resolved during the voter's last voting round, the voter revealed\n                // and was correct, so they are eligible for a reward.\n                // Compute the reward and add to the cumulative reward.\n\n                FixedPoint.Unsigned memory reward =\n                    snapshotBalance.mul(totalRewardPerVote).div(\n                        voteInstance.resultComputation.getTotalCorrectlyVotedTokens()\n                    );\n                totalRewardToIssue = totalRewardToIssue.add(reward);\n\n                // Emit reward retrieval for this vote.\n                emit RewardsRetrieved(\n                    voterAddress,\n                    roundId,\n                    toRetrieve[i].identifier,\n                    toRetrieve[i].time,\n                    toRetrieve[i].ancillaryData,\n                    reward.rawValue\n                );\n            } else {\n                // Emit a 0 token retrieval on incorrect votes.\n                emit RewardsRetrieved(\n                    voterAddress,\n                    roundId,\n                    toRetrieve[i].identifier,\n                    toRetrieve[i].time,\n                    toRetrieve[i].ancillaryData,\n                    0\n                );\n            }\n\n            // Delete the submission to capture any refund and clean up storage.\n            delete voteInstance.voteSubmissions[voterAddress].revealHash;\n        }\n\n        // Issue any accumulated rewards.\n        if (totalRewardToIssue.isGreaterThan(0)) {\n            require(votingToken.mint(voterAddress, totalRewardToIssue.rawValue), \"Voting token issuance failed\");\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Retrieves rewards owed for a set of resolved price requests.",
            "     * @dev Can only retrieve rewards if calling for a valid round and if the call is done within the timeout threshold",
            "     * (not expired). Note that a named return value is used here to avoid a stack to deep error.",
            "     * @param voterAddress voter for which rewards will be retrieved. Does not have to be the caller.",
            "     * @param roundId the round from which voting rewards will be retrieved from.",
            "     * @param toRetrieve array of PendingRequests which rewards are retrieved from.",
            "     * @return totalRewardToIssue total amount of rewards returned to the voter.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Retrieves rewards owed for a set of resolved price requests.\n     * @dev Can only retrieve rewards if calling for a valid round and if the call is done within the timeout threshold\n     * (not expired). Note that a named return value is used here to avoid a stack to deep error.\n     * @param voterAddress voter for which rewards will be retrieved. Does not have to be the caller.\n     * @param roundId the round from which voting rewards will be retrieved from.\n     * @param toRetrieve array of PendingRequests which rewards are retrieved from.\n     * @return totalRewardToIssue total amount of rewards returned to the voter.\n     */\n",
        "@notice": "Retrieves rewards owed for a set of resolved price requests.",
        "@dev": "Can only retrieve rewards if calling for a valid round and if the call is done within the timeout threshold * (not expired). Note that a named return value is used here to avoid a stack to deep error.",
        "@param1": "voterAddress voter for which rewards will be retrieved. Does not have to be the caller.",
        "@param2": "roundId the round from which voting rewards will be retrieved from.",
        "@param3": "toRetrieve array of PendingRequests which rewards are retrieved from.",
        "@return1": "totalRewardToIssue total amount of rewards returned to the voter.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "retrieveRewards",
        "visibility": "public",
        "args": [
            {
                "name": "voterAddress",
                "type": "address"
            },
            {
                "name": "roundId",
                "type": "uint256"
            },
            {
                "name": "toRetrieve",
                "type": "PendingRequest[] memory"
            }
        ],
        "func": "function retrieveRewards(\n        address voterAddress,\n        uint256 roundId,\n        PendingRequest[] memory toRetrieve\n    ) public override returns (FixedPoint.Unsigned memory) {\n        PendingRequestAncillary[] memory toRetrieveAncillary = new PendingRequestAncillary[](toRetrieve.length);\n\n        for (uint256 i = 0; i < toRetrieve.length; i++) {\n            toRetrieveAncillary[i].identifier = toRetrieve[i].identifier;\n            toRetrieveAncillary[i].time = toRetrieve[i].time;\n            toRetrieveAncillary[i].ancillaryData = \"\";\n        }\n\n        return retrieveRewards(voterAddress, roundId, toRetrieveAncillary);\n    }",
        "comments": [
            "",
            "    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.",
            "    "
        ],
        "comt": "\n    // Overloaded method to enable short term backwards compatibility. Will be deprecated in the next DVM version.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPendingRequests",
        "visibility": "external",
        "args": [],
        "func": "function getPendingRequests()\n        external\n        view\n        override(VotingInterface, VotingAncillaryInterface)\n        returns (PendingRequestAncillary[] memory)\n    {\n        uint256 blockTime = getCurrentTime();\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\n\n        // Solidity memory arrays aren't resizable (and reading storage is expensive). Hence this hackery to filter\n        // `pendingPriceRequests` only to those requests that have an Active RequestStatus.\n        PendingRequestAncillary[] memory unresolved = new PendingRequestAncillary[](pendingPriceRequests.length);\n        uint256 numUnresolved = 0;\n\n        for (uint256 i = 0; i < pendingPriceRequests.length; i++) {\n            PriceRequest storage priceRequest = priceRequests[pendingPriceRequests[i]];\n            if (_getRequestStatus(priceRequest, currentRoundId) == RequestStatus.Active) {\n                unresolved[numUnresolved] = PendingRequestAncillary({\n                    identifier: priceRequest.identifier,\n                    time: priceRequest.time,\n                    ancillaryData: priceRequest.ancillaryData\n                });\n                numUnresolved++;\n            }\n        }\n\n        PendingRequestAncillary[] memory pendingRequests = new PendingRequestAncillary[](numUnresolved);\n        for (uint256 i = 0; i < numUnresolved; i++) {\n            pendingRequests[i] = unresolved[i];\n        }\n        return pendingRequests;\n    }",
        "comments": [
            "/**",
            "     * @notice Gets the queries that are being voted on this round.",
            "     * @return pendingRequests array containing identifiers of type `PendingRequest`.",
            "     * and timestamps for all pending requests.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets the queries that are being voted on this round.\n     * @return pendingRequests array containing identifiers of type `PendingRequest`.\n     * and timestamps for all pending requests.\n     */\n",
        "@notice": "Gets the queries that are being voted on this round.",
        "@return1": "pendingRequests array containing identifiers of type `PendingRequest`. * and timestamps for all pending requests.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getVotePhase",
        "visibility": "external",
        "args": [],
        "func": "function getVotePhase() external view override(VotingInterface, VotingAncillaryInterface) returns (Phase) {\n        return voteTiming.computeCurrentPhase(getCurrentTime());\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the current voting phase, as a function of the current time.",
            "     * @return Phase to indicate the current phase. Either { Commit, Reveal, NUM_PHASES_PLACEHOLDER }.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the current voting phase, as a function of the current time.\n     * @return Phase to indicate the current phase. Either { Commit, Reveal, NUM_PHASES_PLACEHOLDER }.\n     */\n",
        "@notice": "Returns the current voting phase, as a function of the current time.",
        "@return1": "Phase to indicate the current phase. Either { Commit, Reveal, NUM_PHASES_PLACEHOLDER }.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentRoundId",
        "visibility": "external",
        "args": [],
        "func": "function getCurrentRoundId() external view override(VotingInterface, VotingAncillaryInterface) returns (uint256) {\n        return voteTiming.computeCurrentRoundId(getCurrentTime());\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the current round ID, as a function of the current time.",
            "     * @return uint256 representing the unique round ID.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the current round ID, as a function of the current time.\n     * @return uint256 representing the unique round ID.\n     */\n",
        "@notice": "Returns the current round ID, as a function of the current time.",
        "@return1": "uint256 representing the unique round ID.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setMigrated",
        "visibility": "external",
        "args": [
            {
                "name": "newVotingAddress",
                "type": "address"
            }
        ],
        "func": "function setMigrated(address newVotingAddress)\n        external\n        override(VotingInterface, VotingAncillaryInterface)\n        onlyOwner\n    {\n        migratedAddress = newVotingAddress;\n    }",
        "comments": [
            "/**",
            "     * @notice Disables this Voting contract in favor of the migrated one.",
            "     * @dev Can only be called by the contract owner.",
            "     * @param newVotingAddress the newly migrated contract address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Disables this Voting contract in favor of the migrated one.\n     * @dev Can only be called by the contract owner.\n     * @param newVotingAddress the newly migrated contract address.\n     */\n",
        "@notice": "Disables this Voting contract in favor of the migrated one.",
        "@dev": "Can only be called by the contract owner.",
        "@param1": "newVotingAddress the newly migrated contract address.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setInflationRate",
        "visibility": "public",
        "args": [
            {
                "name": "newInflationRate",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function setInflationRate(FixedPoint.Unsigned memory newInflationRate)\n        public\n        override(VotingInterface, VotingAncillaryInterface)\n        onlyOwner\n    {\n        inflationRate = newInflationRate;\n    }",
        "comments": [
            "/**",
            "     * @notice Resets the inflation rate. Note: this change only applies to rounds that have not yet begun.",
            "     * @dev This method is public because calldata structs are not currently supported by solidity.",
            "     * @param newInflationRate sets the next round's inflation rate.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Resets the inflation rate. Note: this change only applies to rounds that have not yet begun.\n     * @dev This method is public because calldata structs are not currently supported by solidity.\n     * @param newInflationRate sets the next round's inflation rate.\n     */\n",
        "@notice": "Resets the inflation rate. Note: this change only applies to rounds that have not yet begun.",
        "@dev": "This method is public because calldata structs are not currently supported by solidity.",
        "@param1": "newInflationRate sets the next round's inflation rate.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setGatPercentage",
        "visibility": "public",
        "args": [
            {
                "name": "newGatPercentage",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function setGatPercentage(FixedPoint.Unsigned memory newGatPercentage)\n        public\n        override(VotingInterface, VotingAncillaryInterface)\n        onlyOwner\n    {\n        require(newGatPercentage.isLessThan(1), \"GAT percentage must be < 100%\");\n        gatPercentage = newGatPercentage;\n    }",
        "comments": [
            "/**",
            "     * @notice Resets the Gat percentage. Note: this change only applies to rounds that have not yet begun.",
            "     * @dev This method is public because calldata structs are not currently supported by solidity.",
            "     * @param newGatPercentage sets the next round's Gat percentage.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Resets the Gat percentage. Note: this change only applies to rounds that have not yet begun.\n     * @dev This method is public because calldata structs are not currently supported by solidity.\n     * @param newGatPercentage sets the next round's Gat percentage.\n     */\n",
        "@notice": "Resets the Gat percentage. Note: this change only applies to rounds that have not yet begun.",
        "@dev": "This method is public because calldata structs are not currently supported by solidity.",
        "@param1": "newGatPercentage sets the next round's Gat percentage.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setRewardsExpirationTimeout",
        "visibility": "public",
        "args": [
            {
                "name": "NewRewardsExpirationTimeout",
                "type": "uint256"
            }
        ],
        "func": "function setRewardsExpirationTimeout(uint256 NewRewardsExpirationTimeout)\n        public\n        override(VotingInterface, VotingAncillaryInterface)\n        onlyOwner\n    {\n        rewardsExpirationTimeout = NewRewardsExpirationTimeout;\n    }",
        "comments": [
            "/**",
            "     * @notice Resets the rewards expiration timeout.",
            "     * @dev This change only applies to rounds that have not yet begun.",
            "     * @param NewRewardsExpirationTimeout how long a caller can wait before choosing to withdraw their rewards.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Resets the rewards expiration timeout.\n     * @dev This change only applies to rounds that have not yet begun.\n     * @param NewRewardsExpirationTimeout how long a caller can wait before choosing to withdraw their rewards.\n     */\n",
        "@notice": "Resets the rewards expiration timeout.",
        "@dev": "This change only applies to rounds that have not yet begun.",
        "@param1": "NewRewardsExpirationTimeout how long a caller can wait before choosing to withdraw their rewards.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "registerContract",
        "visibility": "external",
        "args": [
            {
                "name": "parties",
                "type": "address[] calldata"
            },
            {
                "name": "contractAddress",
                "type": "address"
            }
        ],
        "func": "function registerContract(address[] calldata parties, address contractAddress)\n        external\n        override\n        onlyRoleHolder(uint256(Roles.ContractCreator))\n    {\n        FinancialContract storage financialContract = contractMap[contractAddress];\n        require(contractMap[contractAddress].valid == Validity.Invalid, \"Can only register once\");\n\n        // Store contract address as a registered contract.\n        registeredContracts.push(contractAddress);\n\n        // No length check necessary because we should never hit (2^127 - 1) contracts.\n        financialContract.index = uint128(registeredContracts.length.sub(1));\n\n        // For all parties in the array add them to the contract's parties.\n        financialContract.valid = Validity.Valid;\n        for (uint256 i = 0; i < parties.length; i = i.add(1)) {\n            _addPartyToContract(parties[i], contractAddress);\n        }\n\n        emit NewContractRegistered(contractAddress, msg.sender, parties);\n    }",
        "comments": [
            "/**",
            "     * @notice Registers a new financial contract.",
            "     * @dev Only authorized contract creators can call this method.",
            "     * @param parties array of addresses who become parties in the contract.",
            "     * @param contractAddress address of the contract against which the parties are registered.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Registers a new financial contract.\n     * @dev Only authorized contract creators can call this method.\n     * @param parties array of addresses who become parties in the contract.\n     * @param contractAddress address of the contract against which the parties are registered.\n     */\n",
        "@notice": "Registers a new financial contract.",
        "@dev": "Only authorized contract creators can call this method.",
        "@param1": "parties array of addresses who become parties in the contract.",
        "@param2": "contractAddress address of the contract against which the parties are registered.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addPartyToContract",
        "visibility": "external",
        "args": [
            {
                "name": "party",
                "type": "address"
            }
        ],
        "func": "function addPartyToContract(address party) external override {\n        address contractAddress = msg.sender;\n        require(contractMap[contractAddress].valid == Validity.Valid, \"Can only add to valid contract\");\n\n        _addPartyToContract(party, contractAddress);\n    }",
        "comments": [
            "/**",
            "     * @notice Adds a party member to the calling contract.",
            "     * @dev msg.sender will be used to determine the contract that this party is added to.",
            "     * @param party new party for the calling contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Adds a party member to the calling contract.\n     * @dev msg.sender will be used to determine the contract that this party is added to.\n     * @param party new party for the calling contract.\n     */\n",
        "@notice": "Adds a party member to the calling contract.",
        "@dev": "msg.sender will be used to determine the contract that this party is added to.",
        "@param1": "party new party for the calling contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removePartyFromContract",
        "visibility": "external",
        "args": [
            {
                "name": "partyAddress",
                "type": "address"
            }
        ],
        "func": "function removePartyFromContract(address partyAddress) external override {\n        address contractAddress = msg.sender;\n        Party storage party = partyMap[partyAddress];\n        uint256 numberOfContracts = party.contracts.length;\n\n        require(numberOfContracts != 0, \"Party has no contracts\");\n        require(contractMap[contractAddress].valid == Validity.Valid, \"Remove only from valid contract\");\n        require(isPartyMemberOfContract(partyAddress, contractAddress), \"Can only remove existing party\");\n\n        // Index of the current location of the contract to remove.\n        uint256 deleteIndex = party.contractIndex[contractAddress];\n\n        // Store the last contract's address to update the lookup map.\n        address lastContractAddress = party.contracts[numberOfContracts - 1];\n\n        // Swap the contract to be removed with the last contract.\n        party.contracts[deleteIndex] = lastContractAddress;\n\n        // Update the lookup index with the new location.\n        party.contractIndex[lastContractAddress] = deleteIndex;\n\n        // Pop the last contract from the array and update the lookup map.\n        party.contracts.pop();\n        delete party.contractIndex[contractAddress];\n\n        emit PartyRemoved(contractAddress, partyAddress);\n    }",
        "comments": [
            "/**",
            "     * @notice Removes a party member from the calling contract.",
            "     * @dev msg.sender will be used to determine the contract that this party is removed from.",
            "     * @param partyAddress address to be removed from the calling contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Removes a party member from the calling contract.\n     * @dev msg.sender will be used to determine the contract that this party is removed from.\n     * @param partyAddress address to be removed from the calling contract.\n     */\n",
        "@notice": "Removes a party member from the calling contract.",
        "@dev": "msg.sender will be used to determine the contract that this party is removed from.",
        "@param1": "partyAddress address to be removed from the calling contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isContractRegistered",
        "visibility": "external",
        "args": [
            {
                "name": "contractAddress",
                "type": "address"
            }
        ],
        "func": "function isContractRegistered(address contractAddress) external view override returns (bool) {\n        return contractMap[contractAddress].valid == Validity.Valid;\n    }",
        "comments": [
            "/**",
            "     * @notice Returns whether the contract has been registered with the registry.",
            "     * @dev If it is registered, it is an authorized participant in the UMA system.",
            "     * @param contractAddress address of the financial contract.",
            "     * @return bool indicates whether the contract is registered.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns whether the contract has been registered with the registry.\n     * @dev If it is registered, it is an authorized participant in the UMA system.\n     * @param contractAddress address of the financial contract.\n     * @return bool indicates whether the contract is registered.\n     */\n",
        "@notice": "Returns whether the contract has been registered with the registry.",
        "@dev": "If it is registered, it is an authorized participant in the UMA system.",
        "@param1": "contractAddress address of the financial contract.",
        "@return1": "bool indicates whether the contract is registered.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getRegisteredContracts",
        "visibility": "external",
        "args": [
            {
                "name": "party",
                "type": "address"
            }
        ],
        "func": "function getRegisteredContracts(address party) external view override returns (address[] memory) {\n        return partyMap[party].contracts;\n    }",
        "comments": [
            "/**",
            "     * @notice Returns a list of all contracts that are associated with a particular party.",
            "     * @param party address of the party.",
            "     * @return an array of the contracts the party is registered to.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns a list of all contracts that are associated with a particular party.\n     * @param party address of the party.\n     * @return an array of the contracts the party is registered to.\n     */\n",
        "@notice": "Returns a list of all contracts that are associated with a particular party.",
        "@param1": "party address of the party.",
        "@return1": "an array of the contracts the party is registered to.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAllRegisteredContracts",
        "visibility": "external",
        "args": [],
        "func": "function getAllRegisteredContracts() external view override returns (address[] memory) {\n        return registeredContracts;\n    }",
        "comments": [
            "/**",
            "     * @notice Returns all registered contracts.",
            "     * @return all registered contract addresses within the system.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns all registered contracts.\n     * @return all registered contract addresses within the system.\n     */\n",
        "@notice": "Returns all registered contracts.",
        "@return1": "all registered contract addresses within the system.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isPartyMemberOfContract",
        "visibility": "public",
        "args": [
            {
                "name": "party",
                "type": "address"
            },
            {
                "name": "contractAddress",
                "type": "address"
            }
        ],
        "func": "function isPartyMemberOfContract(address party, address contractAddress) public view override returns (bool) {\n        uint256 index = partyMap[party].contractIndex[contractAddress];\n        return partyMap[party].contracts.length > index && partyMap[party].contracts[index] == contractAddress;\n    }",
        "comments": [
            "/**",
            "     * @notice checks if an address is a party of a contract.",
            "     * @param party party to check.",
            "     * @param contractAddress address to check against the party.",
            "     * @return bool indicating if the address is a party of the contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice checks if an address is a party of a contract.\n     * @param party party to check.\n     * @param contractAddress address to check against the party.\n     * @return bool indicating if the address is a party of the contract.\n     */\n",
        "@notice": "checks if an address is a party of a contract.",
        "@param1": "party party to check.",
        "@param2": "contractAddress address to check against the party.",
        "@return1": "bool indicating if the address is a party of the contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "snapshot",
        "visibility": "external",
        "args": [],
        "func": "function snapshot() external returns (uint256) {\n        return _snapshot();\n    }",
        "comments": [
            "/**",
            "     * @notice Creates a new snapshot ID.",
            "     * @return uint256 Thew new snapshot ID.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Creates a new snapshot ID.\n     * @return uint256 Thew new snapshot ID.\n     */\n",
        "@notice": "Creates a new snapshot ID.",
        "@return1": "uint256 Thew new snapshot ID.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "external",
        "args": [
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint256"
            }
        ],
        "func": "function mint(address recipient, uint256 value)\n        external\n        override\n        onlyRoleHolder(uint256(Roles.Minter))\n        returns (bool)\n    {\n        _mint(recipient, value);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Mints `value` tokens to `recipient`, returning true on success.",
            "     * @param recipient address to mint to.",
            "     * @param value amount of tokens to mint.",
            "     * @return True if the mint succeeded, or False.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Mints `value` tokens to `recipient`, returning true on success.\n     * @param recipient address to mint to.\n     * @param value amount of tokens to mint.\n     * @return True if the mint succeeded, or False.\n     */\n",
        "@dev": "Mints `value` tokens to `recipient`, returning true on success.",
        "@param1": "recipient address to mint to.",
        "@param2": "value amount of tokens to mint.",
        "@return1": "True if the mint succeeded, or False.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "external",
        "args": [
            {
                "name": "value",
                "type": "uint256"
            }
        ],
        "func": "function burn(uint256 value) external override onlyRoleHolder(uint256(Roles.Burner)) {\n        _burn(msg.sender, value);\n    }",
        "comments": [
            "/**",
            "     * @dev Burns `value` tokens owned by `msg.sender`.",
            "     * @param value amount of tokens to burn.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Burns `value` tokens owned by `msg.sender`.\n     * @param value amount of tokens to burn.\n     */\n",
        "@dev": "Burns `value` tokens owned by `msg.sender`.",
        "@param1": "value amount of tokens to burn.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addMinter",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function addMinter(address account) external virtual override {\n        addMember(uint256(Roles.Minter), account);\n    }",
        "comments": [
            "/**",
            "     * @notice Add Minter role to account.",
            "     * @dev The caller must have the Owner role.",
            "     * @param account The address to which the Minter role is added.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Add Minter role to account.\n     * @dev The caller must have the Owner role.\n     * @param account The address to which the Minter role is added.\n     */\n",
        "@notice": "Add Minter role to account.",
        "@dev": "The caller must have the Owner role.",
        "@param1": "account The address to which the Minter role is added.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addBurner",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function addBurner(address account) external virtual override {\n        addMember(uint256(Roles.Burner), account);\n    }",
        "comments": [
            "/**",
            "     * @notice Add Burner role to account.",
            "     * @dev The caller must have the Owner role.",
            "     * @param account The address to which the Burner role is added.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Add Burner role to account.\n     * @dev The caller must have the Owner role.\n     * @param account The address to which the Burner role is added.\n     */\n",
        "@notice": "Add Burner role to account.",
        "@dev": "The caller must have the Owner role.",
        "@param1": "account The address to which the Burner role is added.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "resetOwner",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function resetOwner(address account) external virtual override {\n        resetMember(uint256(Roles.Owner), account);\n    }",
        "comments": [
            "/**",
            "     * @notice Reset Owner role to account.",
            "     * @dev The caller must have the Owner role.",
            "     * @param account The new holder of the Owner role.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Reset Owner role to account.\n     * @dev The caller must have the Owner role.\n     * @param account The new holder of the Owner role.\n     */\n",
        "@notice": "Reset Owner role to account.",
        "@dev": "The caller must have the Owner role.",
        "@param1": "account The new holder of the Owner role.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOfAt",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            },
            {
                "name": "snapshotId",
                "type": "uint256"
            }
        ],
        "func": "function balanceOfAt(address account, uint256 snapshotId) public view returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\n\n        return snapshotted ? value : balanceOf(account);\n    }",
        "comments": [
            "/**",
            "     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\n     */\n",
        "@dev": "Retrieves the balance of `account` at the time `snapshotId` was created.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupplyAt",
        "visibility": "public",
        "args": [
            {
                "name": "snapshotId",
                "type": "uint256"
            }
        ],
        "func": "function totalSupplyAt(uint256 snapshotId) public view returns(uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\n\n        return snapshotted ? value : totalSupply();\n    }",
        "comments": [
            "/**",
            "     * @dev Retrieves the total supply at the time `snapshotId` was created.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\n     */\n",
        "@dev": "Retrieves the total supply at the time `snapshotId` was created.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "name",
        "visibility": "public",
        "args": [],
        "func": "function name() public view returns (string memory) {\n        return _name;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the name of the token.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the name of the token.\n     */\n",
        "@dev": "Returns the name of the token.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "symbol",
        "visibility": "public",
        "args": [],
        "func": "function symbol() public view returns (string memory) {\n        return _symbol;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the symbol of the token, usually a shorter version of the",
            "     * name.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n",
        "@dev": "Returns the symbol of the token, usually a shorter version of the * name.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decimals",
        "visibility": "public",
        "args": [],
        "func": "function decimals() public view returns (uint8) {\n        return _decimals;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the number of decimals used to get its user representation.",
            "     * For example, if `decimals` equals `2`, a balance of `505` tokens should",
            "     * be displayed to a user as `5,05` (`505 / 10 ** 2`).",
            "     *",
            "     * Tokens usually opt for a value of 18, imitating the relationship between",
            "     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is",
            "     * called.",
            "     *",
            "     * NOTE: This information is only used for _display_ purposes: it in",
            "     * no way affects any of the arithmetic of the contract, including",
            "     * {IERC20-balanceOf} and {IERC20-transfer}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n",
        "@dev": "Returns the number of decimals used to get its user representation. * For example, if `decimals` equals `2`, a balance of `505` tokens should * be displayed to a user as `5,05` (`505 / 10 ** 2`). * * Tokens usually opt for a value of 18, imitating the relationship between * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is * called. * * NOTE: This information is only used for _display_ purposes: it in * no way affects any of the arithmetic of the contract, including * {IERC20-balanceOf} and {IERC20-transfer}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-totalSupply}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-totalSupply}.\n     */\n",
        "@dev": "See {IERC20-totalSupply}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-balanceOf}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-balanceOf}.\n     */\n",
        "@dev": "See {IERC20-balanceOf}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-transfer}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `recipient` cannot be the zero address.",
            "     * - the caller must have a balance of at least `amount`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n",
        "@dev": "See {IERC20-transfer}. * * Requirements: * * - `recipient` cannot be the zero address. * - the caller must have a balance of at least `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allowance",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            }
        ],
        "func": "function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-allowance}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-allowance}.\n     */\n",
        "@dev": "See {IERC20-allowance}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-approve}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n",
        "@dev": "See {IERC20-approve}. * * Requirements: * * - `spender` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-transferFrom}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance. This is not",
            "     * required by the EIP. See the note at the beginning of {ERC20};",
            "     *",
            "     * Requirements:",
            "     * - `sender` and `recipient` cannot be the zero address.",
            "     * - `sender` must have a balance of at least `amount`.",
            "     * - the caller must have allowance for ``sender``'s tokens of at least",
            "     * `amount`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n",
        "@dev": "See {IERC20-transferFrom}. * * Emits an {Approval} event indicating the updated allowance. This is not * required by the EIP. See the note at the beginning of {ERC20}; * * Requirements: * - `sender` and `recipient` cannot be the zero address. * - `sender` must have a balance of at least `amount`. * - the caller must have allowance for ``sender``'s tokens of at least * `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "increaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "addedValue",
                "type": "uint256"
            }
        ],
        "func": "function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Atomically increases the allowance granted to `spender` by the caller.",
            "     *",
            "     * This is an alternative to {approve} that can be used as a mitigation for",
            "     * problems described in {IERC20-approve}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n",
        "@dev": "Atomically increases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decreaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "subtractedValue",
                "type": "uint256"
            }
        ],
        "func": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Atomically decreases the allowance granted to `spender` by the caller.",
            "     *",
            "     * This is an alternative to {approve} that can be used as a mitigation for",
            "     * problems described in {IERC20-approve}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     * - `spender` must have allowance for the caller of at least",
            "     * `subtractedValue`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n",
        "@dev": "Atomically decreases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address. * - `spender` must have allowance for the caller of at least * `subtractedValue`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "upgrade",
        "visibility": "external",
        "args": [],
        "func": "function upgrade() external {\n        require(msg.sender == governor, \"Upgrade can only be initiated by the existing governor.\");\n\n        // Change the addresses in the Finder.\n        finder.changeImplementationAddress(OracleInterfaces.Oracle, newVoting);\n        // Set current Voting contract to migrated.\n        existingVoting.setMigrated(newVoting);\n\n        // Transfer back ownership of old voting contract and the finder to the governor.\n        existingVoting.transferOwnership(governor);\n        finder.transferOwnership(governor);\n    }",
        "comments": [
            "/**",
            "     * @notice Performs the atomic portion of the upgrade process.",
            "     * @dev This method updates the Voting address in the finder, sets the old voting contract to migrated state, and",
            "     * returns ownership of the existing Voting contract and Finder back to the Governor.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Performs the atomic portion of the upgrade process.\n     * @dev This method updates the Voting address in the finder, sets the old voting contract to migrated state, and\n     * returns ownership of the existing Voting contract and Finder back to the Governor.\n     */\n",
        "@notice": "Performs the atomic portion of the upgrade process.",
        "@dev": "This method updates the Voting address in the finder, sets the old voting contract to migrated state, and * returns ownership of the existing Voting contract and Finder back to the Governor.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeImplementationAddress",
        "visibility": "external",
        "args": [
            {
                "name": "interfaceName",
                "type": "bytes32"
            },
            {
                "name": "implementationAddress",
                "type": "address"
            }
        ],
        "func": "function changeImplementationAddress(bytes32 interfaceName, address implementationAddress)\n        external\n        override\n        onlyOwner\n    {\n        interfacesImplemented[interfaceName] = implementationAddress;\n\n        emit InterfaceImplementationChanged(interfaceName, implementationAddress);\n    }",
        "comments": [
            "/**",
            "     * @notice Updates the address of the contract that implements `interfaceName`.",
            "     * @param interfaceName bytes32 of the interface name that is either changed or registered.",
            "     * @param implementationAddress address of the implementation contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Updates the address of the contract that implements `interfaceName`.\n     * @param interfaceName bytes32 of the interface name that is either changed or registered.\n     * @param implementationAddress address of the implementation contract.\n     */\n",
        "@notice": "Updates the address of the contract that implements `interfaceName`.",
        "@param1": "interfaceName bytes32 of the interface name that is either changed or registered.",
        "@param2": "implementationAddress address of the implementation contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getImplementationAddress",
        "visibility": "external",
        "args": [
            {
                "name": "interfaceName",
                "type": "bytes32"
            }
        ],
        "func": "function getImplementationAddress(bytes32 interfaceName) external view override returns (address) {\n        address implementationAddress = interfacesImplemented[interfaceName];\n        require(implementationAddress != address(0x0), \"Implementation not found\");\n        return implementationAddress;\n    }",
        "comments": [
            "/**",
            "     * @notice Gets the address of the contract that implements the given `interfaceName`.",
            "     * @param interfaceName queried interface.",
            "     * @return implementationAddress address of the defined interface.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets the address of the contract that implements the given `interfaceName`.\n     * @param interfaceName queried interface.\n     * @return implementationAddress address of the defined interface.\n     */\n",
        "@notice": "Gets the address of the contract that implements the given `interfaceName`.",
        "@param1": "interfaceName queried interface.",
        "@return1": "implementationAddress address of the defined interface.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "upgrade",
        "visibility": "external",
        "args": [],
        "func": "function upgrade() external {\n        require(msg.sender == existingGovernor, \"Upgrade can only be initiated by the existing governor.\");\n\n        // Change the addresses in the Finder.\n        finder.changeImplementationAddress(OracleInterfaces.Oracle, voting);\n        finder.changeImplementationAddress(OracleInterfaces.IdentifierWhitelist, identifierWhitelist);\n        finder.changeImplementationAddress(OracleInterfaces.Store, store);\n        finder.changeImplementationAddress(OracleInterfaces.FinancialContractsAdmin, financialContractsAdmin);\n        finder.changeImplementationAddress(OracleInterfaces.Registry, registry);\n\n        // Transfer the ownership of the Finder to the new Governor now that all the addresses have been updated.\n        finder.transferOwnership(newGovernor);\n\n        // Inform the existing Voting contract of the address of the new Voting contract and transfer its\n        // ownership to the new governor to allow for any future changes to the migrated contract.\n        existingVoting.setMigrated(voting);\n        existingVoting.transferOwnership(newGovernor);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "requestPrice",
        "visibility": "public",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            }
        ],
        "func": "function requestPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public override {\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\n        Price storage lookup = verifiedPrices[identifier][time][ancillaryData];\n        if (!lookup.isAvailable && !queryIndices[identifier][time][ancillaryData].isValid) {\n            // New query, enqueue it for review.\n            queryIndices[identifier][time][ancillaryData] = QueryIndex(true, requestedPrices.length);\n            requestedPrices.push(QueryPoint(identifier, time, ancillaryData));\n        }\n    }",
        "comments": [
            "",
            "    // Enqueues a request (if a request isn't already present) for the given (identifier, time) pair.",
            "",
            "    "
        ],
        "comt": "\n    // Enqueues a request (if a request isn't already present) for the given (identifier, time) pair.\n\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "pushPrice",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            },
            {
                "name": "price",
                "type": "int256"
            }
        ],
        "func": "function pushPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        int256 price\n    ) external {\n        verifiedPrices[identifier][time][ancillaryData] = Price(true, price, getCurrentTime());\n\n        QueryIndex storage queryIndex = queryIndices[identifier][time][ancillaryData];\n        require(queryIndex.isValid, \"Can't push prices that haven't been requested\");\n        // Delete from the array. Instead of shifting the queries over, replace the contents of `indexToReplace` with\n        // the contents of the last index (unless it is the last index).\n        uint256 indexToReplace = queryIndex.index;\n        delete queryIndices[identifier][time][ancillaryData];\n        uint256 lastIndex = requestedPrices.length - 1;\n        if (lastIndex != indexToReplace) {\n            QueryPoint storage queryToCopy = requestedPrices[lastIndex];\n            queryIndices[queryToCopy.identifier][queryToCopy.time][queryToCopy.ancillaryData].index = indexToReplace;\n            requestedPrices[indexToReplace] = queryToCopy;\n        }\n    }",
        "comments": [
            "",
            "    // Pushes the verified price for a requested query.",
            "    "
        ],
        "comt": "\n    // Pushes the verified price for a requested query.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "hasPrice",
        "visibility": "public",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            }
        ],
        "func": "function hasPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view override returns (bool) {\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\n        Price storage lookup = verifiedPrices[identifier][time][ancillaryData];\n        return lookup.isAvailable;\n    }",
        "comments": [
            "",
            "    // Checks whether a price has been resolved.",
            "    "
        ],
        "comt": "\n    // Checks whether a price has been resolved.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPrice",
        "visibility": "public",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            }
        ],
        "func": "function getPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view override returns (int256) {\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\n        Price storage lookup = verifiedPrices[identifier][time][ancillaryData];\n        require(lookup.isAvailable);\n        return lookup.price;\n    }",
        "comments": [
            "",
            "    // Gets a price that has already been resolved.",
            "    "
        ],
        "comt": "\n    // Gets a price that has already been resolved.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPendingQueries",
        "visibility": "external",
        "args": [],
        "func": "function getPendingQueries() external view returns (QueryPoint[] memory) {\n        return requestedPrices;\n    }",
        "comments": [
            "",
            "    // Gets the queries that still need verified prices.",
            "    "
        ],
        "comt": "\n    // Gets the queries that still need verified prices.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "requestPrice",
        "visibility": "public",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            }
        ],
        "func": "function requestPrice(bytes32 identifier, uint256 time) public override {\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\n        Price storage lookup = verifiedPrices[identifier][time];\n        if (!lookup.isAvailable && !queryIndices[identifier][time].isValid) {\n            // New query, enqueue it for review.\n            queryIndices[identifier][time] = QueryIndex(true, requestedPrices.length);\n            requestedPrices.push(QueryPoint(identifier, time));\n        }\n    }",
        "comments": [
            "",
            "    // Enqueues a request (if a request isn't already present) for the given (identifier, time) pair.",
            "",
            "    "
        ],
        "comt": "\n    // Enqueues a request (if a request isn't already present) for the given (identifier, time) pair.\n\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "pushPrice",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            },
            {
                "name": "price",
                "type": "int256"
            }
        ],
        "func": "function pushPrice(\n        bytes32 identifier,\n        uint256 time,\n        int256 price\n    ) external {\n        verifiedPrices[identifier][time] = Price(true, price, getCurrentTime());\n\n        QueryIndex storage queryIndex = queryIndices[identifier][time];\n        require(queryIndex.isValid, \"Can't push prices that haven't been requested\");\n        // Delete from the array. Instead of shifting the queries over, replace the contents of `indexToReplace` with\n        // the contents of the last index (unless it is the last index).\n        uint256 indexToReplace = queryIndex.index;\n        delete queryIndices[identifier][time];\n        uint256 lastIndex = requestedPrices.length - 1;\n        if (lastIndex != indexToReplace) {\n            QueryPoint storage queryToCopy = requestedPrices[lastIndex];\n            queryIndices[queryToCopy.identifier][queryToCopy.time].index = indexToReplace;\n            requestedPrices[indexToReplace] = queryToCopy;\n        }\n    }",
        "comments": [
            "",
            "    // Pushes the verified price for a requested query.",
            "    "
        ],
        "comt": "\n    // Pushes the verified price for a requested query.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "hasPrice",
        "visibility": "public",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            }
        ],
        "func": "function hasPrice(bytes32 identifier, uint256 time) public view override returns (bool) {\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\n        Price storage lookup = verifiedPrices[identifier][time];\n        return lookup.isAvailable;\n    }",
        "comments": [
            "",
            "    // Checks whether a price has been resolved.",
            "    "
        ],
        "comt": "\n    // Checks whether a price has been resolved.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPrice",
        "visibility": "public",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            }
        ],
        "func": "function getPrice(bytes32 identifier, uint256 time) public view override returns (int256) {\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\n        Price storage lookup = verifiedPrices[identifier][time];\n        require(lookup.isAvailable);\n        return lookup.price;\n    }",
        "comments": [
            "",
            "    // Gets a price that has already been resolved.",
            "    "
        ],
        "comt": "\n    // Gets a price that has already been resolved.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPendingQueries",
        "visibility": "external",
        "args": [],
        "func": "function getPendingQueries() external view returns (QueryPoint[] memory) {\n        return requestedPrices;\n    }",
        "comments": [
            "",
            "    // Gets the queries that still need verified prices.",
            "    "
        ],
        "comt": "\n    // Gets the queries that still need verified prices.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "propose",
        "visibility": "public",
        "args": [
            {
                "name": "transactions",
                "type": "Transaction[] memory"
            }
        ],
        "func": "function propose(Transaction[] memory transactions) public onlyRoleHolder(uint256(Roles.Proposer)) {\n        uint256 id = proposals.length;\n        uint256 time = getCurrentTime();\n\n        // Note: doing all of this array manipulation manually is necessary because directly setting an array of\n        // structs in storage to an an array of structs in memory is currently not implemented in solidity :/.\n\n        // Add a zero-initialized element to the proposals array.\n        proposals.push();\n\n        // Initialize the new proposal.\n        Proposal storage proposal = proposals[id];\n        proposal.requestTime = time;\n\n        // Initialize the transaction array.\n        for (uint256 i = 0; i < transactions.length; i++) {\n            require(transactions[i].to != address(0), \"The `to` address cannot be 0x0\");\n            // If the transaction has any data with it the recipient must be a contract, not an EOA.\n            if (transactions[i].data.length > 0) {\n                require(transactions[i].to.isContract(), \"EOA can't accept tx with data\");\n            }\n            proposal.transactions.push(transactions[i]);\n        }\n\n        bytes32 identifier = _constructIdentifier(id);\n\n        // Request a vote on this proposal in the DVM.\n        OracleInterface oracle = _getOracle();\n        IdentifierWhitelistInterface supportedIdentifiers = _getIdentifierWhitelist();\n        supportedIdentifiers.addSupportedIdentifier(identifier);\n\n        oracle.requestPrice(identifier, time);\n        supportedIdentifiers.removeSupportedIdentifier(identifier);\n\n        emit NewProposal(id, transactions);\n    }",
        "comments": [
            "/**",
            "     * @notice Proposes a new governance action. Can only be called by the holder of the Proposer role.",
            "     * @param transactions list of transactions that are being proposed.",
            "     * @dev You can create the data portion of each transaction by doing the following:",
            "     * ```",
            "     * const truffleContractInstance = await TruffleContract.deployed()",
            "     * const data = truffleContractInstance.methods.methodToCall(arg1, arg2).encodeABI()",
            "     * ```",
            "     * Note: this method must be public because of a solidity limitation that",
            "     * disallows structs arrays to be passed to external functions.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Proposes a new governance action. Can only be called by the holder of the Proposer role.\n     * @param transactions list of transactions that are being proposed.\n     * @dev You can create the data portion of each transaction by doing the following:\n     * ```\n     * const truffleContractInstance = await TruffleContract.deployed()\n     * const data = truffleContractInstance.methods.methodToCall(arg1, arg2).encodeABI()\n     * ```\n     * Note: this method must be public because of a solidity limitation that\n     * disallows structs arrays to be passed to external functions.\n     */\n",
        "@notice": "Proposes a new governance action. Can only be called by the holder of the Proposer role.",
        "@param1": "transactions list of transactions that are being proposed.",
        "@dev": "You can create the data portion of each transaction by doing the following: * ``` * const truffleContractInstance = await TruffleContract.deployed() * const data = truffleContractInstance.methods.methodToCall(arg1, arg2).encodeABI() * ``` * Note: this method must be public because of a solidity limitation that * disallows structs arrays to be passed to external functions.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "executeProposal",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint256"
            },
            {
                "name": "transactionIndex",
                "type": "uint256"
            }
        ],
        "func": "function executeProposal(uint256 id, uint256 transactionIndex) external payable {\n        Proposal storage proposal = proposals[id];\n        int256 price = _getOracle().getPrice(_constructIdentifier(id), proposal.requestTime);\n\n        Transaction memory transaction = proposal.transactions[transactionIndex];\n\n        require(\n            transactionIndex == 0 || proposal.transactions[transactionIndex.sub(1)].to == address(0),\n            \"Previous tx not yet executed\"\n        );\n        require(transaction.to != address(0), \"Tx already executed\");\n        require(price != 0, \"Proposal was rejected\");\n        require(msg.value == transaction.value, \"Must send exact amount of ETH\");\n\n        // Delete the transaction before execution to avoid any potential re-entrancy issues.\n        delete proposal.transactions[transactionIndex];\n\n        require(_executeCall(transaction.to, transaction.value, transaction.data), \"Tx execution failed\");\n\n        emit ProposalExecuted(id, transactionIndex);\n    }",
        "comments": [
            "/**",
            "     * @notice Executes a proposed governance action that has been approved by voters.",
            "     * @dev This can be called by any address. Caller is expected to send enough ETH to execute payable transactions.",
            "     * @param id unique id for the executed proposal.",
            "     * @param transactionIndex unique transaction index for the executed proposal.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Executes a proposed governance action that has been approved by voters.\n     * @dev This can be called by any address. Caller is expected to send enough ETH to execute payable transactions.\n     * @param id unique id for the executed proposal.\n     * @param transactionIndex unique transaction index for the executed proposal.\n     */\n",
        "@notice": "Executes a proposed governance action that has been approved by voters.",
        "@dev": "This can be called by any address. Caller is expected to send enough ETH to execute payable transactions.",
        "@param1": "id unique id for the executed proposal.",
        "@param2": "transactionIndex unique transaction index for the executed proposal.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "numProposals",
        "visibility": "external",
        "args": [],
        "func": "function numProposals() external view returns (uint256) {\n        return proposals.length;\n    }",
        "comments": [
            "/**",
            "     * @notice Gets the total number of proposals (includes executed and non-executed).",
            "     * @return uint256 representing the current number of proposals.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets the total number of proposals (includes executed and non-executed).\n     * @return uint256 representing the current number of proposals.\n     */\n",
        "@notice": "Gets the total number of proposals (includes executed and non-executed).",
        "@return1": "uint256 representing the current number of proposals.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getProposal",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function getProposal(uint256 id) external view returns (Proposal memory) {\n        return proposals[id];\n    }",
        "comments": [
            "/**",
            "     * @notice Gets the proposal data for a particular id.",
            "     * @dev after a proposal is executed, its data will be zeroed out, except for the request time.",
            "     * @param id uniquely identify the identity of the proposal.",
            "     * @return proposal struct containing transactions[] and requestTime.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets the proposal data for a particular id.\n     * @dev after a proposal is executed, its data will be zeroed out, except for the request time.\n     * @param id uniquely identify the identity of the proposal.\n     * @return proposal struct containing transactions[] and requestTime.\n     */\n",
        "@notice": "Gets the proposal data for a particular id.",
        "@dev": "after a proposal is executed, its data will be zeroed out, except for the request time.",
        "@param1": "id uniquely identify the identity of the proposal.",
        "@return1": "proposal struct containing transactions[] and requestTime.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addPrefix",
        "visibility": "external",
        "args": [
            {
                "name": "input",
                "type": "bytes32"
            },
            {
                "name": "prefix",
                "type": "bytes32"
            },
            {
                "name": "prefixLength",
                "type": "uint256"
            }
        ],
        "func": "function addPrefix(\n        bytes32 input,\n        bytes32 prefix,\n        uint256 prefixLength\n    ) external pure returns (bytes32) {\n        return _addPrefix(input, prefix, prefixLength);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "uintToUtf8",
        "visibility": "external",
        "args": [
            {
                "name": "v",
                "type": "uint256"
            }
        ],
        "func": "function uintToUtf8(uint256 v) external pure returns (bytes32 ret) {\n        return _uintToUtf8(v);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "constructIdentifier",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function constructIdentifier(uint256 id) external pure returns (bytes32 identifier) {\n        return _constructIdentifier(id);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "requestTransferPosition",
        "visibility": "public",
        "args": [],
        "func": "function requestTransferPosition() public onlyPreExpiration() nonReentrant() {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.transferPositionRequestPassTimestamp == 0);\n\n        // Make sure the proposed expiration of this request is not post-expiry.\n        uint256 requestPassTime = getCurrentTime().add(withdrawalLiveness);\n        require(requestPassTime < expirationTimestamp);\n\n        // Update the position object for the user.\n        positionData.transferPositionRequestPassTimestamp = requestPassTime;\n\n        emit RequestTransferPosition(msg.sender);\n    }",
        "comments": [
            "/**",
            "     * @notice Requests to transfer ownership of the caller's current position to a new sponsor address.",
            "     * Once the request liveness is passed, the sponsor can execute the transfer and specify the new sponsor.",
            "     * @dev The liveness length is the same as the withdrawal liveness.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Requests to transfer ownership of the caller's current position to a new sponsor address.\n     * Once the request liveness is passed, the sponsor can execute the transfer and specify the new sponsor.\n     * @dev The liveness length is the same as the withdrawal liveness.\n     */\n",
        "@notice": "Requests to transfer ownership of the caller's current position to a new sponsor address. * Once the request liveness is passed, the sponsor can execute the transfer and specify the new sponsor.",
        "@dev": "The liveness length is the same as the withdrawal liveness.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferPositionPassedRequest",
        "visibility": "public",
        "args": [
            {
                "name": "newSponsorAddress",
                "type": "address"
            }
        ],
        "func": "function transferPositionPassedRequest(address newSponsorAddress)\n        public\n        onlyPreExpiration()\n        noPendingWithdrawal(msg.sender)\n        nonReentrant()\n    {\n        require(\n            _getFeeAdjustedCollateral(positions[newSponsorAddress].rawCollateral).isEqual(\n                FixedPoint.fromUnscaledUint(0)\n            )\n        );\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(\n            positionData.transferPositionRequestPassTimestamp != 0 &&\n                positionData.transferPositionRequestPassTimestamp <= getCurrentTime()\n        );\n\n        // Reset transfer request.\n        positionData.transferPositionRequestPassTimestamp = 0;\n\n        positions[newSponsorAddress] = positionData;\n        delete positions[msg.sender];\n\n        emit RequestTransferPositionExecuted(msg.sender, newSponsorAddress);\n        emit NewSponsor(newSponsorAddress);\n        emit EndedSponsorPosition(msg.sender);\n    }",
        "comments": [
            "/**",
            "     * @notice After a passed transfer position request (i.e., by a call to `requestTransferPosition` and waiting",
            "     * `withdrawalLiveness`), transfers ownership of the caller's current position to `newSponsorAddress`.",
            "     * @dev Transferring positions can only occur if the recipient does not already have a position.",
            "     * @param newSponsorAddress is the address to which the position will be transferred.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice After a passed transfer position request (i.e., by a call to `requestTransferPosition` and waiting\n     * `withdrawalLiveness`), transfers ownership of the caller's current position to `newSponsorAddress`.\n     * @dev Transferring positions can only occur if the recipient does not already have a position.\n     * @param newSponsorAddress is the address to which the position will be transferred.\n     */\n",
        "@notice": "After a passed transfer position request (i.e., by a call to `requestTransferPosition` and waiting * `withdrawalLiveness`), transfers ownership of the caller's current position to `newSponsorAddress`.",
        "@dev": "Transferring positions can only occur if the recipient does not already have a position.",
        "@param1": "newSponsorAddress is the address to which the position will be transferred.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cancelTransferPosition",
        "visibility": "external",
        "args": [],
        "func": "function cancelTransferPosition() external onlyPreExpiration() nonReentrant() {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.transferPositionRequestPassTimestamp != 0);\n\n        emit RequestTransferPositionCanceled(msg.sender);\n\n        // Reset withdrawal request.\n        positionData.transferPositionRequestPassTimestamp = 0;\n    }",
        "comments": [
            "/**",
            "     * @notice Cancels a pending transfer position request.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Cancels a pending transfer position request.\n     */\n",
        "@notice": "Cancels a pending transfer position request.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "depositTo",
        "visibility": "public",
        "args": [
            {
                "name": "sponsor",
                "type": "address"
            },
            {
                "name": "collateralAmount",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function depositTo(address sponsor, FixedPoint.Unsigned memory collateralAmount)\n        public\n        onlyPreExpiration()\n        noPendingWithdrawal(sponsor)\n        fees()\n        nonReentrant()\n    {\n        require(collateralAmount.isGreaterThan(0));\n        PositionData storage positionData = _getPositionData(sponsor);\n\n        // Increase the position and global collateral balance by collateral amount.\n        _incrementCollateralBalances(positionData, collateralAmount);\n\n        emit Deposit(sponsor, collateralAmount.rawValue);\n\n        // Move collateral currency from sender to contract.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Transfers `collateralAmount` of `collateralCurrency` into the specified sponsor's position.",
            "     * @dev Increases the collateralization level of a position after creation. This contract must be approved to spend",
            "     * at least `collateralAmount` of `collateralCurrency`.",
            "     * @param sponsor the sponsor to credit the deposit to.",
            "     * @param collateralAmount total amount of collateral tokens to be sent to the sponsor's position.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfers `collateralAmount` of `collateralCurrency` into the specified sponsor's position.\n     * @dev Increases the collateralization level of a position after creation. This contract must be approved to spend\n     * at least `collateralAmount` of `collateralCurrency`.\n     * @param sponsor the sponsor to credit the deposit to.\n     * @param collateralAmount total amount of collateral tokens to be sent to the sponsor's position.\n     */\n",
        "@notice": "Transfers `collateralAmount` of `collateralCurrency` into the specified sponsor's position.",
        "@dev": "Increases the collateralization level of a position after creation. This contract must be approved to spend * at least `collateralAmount` of `collateralCurrency`.",
        "@param1": "sponsor the sponsor to credit the deposit to.",
        "@param2": "collateralAmount total amount of collateral tokens to be sent to the sponsor's position.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "deposit",
        "visibility": "public",
        "args": [
            {
                "name": "collateralAmount",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function deposit(FixedPoint.Unsigned memory collateralAmount) public {\n        // This is just a thin wrapper over depositTo that specified the sender as the sponsor.\n        depositTo(msg.sender, collateralAmount);\n    }",
        "comments": [
            "/**",
            "     * @notice Transfers `collateralAmount` of `collateralCurrency` into the caller's position.",
            "     * @dev Increases the collateralization level of a position after creation. This contract must be approved to spend",
            "     * at least `collateralAmount` of `collateralCurrency`.",
            "     * @param collateralAmount total amount of collateral tokens to be sent to the sponsor's position.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfers `collateralAmount` of `collateralCurrency` into the caller's position.\n     * @dev Increases the collateralization level of a position after creation. This contract must be approved to spend\n     * at least `collateralAmount` of `collateralCurrency`.\n     * @param collateralAmount total amount of collateral tokens to be sent to the sponsor's position.\n     */\n",
        "@notice": "Transfers `collateralAmount` of `collateralCurrency` into the caller's position.",
        "@dev": "Increases the collateralization level of a position after creation. This contract must be approved to spend * at least `collateralAmount` of `collateralCurrency`.",
        "@param1": "collateralAmount total amount of collateral tokens to be sent to the sponsor's position.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "collateralAmount",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function withdraw(FixedPoint.Unsigned memory collateralAmount)\n        public\n        onlyPreExpiration()\n        noPendingWithdrawal(msg.sender)\n        fees()\n        nonReentrant()\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        require(collateralAmount.isGreaterThan(0));\n        PositionData storage positionData = _getPositionData(msg.sender);\n\n        // Decrement the sponsor's collateral and global collateral amounts. Check the GCR between decrement to ensure\n        // position remains above the GCR within the withdrawal. If this is not the case the caller must submit a request.\n        amountWithdrawn = _decrementCollateralBalancesCheckGCR(positionData, collateralAmount);\n\n        emit Withdrawal(msg.sender, amountWithdrawn.rawValue);\n\n        // Move collateral currency from contract to sender.\n        // Note: that we move the amount of collateral that is decreased from rawCollateral (inclusive of fees)\n        // instead of the user requested amount. This eliminates precision loss that could occur\n        // where the user withdraws more collateral than rawCollateral is decremented by.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Transfers `collateralAmount` of `collateralCurrency` from the sponsor's position to the sponsor.",
            "     * @dev Reverts if the withdrawal puts this position's collateralization ratio below the global collateralization",
            "     * ratio. In that case, use `requestWithdrawal`. Might not withdraw the full requested amount to account for precision loss.",
            "     * @param collateralAmount is the amount of collateral to withdraw.",
            "     * @return amountWithdrawn The actual amount of collateral withdrawn.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfers `collateralAmount` of `collateralCurrency` from the sponsor's position to the sponsor.\n     * @dev Reverts if the withdrawal puts this position's collateralization ratio below the global collateralization\n     * ratio. In that case, use `requestWithdrawal`. Might not withdraw the full requested amount to account for precision loss.\n     * @param collateralAmount is the amount of collateral to withdraw.\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\n     */\n",
        "@notice": "Transfers `collateralAmount` of `collateralCurrency` from the sponsor's position to the sponsor.",
        "@dev": "Reverts if the withdrawal puts this position's collateralization ratio below the global collateralization * ratio. In that case, use `requestWithdrawal`. Might not withdraw the full requested amount to account for precision loss.",
        "@param1": "collateralAmount is the amount of collateral to withdraw.",
        "@return1": "amountWithdrawn The actual amount of collateral withdrawn.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "requestWithdrawal",
        "visibility": "public",
        "args": [
            {
                "name": "collateralAmount",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function requestWithdrawal(FixedPoint.Unsigned memory collateralAmount)\n        public\n        onlyPreExpiration()\n        noPendingWithdrawal(msg.sender)\n        nonReentrant()\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(\n            collateralAmount.isGreaterThan(0) &&\n                collateralAmount.isLessThanOrEqual(_getFeeAdjustedCollateral(positionData.rawCollateral))\n        );\n\n        // Make sure the proposed expiration of this request is not post-expiry.\n        uint256 requestPassTime = getCurrentTime().add(withdrawalLiveness);\n        require(requestPassTime < expirationTimestamp);\n\n        // Update the position object for the user.\n        positionData.withdrawalRequestPassTimestamp = requestPassTime;\n        positionData.withdrawalRequestAmount = collateralAmount;\n\n        emit RequestWithdrawal(msg.sender, collateralAmount.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Starts a withdrawal request that, if passed, allows the sponsor to withdraw` from their position.",
            "     * @dev The request will be pending for `withdrawalLiveness`, during which the position can be liquidated.",
            "     * @param collateralAmount the amount of collateral requested to withdraw",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Starts a withdrawal request that, if passed, allows the sponsor to withdraw` from their position.\n     * @dev The request will be pending for `withdrawalLiveness`, during which the position can be liquidated.\n     * @param collateralAmount the amount of collateral requested to withdraw\n     */\n",
        "@notice": "Starts a withdrawal request that, if passed, allows the sponsor to withdraw` from their position.",
        "@dev": "The request will be pending for `withdrawalLiveness`, during which the position can be liquidated.",
        "@param1": "collateralAmount the amount of collateral requested to withdraw",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawPassedRequest",
        "visibility": "external",
        "args": [],
        "func": "function withdrawPassedRequest()\n        external\n        onlyPreExpiration()\n        fees()\n        nonReentrant()\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(\n            positionData.withdrawalRequestPassTimestamp != 0 &&\n                positionData.withdrawalRequestPassTimestamp <= getCurrentTime()\n        );\n\n        // If withdrawal request amount is > position collateral, then withdraw the full collateral amount.\n        // This situation is possible due to fees charged since the withdrawal was originally requested.\n        FixedPoint.Unsigned memory amountToWithdraw = positionData.withdrawalRequestAmount;\n        if (positionData.withdrawalRequestAmount.isGreaterThan(_getFeeAdjustedCollateral(positionData.rawCollateral))) {\n            amountToWithdraw = _getFeeAdjustedCollateral(positionData.rawCollateral);\n        }\n\n        // Decrement the sponsor's collateral and global collateral amounts.\n        amountWithdrawn = _decrementCollateralBalances(positionData, amountToWithdraw);\n\n        // Reset withdrawal request by setting withdrawal amount and withdrawal timestamp to 0.\n        _resetWithdrawalRequest(positionData);\n\n        // Transfer approved withdrawal amount from the contract to the caller.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n\n        emit RequestWithdrawalExecuted(msg.sender, amountWithdrawn.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice After a passed withdrawal request (i.e., by a call to `requestWithdrawal` and waiting",
            "     * `withdrawalLiveness`), withdraws `positionData.withdrawalRequestAmount` of collateral currency.",
            "     * @dev Might not withdraw the full requested amount in order to account for precision loss or if the full requested",
            "     * amount exceeds the collateral in the position (due to paying fees).",
            "     * @return amountWithdrawn The actual amount of collateral withdrawn.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice After a passed withdrawal request (i.e., by a call to `requestWithdrawal` and waiting\n     * `withdrawalLiveness`), withdraws `positionData.withdrawalRequestAmount` of collateral currency.\n     * @dev Might not withdraw the full requested amount in order to account for precision loss or if the full requested\n     * amount exceeds the collateral in the position (due to paying fees).\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\n     */\n",
        "@notice": "After a passed withdrawal request (i.e., by a call to `requestWithdrawal` and waiting * `withdrawalLiveness`), withdraws `positionData.withdrawalRequestAmount` of collateral currency.",
        "@dev": "Might not withdraw the full requested amount in order to account for precision loss or if the full requested * amount exceeds the collateral in the position (due to paying fees).",
        "@return1": "amountWithdrawn The actual amount of collateral withdrawn.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cancelWithdrawal",
        "visibility": "external",
        "args": [],
        "func": "function cancelWithdrawal() external nonReentrant() {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.withdrawalRequestPassTimestamp != 0);\n\n        emit RequestWithdrawalCanceled(msg.sender, positionData.withdrawalRequestAmount.rawValue);\n\n        // Reset withdrawal request by setting withdrawal amount and withdrawal timestamp to 0.\n        _resetWithdrawalRequest(positionData);\n    }",
        "comments": [
            "/**",
            "     * @notice Cancels a pending withdrawal request.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Cancels a pending withdrawal request.\n     */\n",
        "@notice": "Cancels a pending withdrawal request.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "create",
        "visibility": "public",
        "args": [
            {
                "name": "collateralAmount",
                "type": "FixedPoint.Unsigned memory"
            },
            {
                "name": "numTokens",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function create(FixedPoint.Unsigned memory collateralAmount, FixedPoint.Unsigned memory numTokens)\n        public\n        onlyPreExpiration()\n        fees()\n        nonReentrant()\n    {\n        PositionData storage positionData = positions[msg.sender];\n\n        // Either the new create ratio or the resultant position CR must be above the current GCR.\n        require(\n            (_checkCollateralization(\n                _getFeeAdjustedCollateral(positionData.rawCollateral).add(collateralAmount),\n                positionData.tokensOutstanding.add(numTokens)\n            ) || _checkCollateralization(collateralAmount, numTokens)),\n            \"Insufficient collateral\"\n        );\n\n        require(positionData.withdrawalRequestPassTimestamp == 0, \"Pending withdrawal\");\n        if (positionData.tokensOutstanding.isEqual(0)) {\n            require(numTokens.isGreaterThanOrEqual(minSponsorTokens), \"Below minimum sponsor position\");\n            emit NewSponsor(msg.sender);\n        }\n\n        // Increase the position and global collateral balance by collateral amount.\n        _incrementCollateralBalances(positionData, collateralAmount);\n\n        // Add the number of tokens created to the position's outstanding tokens.\n        positionData.tokensOutstanding = positionData.tokensOutstanding.add(numTokens);\n\n        totalTokensOutstanding = totalTokensOutstanding.add(numTokens);\n\n        emit PositionCreated(msg.sender, collateralAmount.rawValue, numTokens.rawValue);\n\n        // Transfer tokens into the contract from caller and mint corresponding synthetic tokens to the caller's address.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n        require(tokenCurrency.mint(msg.sender, numTokens.rawValue));\n    }",
        "comments": [
            "/**",
            "     * @notice Creates tokens by creating a new position or by augmenting an existing position. Pulls `collateralAmount` into the sponsor's position and mints `numTokens` of `tokenCurrency`.",
            "     * @dev Reverts if minting these tokens would put the position's collateralization ratio below the",
            "     * global collateralization ratio. This contract must be approved to spend at least `collateralAmount` of",
            "     * `collateralCurrency`.",
            "     * @dev This contract must have the Minter role for the `tokenCurrency`.",
            "     * @param collateralAmount is the number of collateral tokens to collateralize the position with",
            "     * @param numTokens is the number of tokens to mint from the position.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Creates tokens by creating a new position or by augmenting an existing position. Pulls `collateralAmount` into the sponsor's position and mints `numTokens` of `tokenCurrency`.\n     * @dev Reverts if minting these tokens would put the position's collateralization ratio below the\n     * global collateralization ratio. This contract must be approved to spend at least `collateralAmount` of\n     * `collateralCurrency`.\n     * @dev This contract must have the Minter role for the `tokenCurrency`.\n     * @param collateralAmount is the number of collateral tokens to collateralize the position with\n     * @param numTokens is the number of tokens to mint from the position.\n     */\n",
        "@notice": "Creates tokens by creating a new position or by augmenting an existing position. Pulls `collateralAmount` into the sponsor's position and mints `numTokens` of `tokenCurrency`.",
        "@dev": "Reverts if minting these tokens would put the position's collateralization ratio below the * global collateralization ratio. This contract must be approved to spend at least `collateralAmount` of * `collateralCurrency`. * This contract must have the Minter role for the `tokenCurrency`.",
        "@param1": "collateralAmount is the number of collateral tokens to collateralize the position with",
        "@param2": "numTokens is the number of tokens to mint from the position.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repay",
        "visibility": "public",
        "args": [
            {
                "name": "numTokens",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function repay(FixedPoint.Unsigned memory numTokens)\n        public\n        onlyPreExpiration()\n        noPendingWithdrawal(msg.sender)\n        fees()\n        nonReentrant()\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(numTokens.isLessThanOrEqual(positionData.tokensOutstanding));\n\n        // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\n        FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n        require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens));\n        positionData.tokensOutstanding = newTokenCount;\n\n        // Update the totalTokensOutstanding after redemption.\n        totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n\n        emit Repay(msg.sender, numTokens.rawValue, newTokenCount.rawValue);\n\n        // Transfer the tokens back from the sponsor and burn them.\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n        tokenCurrency.burn(numTokens.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Burns `numTokens` of `tokenCurrency` to decrease sponsors position size, without sending back `collateralCurrency`.",
            "     * This is done by a sponsor to increase position CR. Resulting size is bounded by minSponsorTokens.",
            "     * @dev Can only be called by token sponsor. This contract must be approved to spend `numTokens` of `tokenCurrency`.",
            "     * @dev This contract must have the Burner role for the `tokenCurrency`.",
            "     * @param numTokens is the number of tokens to be burnt from the sponsor's debt position.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Burns `numTokens` of `tokenCurrency` to decrease sponsors position size, without sending back `collateralCurrency`.\n     * This is done by a sponsor to increase position CR. Resulting size is bounded by minSponsorTokens.\n     * @dev Can only be called by token sponsor. This contract must be approved to spend `numTokens` of `tokenCurrency`.\n     * @dev This contract must have the Burner role for the `tokenCurrency`.\n     * @param numTokens is the number of tokens to be burnt from the sponsor's debt position.\n     */\n",
        "@notice": "Burns `numTokens` of `tokenCurrency` to decrease sponsors position size, without sending back `collateralCurrency`. * This is done by a sponsor to increase position CR. Resulting size is bounded by minSponsorTokens.",
        "@dev": "Can only be called by token sponsor. This contract must be approved to spend `numTokens` of `tokenCurrency`. * This contract must have the Burner role for the `tokenCurrency`.",
        "@param1": "numTokens is the number of tokens to be burnt from the sponsor's debt position.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "redeem",
        "visibility": "public",
        "args": [
            {
                "name": "numTokens",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function redeem(FixedPoint.Unsigned memory numTokens)\n        public\n        noPendingWithdrawal(msg.sender)\n        fees()\n        nonReentrant()\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(!numTokens.isGreaterThan(positionData.tokensOutstanding));\n\n        FixedPoint.Unsigned memory fractionRedeemed = numTokens.div(positionData.tokensOutstanding);\n        FixedPoint.Unsigned memory collateralRedeemed =\n            fractionRedeemed.mul(_getFeeAdjustedCollateral(positionData.rawCollateral));\n\n        // If redemption returns all tokens the sponsor has then we can delete their position. Else, downsize.\n        if (positionData.tokensOutstanding.isEqual(numTokens)) {\n            amountWithdrawn = _deleteSponsorPosition(msg.sender);\n        } else {\n            // Decrement the sponsor's collateral and global collateral amounts.\n            amountWithdrawn = _decrementCollateralBalances(positionData, collateralRedeemed);\n\n            // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\n            FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n            require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens), \"Below minimum sponsor position\");\n            positionData.tokensOutstanding = newTokenCount;\n\n            // Update the totalTokensOutstanding after redemption.\n            totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n        }\n\n        emit Redeem(msg.sender, amountWithdrawn.rawValue, numTokens.rawValue);\n\n        // Transfer collateral from contract to caller and burn callers synthetic tokens.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n        tokenCurrency.burn(numTokens.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Burns `numTokens` of `tokenCurrency` and sends back the proportional amount of `collateralCurrency`.",
            "     * @dev Can only be called by a token sponsor. Might not redeem the full proportional amount of collateral",
            "     * in order to account for precision loss. This contract must be approved to spend at least `numTokens` of",
            "     * `tokenCurrency`.",
            "     * @dev This contract must have the Burner role for the `tokenCurrency`.",
            "     * @param numTokens is the number of tokens to be burnt for a commensurate amount of collateral.",
            "     * @return amountWithdrawn The actual amount of collateral withdrawn.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Burns `numTokens` of `tokenCurrency` and sends back the proportional amount of `collateralCurrency`.\n     * @dev Can only be called by a token sponsor. Might not redeem the full proportional amount of collateral\n     * in order to account for precision loss. This contract must be approved to spend at least `numTokens` of\n     * `tokenCurrency`.\n     * @dev This contract must have the Burner role for the `tokenCurrency`.\n     * @param numTokens is the number of tokens to be burnt for a commensurate amount of collateral.\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\n     */\n",
        "@notice": "Burns `numTokens` of `tokenCurrency` and sends back the proportional amount of `collateralCurrency`.",
        "@dev": "Can only be called by a token sponsor. Might not redeem the full proportional amount of collateral * in order to account for precision loss. This contract must be approved to spend at least `numTokens` of * `tokenCurrency`. * This contract must have the Burner role for the `tokenCurrency`.",
        "@param1": "numTokens is the number of tokens to be burnt for a commensurate amount of collateral.",
        "@return1": "amountWithdrawn The actual amount of collateral withdrawn.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "settleExpired",
        "visibility": "external",
        "args": [],
        "func": "function settleExpired()\n        external\n        onlyPostExpiration()\n        fees()\n        nonReentrant()\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        // If the contract state is open and onlyPostExpiration passed then `expire()` has not yet been called.\n        require(contractState != ContractState.Open, \"Unexpired position\");\n\n        // Get the current settlement price and store it. If it is not resolved will revert.\n        if (contractState != ContractState.ExpiredPriceReceived) {\n            expiryPrice = _getOraclePriceExpiration(expirationTimestamp);\n            contractState = ContractState.ExpiredPriceReceived;\n        }\n\n        // Get caller's tokens balance and calculate amount of underlying entitled to them.\n        FixedPoint.Unsigned memory tokensToRedeem = FixedPoint.Unsigned(tokenCurrency.balanceOf(msg.sender));\n        FixedPoint.Unsigned memory totalRedeemableCollateral = tokensToRedeem.mul(expiryPrice);\n\n        // If the caller is a sponsor with outstanding collateral they are also entitled to their excess collateral after their debt.\n        PositionData storage positionData = positions[msg.sender];\n        if (_getFeeAdjustedCollateral(positionData.rawCollateral).isGreaterThan(0)) {\n            // Calculate the underlying entitled to a token sponsor. This is collateral - debt in underlying.\n            FixedPoint.Unsigned memory tokenDebtValueInCollateral = positionData.tokensOutstanding.mul(expiryPrice);\n            FixedPoint.Unsigned memory positionCollateral = _getFeeAdjustedCollateral(positionData.rawCollateral);\n\n            // If the debt is greater than the remaining collateral, they cannot redeem anything.\n            FixedPoint.Unsigned memory positionRedeemableCollateral =\n                tokenDebtValueInCollateral.isLessThan(positionCollateral)\n                    ? positionCollateral.sub(tokenDebtValueInCollateral)\n                    : FixedPoint.Unsigned(0);\n\n            // Add the number of redeemable tokens for the sponsor to their total redeemable collateral.\n            totalRedeemableCollateral = totalRedeemableCollateral.add(positionRedeemableCollateral);\n\n            // Reset the position state as all the value has been removed after settlement.\n            delete positions[msg.sender];\n            emit EndedSponsorPosition(msg.sender);\n        }\n\n        // Take the min of the remaining collateral and the collateral \"owed\". If the contract is undercapitalized,\n        // the caller will get as much collateral as the contract can pay out.\n        FixedPoint.Unsigned memory payout =\n            FixedPoint.min(_getFeeAdjustedCollateral(rawTotalPositionCollateral), totalRedeemableCollateral);\n\n        // Decrement total contract collateral and outstanding debt.\n        amountWithdrawn = _removeCollateral(rawTotalPositionCollateral, payout);\n        totalTokensOutstanding = totalTokensOutstanding.sub(tokensToRedeem);\n\n        emit SettleExpiredPosition(msg.sender, amountWithdrawn.rawValue, tokensToRedeem.rawValue);\n\n        // Transfer tokens & collateral and burn the redeemed tokens.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), tokensToRedeem.rawValue);\n        tokenCurrency.burn(tokensToRedeem.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice After a contract has passed expiry all token holders can redeem their tokens for underlying at the",
            "     * prevailing price defined by the DVM from the `expire` function.",
            "     * @dev This burns all tokens from the caller of `tokenCurrency` and sends back the proportional amount of",
            "     * `collateralCurrency`. Might not redeem the full proportional amount of collateral in order to account for",
            "     * precision loss. This contract must be approved to spend `tokenCurrency` at least up to the caller's full balance.",
            "     * @dev This contract must have the Burner role for the `tokenCurrency`.",
            "     * @return amountWithdrawn The actual amount of collateral withdrawn.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice After a contract has passed expiry all token holders can redeem their tokens for underlying at the\n     * prevailing price defined by the DVM from the `expire` function.\n     * @dev This burns all tokens from the caller of `tokenCurrency` and sends back the proportional amount of\n     * `collateralCurrency`. Might not redeem the full proportional amount of collateral in order to account for\n     * precision loss. This contract must be approved to spend `tokenCurrency` at least up to the caller's full balance.\n     * @dev This contract must have the Burner role for the `tokenCurrency`.\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\n     */\n",
        "@notice": "After a contract has passed expiry all token holders can redeem their tokens for underlying at the * prevailing price defined by the DVM from the `expire` function.",
        "@dev": "This burns all tokens from the caller of `tokenCurrency` and sends back the proportional amount of * `collateralCurrency`. Might not redeem the full proportional amount of collateral in order to account for * precision loss. This contract must be approved to spend `tokenCurrency` at least up to the caller's full balance. * This contract must have the Burner role for the `tokenCurrency`.",
        "@return1": "amountWithdrawn The actual amount of collateral withdrawn.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "expire",
        "visibility": "external",
        "args": [],
        "func": "function expire() external onlyPostExpiration() onlyOpenState() fees() nonReentrant() {\n        contractState = ContractState.ExpiredPriceRequested;\n\n        // Final fees do not need to be paid when sending a request to the optimistic oracle.\n        _requestOraclePriceExpiration(expirationTimestamp);\n\n        emit ContractExpired(msg.sender);\n    }",
        "comments": [
            "/**",
            "     * @notice Locks contract state in expired and requests oracle price.",
            "     * @dev this function can only be called once the contract is expired and can't be re-called.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Locks contract state in expired and requests oracle price.\n     * @dev this function can only be called once the contract is expired and can't be re-called.\n     */\n",
        "@notice": "Locks contract state in expired and requests oracle price.",
        "@dev": "this function can only be called once the contract is expired and can't be re-called.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "emergencyShutdown",
        "visibility": "external",
        "args": [],
        "func": "function emergencyShutdown() external override onlyPreExpiration() onlyOpenState() nonReentrant() {\n        require(msg.sender == _getFinancialContractsAdminAddress());\n\n        contractState = ContractState.ExpiredPriceRequested;\n        // Expiratory time now becomes the current time (emergency shutdown time).\n        // Price requested at this time stamp. `settleExpired` can now withdraw at this timestamp.\n        uint256 oldExpirationTimestamp = expirationTimestamp;\n        expirationTimestamp = getCurrentTime();\n        _requestOraclePriceExpiration(expirationTimestamp);\n\n        emit EmergencyShutdown(msg.sender, oldExpirationTimestamp, expirationTimestamp);\n    }",
        "comments": [
            "/**",
            "     * @notice Premature contract settlement under emergency circumstances.",
            "     * @dev Only the governor can call this function as they are permissioned within the `FinancialContractAdmin`.",
            "     * Upon emergency shutdown, the contract settlement time is set to the shutdown time. This enables withdrawal",
            "     * to occur via the standard `settleExpired` function. Contract state is set to `ExpiredPriceRequested`",
            "     * which prevents re-entry into this function or the `expire` function. No fees are paid when calling",
            "     * `emergencyShutdown` as the governor who would call the function would also receive the fees.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Premature contract settlement under emergency circumstances.\n     * @dev Only the governor can call this function as they are permissioned within the `FinancialContractAdmin`.\n     * Upon emergency shutdown, the contract settlement time is set to the shutdown time. This enables withdrawal\n     * to occur via the standard `settleExpired` function. Contract state is set to `ExpiredPriceRequested`\n     * which prevents re-entry into this function or the `expire` function. No fees are paid when calling\n     * `emergencyShutdown` as the governor who would call the function would also receive the fees.\n     */\n",
        "@notice": "Premature contract settlement under emergency circumstances.",
        "@dev": "Only the governor can call this function as they are permissioned within the `FinancialContractAdmin`. * Upon emergency shutdown, the contract settlement time is set to the shutdown time. This enables withdrawal * to occur via the standard `settleExpired` function. Contract state is set to `ExpiredPriceRequested` * which prevents re-entry into this function or the `expire` function. No fees are paid when calling * `emergencyShutdown` as the governor who would call the function would also receive the fees.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "remargin",
        "visibility": "external",
        "args": [],
        "func": "function remargin() external override onlyPreExpiration() nonReentrant() {\n        return;\n    }",
        "comments": [
            "/**",
            "     * @notice Theoretically supposed to pay fees and move money between margin accounts to make sure they",
            "     * reflect the NAV of the contract. However, this functionality doesn't apply to this contract.",
            "     * @dev This is supposed to be implemented by any contract that inherits `AdministrateeInterface` and callable",
            "     * only by the Governor contract. This method is therefore minimally implemented in this contract and does nothing.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Theoretically supposed to pay fees and move money between margin accounts to make sure they\n     * reflect the NAV of the contract. However, this functionality doesn't apply to this contract.\n     * @dev This is supposed to be implemented by any contract that inherits `AdministrateeInterface` and callable\n     * only by the Governor contract. This method is therefore minimally implemented in this contract and does nothing.\n     */\n",
        "@notice": "Theoretically supposed to pay fees and move money between margin accounts to make sure they * reflect the NAV of the contract. However, this functionality doesn't apply to this contract.",
        "@dev": "This is supposed to be implemented by any contract that inherits `AdministrateeInterface` and callable * only by the Governor contract. This method is therefore minimally implemented in this contract and does nothing.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCollateral",
        "visibility": "external",
        "args": [
            {
                "name": "sponsor",
                "type": "address"
            }
        ],
        "func": "function getCollateral(address sponsor) external view nonReentrantView() returns (FixedPoint.Unsigned memory) {\n        // Note: do a direct access to avoid the validity check.\n        return _getPendingRegularFeeAdjustedCollateral(_getFeeAdjustedCollateral(positions[sponsor].rawCollateral));\n    }",
        "comments": [
            "/**",
            "     * @notice Accessor method for a sponsor's collateral.",
            "     * @dev This is necessary because the struct returned by the positions() method shows",
            "     * rawCollateral, which isn't a user-readable value.",
            "     * @dev This method accounts for pending regular fees that have not yet been withdrawn from this contract, for",
            "     * example if the `lastPaymentTime != currentTime`.",
            "     * @param sponsor address whose collateral amount is retrieved.",
            "     * @return collateralAmount amount of collateral within a sponsors position.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Accessor method for a sponsor's collateral.\n     * @dev This is necessary because the struct returned by the positions() method shows\n     * rawCollateral, which isn't a user-readable value.\n     * @dev This method accounts for pending regular fees that have not yet been withdrawn from this contract, for\n     * example if the `lastPaymentTime != currentTime`.\n     * @param sponsor address whose collateral amount is retrieved.\n     * @return collateralAmount amount of collateral within a sponsors position.\n     */\n",
        "@notice": "Accessor method for a sponsor's collateral.",
        "@dev": "This is necessary because the struct returned by the positions() method shows * rawCollateral, which isn't a user-readable value. * This method accounts for pending regular fees that have not yet been withdrawn from this contract, for * example if the `lastPaymentTime != currentTime`.",
        "@param1": "sponsor address whose collateral amount is retrieved.",
        "@return1": "collateralAmount amount of collateral within a sponsors position.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalPositionCollateral",
        "visibility": "external",
        "args": [],
        "func": "function totalPositionCollateral() external view nonReentrantView() returns (FixedPoint.Unsigned memory) {\n        return _getPendingRegularFeeAdjustedCollateral(_getFeeAdjustedCollateral(rawTotalPositionCollateral));\n    }",
        "comments": [
            "/**",
            "     * @notice Accessor method for the total collateral stored within the PricelessPositionManager.",
            "     * @return totalCollateral amount of all collateral within the Expiring Multi Party Contract.",
            "     * @dev This method accounts for pending regular fees that have not yet been withdrawn from this contract, for",
            "     * example if the `lastPaymentTime != currentTime`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Accessor method for the total collateral stored within the PricelessPositionManager.\n     * @return totalCollateral amount of all collateral within the Expiring Multi Party Contract.\n     * @dev This method accounts for pending regular fees that have not yet been withdrawn from this contract, for\n     * example if the `lastPaymentTime != currentTime`.\n     */\n",
        "@notice": "Accessor method for the total collateral stored within the PricelessPositionManager.",
        "@return1": "totalCollateral amount of all collateral within the Expiring Multi Party Contract.",
        "@dev": "This method accounts for pending regular fees that have not yet been withdrawn from this contract, for * example if the `lastPaymentTime != currentTime`.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transformPrice",
        "visibility": "public",
        "args": [
            {
                "name": "price",
                "type": "FixedPoint.Unsigned memory"
            },
            {
                "name": "requestTime",
                "type": "uint256"
            }
        ],
        "func": "function transformPrice(FixedPoint.Unsigned memory price, uint256 requestTime)\n        public\n        view\n        nonReentrantView()\n        returns (FixedPoint.Unsigned memory)\n    {\n        return _transformPrice(price, requestTime);\n    }",
        "comments": [
            "/**",
            "     * @notice Accessor method to compute a transformed price using the finanicalProductLibrary specified at contract",
            "     * deployment. If no library was provided then no modification to the price is done.",
            "     * @param price input price to be transformed.",
            "     * @param requestTime timestamp the oraclePrice was requested at.",
            "     * @return transformedPrice price with the transformation function applied to it.",
            "     * @dev This method should never revert.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Accessor method to compute a transformed price using the finanicalProductLibrary specified at contract\n     * deployment. If no library was provided then no modification to the price is done.\n     * @param price input price to be transformed.\n     * @param requestTime timestamp the oraclePrice was requested at.\n     * @return transformedPrice price with the transformation function applied to it.\n     * @dev This method should never revert.\n     */\n",
        "@notice": "Accessor method to compute a transformed price using the finanicalProductLibrary specified at contract * deployment. If no library was provided then no modification to the price is done.",
        "@param1": "price input price to be transformed.",
        "@param2": "requestTime timestamp the oraclePrice was requested at.",
        "@return1": "transformedPrice price with the transformation function applied to it.",
        "@dev": "This method should never revert.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transformPriceIdentifier",
        "visibility": "public",
        "args": [
            {
                "name": "requestTime",
                "type": "uint256"
            }
        ],
        "func": "function transformPriceIdentifier(uint256 requestTime) public view nonReentrantView() returns (bytes32) {\n        return _transformPriceIdentifier(requestTime);\n    }",
        "comments": [
            "/**",
            "     * @notice Accessor method to compute a transformed price identifier using the finanicalProductLibrary specified",
            "     * at contract deployment. If no library was provided then no modification to the identifier is done.",
            "     * @param requestTime timestamp the identifier is to be used at.",
            "     * @return transformedPrice price with the transformation function applied to it.",
            "     * @dev This method should never revert.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Accessor method to compute a transformed price identifier using the finanicalProductLibrary specified\n     * at contract deployment. If no library was provided then no modification to the identifier is done.\n     * @param requestTime timestamp the identifier is to be used at.\n     * @return transformedPrice price with the transformation function applied to it.\n     * @dev This method should never revert.\n     */\n",
        "@notice": "Accessor method to compute a transformed price identifier using the finanicalProductLibrary specified * at contract deployment. If no library was provided then no modification to the identifier is done.",
        "@param1": "requestTime timestamp the identifier is to be used at.",
        "@return1": "transformedPrice price with the transformation function applied to it.",
        "@dev": "This method should never revert.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_getSyntheticDecimals",
        "visibility": "public",
        "args": [
            {
                "name": "_collateralAddress",
                "type": "address"
            }
        ],
        "func": "function _getSyntheticDecimals(address _collateralAddress) public view returns (uint8 decimals) {\n        try IERC20Standard(_collateralAddress).decimals() returns (uint8 _decimals) {\n            return _decimals;\n        } catch {\n            return 18;\n        }\n    }",
        "comments": [
            "",
            "    // IERC20Standard.decimals() will revert if the collateral contract has not implemented the decimals() method,",
            "    // which is possible since the method is only an OPTIONAL method in the ERC20 standard:",
            "    // https://eips.ethereum.org/EIPS/eip-20#methods.",
            "    "
        ],
        "comt": "\n    // IERC20Standard.decimals() will revert if the collateral contract has not implemented the decimals() method,\n    // which is possible since the method is only an OPTIONAL method in the ERC20 standard:\n    // https://eips.ethereum.org/EIPS/eip-20#methods.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "payRegularFees",
        "visibility": "public",
        "args": [],
        "func": "function payRegularFees() public nonReentrant() returns (FixedPoint.Unsigned memory) {\n        uint256 time = getCurrentTime();\n        FixedPoint.Unsigned memory collateralPool = _pfc();\n\n        // Fetch the regular fees, late penalty and the max possible to pay given the current collateral within the contract.\n        (\n            FixedPoint.Unsigned memory regularFee,\n            FixedPoint.Unsigned memory latePenalty,\n            FixedPoint.Unsigned memory totalPaid\n        ) = getOutstandingRegularFees(time);\n        lastPaymentTime = time;\n\n        // If there are no fees to pay then exit early.\n        if (totalPaid.isEqual(0)) {\n            return totalPaid;\n        }\n\n        emit RegularFeesPaid(regularFee.rawValue, latePenalty.rawValue);\n\n        _adjustCumulativeFeeMultiplier(totalPaid, collateralPool);\n\n        if (regularFee.isGreaterThan(0)) {\n            StoreInterface store = _getStore();\n            collateralCurrency.safeIncreaseAllowance(address(store), regularFee.rawValue);\n            store.payOracleFeesErc20(address(collateralCurrency), regularFee);\n        }\n\n        if (latePenalty.isGreaterThan(0)) {\n            collateralCurrency.safeTransfer(msg.sender, latePenalty.rawValue);\n        }\n        return totalPaid;\n    }",
        "comments": [
            "/**",
            "     * @notice Pays UMA DVM regular fees (as a % of the collateral pool) to the Store contract.",
            "     * @dev These must be paid periodically for the life of the contract. If the contract has not paid its regular fee",
            "     * in a week or more then a late penalty is applied which is sent to the caller. If the amount of",
            "     * fees owed are greater than the pfc, then this will pay as much as possible from the available collateral.",
            "     * An event is only fired if the fees charged are greater than 0.",
            "     * @return totalPaid Amount of collateral that the contract paid (sum of the amount paid to the Store and caller).",
            "     * This returns 0 and exit early if there is no pfc, fees were already paid during the current block, or the fee rate is 0.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Pays UMA DVM regular fees (as a % of the collateral pool) to the Store contract.\n     * @dev These must be paid periodically for the life of the contract. If the contract has not paid its regular fee\n     * in a week or more then a late penalty is applied which is sent to the caller. If the amount of\n     * fees owed are greater than the pfc, then this will pay as much as possible from the available collateral.\n     * An event is only fired if the fees charged are greater than 0.\n     * @return totalPaid Amount of collateral that the contract paid (sum of the amount paid to the Store and caller).\n     * This returns 0 and exit early if there is no pfc, fees were already paid during the current block, or the fee rate is 0.\n     */\n",
        "@notice": "Pays UMA DVM regular fees (as a % of the collateral pool) to the Store contract.",
        "@dev": "These must be paid periodically for the life of the contract. If the contract has not paid its regular fee * in a week or more then a late penalty is applied which is sent to the caller. If the amount of * fees owed are greater than the pfc, then this will pay as much as possible from the available collateral. * An event is only fired if the fees charged are greater than 0.",
        "@return1": "totalPaid Amount of collateral that the contract paid (sum of the amount paid to the Store and caller). * This returns 0 and exit early if there is no pfc, fees were already paid during the current block, or the fee rate is 0.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getOutstandingRegularFees",
        "visibility": "public",
        "args": [
            {
                "name": "time",
                "type": "uint256"
            }
        ],
        "func": "function getOutstandingRegularFees(uint256 time)\n        public\n        view\n        returns (\n            FixedPoint.Unsigned memory regularFee,\n            FixedPoint.Unsigned memory latePenalty,\n            FixedPoint.Unsigned memory totalPaid\n        )\n    {\n        StoreInterface store = _getStore();\n        FixedPoint.Unsigned memory collateralPool = _pfc();\n\n        // Exit early if there is no collateral or if fees were already paid during this block.\n        if (collateralPool.isEqual(0) || lastPaymentTime == time) {\n            return (regularFee, latePenalty, totalPaid);\n        }\n\n        (regularFee, latePenalty) = store.computeRegularFee(lastPaymentTime, time, collateralPool);\n\n        totalPaid = regularFee.add(latePenalty);\n        if (totalPaid.isEqual(0)) {\n            return (regularFee, latePenalty, totalPaid);\n        }\n        // If the effective fees paid as a % of the pfc is > 100%, then we need to reduce it and make the contract pay\n        // as much of the fee that it can (up to 100% of its pfc). We'll reduce the late penalty first and then the\n        // regular fee, which has the effect of paying the store first, followed by the caller if there is any fee remaining.\n        if (totalPaid.isGreaterThan(collateralPool)) {\n            FixedPoint.Unsigned memory deficit = totalPaid.sub(collateralPool);\n            FixedPoint.Unsigned memory latePenaltyReduction = FixedPoint.min(latePenalty, deficit);\n            latePenalty = latePenalty.sub(latePenaltyReduction);\n            deficit = deficit.sub(latePenaltyReduction);\n            regularFee = regularFee.sub(FixedPoint.min(regularFee, deficit));\n            totalPaid = collateralPool;\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Fetch any regular fees that the contract has pending but has not yet paid. If the fees to be paid are more",
            "     * than the total collateral within the contract then the totalPaid returned is full contract collateral amount.",
            "     * @dev This returns 0 and exit early if there is no pfc, fees were already paid during the current block, or the fee rate is 0.",
            "     * @return regularFee outstanding unpaid regular fee.",
            "     * @return latePenalty outstanding unpaid late fee for being late in previous fee payments.",
            "     * @return totalPaid Amount of collateral that the contract paid (sum of the amount paid to the Store and caller).",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Fetch any regular fees that the contract has pending but has not yet paid. If the fees to be paid are more\n     * than the total collateral within the contract then the totalPaid returned is full contract collateral amount.\n     * @dev This returns 0 and exit early if there is no pfc, fees were already paid during the current block, or the fee rate is 0.\n     * @return regularFee outstanding unpaid regular fee.\n     * @return latePenalty outstanding unpaid late fee for being late in previous fee payments.\n     * @return totalPaid Amount of collateral that the contract paid (sum of the amount paid to the Store and caller).\n     */\n",
        "@notice": "Fetch any regular fees that the contract has pending but has not yet paid. If the fees to be paid are more * than the total collateral within the contract then the totalPaid returned is full contract collateral amount.",
        "@dev": "This returns 0 and exit early if there is no pfc, fees were already paid during the current block, or the fee rate is 0.",
        "@return1": "regularFee outstanding unpaid regular fee.",
        "@return2": "latePenalty outstanding unpaid late fee for being late in previous fee payments.",
        "@return3": "totalPaid Amount of collateral that the contract paid (sum of the amount paid to the Store and caller).",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "pfc",
        "visibility": "external",
        "args": [],
        "func": "function pfc() external view override nonReentrantView() returns (FixedPoint.Unsigned memory) {\n        return _pfc();\n    }",
        "comments": [
            "/**",
            "     * @notice Gets the current profit from corruption for this contract in terms of the collateral currency.",
            "     * @dev This is equivalent to the collateral pool available from which to pay fees. Therefore, derived contracts are",
            "     * expected to implement this so that pay-fee methods can correctly compute the owed fees as a % of PfC.",
            "     * @return pfc value for equal to the current profit from corruption denominated in collateral currency.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets the current profit from corruption for this contract in terms of the collateral currency.\n     * @dev This is equivalent to the collateral pool available from which to pay fees. Therefore, derived contracts are\n     * expected to implement this so that pay-fee methods can correctly compute the owed fees as a % of PfC.\n     * @return pfc value for equal to the current profit from corruption denominated in collateral currency.\n     */\n",
        "@notice": "Gets the current profit from corruption for this contract in terms of the collateral currency.",
        "@dev": "This is equivalent to the collateral pool available from which to pay fees. Therefore, derived contracts are * expected to implement this so that pay-fee methods can correctly compute the owed fees as a % of PfC.",
        "@return1": "pfc value for equal to the current profit from corruption denominated in collateral currency.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "gulp",
        "visibility": "external",
        "args": [],
        "func": "function gulp() external nonReentrant() {\n        _gulp();\n    }",
        "comments": [
            "/**",
            "     * @notice Removes excess collateral balance not counted in the PfC by distributing it out pro-rata to all sponsors.",
            "     * @dev Multiplying the `cumulativeFeeMultiplier` by the ratio of non-PfC-collateral :: PfC-collateral effectively",
            "     * pays all sponsors a pro-rata portion of the excess collateral.",
            "     * @dev This will revert if PfC is 0 and this contract's collateral balance > 0.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Removes excess collateral balance not counted in the PfC by distributing it out pro-rata to all sponsors.\n     * @dev Multiplying the `cumulativeFeeMultiplier` by the ratio of non-PfC-collateral :: PfC-collateral effectively\n     * pays all sponsors a pro-rata portion of the excess collateral.\n     * @dev This will revert if PfC is 0 and this contract's collateral balance > 0.\n     */\n",
        "@notice": "Removes excess collateral balance not counted in the PfC by distributing it out pro-rata to all sponsors.",
        "@dev": "Multiplying the `cumulativeFeeMultiplier` by the ratio of non-PfC-collateral :: PfC-collateral effectively * pays all sponsors a pro-rata portion of the excess collateral. * This will revert if PfC is 0 and this contract's collateral balance > 0.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transformPrice",
        "visibility": "public",
        "args": [
            {
                "name": "oraclePrice",
                "type": "FixedPoint.Unsigned memory"
            },
            {
                "name": "requestTime",
                "type": "uint256"
            }
        ],
        "func": "function transformPrice(FixedPoint.Unsigned memory oraclePrice, uint256 requestTime)\n        public\n        view\n        virtual\n        returns (FixedPoint.Unsigned memory)\n    {\n        return oraclePrice;\n    }",
        "comments": [
            "/**",
            "     * @notice Transforms a given oracle price using the financial product libraries transformation logic.",
            "     * @param oraclePrice input price returned by the DVM to be transformed.",
            "     * @param requestTime timestamp the oraclePrice was requested at.",
            "     * @return transformedOraclePrice input oraclePrice with the transformation function applied.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transforms a given oracle price using the financial product libraries transformation logic.\n     * @param oraclePrice input price returned by the DVM to be transformed.\n     * @param requestTime timestamp the oraclePrice was requested at.\n     * @return transformedOraclePrice input oraclePrice with the transformation function applied.\n     */\n",
        "@notice": "Transforms a given oracle price using the financial product libraries transformation logic.",
        "@param1": "oraclePrice input price returned by the DVM to be transformed.",
        "@param2": "requestTime timestamp the oraclePrice was requested at.",
        "@return1": "transformedOraclePrice input oraclePrice with the transformation function applied.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transformCollateralRequirement",
        "visibility": "public",
        "args": [
            {
                "name": "oraclePrice",
                "type": "FixedPoint.Unsigned memory"
            },
            {
                "name": "collateralRequirement",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function transformCollateralRequirement(\n        FixedPoint.Unsigned memory oraclePrice,\n        FixedPoint.Unsigned memory collateralRequirement\n    ) public view virtual returns (FixedPoint.Unsigned memory) {\n        return collateralRequirement;\n    }",
        "comments": [
            "/**",
            "     * @notice Transforms a given collateral requirement using the financial product libraries transformation logic.",
            "     * @param oraclePrice input price returned by DVM used to transform the collateral requirement.",
            "     * @param collateralRequirement input collateral requirement to be transformed.",
            "     * @return transformedCollateralRequirement input collateral requirement with the transformation function applied.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transforms a given collateral requirement using the financial product libraries transformation logic.\n     * @param oraclePrice input price returned by DVM used to transform the collateral requirement.\n     * @param collateralRequirement input collateral requirement to be transformed.\n     * @return transformedCollateralRequirement input collateral requirement with the transformation function applied.\n     */\n",
        "@notice": "Transforms a given collateral requirement using the financial product libraries transformation logic.",
        "@param1": "oraclePrice input price returned by DVM used to transform the collateral requirement.",
        "@param2": "collateralRequirement input collateral requirement to be transformed.",
        "@return1": "transformedCollateralRequirement input collateral requirement with the transformation function applied.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transformPriceIdentifier",
        "visibility": "public",
        "args": [
            {
                "name": "priceIdentifier",
                "type": "bytes32"
            },
            {
                "name": "requestTime",
                "type": "uint256"
            }
        ],
        "func": "function transformPriceIdentifier(bytes32 priceIdentifier, uint256 requestTime)\n        public\n        view\n        virtual\n        returns (bytes32)\n    {\n        return priceIdentifier;\n    }",
        "comments": [
            "/**",
            "     * @notice Transforms a given price identifier using the financial product libraries transformation logic.",
            "     * @param priceIdentifier input price identifier defined for the financial contract.",
            "     * @param requestTime timestamp the identifier is to be used at. EG the time that a price request would be sent using this identifier.",
            "     * @return transformedPriceIdentifier input price identifier with the transformation function applied.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transforms a given price identifier using the financial product libraries transformation logic.\n     * @param priceIdentifier input price identifier defined for the financial contract.\n     * @param requestTime timestamp the identifier is to be used at. EG the time that a price request would be sent using this identifier.\n     * @return transformedPriceIdentifier input price identifier with the transformation function applied.\n     */\n",
        "@notice": "Transforms a given price identifier using the financial product libraries transformation logic.",
        "@param1": "priceIdentifier input price identifier defined for the financial contract.",
        "@param2": "requestTime timestamp the identifier is to be used at. EG the time that a price request would be sent using this identifier.",
        "@return1": "transformedPriceIdentifier input price identifier with the transformation function applied.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setShouldRevert",
        "visibility": "public",
        "args": [
            {
                "name": "_shouldRevert",
                "type": "bool"
            }
        ],
        "func": "function setShouldRevert(bool _shouldRevert) public {\n        shouldRevert = _shouldRevert;\n    }",
        "comments": [
            "",
            "    // Set the mocked methods to revert to test failed library computation.",
            "    "
        ],
        "comt": "\n    // Set the mocked methods to revert to test failed library computation.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transformPrice",
        "visibility": "public",
        "args": [
            {
                "name": "oraclePrice",
                "type": "FixedPoint.Unsigned memory"
            },
            {
                "name": "requestTime",
                "type": "uint256"
            }
        ],
        "func": "function transformPrice(FixedPoint.Unsigned memory oraclePrice, uint256 requestTime)\n        public\n        view\n        override\n        returns (FixedPoint.Unsigned memory)\n    {\n        require(!shouldRevert, \"set to always reverts\");\n        return oraclePrice.mul(priceTransformationScalar);\n    }",
        "comments": [
            "",
            "    // Create a simple price transformation function that scales the input price by the scalar for testing.",
            "    "
        ],
        "comt": "\n    // Create a simple price transformation function that scales the input price by the scalar for testing.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transformCollateralRequirement",
        "visibility": "public",
        "args": [
            {
                "name": "price",
                "type": "FixedPoint.Unsigned memory"
            },
            {
                "name": "collateralRequirement",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function transformCollateralRequirement(\n        FixedPoint.Unsigned memory price,\n        FixedPoint.Unsigned memory collateralRequirement\n    ) public view override returns (FixedPoint.Unsigned memory) {\n        require(!shouldRevert, \"set to always reverts\");\n        return collateralRequirement.mul(collateralRequirementTransformationScalar);\n    }",
        "comments": [
            "",
            "    // Create a simple collateral requirement transformation that doubles the input collateralRequirement.",
            "    "
        ],
        "comt": "\n    // Create a simple collateral requirement transformation that doubles the input collateralRequirement.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transformPriceIdentifier",
        "visibility": "public",
        "args": [
            {
                "name": "priceIdentifier",
                "type": "bytes32"
            },
            {
                "name": "requestTime",
                "type": "uint256"
            }
        ],
        "func": "function transformPriceIdentifier(bytes32 priceIdentifier, uint256 requestTime)\n        public\n        view\n        override\n        returns (bytes32)\n    {\n        require(!shouldRevert, \"set to always reverts\");\n        return transformedPriceIdentifier;\n    }",
        "comments": [
            "",
            "    // Create a simple transformPriceIdentifier function that returns the transformed price identifier.",
            "    "
        ],
        "comt": "\n    // Create a simple transformPriceIdentifier function that returns the transformed price identifier.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transformPrice",
        "visibility": "public",
        "args": [
            {
                "name": "price",
                "type": "FixedPoint.Unsigned memory"
            },
            {
                "name": "requestTime",
                "type": "uint256"
            }
        ],
        "func": "function transformPrice(FixedPoint.Unsigned memory price, uint256 requestTime)\n        public\n        view\n        returns (FixedPoint.Unsigned memory)\n    {\n        if (address(financialProductLibrary) == address(0)) return price;\n        try financialProductLibrary.transformPrice(price, requestTime) returns (\n            FixedPoint.Unsigned memory transformedPrice\n        ) {\n            return transformedPrice;\n        } catch {\n            return price;\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transformCollateralRequirement",
        "visibility": "public",
        "args": [
            {
                "name": "price",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function transformCollateralRequirement(FixedPoint.Unsigned memory price)\n        public\n        view\n        returns (FixedPoint.Unsigned memory)\n    {\n        if (address(financialProductLibrary) == address(0)) return collateralRequirement;\n        try financialProductLibrary.transformCollateralRequirement(price, collateralRequirement) returns (\n            FixedPoint.Unsigned memory transformedCollateralRequirement\n        ) {\n            return transformedCollateralRequirement;\n        } catch {\n            return collateralRequirement;\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transformPriceIdentifier",
        "visibility": "public",
        "args": [
            {
                "name": "requestTime",
                "type": "uint256"
            }
        ],
        "func": "function transformPriceIdentifier(uint256 requestTime) public view returns (bytes32) {\n        if (address(financialProductLibrary) == address(0)) return priceIdentifier;\n        try financialProductLibrary.transformPriceIdentifier(priceIdentifier, requestTime) returns (\n            bytes32 transformedIdentifier\n        ) {\n            return transformedIdentifier;\n        } catch {\n            return priceIdentifier;\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "commitVote",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            },
            {
                "name": "hash",
                "type": "bytes32"
            }
        ],
        "func": "function commitVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bytes32 hash\n    ) external onlyRoleHolder(uint256(Roles.Voter)) {\n        _getVotingAddress().commitVote(identifier, time, ancillaryData, hash);\n    }",
        "comments": [
            "/**",
            "     * @notice Forwards a commit to Voting.",
            "     * @param identifier uniquely identifies the feed for this vote. EG BTC/USD price pair.",
            "     * @param time specifies the unix timestamp of the price being voted on.",
            "     * @param hash the keccak256 hash of the price you want to vote for and a random integer salt value.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Forwards a commit to Voting.\n     * @param identifier uniquely identifies the feed for this vote. EG BTC/USD price pair.\n     * @param time specifies the unix timestamp of the price being voted on.\n     * @param hash the keccak256 hash of the price you want to vote for and a random integer salt value.\n     */\n",
        "@notice": "Forwards a commit to Voting.",
        "@param1": "identifier uniquely identifies the feed for this vote. EG BTC/USD price pair.",
        "@param2": "time specifies the unix timestamp of the price being voted on.",
        "@param3": "hash the keccak256 hash of the price you want to vote for and a random integer salt value.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "batchCommit",
        "visibility": "external",
        "args": [
            {
                "name": "commits",
                "type": "VotingAncillaryInterface.CommitmentAncillary[] calldata"
            }
        ],
        "func": "function batchCommit(VotingAncillaryInterface.CommitmentAncillary[] calldata commits)\n        external\n        onlyRoleHolder(uint256(Roles.Voter))\n    {\n        _getVotingAddress().batchCommit(commits);\n    }",
        "comments": [
            "/**",
            "     * @notice Forwards a batch commit to Voting.",
            "     * @param commits struct to encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Forwards a batch commit to Voting.\n     * @param commits struct to encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.\n     */\n",
        "@notice": "Forwards a batch commit to Voting.",
        "@param1": "commits struct to encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "revealVote",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            },
            {
                "name": "price",
                "type": "int256"
            },
            {
                "name": "ancillaryData",
                "type": "bytes memory"
            },
            {
                "name": "salt",
                "type": "int256"
            }
        ],
        "func": "function revealVote(\n        bytes32 identifier,\n        uint256 time,\n        int256 price,\n        bytes memory ancillaryData,\n        int256 salt\n    ) external onlyRoleHolder(uint256(Roles.Voter)) {\n        _getVotingAddress().revealVote(identifier, time, price, ancillaryData, salt);\n    }",
        "comments": [
            "/**",
            "     * @notice Forwards a reveal to Voting.",
            "     * @param identifier voted on in the commit phase. EG BTC/USD price pair.",
            "     * @param time specifies the unix timestamp of the price being voted on.",
            "     * @param price used along with the `salt` to produce the `hash` during the commit phase.",
            "     * @param salt used along with the `price` to produce the `hash` during the commit phase.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Forwards a reveal to Voting.\n     * @param identifier voted on in the commit phase. EG BTC/USD price pair.\n     * @param time specifies the unix timestamp of the price being voted on.\n     * @param price used along with the `salt` to produce the `hash` during the commit phase.\n     * @param salt used along with the `price` to produce the `hash` during the commit phase.\n     */\n",
        "@notice": "Forwards a reveal to Voting.",
        "@param1": "identifier voted on in the commit phase. EG BTC/USD price pair.",
        "@param2": "time specifies the unix timestamp of the price being voted on.",
        "@param3": "price used along with the `salt` to produce the `hash` during the commit phase.",
        "@param4": "salt used along with the `price` to produce the `hash` during the commit phase.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "batchReveal",
        "visibility": "external",
        "args": [
            {
                "name": "reveals",
                "type": "VotingAncillaryInterface.RevealAncillary[] calldata"
            }
        ],
        "func": "function batchReveal(VotingAncillaryInterface.RevealAncillary[] calldata reveals)\n        external\n        onlyRoleHolder(uint256(Roles.Voter))\n    {\n        _getVotingAddress().batchReveal(reveals);\n    }",
        "comments": [
            "/**",
            "     * @notice Forwards a batch reveal to Voting.",
            "     * @param reveals is an array of the Reveal struct which contains an identifier, time, price and salt.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Forwards a batch reveal to Voting.\n     * @param reveals is an array of the Reveal struct which contains an identifier, time, price and salt.\n     */\n",
        "@notice": "Forwards a batch reveal to Voting.",
        "@param1": "reveals is an array of the Reveal struct which contains an identifier, time, price and salt.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "retrieveRewards",
        "visibility": "public",
        "args": [
            {
                "name": "roundId",
                "type": "uint256"
            },
            {
                "name": "toRetrieve",
                "type": "VotingAncillaryInterface.PendingRequestAncillary[] memory"
            }
        ],
        "func": "function retrieveRewards(uint256 roundId, VotingAncillaryInterface.PendingRequestAncillary[] memory toRetrieve)\n        public\n        onlyRoleHolder(uint256(Roles.Voter))\n        returns (FixedPoint.Unsigned memory)\n    {\n        return _getVotingAddress().retrieveRewards(address(this), roundId, toRetrieve);\n    }",
        "comments": [
            "/**",
            "     * @notice Forwards a reward retrieval to Voting.",
            "     * @dev Rewards are added to the tokens already held by this contract.",
            "     * @param roundId defines the round from which voting rewards will be retrieved from.",
            "     * @param toRetrieve an array of PendingRequests which rewards are retrieved from.",
            "     * @return amount of rewards that the user should receive.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Forwards a reward retrieval to Voting.\n     * @dev Rewards are added to the tokens already held by this contract.\n     * @param roundId defines the round from which voting rewards will be retrieved from.\n     * @param toRetrieve an array of PendingRequests which rewards are retrieved from.\n     * @return amount of rewards that the user should receive.\n     */\n",
        "@notice": "Forwards a reward retrieval to Voting.",
        "@dev": "Rewards are added to the tokens already held by this contract.",
        "@param1": "roundId defines the round from which voting rewards will be retrieved from.",
        "@param2": "toRetrieve an array of PendingRequests which rewards are retrieved from.",
        "@return1": "amount of rewards that the user should receive.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "newDesignatedVoting",
        "visibility": "external",
        "args": [
            {
                "name": "ownerAddress",
                "type": "address"
            }
        ],
        "func": "function newDesignatedVoting(address ownerAddress) external returns (DesignatedVoting) {\n        require(address(designatedVotingContracts[msg.sender]) == address(0), \"Duplicate hot key not permitted\");\n\n        DesignatedVoting designatedVoting = new DesignatedVoting(finder, ownerAddress, msg.sender);\n        designatedVotingContracts[msg.sender] = designatedVoting;\n        return designatedVoting;\n    }",
        "comments": [
            "/**",
            "     * @notice Deploys a new `DesignatedVoting` contract.",
            "     * @param ownerAddress defines who will own the deployed instance of the designatedVoting contract.",
            "     * @return designatedVoting a new DesignatedVoting contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Deploys a new `DesignatedVoting` contract.\n     * @param ownerAddress defines who will own the deployed instance of the designatedVoting contract.\n     * @return designatedVoting a new DesignatedVoting contract.\n     */\n",
        "@notice": "Deploys a new `DesignatedVoting` contract.",
        "@param1": "ownerAddress defines who will own the deployed instance of the designatedVoting contract.",
        "@return1": "designatedVoting a new DesignatedVoting contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setDesignatedVoting",
        "visibility": "external",
        "args": [
            {
                "name": "designatedVotingAddress",
                "type": "address"
            }
        ],
        "func": "function setDesignatedVoting(address designatedVotingAddress) external {\n        require(address(designatedVotingContracts[msg.sender]) == address(0), \"Duplicate hot key not permitted\");\n        designatedVotingContracts[msg.sender] = DesignatedVoting(designatedVotingAddress);\n    }",
        "comments": [
            "/**",
            "     * @notice Associates a `DesignatedVoting` instance with `msg.sender`.",
            "     * @param designatedVotingAddress address to designate voting to.",
            "     * @dev This is generally only used if the owner of a `DesignatedVoting` contract changes their `voter`",
            "     * address and wants that reflected here.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Associates a `DesignatedVoting` instance with `msg.sender`.\n     * @param designatedVotingAddress address to designate voting to.\n     * @dev This is generally only used if the owner of a `DesignatedVoting` contract changes their `voter`\n     * address and wants that reflected here.\n     */\n",
        "@notice": "Associates a `DesignatedVoting` instance with `msg.sender`.",
        "@param1": "designatedVotingAddress address to designate voting to.",
        "@dev": "This is generally only used if the owner of a `DesignatedVoting` contract changes their `voter` * address and wants that reflected here.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "pay",
        "visibility": "external",
        "args": [],
        "func": "function pay() external payable {\n        require(msg.value > 0);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setInternalWithdrawRole",
        "visibility": "public",
        "args": [
            {
                "name": "setRoleId",
                "type": "uint256"
            }
        ],
        "func": "function setInternalWithdrawRole(uint256 setRoleId) public {\n        _setWithdrawRole(setRoleId);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allocateTo",
        "visibility": "external",
        "args": [
            {
                "name": "ownerAddress",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint256"
            }
        ],
        "func": "function allocateTo(address ownerAddress, uint256 value) external {\n        _mint(ownerAddress, value);\n    }",
        "comments": [
            "",
            "    // Sample token information.",
            "",
            "    /**",
            "     * @notice Mints value tokens to the owner address.",
            "     * @param ownerAddress the address to mint to.",
            "     * @param value the amount of tokens to mint.",
            "     */",
            "    "
        ],
        "comt": "\n    // Sample token information.\n\n    /**\n     * @notice Mints value tokens to the owner address.\n     * @param ownerAddress the address to mint to.\n     * @param value the amount of tokens to mint.\n     */\n    ",
        "@notice": "Mints value tokens to the owner address.",
        "@param1": "ownerAddress the address to mint to.",
        "@param2": "value the amount of tokens to mint.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addSupportedIdentifier",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            }
        ],
        "func": "function addSupportedIdentifier(bytes32 identifier) external override onlyOwner {\n        if (!supportedIdentifiers[identifier]) {\n            supportedIdentifiers[identifier] = true;\n            emit SupportedIdentifierAdded(identifier);\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Adds the provided identifier as a supported identifier.",
            "     * @dev Price requests using this identifier will succeed after this call.",
            "     * @param identifier unique UTF-8 representation for the feed being added. Eg: BTC/USD.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Adds the provided identifier as a supported identifier.\n     * @dev Price requests using this identifier will succeed after this call.\n     * @param identifier unique UTF-8 representation for the feed being added. Eg: BTC/USD.\n     */\n",
        "@notice": "Adds the provided identifier as a supported identifier.",
        "@dev": "Price requests using this identifier will succeed after this call.",
        "@param1": "identifier unique UTF-8 representation for the feed being added. Eg: BTC/USD.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeSupportedIdentifier",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            }
        ],
        "func": "function removeSupportedIdentifier(bytes32 identifier) external override onlyOwner {\n        if (supportedIdentifiers[identifier]) {\n            supportedIdentifiers[identifier] = false;\n            emit SupportedIdentifierRemoved(identifier);\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Removes the identifier from the whitelist.",
            "     * @dev Price requests using this identifier will no longer succeed after this call.",
            "     * @param identifier unique UTF-8 representation for the feed being removed. Eg: BTC/USD.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Removes the identifier from the whitelist.\n     * @dev Price requests using this identifier will no longer succeed after this call.\n     * @param identifier unique UTF-8 representation for the feed being removed. Eg: BTC/USD.\n     */\n",
        "@notice": "Removes the identifier from the whitelist.",
        "@dev": "Price requests using this identifier will no longer succeed after this call.",
        "@param1": "identifier unique UTF-8 representation for the feed being removed. Eg: BTC/USD.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isIdentifierSupported",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            }
        ],
        "func": "function isIdentifierSupported(bytes32 identifier) external view override returns (bool) {\n        return supportedIdentifiers[identifier];\n    }",
        "comments": [
            "/**",
            "     * @notice Checks whether an identifier is on the whitelist.",
            "     * @param identifier unique UTF-8 representation for the feed being queried. Eg: BTC/USD.",
            "     * @return bool if the identifier is supported (or not).",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Checks whether an identifier is on the whitelist.\n     * @param identifier unique UTF-8 representation for the feed being queried. Eg: BTC/USD.\n     * @return bool if the identifier is supported (or not).\n     */\n",
        "@notice": "Checks whether an identifier is on the whitelist.",
        "@param1": "identifier unique UTF-8 representation for the feed being queried. Eg: BTC/USD.",
        "@return1": "bool if the identifier is supported (or not).",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "callEmergencyShutdown",
        "visibility": "external",
        "args": [
            {
                "name": "financialContract",
                "type": "address"
            }
        ],
        "func": "function callEmergencyShutdown(address financialContract) external onlyOwner {\n        AdministrateeInterface administratee = AdministrateeInterface(financialContract);\n        administratee.emergencyShutdown();\n    }",
        "comments": [
            "/**",
            "     * @notice Calls emergency shutdown on the provided financial contract.",
            "     * @param financialContract address of the FinancialContract to be shut down.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Calls emergency shutdown on the provided financial contract.\n     * @param financialContract address of the FinancialContract to be shut down.\n     */\n",
        "@notice": "Calls emergency shutdown on the provided financial contract.",
        "@param1": "financialContract address of the FinancialContract to be shut down.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "callRemargin",
        "visibility": "external",
        "args": [
            {
                "name": "financialContract",
                "type": "address"
            }
        ],
        "func": "function callRemargin(address financialContract) external onlyOwner {\n        AdministrateeInterface administratee = AdministrateeInterface(financialContract);\n        administratee.remargin();\n    }",
        "comments": [
            "/**",
            "     * @notice Calls remargin on the provided financial contract.",
            "     * @param financialContract address of the FinancialContract to be remargined.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Calls remargin on the provided financial contract.\n     * @param financialContract address of the FinancialContract to be remargined.\n     */\n",
        "@notice": "Calls remargin on the provided financial contract.",
        "@param1": "financialContract address of the FinancialContract to be remargined.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "remargin",
        "visibility": "external",
        "args": [],
        "func": "function remargin() external override {\n        timesRemargined++;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "emergencyShutdown",
        "visibility": "external",
        "args": [],
        "func": "function emergencyShutdown() external override {\n        timesEmergencyShutdown++;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "pfc",
        "visibility": "external",
        "args": [],
        "func": "function pfc() external view override returns (FixedPoint.Unsigned memory) {\n        return FixedPoint.fromUnscaledUint(0);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "initialize",
        "visibility": "public",
        "args": [],
        "func": "function initialize() public nonReentrant() {\n        initialized = true;\n        _registerContract(new address[](0), address(this));\n    }",
        "comments": [
            "/**",
            "     * @notice This should be called after construction of the DepositBox and handles registration with the Registry, which is required",
            "     * to make price requests in production environments.",
            "     * @dev This contract must hold the `ContractCreator` role with the Registry in order to register itself as a financial-template with the DVM.",
            "     * Note that `_registerContract` cannot be called from the constructor because this contract first needs to be given the `ContractCreator` role",
            "     * in order to register with the `Registry`. But, its address is not known until after deployment.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This should be called after construction of the DepositBox and handles registration with the Registry, which is required\n     * to make price requests in production environments.\n     * @dev This contract must hold the `ContractCreator` role with the Registry in order to register itself as a financial-template with the DVM.\n     * Note that `_registerContract` cannot be called from the constructor because this contract first needs to be given the `ContractCreator` role\n     * in order to register with the `Registry`. But, its address is not known until after deployment.\n     */\n",
        "@notice": "This should be called after construction of the DepositBox and handles registration with the Registry, which is required * to make price requests in production environments.",
        "@dev": "This contract must hold the `ContractCreator` role with the Registry in order to register itself as a financial-template with the DVM. * Note that `_registerContract` cannot be called from the constructor because this contract first needs to be given the `ContractCreator` role * in order to register with the `Registry`. But, its address is not known until after deployment.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "deposit",
        "visibility": "public",
        "args": [
            {
                "name": "collateralAmount",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function deposit(FixedPoint.Unsigned memory collateralAmount) public isInitialized() fees() nonReentrant() {\n        require(collateralAmount.isGreaterThan(0), \"Invalid collateral amount\");\n        DepositBoxData storage depositBoxData = depositBoxes[msg.sender];\n        if (_getFeeAdjustedCollateral(depositBoxData.rawCollateral).isEqual(0)) {\n            emit NewDepositBox(msg.sender);\n        }\n\n        // Increase the individual deposit box and global collateral balance by collateral amount.\n        _incrementCollateralBalances(depositBoxData, collateralAmount);\n\n        emit Deposit(msg.sender, collateralAmount.rawValue);\n\n        // Move collateral currency from sender to contract.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Transfers `collateralAmount` of `collateralCurrency` into caller's deposit box.",
            "     * @dev This contract must be approved to spend at least `collateralAmount` of `collateralCurrency`.",
            "     * @param collateralAmount total amount of collateral tokens to be sent to the sponsor's position.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfers `collateralAmount` of `collateralCurrency` into caller's deposit box.\n     * @dev This contract must be approved to spend at least `collateralAmount` of `collateralCurrency`.\n     * @param collateralAmount total amount of collateral tokens to be sent to the sponsor's position.\n     */\n",
        "@notice": "Transfers `collateralAmount` of `collateralCurrency` into caller's deposit box.",
        "@dev": "This contract must be approved to spend at least `collateralAmount` of `collateralCurrency`.",
        "@param1": "collateralAmount total amount of collateral tokens to be sent to the sponsor's position.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "requestWithdrawal",
        "visibility": "public",
        "args": [
            {
                "name": "denominatedCollateralAmount",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function requestWithdrawal(FixedPoint.Unsigned memory denominatedCollateralAmount)\n        public\n        isInitialized()\n        noPendingWithdrawal(msg.sender)\n        nonReentrant()\n    {\n        DepositBoxData storage depositBoxData = depositBoxes[msg.sender];\n        require(denominatedCollateralAmount.isGreaterThan(0), \"Invalid collateral amount\");\n\n        // Update the position object for the user.\n        depositBoxData.withdrawalRequestAmount = denominatedCollateralAmount;\n        depositBoxData.requestPassTimestamp = getCurrentTime();\n\n        emit RequestWithdrawal(msg.sender, denominatedCollateralAmount.rawValue, depositBoxData.requestPassTimestamp);\n\n        // Every price request costs a fixed fee. Check that this user has enough deposited to cover the final fee.\n        FixedPoint.Unsigned memory finalFee = _computeFinalFees();\n        require(\n            _getFeeAdjustedCollateral(depositBoxData.rawCollateral).isGreaterThanOrEqual(finalFee),\n            \"Cannot pay final fee\"\n        );\n        _payFinalFees(address(this), finalFee);\n        // A price request is sent for the current timestamp.\n        _requestOraclePrice(depositBoxData.requestPassTimestamp);\n    }",
        "comments": [
            "/**",
            "     * @notice Starts a withdrawal request that allows the sponsor to withdraw `denominatedCollateralAmount`",
            "     * from their position denominated in the quote asset of the price identifier, following a DVM price resolution.",
            "     * @dev The request will be pending for the duration of the DVM vote and can be cancelled at any time.",
            "     * Only one withdrawal request can exist for the user.",
            "     * @param denominatedCollateralAmount the quote-asset denominated amount of collateral requested to withdraw.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Starts a withdrawal request that allows the sponsor to withdraw `denominatedCollateralAmount`\n     * from their position denominated in the quote asset of the price identifier, following a DVM price resolution.\n     * @dev The request will be pending for the duration of the DVM vote and can be cancelled at any time.\n     * Only one withdrawal request can exist for the user.\n     * @param denominatedCollateralAmount the quote-asset denominated amount of collateral requested to withdraw.\n     */\n",
        "@notice": "Starts a withdrawal request that allows the sponsor to withdraw `denominatedCollateralAmount` * from their position denominated in the quote asset of the price identifier, following a DVM price resolution.",
        "@dev": "The request will be pending for the duration of the DVM vote and can be cancelled at any time. * Only one withdrawal request can exist for the user.",
        "@param1": "denominatedCollateralAmount the quote-asset denominated amount of collateral requested to withdraw.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "executeWithdrawal",
        "visibility": "external",
        "args": [],
        "func": "function executeWithdrawal()\n        external\n        isInitialized()\n        fees()\n        nonReentrant()\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        DepositBoxData storage depositBoxData = depositBoxes[msg.sender];\n        require(\n            depositBoxData.requestPassTimestamp != 0 && depositBoxData.requestPassTimestamp <= getCurrentTime(),\n            \"Invalid withdraw request\"\n        );\n\n        // Get the resolved price or revert.\n        FixedPoint.Unsigned memory exchangeRate = _getOraclePrice(depositBoxData.requestPassTimestamp);\n\n        // Calculate denomated amount of collateral based on resolved exchange rate.\n        // Example 1: User wants to withdraw $100 of ETH, exchange rate is $200/ETH, therefore user to receive 0.5 ETH.\n        // Example 2: User wants to withdraw $250 of ETH, exchange rate is $200/ETH, therefore user to receive 1.25 ETH.\n        FixedPoint.Unsigned memory denominatedAmountToWithdraw =\n            depositBoxData.withdrawalRequestAmount.div(exchangeRate);\n\n        // If withdrawal request amount is > collateral, then withdraw the full collateral amount and delete the deposit box data.\n        if (denominatedAmountToWithdraw.isGreaterThan(_getFeeAdjustedCollateral(depositBoxData.rawCollateral))) {\n            denominatedAmountToWithdraw = _getFeeAdjustedCollateral(depositBoxData.rawCollateral);\n\n            // Reset the position state as all the value has been removed after settlement.\n            emit EndedDepositBox(msg.sender);\n        }\n\n        // Decrease the individual deposit box and global collateral balance.\n        amountWithdrawn = _decrementCollateralBalances(depositBoxData, denominatedAmountToWithdraw);\n\n        emit RequestWithdrawalExecuted(\n            msg.sender,\n            amountWithdrawn.rawValue,\n            exchangeRate.rawValue,\n            depositBoxData.requestPassTimestamp\n        );\n\n        // Reset withdrawal request by setting withdrawal request timestamp to 0.\n        _resetWithdrawalRequest(depositBoxData);\n\n        // Transfer approved withdrawal amount from the contract to the caller.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice After a passed withdrawal request (i.e., by a call to `requestWithdrawal` and subsequent DVM price resolution),",
            "     * withdraws `depositBoxData.withdrawalRequestAmount` of collateral currency denominated in the quote asset.",
            "     * @dev Might not withdraw the full requested amount in order to account for precision loss or if the full requested",
            "     * amount exceeds the collateral in the position (due to paying fees).",
            "     * @return amountWithdrawn The actual amount of collateral withdrawn.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice After a passed withdrawal request (i.e., by a call to `requestWithdrawal` and subsequent DVM price resolution),\n     * withdraws `depositBoxData.withdrawalRequestAmount` of collateral currency denominated in the quote asset.\n     * @dev Might not withdraw the full requested amount in order to account for precision loss or if the full requested\n     * amount exceeds the collateral in the position (due to paying fees).\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\n     */\n",
        "@notice": "After a passed withdrawal request (i.e., by a call to `requestWithdrawal` and subsequent DVM price resolution), * withdraws `depositBoxData.withdrawalRequestAmount` of collateral currency denominated in the quote asset.",
        "@dev": "Might not withdraw the full requested amount in order to account for precision loss or if the full requested * amount exceeds the collateral in the position (due to paying fees).",
        "@return1": "amountWithdrawn The actual amount of collateral withdrawn.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cancelWithdrawal",
        "visibility": "external",
        "args": [],
        "func": "function cancelWithdrawal() external isInitialized() nonReentrant() {\n        DepositBoxData storage depositBoxData = depositBoxes[msg.sender];\n        require(depositBoxData.requestPassTimestamp != 0, \"No pending withdrawal\");\n\n        emit RequestWithdrawalCanceled(\n            msg.sender,\n            depositBoxData.withdrawalRequestAmount.rawValue,\n            depositBoxData.requestPassTimestamp\n        );\n\n        // Reset withdrawal request by setting withdrawal request timestamp to 0.\n        _resetWithdrawalRequest(depositBoxData);\n    }",
        "comments": [
            "/**",
            "     * @notice Cancels a pending withdrawal request.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Cancels a pending withdrawal request.\n     */\n",
        "@notice": "Cancels a pending withdrawal request.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "emergencyShutdown",
        "visibility": "external",
        "args": [],
        "func": "function emergencyShutdown() external override isInitialized() nonReentrant() {\n        return;\n    }",
        "comments": [
            "/**",
            "     * @notice `emergencyShutdown` and `remargin` are required to be implemented by all financial contracts and exposed to the DVM, but",
            "     * because this is a minimal demo they will simply exit silently.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice `emergencyShutdown` and `remargin` are required to be implemented by all financial contracts and exposed to the DVM, but\n     * because this is a minimal demo they will simply exit silently.\n     */\n",
        "@notice": "`emergencyShutdown` and `remargin` are required to be implemented by all financial contracts and exposed to the DVM, but * because this is a minimal demo they will simply exit silently.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 1
    },
    {
        "name": "remargin",
        "visibility": "external",
        "args": [],
        "func": "function remargin() external override isInitialized() nonReentrant() {\n        return;\n    }",
        "comments": [
            "/**",
            "     * @notice Same comment as `emergencyShutdown`. For the sake of simplicity, this will simply exit silently.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Same comment as `emergencyShutdown`. For the sake of simplicity, this will simply exit silently.\n     */\n",
        "@notice": "Same comment as `emergencyShutdown`. For the sake of simplicity, this will simply exit silently.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 1
    },
    {
        "name": "getCollateral",
        "visibility": "external",
        "args": [
            {
                "name": "user",
                "type": "address"
            }
        ],
        "func": "function getCollateral(address user) external view nonReentrantView() returns (FixedPoint.Unsigned memory) {\n        return _getFeeAdjustedCollateral(depositBoxes[user].rawCollateral);\n    }",
        "comments": [
            "/**",
            "     * @notice Accessor method for a user's collateral.",
            "     * @dev This is necessary because the struct returned by the depositBoxes() method shows",
            "     * rawCollateral, which isn't a user-readable value.",
            "     * @param user address whose collateral amount is retrieved.",
            "     * @return the fee-adjusted collateral amount in the deposit box (i.e. available for withdrawal).",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Accessor method for a user's collateral.\n     * @dev This is necessary because the struct returned by the depositBoxes() method shows\n     * rawCollateral, which isn't a user-readable value.\n     * @param user address whose collateral amount is retrieved.\n     * @return the fee-adjusted collateral amount in the deposit box (i.e. available for withdrawal).\n     */\n",
        "@notice": "Accessor method for a user's collateral.",
        "@dev": "This is necessary because the struct returned by the depositBoxes() method shows * rawCollateral, which isn't a user-readable value.",
        "@param1": "user address whose collateral amount is retrieved.",
        "@return1": "the fee-adjusted collateral amount in the deposit box (i.e. available for withdrawal).",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalDepositBoxCollateral",
        "visibility": "external",
        "args": [],
        "func": "function totalDepositBoxCollateral() external view nonReentrantView() returns (FixedPoint.Unsigned memory) {\n        return _getFeeAdjustedCollateral(rawTotalDepositBoxCollateral);\n    }",
        "comments": [
            "/**",
            "     * @notice Accessor method for the total collateral stored within the entire contract.",
            "     * @return the total fee-adjusted collateral amount in the contract (i.e. across all users).",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Accessor method for the total collateral stored within the entire contract.\n     * @return the total fee-adjusted collateral amount in the contract (i.e. across all users).\n     */\n",
        "@notice": "Accessor method for the total collateral stored within the entire contract.",
        "@return1": "the total fee-adjusted collateral amount in the contract (i.e. across all users).",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createPerpetual",
        "visibility": "public",
        "args": [
            {
                "name": "params",
                "type": "Params memory"
            },
            {
                "name": "configSettings",
                "type": "ConfigStore.ConfigSettings memory"
            }
        ],
        "func": "function createPerpetual(Params memory params, ConfigStore.ConfigSettings memory configSettings)\n        public\n        nonReentrant()\n        returns (address)\n    {\n        require(bytes(params.syntheticName).length != 0, \"Missing synthetic name\");\n        require(bytes(params.syntheticSymbol).length != 0, \"Missing synthetic symbol\");\n\n        // Create new config settings store for this contract and reset ownership to the deployer.\n        ConfigStore configStore = new ConfigStore(configSettings, timerAddress);\n        configStore.transferOwnership(msg.sender);\n        emit CreatedConfigStore(address(configStore), configStore.owner());\n\n        // Create a new synthetic token using the params.\n        TokenFactory tf = TokenFactory(tokenFactoryAddress);\n\n        // If the collateral token does not have a `decimals()` method,\n        // then a default precision of 18 will be applied to the newly created synthetic token.\n        uint8 syntheticDecimals = _getSyntheticDecimals(params.collateralAddress);\n        ExpandedIERC20 tokenCurrency = tf.createToken(params.syntheticName, params.syntheticSymbol, syntheticDecimals);\n        address derivative = PerpetualLib.deploy(_convertParams(params, tokenCurrency, address(configStore)));\n\n        // Give permissions to new derivative contract and then hand over ownership.\n        tokenCurrency.addMinter(derivative);\n        tokenCurrency.addBurner(derivative);\n        tokenCurrency.resetOwner(derivative);\n\n        _registerContract(new address[](0), derivative);\n\n        emit CreatedPerpetual(derivative, msg.sender);\n\n        return derivative;\n    }",
        "comments": [
            "/**",
            "     * @notice Creates an instance of perpetual and registers it within the registry.",
            "     * @param params is a `ConstructorParams` object from Perpetual.",
            "     * @return address of the deployed contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Creates an instance of perpetual and registers it within the registry.\n     * @param params is a `ConstructorParams` object from Perpetual.\n     * @return address of the deployed contract.\n     */\n",
        "@notice": "Creates an instance of perpetual and registers it within the registry.",
        "@param1": "params is a `ConstructorParams` object from Perpetual.",
        "@return1": "address of the deployed contract.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_getSyntheticDecimals",
        "visibility": "public",
        "args": [
            {
                "name": "_collateralAddress",
                "type": "address"
            }
        ],
        "func": "function _getSyntheticDecimals(address _collateralAddress) public view returns (uint8 decimals) {\n        try IERC20Standard(_collateralAddress).decimals() returns (uint8 _decimals) {\n            return _decimals;\n        } catch {\n            return 18;\n        }\n    }",
        "comments": [
            "",
            "    // IERC20Standard.decimals() will revert if the collateral contract has not implemented the decimals() method,",
            "    // which is possible since the method is only an OPTIONAL method in the ERC20 standard:",
            "    // https://eips.ethereum.org/EIPS/eip-20#methods.",
            "    "
        ],
        "comt": "\n    // IERC20Standard.decimals() will revert if the collateral contract has not implemented the decimals() method,\n    // which is possible since the method is only an OPTIONAL method in the ERC20 standard:\n    // https://eips.ethereum.org/EIPS/eip-20#methods.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createToken",
        "visibility": "external",
        "args": [
            {
                "name": "tokenName",
                "type": "string calldata"
            },
            {
                "name": "tokenSymbol",
                "type": "string calldata"
            },
            {
                "name": "tokenDecimals",
                "type": "uint8"
            }
        ],
        "func": "function createToken(\n        string calldata tokenName,\n        string calldata tokenSymbol,\n        uint8 tokenDecimals\n    ) external nonReentrant() returns (ExpandedIERC20 newToken) {\n        SyntheticToken mintableToken = new SyntheticToken(tokenName, tokenSymbol, tokenDecimals);\n        mintableToken.addMinter(msg.sender);\n        mintableToken.addBurner(msg.sender);\n        mintableToken.resetOwner(msg.sender);\n        newToken = ExpandedIERC20(address(mintableToken));\n    }",
        "comments": [
            "/**",
            "     * @notice Create a new token and return it to the caller.",
            "     * @dev The caller will become the only minter and burner and the new owner capable of assigning the roles.",
            "     * @param tokenName used to describe the new token.",
            "     * @param tokenSymbol short ticker abbreviation of the name. Ideally < 5 chars.",
            "     * @param tokenDecimals used to define the precision used in the token's numerical representation.",
            "     * @return newToken an instance of the newly created token interface.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Create a new token and return it to the caller.\n     * @dev The caller will become the only minter and burner and the new owner capable of assigning the roles.\n     * @param tokenName used to describe the new token.\n     * @param tokenSymbol short ticker abbreviation of the name. Ideally < 5 chars.\n     * @param tokenDecimals used to define the precision used in the token's numerical representation.\n     * @return newToken an instance of the newly created token interface.\n     */\n",
        "@notice": "Create a new token and return it to the caller.",
        "@dev": "The caller will become the only minter and burner and the new owner capable of assigning the roles.",
        "@param1": "tokenName used to describe the new token.",
        "@param2": "tokenSymbol short ticker abbreviation of the name. Ideally < 5 chars.",
        "@param3": "tokenDecimals used to define the precision used in the token's numerical representation.",
        "@return1": "newToken an instance of the newly created token interface.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addMinter",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function addMinter(address account) external override nonReentrant() {\n        addMember(uint256(Roles.Minter), account);\n    }",
        "comments": [
            "/**",
            "     * @notice Add Minter role to account.",
            "     * @dev The caller must have the Owner role.",
            "     * @param account The address to which the Minter role is added.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Add Minter role to account.\n     * @dev The caller must have the Owner role.\n     * @param account The address to which the Minter role is added.\n     */\n",
        "@notice": "Add Minter role to account.",
        "@dev": "The caller must have the Owner role.",
        "@param1": "account The address to which the Minter role is added.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeMinter",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function removeMinter(address account) external nonReentrant() {\n        removeMember(uint256(Roles.Minter), account);\n    }",
        "comments": [
            "/**",
            "     * @notice Remove Minter role from account.",
            "     * @dev The caller must have the Owner role.",
            "     * @param account The address from which the Minter role is removed.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Remove Minter role from account.\n     * @dev The caller must have the Owner role.\n     * @param account The address from which the Minter role is removed.\n     */\n",
        "@notice": "Remove Minter role from account.",
        "@dev": "The caller must have the Owner role.",
        "@param1": "account The address from which the Minter role is removed.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addBurner",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function addBurner(address account) external override nonReentrant() {\n        addMember(uint256(Roles.Burner), account);\n    }",
        "comments": [
            "/**",
            "     * @notice Add Burner role to account.",
            "     * @dev The caller must have the Owner role.",
            "     * @param account The address to which the Burner role is added.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Add Burner role to account.\n     * @dev The caller must have the Owner role.\n     * @param account The address to which the Burner role is added.\n     */\n",
        "@notice": "Add Burner role to account.",
        "@dev": "The caller must have the Owner role.",
        "@param1": "account The address to which the Burner role is added.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeBurner",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function removeBurner(address account) external nonReentrant() {\n        removeMember(uint256(Roles.Burner), account);\n    }",
        "comments": [
            "/**",
            "     * @notice Removes Burner role from account.",
            "     * @dev The caller must have the Owner role.",
            "     * @param account The address from which the Burner role is removed.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Removes Burner role from account.\n     * @dev The caller must have the Owner role.\n     * @param account The address from which the Burner role is removed.\n     */\n",
        "@notice": "Removes Burner role from account.",
        "@dev": "The caller must have the Owner role.",
        "@param1": "account The address from which the Burner role is removed.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "resetOwner",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function resetOwner(address account) external override nonReentrant() {\n        resetMember(uint256(Roles.Owner), account);\n    }",
        "comments": [
            "/**",
            "     * @notice Reset Owner role to account.",
            "     * @dev The caller must have the Owner role.",
            "     * @param account The new holder of the Owner role.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Reset Owner role to account.\n     * @dev The caller must have the Owner role.\n     * @param account The new holder of the Owner role.\n     */\n",
        "@notice": "Reset Owner role to account.",
        "@dev": "The caller must have the Owner role.",
        "@param1": "account The new holder of the Owner role.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isMinter",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function isMinter(address account) public view nonReentrantView() returns (bool) {\n        return holdsRole(uint256(Roles.Minter), account);\n    }",
        "comments": [
            "/**",
            "     * @notice Checks if a given account holds the Minter role.",
            "     * @param account The address which is checked for the Minter role.",
            "     * @return bool True if the provided account is a Minter.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Checks if a given account holds the Minter role.\n     * @param account The address which is checked for the Minter role.\n     * @return bool True if the provided account is a Minter.\n     */\n",
        "@notice": "Checks if a given account holds the Minter role.",
        "@param1": "account The address which is checked for the Minter role.",
        "@return1": "bool True if the provided account is a Minter.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isBurner",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function isBurner(address account) public view nonReentrantView() returns (bool) {\n        return holdsRole(uint256(Roles.Burner), account);\n    }",
        "comments": [
            "/**",
            "     * @notice Checks if a given account holds the Burner role.",
            "     * @param account The address which is checked for the Burner role.",
            "     * @return bool True if the provided account is a Burner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Checks if a given account holds the Burner role.\n     * @param account The address which is checked for the Burner role.\n     * @return bool True if the provided account is a Burner.\n     */\n",
        "@notice": "Checks if a given account holds the Burner role.",
        "@param1": "account The address which is checked for the Burner role.",
        "@return1": "bool True if the provided account is a Burner.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "deploy",
        "visibility": "public",
        "args": [
            {
                "name": "params",
                "type": "Perpetual.ConstructorParams memory"
            }
        ],
        "func": "function deploy(Perpetual.ConstructorParams memory params) public returns (address) {\n        Perpetual derivative = new Perpetual(params);\n        return address(derivative);\n    }",
        "comments": [
            "/**",
            "     * @notice Returns address of new Perpetual deployed with given `params` configuration.",
            "     * @dev Caller will need to register new Perpetual with the Registry to begin requesting prices. Caller is also",
            "     * responsible for enforcing constraints on `params`.",
            "     * @param params is a `ConstructorParams` object from Perpetual.",
            "     * @return address of the deployed Perpetual contract",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns address of new Perpetual deployed with given `params` configuration.\n     * @dev Caller will need to register new Perpetual with the Registry to begin requesting prices. Caller is also\n     * responsible for enforcing constraints on `params`.\n     * @param params is a `ConstructorParams` object from Perpetual.\n     * @return address of the deployed Perpetual contract\n     */\n",
        "@notice": "Returns address of new Perpetual deployed with given `params` configuration.",
        "@dev": "Caller will need to register new Perpetual with the Registry to begin requesting prices. Caller is also * responsible for enforcing constraints on `params`.",
        "@param1": "params is a `ConstructorParams` object from Perpetual.",
        "@return1": "address of the deployed Perpetual contract",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateAndGetCurrentConfig",
        "visibility": "external",
        "args": [],
        "func": "function updateAndGetCurrentConfig()\n        external\n        override\n        updateConfig()\n        nonReentrant()\n        returns (ConfigStoreInterface.ConfigSettings memory)\n    {\n        return currentConfig;\n    }",
        "comments": [
            "/**",
            "     * @notice Returns current config or pending config if pending liveness has expired.",
            "     * @return ConfigSettings config settings that calling financial contract should view as \"live\".",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns current config or pending config if pending liveness has expired.\n     * @return ConfigSettings config settings that calling financial contract should view as \"live\".\n     */\n",
        "@notice": "Returns current config or pending config if pending liveness has expired.",
        "@return1": "ConfigSettings config settings that calling financial contract should view as \"live\".",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "proposeNewConfig",
        "visibility": "external",
        "args": [
            {
                "name": "newConfig",
                "type": "ConfigSettings memory"
            }
        ],
        "func": "function proposeNewConfig(ConfigSettings memory newConfig) external onlyOwner() nonReentrant() updateConfig() {\n        _validateConfig(newConfig);\n\n        // Warning: This overwrites a pending proposal!\n        pendingConfig = newConfig;\n\n        // Use current config's liveness period to timelock this proposal.\n        pendingPassedTimestamp = getCurrentTime().add(currentConfig.timelockLiveness);\n\n        emit ProposedNewConfigSettings(\n            msg.sender,\n            newConfig.rewardRatePerSecond.rawValue,\n            newConfig.proposerBondPercentage.rawValue,\n            newConfig.timelockLiveness,\n            newConfig.maxFundingRate.rawValue,\n            newConfig.minFundingRate.rawValue,\n            newConfig.proposalTimePastLimit,\n            pendingPassedTimestamp\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Propose new configuration settings. New settings go into effect after a liveness period passes.",
            "     * @param newConfig Configuration settings to publish after `currentConfig.timelockLiveness` passes from now.",
            "     * @dev Callable only by owner. Calling this while there is already a pending proposal will overwrite the pending proposal.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Propose new configuration settings. New settings go into effect after a liveness period passes.\n     * @param newConfig Configuration settings to publish after `currentConfig.timelockLiveness` passes from now.\n     * @dev Callable only by owner. Calling this while there is already a pending proposal will overwrite the pending proposal.\n     */\n",
        "@notice": "Propose new configuration settings. New settings go into effect after a liveness period passes.",
        "@param1": "newConfig Configuration settings to publish after `currentConfig.timelockLiveness` passes from now.",
        "@dev": "Callable only by owner. Calling this while there is already a pending proposal will overwrite the pending proposal.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "publishPendingConfig",
        "visibility": "external",
        "args": [],
        "func": "function publishPendingConfig() external nonReentrant() updateConfig() {}",
        "comments": [
            "/**",
            "     * @notice Publish any pending configuration settings if there is a pending proposal that has passed liveness.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Publish any pending configuration settings if there is a pending proposal that has passed liveness.\n     */\n",
        "@notice": "Publish any pending configuration settings if there is a pending proposal that has passed liveness.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createLiquidation",
        "visibility": "external",
        "args": [
            {
                "name": "sponsor",
                "type": "address"
            },
            {
                "name": "minCollateralPerToken",
                "type": "FixedPoint.Unsigned calldata"
            },
            {
                "name": "maxCollateralPerToken",
                "type": "FixedPoint.Unsigned calldata"
            },
            {
                "name": "maxTokensToLiquidate",
                "type": "FixedPoint.Unsigned calldata"
            },
            {
                "name": "deadline",
                "type": "uint256"
            }
        ],
        "func": "function createLiquidation(\n        address sponsor,\n        FixedPoint.Unsigned calldata minCollateralPerToken,\n        FixedPoint.Unsigned calldata maxCollateralPerToken,\n        FixedPoint.Unsigned calldata maxTokensToLiquidate,\n        uint256 deadline\n    )\n        external\n        notEmergencyShutdown()\n        fees()\n        nonReentrant()\n        returns (\n            uint256 liquidationId,\n            FixedPoint.Unsigned memory tokensLiquidated,\n            FixedPoint.Unsigned memory finalFeeBond\n        )\n    {\n        // Check that this transaction was mined pre-deadline.\n        require(getCurrentTime() <= deadline, \"Mined after deadline\");\n\n        // Retrieve Position data for sponsor\n        PositionData storage positionToLiquidate = _getPositionData(sponsor);\n\n        tokensLiquidated = FixedPoint.min(maxTokensToLiquidate, positionToLiquidate.tokensOutstanding);\n        require(tokensLiquidated.isGreaterThan(0));\n\n        // Starting values for the Position being liquidated. If withdrawal request amount is > position's collateral,\n        // then set this to 0, otherwise set it to (startCollateral - withdrawal request amount).\n        FixedPoint.Unsigned memory startCollateral = _getFeeAdjustedCollateral(positionToLiquidate.rawCollateral);\n        FixedPoint.Unsigned memory startCollateralNetOfWithdrawal = FixedPoint.fromUnscaledUint(0);\n        if (positionToLiquidate.withdrawalRequestAmount.isLessThanOrEqual(startCollateral)) {\n            startCollateralNetOfWithdrawal = startCollateral.sub(positionToLiquidate.withdrawalRequestAmount);\n        }\n\n        // Scoping to get rid of a stack too deep error.\n        {\n            FixedPoint.Unsigned memory startTokens = positionToLiquidate.tokensOutstanding;\n\n            // The Position's collateralization ratio must be between [minCollateralPerToken, maxCollateralPerToken].\n            require(\n                maxCollateralPerToken.mul(startTokens).isGreaterThanOrEqual(startCollateralNetOfWithdrawal),\n                \"CR is more than max liq. price\"\n            );\n            // minCollateralPerToken >= startCollateralNetOfWithdrawal / startTokens.\n            require(\n                minCollateralPerToken.mul(startTokens).isLessThanOrEqual(startCollateralNetOfWithdrawal),\n                \"CR is less than min liq. price\"\n            );\n        }\n\n        // Compute final fee at time of liquidation.\n        finalFeeBond = _computeFinalFees();\n\n        // These will be populated within the scope below.\n        FixedPoint.Unsigned memory lockedCollateral;\n        FixedPoint.Unsigned memory liquidatedCollateral;\n\n        // Scoping to get rid of a stack too deep error. The amount of tokens to remove from the position\n        // are not funding-rate adjusted because the multiplier only affects their redemption value, not their\n        // notional.\n        {\n            FixedPoint.Unsigned memory ratio = tokensLiquidated.div(positionToLiquidate.tokensOutstanding);\n\n            // The actual amount of collateral that gets moved to the liquidation.\n            lockedCollateral = startCollateral.mul(ratio);\n\n            // For purposes of disputes, it's actually this liquidatedCollateral value that's used. This value is net of\n            // withdrawal requests.\n            liquidatedCollateral = startCollateralNetOfWithdrawal.mul(ratio);\n\n            // Part of the withdrawal request is also removed. Ideally:\n            // liquidatedCollateral + withdrawalAmountToRemove = lockedCollateral.\n            FixedPoint.Unsigned memory withdrawalAmountToRemove =\n                positionToLiquidate.withdrawalRequestAmount.mul(ratio);\n            _reduceSponsorPosition(sponsor, tokensLiquidated, lockedCollateral, withdrawalAmountToRemove);\n        }\n\n        // Add to the global liquidation collateral count.\n        _addCollateral(rawLiquidationCollateral, lockedCollateral.add(finalFeeBond));\n\n        // Construct liquidation object.\n        // Note: All dispute-related values are zeroed out until a dispute occurs. liquidationId is the index of the new\n        // LiquidationData that is pushed into the array, which is equal to the current length of the array pre-push.\n        liquidationId = liquidations[sponsor].length;\n        liquidations[sponsor].push(\n            LiquidationData({\n                sponsor: sponsor,\n                liquidator: msg.sender,\n                state: Status.NotDisputed,\n                liquidationTime: getCurrentTime(),\n                tokensOutstanding: _getFundingRateAppliedTokenDebt(tokensLiquidated),\n                lockedCollateral: lockedCollateral,\n                liquidatedCollateral: liquidatedCollateral,\n                rawUnitCollateral: _convertToRawCollateral(FixedPoint.fromUnscaledUint(1)),\n                disputer: address(0),\n                settlementPrice: FixedPoint.fromUnscaledUint(0),\n                finalFee: finalFeeBond\n            })\n        );\n\n        // If this liquidation is a subsequent liquidation on the position, and the liquidation size is larger than\n        // some \"griefing threshold\", then re-set the liveness. This enables a liquidation against a withdraw request to be\n        // \"dragged out\" if the position is very large and liquidators need time to gather funds. The griefing threshold\n        // is enforced so that liquidations for trivially small # of tokens cannot drag out an honest sponsor's slow withdrawal.\n\n        // We arbitrarily set the \"griefing threshold\" to `minSponsorTokens` because it is the only parameter\n        // denominated in token currency units and we can avoid adding another parameter.\n        FixedPoint.Unsigned memory griefingThreshold = minSponsorTokens;\n        if (\n            positionToLiquidate.withdrawalRequestPassTimestamp > 0 && // The position is undergoing a slow withdrawal.\n            positionToLiquidate.withdrawalRequestPassTimestamp > getCurrentTime() && // The slow withdrawal has not yet expired.\n            tokensLiquidated.isGreaterThanOrEqual(griefingThreshold) // The liquidated token count is above a \"griefing threshold\".\n        ) {\n            positionToLiquidate.withdrawalRequestPassTimestamp = getCurrentTime().add(withdrawalLiveness);\n        }\n\n        emit LiquidationCreated(\n            sponsor,\n            msg.sender,\n            liquidationId,\n            _getFundingRateAppliedTokenDebt(tokensLiquidated).rawValue,\n            lockedCollateral.rawValue,\n            liquidatedCollateral.rawValue,\n            getCurrentTime()\n        );\n\n        // Destroy tokens\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), tokensLiquidated.rawValue);\n        tokenCurrency.burn(tokensLiquidated.rawValue);\n\n        // Pull final fee from liquidator.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), finalFeeBond.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Liquidates the sponsor's position if the caller has enough",
            "     * synthetic tokens to retire the position's outstanding tokens. Liquidations above",
            "     * a minimum size also reset an ongoing \"slow withdrawal\"'s liveness.",
            "     * @dev This method generates an ID that will uniquely identify liquidation for the sponsor. This contract must be",
            "     * approved to spend at least `tokensLiquidated` of `tokenCurrency` and at least `finalFeeBond` of `collateralCurrency`.",
            "     * @dev This contract must have the Burner role for the `tokenCurrency`.",
            "     * @param sponsor address of the sponsor to liquidate.",
            "     * @param minCollateralPerToken abort the liquidation if the position's collateral per token is below this value.",
            "     * @param maxCollateralPerToken abort the liquidation if the position's collateral per token exceeds this value.",
            "     * @param maxTokensToLiquidate max number of tokens to liquidate.",
            "     * @param deadline abort the liquidation if the transaction is mined after this timestamp.",
            "     * @return liquidationId ID of the newly created liquidation.",
            "     * @return tokensLiquidated amount of synthetic tokens removed and liquidated from the `sponsor`'s position.",
            "     * @return finalFeeBond amount of collateral to be posted by liquidator and returned if not disputed successfully.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Liquidates the sponsor's position if the caller has enough\n     * synthetic tokens to retire the position's outstanding tokens. Liquidations above\n     * a minimum size also reset an ongoing \"slow withdrawal\"'s liveness.\n     * @dev This method generates an ID that will uniquely identify liquidation for the sponsor. This contract must be\n     * approved to spend at least `tokensLiquidated` of `tokenCurrency` and at least `finalFeeBond` of `collateralCurrency`.\n     * @dev This contract must have the Burner role for the `tokenCurrency`.\n     * @param sponsor address of the sponsor to liquidate.\n     * @param minCollateralPerToken abort the liquidation if the position's collateral per token is below this value.\n     * @param maxCollateralPerToken abort the liquidation if the position's collateral per token exceeds this value.\n     * @param maxTokensToLiquidate max number of tokens to liquidate.\n     * @param deadline abort the liquidation if the transaction is mined after this timestamp.\n     * @return liquidationId ID of the newly created liquidation.\n     * @return tokensLiquidated amount of synthetic tokens removed and liquidated from the `sponsor`'s position.\n     * @return finalFeeBond amount of collateral to be posted by liquidator and returned if not disputed successfully.\n     */\n",
        "@notice": "Liquidates the sponsor's position if the caller has enough * synthetic tokens to retire the position's outstanding tokens. Liquidations above * a minimum size also reset an ongoing \"slow withdrawal\"'s liveness.",
        "@dev": "This method generates an ID that will uniquely identify liquidation for the sponsor. This contract must be * approved to spend at least `tokensLiquidated` of `tokenCurrency` and at least `finalFeeBond` of `collateralCurrency`. * This contract must have the Burner role for the `tokenCurrency`.",
        "@param1": "sponsor address of the sponsor to liquidate.",
        "@param2": "minCollateralPerToken abort the liquidation if the position's collateral per token is below this value.",
        "@param3": "maxCollateralPerToken abort the liquidation if the position's collateral per token exceeds this value.",
        "@param4": "maxTokensToLiquidate max number of tokens to liquidate.",
        "@param5": "deadline abort the liquidation if the transaction is mined after this timestamp.",
        "@return1": "liquidationId ID of the newly created liquidation.",
        "@return2": "tokensLiquidated amount of synthetic tokens removed and liquidated from the `sponsor`'s position.",
        "@return3": "finalFeeBond amount of collateral to be posted by liquidator and returned if not disputed successfully.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "dispute",
        "visibility": "external",
        "args": [
            {
                "name": "liquidationId",
                "type": "uint256"
            },
            {
                "name": "sponsor",
                "type": "address"
            }
        ],
        "func": "function dispute(uint256 liquidationId, address sponsor)\n        external\n        disputable(liquidationId, sponsor)\n        fees()\n        nonReentrant()\n        returns (FixedPoint.Unsigned memory totalPaid)\n    {\n        LiquidationData storage disputedLiquidation = _getLiquidationData(sponsor, liquidationId);\n\n        // Multiply by the unit collateral so the dispute bond is a percentage of the locked collateral after fees.\n        FixedPoint.Unsigned memory disputeBondAmount =\n            disputedLiquidation.lockedCollateral.mul(disputeBondPercentage).mul(\n                _getFeeAdjustedCollateral(disputedLiquidation.rawUnitCollateral)\n            );\n        _addCollateral(rawLiquidationCollateral, disputeBondAmount);\n\n        // Request a price from DVM. Liquidation is pending dispute until DVM returns a price.\n        disputedLiquidation.state = Status.Disputed;\n        disputedLiquidation.disputer = msg.sender;\n\n        // Enqueue a request with the DVM.\n        _requestOraclePrice(disputedLiquidation.liquidationTime);\n\n        emit LiquidationDisputed(\n            sponsor,\n            disputedLiquidation.liquidator,\n            msg.sender,\n            liquidationId,\n            disputeBondAmount.rawValue\n        );\n        totalPaid = disputeBondAmount.add(disputedLiquidation.finalFee);\n\n        // Pay the final fee for requesting price from the DVM.\n        _payFinalFees(msg.sender, disputedLiquidation.finalFee);\n\n        // Transfer the dispute bond amount from the caller to this contract.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), disputeBondAmount.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Disputes a liquidation, if the caller has enough collateral to post a dispute bond and pay a fixed final",
            "     * fee charged on each price request.",
            "     * @dev Can only dispute a liquidation before the liquidation expires and if there are no other pending disputes.",
            "     * This contract must be approved to spend at least the dispute bond amount of `collateralCurrency`. This dispute",
            "     * bond amount is calculated from `disputeBondPercentage` times the collateral in the liquidation.",
            "     * @param liquidationId of the disputed liquidation.",
            "     * @param sponsor the address of the sponsor whose liquidation is being disputed.",
            "     * @return totalPaid amount of collateral charged to disputer (i.e. final fee bond + dispute bond).",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Disputes a liquidation, if the caller has enough collateral to post a dispute bond and pay a fixed final\n     * fee charged on each price request.\n     * @dev Can only dispute a liquidation before the liquidation expires and if there are no other pending disputes.\n     * This contract must be approved to spend at least the dispute bond amount of `collateralCurrency`. This dispute\n     * bond amount is calculated from `disputeBondPercentage` times the collateral in the liquidation.\n     * @param liquidationId of the disputed liquidation.\n     * @param sponsor the address of the sponsor whose liquidation is being disputed.\n     * @return totalPaid amount of collateral charged to disputer (i.e. final fee bond + dispute bond).\n     */\n",
        "@notice": "Disputes a liquidation, if the caller has enough collateral to post a dispute bond and pay a fixed final * fee charged on each price request.",
        "@dev": "Can only dispute a liquidation before the liquidation expires and if there are no other pending disputes. * This contract must be approved to spend at least the dispute bond amount of `collateralCurrency`. This dispute * bond amount is calculated from `disputeBondPercentage` times the collateral in the liquidation.",
        "@param1": "liquidationId of the disputed liquidation.",
        "@param2": "sponsor the address of the sponsor whose liquidation is being disputed.",
        "@return1": "totalPaid amount of collateral charged to disputer (i.e. final fee bond + dispute bond).",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawLiquidation",
        "visibility": "public",
        "args": [
            {
                "name": "liquidationId",
                "type": "uint256"
            },
            {
                "name": "sponsor",
                "type": "address"
            }
        ],
        "func": "function withdrawLiquidation(uint256 liquidationId, address sponsor)\n        public\n        withdrawable(liquidationId, sponsor)\n        fees()\n        nonReentrant()\n        returns (RewardsData memory)\n    {\n        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\n\n        // Settles the liquidation if necessary. This call will revert if the price has not resolved yet.\n        _settle(liquidationId, sponsor);\n\n        // Calculate rewards as a function of the TRV.\n        // Note1: all payouts are scaled by the unit collateral value so all payouts are charged the fees pro rata.\n        // Note2: the tokenRedemptionValue uses the tokensOutstanding which was calculated using the funding rate at\n        // liquidation time from _getFundingRateAppliedTokenDebt. Therefore the TRV considers the full debt value at that time.\n        FixedPoint.Unsigned memory feeAttenuation = _getFeeAdjustedCollateral(liquidation.rawUnitCollateral);\n        FixedPoint.Unsigned memory settlementPrice = liquidation.settlementPrice;\n        FixedPoint.Unsigned memory tokenRedemptionValue =\n            liquidation.tokensOutstanding.mul(settlementPrice).mul(feeAttenuation);\n        FixedPoint.Unsigned memory collateral = liquidation.lockedCollateral.mul(feeAttenuation);\n        FixedPoint.Unsigned memory disputerDisputeReward = disputerDisputeRewardPercentage.mul(tokenRedemptionValue);\n        FixedPoint.Unsigned memory sponsorDisputeReward = sponsorDisputeRewardPercentage.mul(tokenRedemptionValue);\n        FixedPoint.Unsigned memory disputeBondAmount = collateral.mul(disputeBondPercentage);\n        FixedPoint.Unsigned memory finalFee = liquidation.finalFee.mul(feeAttenuation);\n\n        // There are three main outcome states: either the dispute succeeded, failed or was not updated.\n        // Based on the state, different parties of a liquidation receive different amounts.\n        // After assigning rewards based on the liquidation status, decrease the total collateral held in this contract\n        // by the amount to pay each party. The actual amounts withdrawn might differ if _removeCollateral causes\n        // precision loss.\n        RewardsData memory rewards;\n        if (liquidation.state == Status.DisputeSucceeded) {\n            // If the dispute is successful then all three users should receive rewards:\n\n            // Pay DISPUTER: disputer reward + dispute bond + returned final fee\n            rewards.payToDisputer = disputerDisputeReward.add(disputeBondAmount).add(finalFee);\n\n            // Pay SPONSOR: remaining collateral (collateral - TRV) + sponsor reward\n            rewards.payToSponsor = sponsorDisputeReward.add(collateral.sub(tokenRedemptionValue));\n\n            // Pay LIQUIDATOR: TRV - dispute reward - sponsor reward\n            // If TRV > Collateral, then subtract rewards from collateral\n            // NOTE: This should never be below zero since we prevent (sponsorDisputePercentage+disputerDisputePercentage) >= 0 in\n            // the constructor when these params are set.\n            rewards.payToLiquidator = tokenRedemptionValue.sub(sponsorDisputeReward).sub(disputerDisputeReward);\n\n            // Transfer rewards and debit collateral\n            rewards.paidToLiquidator = _removeCollateral(rawLiquidationCollateral, rewards.payToLiquidator);\n            rewards.paidToSponsor = _removeCollateral(rawLiquidationCollateral, rewards.payToSponsor);\n            rewards.paidToDisputer = _removeCollateral(rawLiquidationCollateral, rewards.payToDisputer);\n\n            collateralCurrency.safeTransfer(liquidation.disputer, rewards.paidToDisputer.rawValue);\n            collateralCurrency.safeTransfer(liquidation.liquidator, rewards.paidToLiquidator.rawValue);\n            collateralCurrency.safeTransfer(liquidation.sponsor, rewards.paidToSponsor.rawValue);\n\n            // In the case of a failed dispute only the liquidator can withdraw.\n        } else if (liquidation.state == Status.DisputeFailed) {\n            // Pay LIQUIDATOR: collateral + dispute bond + returned final fee\n            rewards.payToLiquidator = collateral.add(disputeBondAmount).add(finalFee);\n\n            // Transfer rewards and debit collateral\n            rewards.paidToLiquidator = _removeCollateral(rawLiquidationCollateral, rewards.payToLiquidator);\n\n            collateralCurrency.safeTransfer(liquidation.liquidator, rewards.paidToLiquidator.rawValue);\n\n            // If the state is pre-dispute but time has passed liveness then there was no dispute. We represent this\n            // state as a dispute failed and the liquidator can withdraw.\n        } else if (liquidation.state == Status.NotDisputed) {\n            // Pay LIQUIDATOR: collateral + returned final fee\n            rewards.payToLiquidator = collateral.add(finalFee);\n\n            // Transfer rewards and debit collateral\n            rewards.paidToLiquidator = _removeCollateral(rawLiquidationCollateral, rewards.payToLiquidator);\n\n            collateralCurrency.safeTransfer(liquidation.liquidator, rewards.paidToLiquidator.rawValue);\n        }\n\n        emit LiquidationWithdrawn(\n            msg.sender,\n            rewards.paidToLiquidator.rawValue,\n            rewards.paidToDisputer.rawValue,\n            rewards.paidToSponsor.rawValue,\n            liquidation.state,\n            settlementPrice.rawValue\n        );\n\n        // Free up space after collateral is withdrawn by removing the liquidation object from the array.\n        delete liquidations[sponsor][liquidationId];\n\n        return rewards;\n    }",
        "comments": [
            "/**",
            "     * @notice After a dispute has settled or after a non-disputed liquidation has expired,",
            "     * anyone can call this method to disperse payments to the sponsor, liquidator, and disputer.",
            "     * @dev If the dispute SUCCEEDED: the sponsor, liquidator, and disputer are eligible for payment.",
            "     * If the dispute FAILED: only the liquidator receives payment. This method deletes the liquidation data.",
            "     * This method will revert if rewards have already been dispersed.",
            "     * @param liquidationId uniquely identifies the sponsor's liquidation.",
            "     * @param sponsor address of the sponsor associated with the liquidation.",
            "     * @return data about rewards paid out.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice After a dispute has settled or after a non-disputed liquidation has expired,\n     * anyone can call this method to disperse payments to the sponsor, liquidator, and disputer.\n     * @dev If the dispute SUCCEEDED: the sponsor, liquidator, and disputer are eligible for payment.\n     * If the dispute FAILED: only the liquidator receives payment. This method deletes the liquidation data.\n     * This method will revert if rewards have already been dispersed.\n     * @param liquidationId uniquely identifies the sponsor's liquidation.\n     * @param sponsor address of the sponsor associated with the liquidation.\n     * @return data about rewards paid out.\n     */\n",
        "@notice": "After a dispute has settled or after a non-disputed liquidation has expired, * anyone can call this method to disperse payments to the sponsor, liquidator, and disputer.",
        "@dev": "If the dispute SUCCEEDED: the sponsor, liquidator, and disputer are eligible for payment. * If the dispute FAILED: only the liquidator receives payment. This method deletes the liquidation data. * This method will revert if rewards have already been dispersed.",
        "@param1": "liquidationId uniquely identifies the sponsor's liquidation.",
        "@param2": "sponsor address of the sponsor associated with the liquidation.",
        "@return1": "data about rewards paid out.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "getLiquidations",
        "visibility": "external",
        "args": [
            {
                "name": "sponsor",
                "type": "address"
            }
        ],
        "func": "function getLiquidations(address sponsor)\n        external\n        view\n        nonReentrantView()\n        returns (LiquidationData[] memory liquidationData)\n    {\n        return liquidations[sponsor];\n    }",
        "comments": [
            "/**",
            "     * @notice Gets all liquidation information for a given sponsor address.",
            "     * @param sponsor address of the position sponsor.",
            "     * @return liquidationData array of all liquidation information for the given sponsor address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets all liquidation information for a given sponsor address.\n     * @param sponsor address of the position sponsor.\n     * @return liquidationData array of all liquidation information for the given sponsor address.\n     */\n",
        "@notice": "Gets all liquidation information for a given sponsor address.",
        "@param1": "sponsor address of the position sponsor.",
        "@return1": "liquidationData array of all liquidation information for the given sponsor address.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "depositTo",
        "visibility": "public",
        "args": [
            {
                "name": "sponsor",
                "type": "address"
            },
            {
                "name": "collateralAmount",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function depositTo(address sponsor, FixedPoint.Unsigned memory collateralAmount)\n        public\n        notEmergencyShutdown()\n        noPendingWithdrawal(sponsor)\n        fees()\n        nonReentrant()\n    {\n        require(collateralAmount.isGreaterThan(0));\n        PositionData storage positionData = _getPositionData(sponsor);\n\n        // Increase the position and global collateral balance by collateral amount.\n        _incrementCollateralBalances(positionData, collateralAmount);\n\n        emit Deposit(sponsor, collateralAmount.rawValue);\n\n        // Move collateral currency from sender to contract.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Transfers `collateralAmount` of `collateralCurrency` into the specified sponsor's position.",
            "     * @dev Increases the collateralization level of a position after creation. This contract must be approved to spend",
            "     * at least `collateralAmount` of `collateralCurrency`.",
            "     * @param sponsor the sponsor to credit the deposit to.",
            "     * @param collateralAmount total amount of collateral tokens to be sent to the sponsor's position.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfers `collateralAmount` of `collateralCurrency` into the specified sponsor's position.\n     * @dev Increases the collateralization level of a position after creation. This contract must be approved to spend\n     * at least `collateralAmount` of `collateralCurrency`.\n     * @param sponsor the sponsor to credit the deposit to.\n     * @param collateralAmount total amount of collateral tokens to be sent to the sponsor's position.\n     */\n",
        "@notice": "Transfers `collateralAmount` of `collateralCurrency` into the specified sponsor's position.",
        "@dev": "Increases the collateralization level of a position after creation. This contract must be approved to spend * at least `collateralAmount` of `collateralCurrency`.",
        "@param1": "sponsor the sponsor to credit the deposit to.",
        "@param2": "collateralAmount total amount of collateral tokens to be sent to the sponsor's position.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "deposit",
        "visibility": "public",
        "args": [
            {
                "name": "collateralAmount",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function deposit(FixedPoint.Unsigned memory collateralAmount) public {\n        // This is just a thin wrapper over depositTo that specified the sender as the sponsor.\n        depositTo(msg.sender, collateralAmount);\n    }",
        "comments": [
            "/**",
            "     * @notice Transfers `collateralAmount` of `collateralCurrency` into the caller's position.",
            "     * @dev Increases the collateralization level of a position after creation. This contract must be approved to spend",
            "     * at least `collateralAmount` of `collateralCurrency`.",
            "     * @param collateralAmount total amount of collateral tokens to be sent to the sponsor's position.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfers `collateralAmount` of `collateralCurrency` into the caller's position.\n     * @dev Increases the collateralization level of a position after creation. This contract must be approved to spend\n     * at least `collateralAmount` of `collateralCurrency`.\n     * @param collateralAmount total amount of collateral tokens to be sent to the sponsor's position.\n     */\n",
        "@notice": "Transfers `collateralAmount` of `collateralCurrency` into the caller's position.",
        "@dev": "Increases the collateralization level of a position after creation. This contract must be approved to spend * at least `collateralAmount` of `collateralCurrency`.",
        "@param1": "collateralAmount total amount of collateral tokens to be sent to the sponsor's position.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "collateralAmount",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function withdraw(FixedPoint.Unsigned memory collateralAmount)\n        public\n        notEmergencyShutdown()\n        noPendingWithdrawal(msg.sender)\n        fees()\n        nonReentrant()\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        require(collateralAmount.isGreaterThan(0));\n        PositionData storage positionData = _getPositionData(msg.sender);\n\n        // Decrement the sponsor's collateral and global collateral amounts. Check the GCR between decrement to ensure\n        // position remains above the GCR within the withdrawal. If this is not the case the caller must submit a request.\n        amountWithdrawn = _decrementCollateralBalancesCheckGCR(positionData, collateralAmount);\n\n        emit Withdrawal(msg.sender, amountWithdrawn.rawValue);\n\n        // Move collateral currency from contract to sender.\n        // Note: that we move the amount of collateral that is decreased from rawCollateral (inclusive of fees)\n        // instead of the user requested amount. This eliminates precision loss that could occur\n        // where the user withdraws more collateral than rawCollateral is decremented by.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Transfers `collateralAmount` of `collateralCurrency` from the sponsor's position to the sponsor.",
            "     * @dev Reverts if the withdrawal puts this position's collateralization ratio below the global collateralization",
            "     * ratio. In that case, use `requestWithdrawal`. Might not withdraw the full requested amount to account for precision loss.",
            "     * @param collateralAmount is the amount of collateral to withdraw.",
            "     * @return amountWithdrawn The actual amount of collateral withdrawn.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfers `collateralAmount` of `collateralCurrency` from the sponsor's position to the sponsor.\n     * @dev Reverts if the withdrawal puts this position's collateralization ratio below the global collateralization\n     * ratio. In that case, use `requestWithdrawal`. Might not withdraw the full requested amount to account for precision loss.\n     * @param collateralAmount is the amount of collateral to withdraw.\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\n     */\n",
        "@notice": "Transfers `collateralAmount` of `collateralCurrency` from the sponsor's position to the sponsor.",
        "@dev": "Reverts if the withdrawal puts this position's collateralization ratio below the global collateralization * ratio. In that case, use `requestWithdrawal`. Might not withdraw the full requested amount to account for precision loss.",
        "@param1": "collateralAmount is the amount of collateral to withdraw.",
        "@return1": "amountWithdrawn The actual amount of collateral withdrawn.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "requestWithdrawal",
        "visibility": "public",
        "args": [
            {
                "name": "collateralAmount",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function requestWithdrawal(FixedPoint.Unsigned memory collateralAmount)\n        public\n        notEmergencyShutdown()\n        noPendingWithdrawal(msg.sender)\n        nonReentrant()\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(\n            collateralAmount.isGreaterThan(0) &&\n                collateralAmount.isLessThanOrEqual(_getFeeAdjustedCollateral(positionData.rawCollateral))\n        );\n\n        // Update the position object for the user.\n        positionData.withdrawalRequestPassTimestamp = getCurrentTime().add(withdrawalLiveness);\n        positionData.withdrawalRequestAmount = collateralAmount;\n\n        emit RequestWithdrawal(msg.sender, collateralAmount.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Starts a withdrawal request that, if passed, allows the sponsor to withdraw from their position.",
            "     * @dev The request will be pending for `withdrawalLiveness`, during which the position can be liquidated.",
            "     * @param collateralAmount the amount of collateral requested to withdraw",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Starts a withdrawal request that, if passed, allows the sponsor to withdraw from their position.\n     * @dev The request will be pending for `withdrawalLiveness`, during which the position can be liquidated.\n     * @param collateralAmount the amount of collateral requested to withdraw\n     */\n",
        "@notice": "Starts a withdrawal request that, if passed, allows the sponsor to withdraw from their position.",
        "@dev": "The request will be pending for `withdrawalLiveness`, during which the position can be liquidated.",
        "@param1": "collateralAmount the amount of collateral requested to withdraw",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawPassedRequest",
        "visibility": "external",
        "args": [],
        "func": "function withdrawPassedRequest()\n        external\n        notEmergencyShutdown()\n        fees()\n        nonReentrant()\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(\n            positionData.withdrawalRequestPassTimestamp != 0 &&\n                positionData.withdrawalRequestPassTimestamp <= getCurrentTime()\n        );\n\n        // If withdrawal request amount is > position collateral, then withdraw the full collateral amount.\n        // This situation is possible due to fees charged since the withdrawal was originally requested.\n        FixedPoint.Unsigned memory amountToWithdraw = positionData.withdrawalRequestAmount;\n        if (positionData.withdrawalRequestAmount.isGreaterThan(_getFeeAdjustedCollateral(positionData.rawCollateral))) {\n            amountToWithdraw = _getFeeAdjustedCollateral(positionData.rawCollateral);\n        }\n\n        // Decrement the sponsor's collateral and global collateral amounts.\n        amountWithdrawn = _decrementCollateralBalances(positionData, amountToWithdraw);\n\n        // Reset withdrawal request by setting withdrawal amount and withdrawal timestamp to 0.\n        _resetWithdrawalRequest(positionData);\n\n        // Transfer approved withdrawal amount from the contract to the caller.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n\n        emit RequestWithdrawalExecuted(msg.sender, amountWithdrawn.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice After a passed withdrawal request (i.e., by a call to `requestWithdrawal` and waiting",
            "     * `withdrawalLiveness`), withdraws `positionData.withdrawalRequestAmount` of collateral currency.",
            "     * @dev Might not withdraw the full requested amount in order to account for precision loss or if the full requested",
            "     * amount exceeds the collateral in the position (due to paying fees).",
            "     * @return amountWithdrawn The actual amount of collateral withdrawn.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice After a passed withdrawal request (i.e., by a call to `requestWithdrawal` and waiting\n     * `withdrawalLiveness`), withdraws `positionData.withdrawalRequestAmount` of collateral currency.\n     * @dev Might not withdraw the full requested amount in order to account for precision loss or if the full requested\n     * amount exceeds the collateral in the position (due to paying fees).\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\n     */\n",
        "@notice": "After a passed withdrawal request (i.e., by a call to `requestWithdrawal` and waiting * `withdrawalLiveness`), withdraws `positionData.withdrawalRequestAmount` of collateral currency.",
        "@dev": "Might not withdraw the full requested amount in order to account for precision loss or if the full requested * amount exceeds the collateral in the position (due to paying fees).",
        "@return1": "amountWithdrawn The actual amount of collateral withdrawn.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cancelWithdrawal",
        "visibility": "external",
        "args": [],
        "func": "function cancelWithdrawal() external notEmergencyShutdown() nonReentrant() {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        // No pending withdrawal require message removed to save bytecode.\n        require(positionData.withdrawalRequestPassTimestamp != 0);\n\n        emit RequestWithdrawalCanceled(msg.sender, positionData.withdrawalRequestAmount.rawValue);\n\n        // Reset withdrawal request by setting withdrawal amount and withdrawal timestamp to 0.\n        _resetWithdrawalRequest(positionData);\n    }",
        "comments": [
            "/**",
            "     * @notice Cancels a pending withdrawal request.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Cancels a pending withdrawal request.\n     */\n",
        "@notice": "Cancels a pending withdrawal request.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "create",
        "visibility": "public",
        "args": [
            {
                "name": "collateralAmount",
                "type": "FixedPoint.Unsigned memory"
            },
            {
                "name": "numTokens",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function create(FixedPoint.Unsigned memory collateralAmount, FixedPoint.Unsigned memory numTokens)\n        public\n        notEmergencyShutdown()\n        fees()\n        nonReentrant()\n    {\n        PositionData storage positionData = positions[msg.sender];\n\n        // Either the new create ratio or the resultant position CR must be above the current GCR.\n        require(\n            (_checkCollateralization(\n                _getFeeAdjustedCollateral(positionData.rawCollateral).add(collateralAmount),\n                positionData.tokensOutstanding.add(numTokens)\n            ) || _checkCollateralization(collateralAmount, numTokens)),\n            \"Insufficient collateral\"\n        );\n\n        require(positionData.withdrawalRequestPassTimestamp == 0);\n        if (positionData.tokensOutstanding.isEqual(0)) {\n            require(numTokens.isGreaterThanOrEqual(minSponsorTokens));\n            emit NewSponsor(msg.sender);\n        }\n\n        // Increase the position and global collateral balance by collateral amount.\n        _incrementCollateralBalances(positionData, collateralAmount);\n\n        // Add the number of tokens created to the position's outstanding tokens.\n        positionData.tokensOutstanding = positionData.tokensOutstanding.add(numTokens);\n\n        totalTokensOutstanding = totalTokensOutstanding.add(numTokens);\n\n        emit PositionCreated(msg.sender, collateralAmount.rawValue, numTokens.rawValue);\n\n        // Transfer tokens into the contract from caller and mint corresponding synthetic tokens to the caller's address.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n\n        // Note: revert reason removed to save bytecode.\n        require(tokenCurrency.mint(msg.sender, numTokens.rawValue));\n    }",
        "comments": [
            "/**",
            "     * @notice Creates tokens by creating a new position or by augmenting an existing position. Pulls `collateralAmount",
            "     * ` into the sponsor's position and mints `numTokens` of `tokenCurrency`.",
            "     * @dev This contract must have the Minter role for the `tokenCurrency`.",
            "     * @dev Reverts if minting these tokens would put the position's collateralization ratio below the",
            "     * global collateralization ratio. This contract must be approved to spend at least `collateralAmount` of",
            "     * `collateralCurrency`.",
            "     * @param collateralAmount is the number of collateral tokens to collateralize the position with",
            "     * @param numTokens is the number of tokens to mint from the position.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Creates tokens by creating a new position or by augmenting an existing position. Pulls `collateralAmount\n     * ` into the sponsor's position and mints `numTokens` of `tokenCurrency`.\n     * @dev This contract must have the Minter role for the `tokenCurrency`.\n     * @dev Reverts if minting these tokens would put the position's collateralization ratio below the\n     * global collateralization ratio. This contract must be approved to spend at least `collateralAmount` of\n     * `collateralCurrency`.\n     * @param collateralAmount is the number of collateral tokens to collateralize the position with\n     * @param numTokens is the number of tokens to mint from the position.\n     */\n",
        "@notice": "Creates tokens by creating a new position or by augmenting an existing position. Pulls `collateralAmount * ` into the sponsor's position and mints `numTokens` of `tokenCurrency`.",
        "@dev": "This contract must have the Minter role for the `tokenCurrency`. * Reverts if minting these tokens would put the position's collateralization ratio below the * global collateralization ratio. This contract must be approved to spend at least `collateralAmount` of * `collateralCurrency`.",
        "@param1": "collateralAmount is the number of collateral tokens to collateralize the position with",
        "@param2": "numTokens is the number of tokens to mint from the position.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "redeem",
        "visibility": "public",
        "args": [
            {
                "name": "numTokens",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function redeem(FixedPoint.Unsigned memory numTokens)\n        public\n        notEmergencyShutdown()\n        noPendingWithdrawal(msg.sender)\n        fees()\n        nonReentrant()\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(numTokens.isLessThanOrEqual(positionData.tokensOutstanding));\n\n        FixedPoint.Unsigned memory fractionRedeemed = numTokens.div(positionData.tokensOutstanding);\n        FixedPoint.Unsigned memory collateralRedeemed =\n            fractionRedeemed.mul(_getFeeAdjustedCollateral(positionData.rawCollateral));\n\n        // If redemption returns all tokens the sponsor has then we can delete their position. Else, downsize.\n        if (positionData.tokensOutstanding.isEqual(numTokens)) {\n            amountWithdrawn = _deleteSponsorPosition(msg.sender);\n        } else {\n            // Decrement the sponsor's collateral and global collateral amounts.\n            amountWithdrawn = _decrementCollateralBalances(positionData, collateralRedeemed);\n\n            // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\n            FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n            require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens));\n            positionData.tokensOutstanding = newTokenCount;\n\n            // Update the totalTokensOutstanding after redemption.\n            totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n        }\n\n        emit Redeem(msg.sender, amountWithdrawn.rawValue, numTokens.rawValue);\n\n        // Transfer collateral from contract to caller and burn callers synthetic tokens.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n        tokenCurrency.burn(numTokens.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Burns `numTokens` of `tokenCurrency` and sends back the proportional amount of `collateralCurrency`.",
            "     * @dev Can only be called by a token sponsor. Might not redeem the full proportional amount of collateral",
            "     * in order to account for precision loss. This contract must be approved to spend at least `numTokens` of",
            "     * `tokenCurrency`.",
            "     * @dev This contract must have the Burner role for the `tokenCurrency`.",
            "     * @param numTokens is the number of tokens to be burnt for a commensurate amount of collateral.",
            "     * @return amountWithdrawn The actual amount of collateral withdrawn.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Burns `numTokens` of `tokenCurrency` and sends back the proportional amount of `collateralCurrency`.\n     * @dev Can only be called by a token sponsor. Might not redeem the full proportional amount of collateral\n     * in order to account for precision loss. This contract must be approved to spend at least `numTokens` of\n     * `tokenCurrency`.\n     * @dev This contract must have the Burner role for the `tokenCurrency`.\n     * @param numTokens is the number of tokens to be burnt for a commensurate amount of collateral.\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\n     */\n",
        "@notice": "Burns `numTokens` of `tokenCurrency` and sends back the proportional amount of `collateralCurrency`.",
        "@dev": "Can only be called by a token sponsor. Might not redeem the full proportional amount of collateral * in order to account for precision loss. This contract must be approved to spend at least `numTokens` of * `tokenCurrency`. * This contract must have the Burner role for the `tokenCurrency`.",
        "@param1": "numTokens is the number of tokens to be burnt for a commensurate amount of collateral.",
        "@return1": "amountWithdrawn The actual amount of collateral withdrawn.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repay",
        "visibility": "public",
        "args": [
            {
                "name": "numTokens",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function repay(FixedPoint.Unsigned memory numTokens)\n        public\n        notEmergencyShutdown()\n        noPendingWithdrawal(msg.sender)\n        fees()\n        nonReentrant()\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(numTokens.isLessThanOrEqual(positionData.tokensOutstanding));\n\n        // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\n        FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n        require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens));\n        positionData.tokensOutstanding = newTokenCount;\n\n        // Update the totalTokensOutstanding after redemption.\n        totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n\n        emit Repay(msg.sender, numTokens.rawValue, newTokenCount.rawValue);\n\n        // Transfer the tokens back from the sponsor and burn them.\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n        tokenCurrency.burn(numTokens.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Burns `numTokens` of `tokenCurrency` to decrease sponsors position size, without sending back `collateralCurrency`.",
            "     * This is done by a sponsor to increase position CR. Resulting size is bounded by minSponsorTokens.",
            "     * @dev Can only be called by token sponsor. This contract must be approved to spend `numTokens` of `tokenCurrency`.",
            "     * @dev This contract must have the Burner role for the `tokenCurrency`.",
            "     * @param numTokens is the number of tokens to be burnt from the sponsor's debt position.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Burns `numTokens` of `tokenCurrency` to decrease sponsors position size, without sending back `collateralCurrency`.\n     * This is done by a sponsor to increase position CR. Resulting size is bounded by minSponsorTokens.\n     * @dev Can only be called by token sponsor. This contract must be approved to spend `numTokens` of `tokenCurrency`.\n     * @dev This contract must have the Burner role for the `tokenCurrency`.\n     * @param numTokens is the number of tokens to be burnt from the sponsor's debt position.\n     */\n",
        "@notice": "Burns `numTokens` of `tokenCurrency` to decrease sponsors position size, without sending back `collateralCurrency`. * This is done by a sponsor to increase position CR. Resulting size is bounded by minSponsorTokens.",
        "@dev": "Can only be called by token sponsor. This contract must be approved to spend `numTokens` of `tokenCurrency`. * This contract must have the Burner role for the `tokenCurrency`.",
        "@param1": "numTokens is the number of tokens to be burnt from the sponsor's debt position.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "settleEmergencyShutdown",
        "visibility": "external",
        "args": [],
        "func": "function settleEmergencyShutdown()\n        external\n        isEmergencyShutdown()\n        fees()\n        nonReentrant()\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        // Set the emergency shutdown price as resolved from the DVM. If DVM has not resolved will revert.\n        if (emergencyShutdownPrice.isEqual(FixedPoint.fromUnscaledUint(0))) {\n            emergencyShutdownPrice = _getOracleEmergencyShutdownPrice();\n        }\n\n        // Get caller's tokens balance and calculate amount of underlying entitled to them.\n        FixedPoint.Unsigned memory tokensToRedeem = FixedPoint.Unsigned(tokenCurrency.balanceOf(msg.sender));\n        FixedPoint.Unsigned memory totalRedeemableCollateral =\n            _getFundingRateAppliedTokenDebt(tokensToRedeem).mul(emergencyShutdownPrice);\n\n        // If the caller is a sponsor with outstanding collateral they are also entitled to their excess collateral after their debt.\n        PositionData storage positionData = positions[msg.sender];\n        if (_getFeeAdjustedCollateral(positionData.rawCollateral).isGreaterThan(0)) {\n            // Calculate the underlying entitled to a token sponsor. This is collateral - debt in underlying with\n            // the funding rate applied to the outstanding token debt.\n\n            FixedPoint.Unsigned memory tokenDebtValueInCollateral =\n                _getFundingRateAppliedTokenDebt(positionData.tokensOutstanding).mul(emergencyShutdownPrice);\n            FixedPoint.Unsigned memory positionCollateral = _getFeeAdjustedCollateral(positionData.rawCollateral);\n\n            // If the debt is greater than the remaining collateral, they cannot redeem anything.\n            FixedPoint.Unsigned memory positionRedeemableCollateral =\n                tokenDebtValueInCollateral.isLessThan(positionCollateral)\n                    ? positionCollateral.sub(tokenDebtValueInCollateral)\n                    : FixedPoint.Unsigned(0);\n\n            // Add the number of redeemable tokens for the sponsor to their total redeemable collateral.\n            totalRedeemableCollateral = totalRedeemableCollateral.add(positionRedeemableCollateral);\n\n            // Reset the position state as all the value has been removed after settlement.\n            delete positions[msg.sender];\n            emit EndedSponsorPosition(msg.sender);\n        }\n\n        // Take the min of the remaining collateral and the collateral \"owed\". If the contract is undercapitalized,\n        // the caller will get as much collateral as the contract can pay out.\n        FixedPoint.Unsigned memory payout =\n            FixedPoint.min(_getFeeAdjustedCollateral(rawTotalPositionCollateral), totalRedeemableCollateral);\n\n        // Decrement total contract collateral and outstanding debt.\n        amountWithdrawn = _removeCollateral(rawTotalPositionCollateral, payout);\n        totalTokensOutstanding = totalTokensOutstanding.sub(tokensToRedeem);\n\n        emit SettleEmergencyShutdown(msg.sender, amountWithdrawn.rawValue, tokensToRedeem.rawValue);\n\n        // Transfer tokens & collateral and burn the redeemed tokens.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), tokensToRedeem.rawValue);\n        tokenCurrency.burn(tokensToRedeem.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice If the contract is emergency shutdown then all token holders and sponsors can redeem their tokens or",
            "     * remaining collateral for underlying at the prevailing price defined by a DVM vote.",
            "     * @dev This burns all tokens from the caller of `tokenCurrency` and sends back the resolved settlement value of",
            "     * `collateralCurrency`. Might not redeem the full proportional amount of collateral in order to account for",
            "     * precision loss. This contract must be approved to spend `tokenCurrency` at least up to the caller's full balance.",
            "     * @dev This contract must have the Burner role for the `tokenCurrency`.",
            "     * @dev Note that this function does not call the updateFundingRate modifier to update the funding rate as this",
            "     * function is only called after an emergency shutdown & there should be no funding rate updates after the shutdown.",
            "     * @return amountWithdrawn The actual amount of collateral withdrawn.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice If the contract is emergency shutdown then all token holders and sponsors can redeem their tokens or\n     * remaining collateral for underlying at the prevailing price defined by a DVM vote.\n     * @dev This burns all tokens from the caller of `tokenCurrency` and sends back the resolved settlement value of\n     * `collateralCurrency`. Might not redeem the full proportional amount of collateral in order to account for\n     * precision loss. This contract must be approved to spend `tokenCurrency` at least up to the caller's full balance.\n     * @dev This contract must have the Burner role for the `tokenCurrency`.\n     * @dev Note that this function does not call the updateFundingRate modifier to update the funding rate as this\n     * function is only called after an emergency shutdown & there should be no funding rate updates after the shutdown.\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\n     */\n",
        "@notice": "If the contract is emergency shutdown then all token holders and sponsors can redeem their tokens or * remaining collateral for underlying at the prevailing price defined by a DVM vote.",
        "@dev": "This burns all tokens from the caller of `tokenCurrency` and sends back the resolved settlement value of * `collateralCurrency`. Might not redeem the full proportional amount of collateral in order to account for * precision loss. This contract must be approved to spend `tokenCurrency` at least up to the caller's full balance. * This contract must have the Burner role for the `tokenCurrency`. * Note that this function does not call the updateFundingRate modifier to update the funding rate as this * function is only called after an emergency shutdown & there should be no funding rate updates after the shutdown.",
        "@return1": "amountWithdrawn The actual amount of collateral withdrawn.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "emergencyShutdown",
        "visibility": "external",
        "args": [],
        "func": "function emergencyShutdown() external override notEmergencyShutdown() fees() nonReentrant() {\n        // Note: revert reason removed to save bytecode.\n        require(msg.sender == _getFinancialContractsAdminAddress());\n\n        emergencyShutdownTimestamp = getCurrentTime();\n        _requestOraclePrice(emergencyShutdownTimestamp);\n\n        emit EmergencyShutdown(msg.sender, emergencyShutdownTimestamp);\n    }",
        "comments": [
            "/**",
            "     * @notice Premature contract settlement under emergency circumstances.",
            "     * @dev Only the governor can call this function as they are permissioned within the `FinancialContractAdmin`.",
            "     * Upon emergency shutdown, the contract settlement time is set to the shutdown time. This enables withdrawal",
            "     * to occur via the `settleEmergencyShutdown` function.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Premature contract settlement under emergency circumstances.\n     * @dev Only the governor can call this function as they are permissioned within the `FinancialContractAdmin`.\n     * Upon emergency shutdown, the contract settlement time is set to the shutdown time. This enables withdrawal\n     * to occur via the `settleEmergencyShutdown` function.\n     */\n",
        "@notice": "Premature contract settlement under emergency circumstances.",
        "@dev": "Only the governor can call this function as they are permissioned within the `FinancialContractAdmin`. * Upon emergency shutdown, the contract settlement time is set to the shutdown time. This enables withdrawal * to occur via the `settleEmergencyShutdown` function.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "remargin",
        "visibility": "external",
        "args": [],
        "func": "function remargin() external override {\n        return;\n    }",
        "comments": [
            "/**",
            "     * @notice Theoretically supposed to pay fees and move money between margin accounts to make sure they",
            "     * reflect the NAV of the contract. However, this functionality doesn't apply to this contract.",
            "     * @dev This is supposed to be implemented by any contract that inherits `AdministrateeInterface` and callable",
            "     * only by the Governor contract. This method is therefore minimally implemented in this contract and does nothing.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Theoretically supposed to pay fees and move money between margin accounts to make sure they\n     * reflect the NAV of the contract. However, this functionality doesn't apply to this contract.\n     * @dev This is supposed to be implemented by any contract that inherits `AdministrateeInterface` and callable\n     * only by the Governor contract. This method is therefore minimally implemented in this contract and does nothing.\n     */\n",
        "@notice": "Theoretically supposed to pay fees and move money between margin accounts to make sure they * reflect the NAV of the contract. However, this functionality doesn't apply to this contract.",
        "@dev": "This is supposed to be implemented by any contract that inherits `AdministrateeInterface` and callable * only by the Governor contract. This method is therefore minimally implemented in this contract and does nothing.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCollateral",
        "visibility": "external",
        "args": [
            {
                "name": "sponsor",
                "type": "address"
            }
        ],
        "func": "function getCollateral(address sponsor)\n        external\n        view\n        nonReentrantView()\n        returns (FixedPoint.Unsigned memory collateralAmount)\n    {\n        // Note: do a direct access to avoid the validity check.\n        return _getPendingRegularFeeAdjustedCollateral(_getFeeAdjustedCollateral(positions[sponsor].rawCollateral));\n    }",
        "comments": [
            "/**",
            "     * @notice Accessor method for a sponsor's collateral.",
            "     * @dev This is necessary because the struct returned by the positions() method shows",
            "     * rawCollateral, which isn't a user-readable value.",
            "     * @dev This method accounts for pending regular fees that have not yet been withdrawn from this contract, for",
            "     * example if the `lastPaymentTime != currentTime`.",
            "     * @param sponsor address whose collateral amount is retrieved.",
            "     * @return collateralAmount amount of collateral within a sponsors position.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Accessor method for a sponsor's collateral.\n     * @dev This is necessary because the struct returned by the positions() method shows\n     * rawCollateral, which isn't a user-readable value.\n     * @dev This method accounts for pending regular fees that have not yet been withdrawn from this contract, for\n     * example if the `lastPaymentTime != currentTime`.\n     * @param sponsor address whose collateral amount is retrieved.\n     * @return collateralAmount amount of collateral within a sponsors position.\n     */\n",
        "@notice": "Accessor method for a sponsor's collateral.",
        "@dev": "This is necessary because the struct returned by the positions() method shows * rawCollateral, which isn't a user-readable value. * This method accounts for pending regular fees that have not yet been withdrawn from this contract, for * example if the `lastPaymentTime != currentTime`.",
        "@param1": "sponsor address whose collateral amount is retrieved.",
        "@return1": "collateralAmount amount of collateral within a sponsors position.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalPositionCollateral",
        "visibility": "external",
        "args": [],
        "func": "function totalPositionCollateral()\n        external\n        view\n        nonReentrantView()\n        returns (FixedPoint.Unsigned memory totalCollateral)\n    {\n        return _getPendingRegularFeeAdjustedCollateral(_getFeeAdjustedCollateral(rawTotalPositionCollateral));\n    }",
        "comments": [
            "/**",
            "     * @notice Accessor method for the total collateral stored within the PerpetualPositionManager.",
            "     * @return totalCollateral amount of all collateral within the position manager.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Accessor method for the total collateral stored within the PerpetualPositionManager.\n     * @return totalCollateral amount of all collateral within the position manager.\n     */\n",
        "@notice": "Accessor method for the total collateral stored within the PerpetualPositionManager.",
        "@return1": "totalCollateral amount of all collateral within the position manager.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getFundingRateAppliedTokenDebt",
        "visibility": "external",
        "args": [
            {
                "name": "rawTokenDebt",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function getFundingRateAppliedTokenDebt(FixedPoint.Unsigned memory rawTokenDebt)\n        external\n        view\n        nonReentrantView()\n        returns (FixedPoint.Unsigned memory totalCollateral)\n    {\n        return _getFundingRateAppliedTokenDebt(rawTokenDebt);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "applyFundingRate",
        "visibility": "public",
        "args": [],
        "func": "function applyFundingRate() public paysRegularFees() nonReentrant() {\n        _applyEffectiveFundingRate();\n    }",
        "comments": [
            "/**",
            "     * @notice This method takes 3 distinct actions:",
            "     * 1. Pays out regular fees.",
            "     * 2. If possible, resolves the outstanding funding rate proposal, pulling the result in and paying out the rewards.",
            "     * 3. Applies the prevailing funding rate over the most recent period.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice This method takes 3 distinct actions:\n     * 1. Pays out regular fees.\n     * 2. If possible, resolves the outstanding funding rate proposal, pulling the result in and paying out the rewards.\n     * 3. Applies the prevailing funding rate over the most recent period.\n     */\n",
        "@notice": "This method takes 3 distinct actions: * 1. Pays out regular fees. * 2. If possible, resolves the outstanding funding rate proposal, pulling the result in and paying out the rewards. * 3. Applies the prevailing funding rate over the most recent period.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "proposeFundingRate",
        "visibility": "external",
        "args": [
            {
                "name": "rate",
                "type": "FixedPoint.Signed memory"
            },
            {
                "name": "timestamp",
                "type": "uint256"
            }
        ],
        "func": "function proposeFundingRate(FixedPoint.Signed memory rate, uint256 timestamp)\n        external\n        fees()\n        nonReentrant()\n        returns (FixedPoint.Unsigned memory totalBond)\n    {\n        require(fundingRate.proposalTime == 0, \"Proposal in progress\");\n        _validateFundingRate(rate);\n\n        // Timestamp must be after the last funding rate update time, within the last 30 minutes.\n        uint256 currentTime = getCurrentTime();\n        uint256 updateTime = fundingRate.updateTime;\n        require(\n            timestamp > updateTime && timestamp >= currentTime.sub(_getConfig().proposalTimePastLimit),\n            \"Invalid proposal time\"\n        );\n\n        // Set the proposal time in order to allow this contract to track this request.\n        fundingRate.proposalTime = timestamp;\n\n        OptimisticOracleInterface optimisticOracle = _getOptimisticOracle();\n\n        // Set up optimistic oracle.\n        bytes32 identifier = fundingRate.identifier;\n        bytes memory ancillaryData = _getAncillaryData();\n        // Note: requestPrice will revert if `timestamp` is less than the current block timestamp.\n        optimisticOracle.requestPrice(identifier, timestamp, ancillaryData, collateralCurrency, 0);\n        totalBond = FixedPoint.Unsigned(\n            optimisticOracle.setBond(\n                identifier,\n                timestamp,\n                ancillaryData,\n                _pfc().mul(_getConfig().proposerBondPercentage).rawValue\n            )\n        );\n\n        // Pull bond from caller and send to optimistic oracle.\n        if (totalBond.isGreaterThan(0)) {\n            collateralCurrency.safeTransferFrom(msg.sender, address(this), totalBond.rawValue);\n            collateralCurrency.safeIncreaseAllowance(address(optimisticOracle), totalBond.rawValue);\n        }\n\n        optimisticOracle.proposePriceFor(\n            msg.sender,\n            address(this),\n            identifier,\n            timestamp,\n            ancillaryData,\n            rate.rawValue\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Proposes a new funding rate. Proposer receives a reward if correct.",
            "     * @param rate funding rate being proposed.",
            "     * @param timestamp time at which the funding rate was computed.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Proposes a new funding rate. Proposer receives a reward if correct.\n     * @param rate funding rate being proposed.\n     * @param timestamp time at which the funding rate was computed.\n     */\n",
        "@notice": "Proposes a new funding rate. Proposer receives a reward if correct.",
        "@param1": "rate funding rate being proposed.",
        "@param2": "timestamp time at which the funding rate was computed.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createExpiringMultiParty",
        "visibility": "public",
        "args": [
            {
                "name": "params",
                "type": "Params memory"
            }
        ],
        "func": "function createExpiringMultiParty(Params memory params) public nonReentrant() returns (address) {\n        // Create a new synthetic token using the params.\n        require(bytes(params.syntheticName).length != 0, \"Missing synthetic name\");\n        require(bytes(params.syntheticSymbol).length != 0, \"Missing synthetic symbol\");\n        TokenFactory tf = TokenFactory(tokenFactoryAddress);\n\n        // If the collateral token does not have a `decimals()` method, then a default precision of 18 will be\n        // applied to the newly created synthetic token.\n        uint8 syntheticDecimals = _getSyntheticDecimals(params.collateralAddress);\n        ExpandedIERC20 tokenCurrency = tf.createToken(params.syntheticName, params.syntheticSymbol, syntheticDecimals);\n        address derivative = ExpiringMultiPartyLib.deploy(_convertParams(params, tokenCurrency));\n\n        // Give permissions to new derivative contract and then hand over ownership.\n        tokenCurrency.addMinter(derivative);\n        tokenCurrency.addBurner(derivative);\n        tokenCurrency.resetOwner(derivative);\n\n        _registerContract(new address[](0), derivative);\n\n        emit CreatedExpiringMultiParty(derivative, msg.sender);\n\n        return derivative;\n    }",
        "comments": [
            "/**",
            "     * @notice Creates an instance of expiring multi party and registers it within the registry.",
            "     * @param params is a `ConstructorParams` object from ExpiringMultiParty.",
            "     * @return address of the deployed ExpiringMultiParty contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Creates an instance of expiring multi party and registers it within the registry.\n     * @param params is a `ConstructorParams` object from ExpiringMultiParty.\n     * @return address of the deployed ExpiringMultiParty contract.\n     */\n",
        "@notice": "Creates an instance of expiring multi party and registers it within the registry.",
        "@param1": "params is a `ConstructorParams` object from ExpiringMultiParty.",
        "@return1": "address of the deployed ExpiringMultiParty contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_getSyntheticDecimals",
        "visibility": "public",
        "args": [
            {
                "name": "_collateralAddress",
                "type": "address"
            }
        ],
        "func": "function _getSyntheticDecimals(address _collateralAddress) public view returns (uint8 decimals) {\n        try IERC20Standard(_collateralAddress).decimals() returns (uint8 _decimals) {\n            return _decimals;\n        } catch {\n            return 18;\n        }\n    }",
        "comments": [
            "",
            "    // IERC20Standard.decimals() will revert if the collateral contract has not implemented the decimals() method,",
            "    // which is possible since the method is only an OPTIONAL method in the ERC20 standard:",
            "    // https://eips.ethereum.org/EIPS/eip-20#methods.",
            "    "
        ],
        "comt": "\n    // IERC20Standard.decimals() will revert if the collateral contract has not implemented the decimals() method,\n    // which is possible since the method is only an OPTIONAL method in the ERC20 standard:\n    // https://eips.ethereum.org/EIPS/eip-20#methods.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "deploy",
        "visibility": "public",
        "args": [
            {
                "name": "params",
                "type": "ExpiringMultiParty.ConstructorParams memory"
            }
        ],
        "func": "function deploy(ExpiringMultiParty.ConstructorParams memory params) public returns (address) {\n        ExpiringMultiParty derivative = new ExpiringMultiParty(params);\n        return address(derivative);\n    }",
        "comments": [
            "/**",
            "     * @notice Returns address of new EMP deployed with given `params` configuration.",
            "     * @dev Caller will need to register new EMP with the Registry to begin requesting prices. Caller is also",
            "     * responsible for enforcing constraints on `params`.",
            "     * @param params is a `ConstructorParams` object from ExpiringMultiParty.",
            "     * @return address of the deployed ExpiringMultiParty contract",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns address of new EMP deployed with given `params` configuration.\n     * @dev Caller will need to register new EMP with the Registry to begin requesting prices. Caller is also\n     * responsible for enforcing constraints on `params`.\n     * @param params is a `ConstructorParams` object from ExpiringMultiParty.\n     * @return address of the deployed ExpiringMultiParty contract\n     */\n",
        "@notice": "Returns address of new EMP deployed with given `params` configuration.",
        "@dev": "Caller will need to register new EMP with the Registry to begin requesting prices. Caller is also * responsible for enforcing constraints on `params`.",
        "@param1": "params is a `ConstructorParams` object from ExpiringMultiParty.",
        "@return1": "address of the deployed ExpiringMultiParty contract",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createLiquidation",
        "visibility": "external",
        "args": [
            {
                "name": "sponsor",
                "type": "address"
            },
            {
                "name": "minCollateralPerToken",
                "type": "FixedPoint.Unsigned calldata"
            },
            {
                "name": "maxCollateralPerToken",
                "type": "FixedPoint.Unsigned calldata"
            },
            {
                "name": "maxTokensToLiquidate",
                "type": "FixedPoint.Unsigned calldata"
            },
            {
                "name": "deadline",
                "type": "uint256"
            }
        ],
        "func": "function createLiquidation(\n        address sponsor,\n        FixedPoint.Unsigned calldata minCollateralPerToken,\n        FixedPoint.Unsigned calldata maxCollateralPerToken,\n        FixedPoint.Unsigned calldata maxTokensToLiquidate,\n        uint256 deadline\n    )\n        external\n        fees()\n        onlyPreExpiration()\n        nonReentrant()\n        returns (\n            uint256 liquidationId,\n            FixedPoint.Unsigned memory tokensLiquidated,\n            FixedPoint.Unsigned memory finalFeeBond\n        )\n    {\n        // Check that this transaction was mined pre-deadline.\n        require(getCurrentTime() <= deadline, \"Mined after deadline\");\n\n        // Retrieve Position data for sponsor\n        PositionData storage positionToLiquidate = _getPositionData(sponsor);\n\n        tokensLiquidated = FixedPoint.min(maxTokensToLiquidate, positionToLiquidate.tokensOutstanding);\n        require(tokensLiquidated.isGreaterThan(0));\n\n        // Starting values for the Position being liquidated. If withdrawal request amount is > position's collateral,\n        // then set this to 0, otherwise set it to (startCollateral - withdrawal request amount).\n        FixedPoint.Unsigned memory startCollateral = _getFeeAdjustedCollateral(positionToLiquidate.rawCollateral);\n        FixedPoint.Unsigned memory startCollateralNetOfWithdrawal = FixedPoint.fromUnscaledUint(0);\n        if (positionToLiquidate.withdrawalRequestAmount.isLessThanOrEqual(startCollateral)) {\n            startCollateralNetOfWithdrawal = startCollateral.sub(positionToLiquidate.withdrawalRequestAmount);\n        }\n\n        // Scoping to get rid of a stack too deep error.\n        {\n            FixedPoint.Unsigned memory startTokens = positionToLiquidate.tokensOutstanding;\n\n            // The Position's collateralization ratio must be between [minCollateralPerToken, maxCollateralPerToken].\n            // maxCollateralPerToken >= startCollateralNetOfWithdrawal / startTokens.\n            require(\n                maxCollateralPerToken.mul(startTokens).isGreaterThanOrEqual(startCollateralNetOfWithdrawal),\n                \"CR is more than max liq. price\"\n            );\n            // minCollateralPerToken >= startCollateralNetOfWithdrawal / startTokens.\n            require(\n                minCollateralPerToken.mul(startTokens).isLessThanOrEqual(startCollateralNetOfWithdrawal),\n                \"CR is less than min liq. price\"\n            );\n        }\n\n        // Compute final fee at time of liquidation.\n        finalFeeBond = _computeFinalFees();\n\n        // These will be populated within the scope below.\n        FixedPoint.Unsigned memory lockedCollateral;\n        FixedPoint.Unsigned memory liquidatedCollateral;\n\n        // Scoping to get rid of a stack too deep error.\n        {\n            FixedPoint.Unsigned memory ratio = tokensLiquidated.div(positionToLiquidate.tokensOutstanding);\n\n            // The actual amount of collateral that gets moved to the liquidation.\n            lockedCollateral = startCollateral.mul(ratio);\n\n            // For purposes of disputes, it's actually this liquidatedCollateral value that's used. This value is net of\n            // withdrawal requests.\n            liquidatedCollateral = startCollateralNetOfWithdrawal.mul(ratio);\n\n            // Part of the withdrawal request is also removed. Ideally:\n            // liquidatedCollateral + withdrawalAmountToRemove = lockedCollateral.\n            FixedPoint.Unsigned memory withdrawalAmountToRemove =\n                positionToLiquidate.withdrawalRequestAmount.mul(ratio);\n            _reduceSponsorPosition(sponsor, tokensLiquidated, lockedCollateral, withdrawalAmountToRemove);\n        }\n\n        // Add to the global liquidation collateral count.\n        _addCollateral(rawLiquidationCollateral, lockedCollateral.add(finalFeeBond));\n\n        // Construct liquidation object.\n        // Note: All dispute-related values are zeroed out until a dispute occurs. liquidationId is the index of the new\n        // LiquidationData that is pushed into the array, which is equal to the current length of the array pre-push.\n        liquidationId = liquidations[sponsor].length;\n        liquidations[sponsor].push(\n            LiquidationData({\n                sponsor: sponsor,\n                liquidator: msg.sender,\n                state: Status.NotDisputed,\n                liquidationTime: getCurrentTime(),\n                tokensOutstanding: tokensLiquidated,\n                lockedCollateral: lockedCollateral,\n                liquidatedCollateral: liquidatedCollateral,\n                rawUnitCollateral: _convertToRawCollateral(FixedPoint.fromUnscaledUint(1)),\n                disputer: address(0),\n                settlementPrice: FixedPoint.fromUnscaledUint(0),\n                finalFee: finalFeeBond\n            })\n        );\n\n        // If this liquidation is a subsequent liquidation on the position, and the liquidation size is larger than\n        // some \"griefing threshold\", then re-set the liveness. This enables a liquidation against a withdraw request to be\n        // \"dragged out\" if the position is very large and liquidators need time to gather funds. The griefing threshold\n        // is enforced so that liquidations for trivially small # of tokens cannot drag out an honest sponsor's slow withdrawal.\n\n        // We arbitrarily set the \"griefing threshold\" to `minSponsorTokens` because it is the only parameter\n        // denominated in token currency units and we can avoid adding another parameter.\n        FixedPoint.Unsigned memory griefingThreshold = minSponsorTokens;\n        if (\n            positionToLiquidate.withdrawalRequestPassTimestamp > 0 && // The position is undergoing a slow withdrawal.\n            positionToLiquidate.withdrawalRequestPassTimestamp > getCurrentTime() && // The slow withdrawal has not yet expired.\n            tokensLiquidated.isGreaterThanOrEqual(griefingThreshold) // The liquidated token count is above a \"griefing threshold\".\n        ) {\n            positionToLiquidate.withdrawalRequestPassTimestamp = getCurrentTime().add(withdrawalLiveness);\n        }\n\n        emit LiquidationCreated(\n            sponsor,\n            msg.sender,\n            liquidationId,\n            tokensLiquidated.rawValue,\n            lockedCollateral.rawValue,\n            liquidatedCollateral.rawValue,\n            getCurrentTime()\n        );\n\n        // Destroy tokens\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), tokensLiquidated.rawValue);\n        tokenCurrency.burn(tokensLiquidated.rawValue);\n\n        // Pull final fee from liquidator.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), finalFeeBond.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Liquidates the sponsor's position if the caller has enough",
            "     * synthetic tokens to retire the position's outstanding tokens. Liquidations above",
            "     * a minimum size also reset an ongoing \"slow withdrawal\"'s liveness.",
            "     * @dev This method generates an ID that will uniquely identify liquidation for the sponsor. This contract must be",
            "     * approved to spend at least `tokensLiquidated` of `tokenCurrency` and at least `finalFeeBond` of `collateralCurrency`.",
            "     * @dev This contract must have the Burner role for the `tokenCurrency`.",
            "     * @param sponsor address of the sponsor to liquidate.",
            "     * @param minCollateralPerToken abort the liquidation if the position's collateral per token is below this value.",
            "     * @param maxCollateralPerToken abort the liquidation if the position's collateral per token exceeds this value.",
            "     * @param maxTokensToLiquidate max number of tokens to liquidate.",
            "     * @param deadline abort the liquidation if the transaction is mined after this timestamp.",
            "     * @return liquidationId ID of the newly created liquidation.",
            "     * @return tokensLiquidated amount of synthetic tokens removed and liquidated from the `sponsor`'s position.",
            "     * @return finalFeeBond amount of collateral to be posted by liquidator and returned if not disputed successfully.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Liquidates the sponsor's position if the caller has enough\n     * synthetic tokens to retire the position's outstanding tokens. Liquidations above\n     * a minimum size also reset an ongoing \"slow withdrawal\"'s liveness.\n     * @dev This method generates an ID that will uniquely identify liquidation for the sponsor. This contract must be\n     * approved to spend at least `tokensLiquidated` of `tokenCurrency` and at least `finalFeeBond` of `collateralCurrency`.\n     * @dev This contract must have the Burner role for the `tokenCurrency`.\n     * @param sponsor address of the sponsor to liquidate.\n     * @param minCollateralPerToken abort the liquidation if the position's collateral per token is below this value.\n     * @param maxCollateralPerToken abort the liquidation if the position's collateral per token exceeds this value.\n     * @param maxTokensToLiquidate max number of tokens to liquidate.\n     * @param deadline abort the liquidation if the transaction is mined after this timestamp.\n     * @return liquidationId ID of the newly created liquidation.\n     * @return tokensLiquidated amount of synthetic tokens removed and liquidated from the `sponsor`'s position.\n     * @return finalFeeBond amount of collateral to be posted by liquidator and returned if not disputed successfully.\n     */\n",
        "@notice": "Liquidates the sponsor's position if the caller has enough * synthetic tokens to retire the position's outstanding tokens. Liquidations above * a minimum size also reset an ongoing \"slow withdrawal\"'s liveness.",
        "@dev": "This method generates an ID that will uniquely identify liquidation for the sponsor. This contract must be * approved to spend at least `tokensLiquidated` of `tokenCurrency` and at least `finalFeeBond` of `collateralCurrency`. * This contract must have the Burner role for the `tokenCurrency`.",
        "@param1": "sponsor address of the sponsor to liquidate.",
        "@param2": "minCollateralPerToken abort the liquidation if the position's collateral per token is below this value.",
        "@param3": "maxCollateralPerToken abort the liquidation if the position's collateral per token exceeds this value.",
        "@param4": "maxTokensToLiquidate max number of tokens to liquidate.",
        "@param5": "deadline abort the liquidation if the transaction is mined after this timestamp.",
        "@return1": "liquidationId ID of the newly created liquidation.",
        "@return2": "tokensLiquidated amount of synthetic tokens removed and liquidated from the `sponsor`'s position.",
        "@return3": "finalFeeBond amount of collateral to be posted by liquidator and returned if not disputed successfully.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "dispute",
        "visibility": "external",
        "args": [
            {
                "name": "liquidationId",
                "type": "uint256"
            },
            {
                "name": "sponsor",
                "type": "address"
            }
        ],
        "func": "function dispute(uint256 liquidationId, address sponsor)\n        external\n        disputable(liquidationId, sponsor)\n        fees()\n        nonReentrant()\n        returns (FixedPoint.Unsigned memory totalPaid)\n    {\n        LiquidationData storage disputedLiquidation = _getLiquidationData(sponsor, liquidationId);\n\n        // Multiply by the unit collateral so the dispute bond is a percentage of the locked collateral after fees.\n        FixedPoint.Unsigned memory disputeBondAmount =\n            disputedLiquidation.lockedCollateral.mul(disputeBondPercentage).mul(\n                _getFeeAdjustedCollateral(disputedLiquidation.rawUnitCollateral)\n            );\n        _addCollateral(rawLiquidationCollateral, disputeBondAmount);\n\n        // Request a price from DVM. Liquidation is pending dispute until DVM returns a price.\n        disputedLiquidation.state = Status.Disputed;\n        disputedLiquidation.disputer = msg.sender;\n\n        // Enqueue a request with the DVM.\n        _requestOraclePriceLiquidation(disputedLiquidation.liquidationTime);\n\n        emit LiquidationDisputed(\n            sponsor,\n            disputedLiquidation.liquidator,\n            msg.sender,\n            liquidationId,\n            disputeBondAmount.rawValue\n        );\n        totalPaid = disputeBondAmount.add(disputedLiquidation.finalFee);\n\n        // Pay the final fee for requesting price from the DVM.\n        _payFinalFees(msg.sender, disputedLiquidation.finalFee);\n\n        // Transfer the dispute bond amount from the caller to this contract.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), disputeBondAmount.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Disputes a liquidation, if the caller has enough collateral to post a dispute bond",
            "     * and pay a fixed final fee charged on each price request.",
            "     * @dev Can only dispute a liquidation before the liquidation expires and if there are no other pending disputes.",
            "     * This contract must be approved to spend at least the dispute bond amount of `collateralCurrency`. This dispute",
            "     * bond amount is calculated from `disputeBondPercentage` times the collateral in the liquidation.",
            "     * @param liquidationId of the disputed liquidation.",
            "     * @param sponsor the address of the sponsor whose liquidation is being disputed.",
            "     * @return totalPaid amount of collateral charged to disputer (i.e. final fee bond + dispute bond).",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Disputes a liquidation, if the caller has enough collateral to post a dispute bond\n     * and pay a fixed final fee charged on each price request.\n     * @dev Can only dispute a liquidation before the liquidation expires and if there are no other pending disputes.\n     * This contract must be approved to spend at least the dispute bond amount of `collateralCurrency`. This dispute\n     * bond amount is calculated from `disputeBondPercentage` times the collateral in the liquidation.\n     * @param liquidationId of the disputed liquidation.\n     * @param sponsor the address of the sponsor whose liquidation is being disputed.\n     * @return totalPaid amount of collateral charged to disputer (i.e. final fee bond + dispute bond).\n     */\n",
        "@notice": "Disputes a liquidation, if the caller has enough collateral to post a dispute bond * and pay a fixed final fee charged on each price request.",
        "@dev": "Can only dispute a liquidation before the liquidation expires and if there are no other pending disputes. * This contract must be approved to spend at least the dispute bond amount of `collateralCurrency`. This dispute * bond amount is calculated from `disputeBondPercentage` times the collateral in the liquidation.",
        "@param1": "liquidationId of the disputed liquidation.",
        "@param2": "sponsor the address of the sponsor whose liquidation is being disputed.",
        "@return1": "totalPaid amount of collateral charged to disputer (i.e. final fee bond + dispute bond).",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawLiquidation",
        "visibility": "public",
        "args": [
            {
                "name": "liquidationId",
                "type": "uint256"
            },
            {
                "name": "sponsor",
                "type": "address"
            }
        ],
        "func": "function withdrawLiquidation(uint256 liquidationId, address sponsor)\n        public\n        withdrawable(liquidationId, sponsor)\n        fees()\n        nonReentrant()\n        returns (RewardsData memory)\n    {\n        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\n\n        // Settles the liquidation if necessary. This call will revert if the price has not resolved yet.\n        _settle(liquidationId, sponsor);\n\n        // Calculate rewards as a function of the TRV.\n        // Note: all payouts are scaled by the unit collateral value so all payouts are charged the fees pro rata.\n        FixedPoint.Unsigned memory feeAttenuation = _getFeeAdjustedCollateral(liquidation.rawUnitCollateral);\n        FixedPoint.Unsigned memory settlementPrice = liquidation.settlementPrice;\n        FixedPoint.Unsigned memory tokenRedemptionValue =\n            liquidation.tokensOutstanding.mul(settlementPrice).mul(feeAttenuation);\n        FixedPoint.Unsigned memory collateral = liquidation.lockedCollateral.mul(feeAttenuation);\n        FixedPoint.Unsigned memory disputerDisputeReward = disputerDisputeRewardPercentage.mul(tokenRedemptionValue);\n        FixedPoint.Unsigned memory sponsorDisputeReward = sponsorDisputeRewardPercentage.mul(tokenRedemptionValue);\n        FixedPoint.Unsigned memory disputeBondAmount = collateral.mul(disputeBondPercentage);\n        FixedPoint.Unsigned memory finalFee = liquidation.finalFee.mul(feeAttenuation);\n\n        // There are three main outcome states: either the dispute succeeded, failed or was not updated.\n        // Based on the state, different parties of a liquidation receive different amounts.\n        // After assigning rewards based on the liquidation status, decrease the total collateral held in this contract\n        // by the amount to pay each party. The actual amounts withdrawn might differ if _removeCollateral causes\n        // precision loss.\n        RewardsData memory rewards;\n        if (liquidation.state == Status.DisputeSucceeded) {\n            // If the dispute is successful then all three users should receive rewards:\n\n            // Pay DISPUTER: disputer reward + dispute bond + returned final fee\n            rewards.payToDisputer = disputerDisputeReward.add(disputeBondAmount).add(finalFee);\n\n            // Pay SPONSOR: remaining collateral (collateral - TRV) + sponsor reward\n            rewards.payToSponsor = sponsorDisputeReward.add(collateral.sub(tokenRedemptionValue));\n\n            // Pay LIQUIDATOR: TRV - dispute reward - sponsor reward\n            // If TRV > Collateral, then subtract rewards from collateral\n            // NOTE: This should never be below zero since we prevent (sponsorDisputePct+disputerDisputePct) >= 0 in\n            // the constructor when these params are set.\n            rewards.payToLiquidator = tokenRedemptionValue.sub(sponsorDisputeReward).sub(disputerDisputeReward);\n\n            // Transfer rewards and debit collateral\n            rewards.paidToLiquidator = _removeCollateral(rawLiquidationCollateral, rewards.payToLiquidator);\n            rewards.paidToSponsor = _removeCollateral(rawLiquidationCollateral, rewards.payToSponsor);\n            rewards.paidToDisputer = _removeCollateral(rawLiquidationCollateral, rewards.payToDisputer);\n\n            collateralCurrency.safeTransfer(liquidation.disputer, rewards.paidToDisputer.rawValue);\n            collateralCurrency.safeTransfer(liquidation.liquidator, rewards.paidToLiquidator.rawValue);\n            collateralCurrency.safeTransfer(liquidation.sponsor, rewards.paidToSponsor.rawValue);\n\n            // In the case of a failed dispute only the liquidator can withdraw.\n        } else if (liquidation.state == Status.DisputeFailed) {\n            // Pay LIQUIDATOR: collateral + dispute bond + returned final fee\n            rewards.payToLiquidator = collateral.add(disputeBondAmount).add(finalFee);\n\n            // Transfer rewards and debit collateral\n            rewards.paidToLiquidator = _removeCollateral(rawLiquidationCollateral, rewards.payToLiquidator);\n\n            collateralCurrency.safeTransfer(liquidation.liquidator, rewards.paidToLiquidator.rawValue);\n\n            // If the state is pre-dispute but time has passed liveness then there was no dispute. We represent this\n            // state as a dispute failed and the liquidator can withdraw.\n        } else if (liquidation.state == Status.NotDisputed) {\n            // Pay LIQUIDATOR: collateral + returned final fee\n            rewards.payToLiquidator = collateral.add(finalFee);\n\n            // Transfer rewards and debit collateral\n            rewards.paidToLiquidator = _removeCollateral(rawLiquidationCollateral, rewards.payToLiquidator);\n\n            collateralCurrency.safeTransfer(liquidation.liquidator, rewards.paidToLiquidator.rawValue);\n        }\n\n        emit LiquidationWithdrawn(\n            msg.sender,\n            rewards.paidToLiquidator.rawValue,\n            rewards.paidToDisputer.rawValue,\n            rewards.paidToSponsor.rawValue,\n            liquidation.state,\n            settlementPrice.rawValue\n        );\n\n        // Free up space after collateral is withdrawn by removing the liquidation object from the array.\n        delete liquidations[sponsor][liquidationId];\n\n        return rewards;\n    }",
        "comments": [
            "/**",
            "     * @notice After a dispute has settled or after a non-disputed liquidation has expired,",
            "     * anyone can call this method to disperse payments to the sponsor, liquidator, and disdputer.",
            "     * @dev If the dispute SUCCEEDED: the sponsor, liquidator, and disputer are eligible for payment.",
            "     * If the dispute FAILED: only the liquidator can receive payment.",
            "     * This method will revert if rewards have already been dispersed.",
            "     * @param liquidationId uniquely identifies the sponsor's liquidation.",
            "     * @param sponsor address of the sponsor associated with the liquidation.",
            "     * @return data about rewards paid out.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice After a dispute has settled or after a non-disputed liquidation has expired,\n     * anyone can call this method to disperse payments to the sponsor, liquidator, and disdputer.\n     * @dev If the dispute SUCCEEDED: the sponsor, liquidator, and disputer are eligible for payment.\n     * If the dispute FAILED: only the liquidator can receive payment.\n     * This method will revert if rewards have already been dispersed.\n     * @param liquidationId uniquely identifies the sponsor's liquidation.\n     * @param sponsor address of the sponsor associated with the liquidation.\n     * @return data about rewards paid out.\n     */\n",
        "@notice": "After a dispute has settled or after a non-disputed liquidation has expired, * anyone can call this method to disperse payments to the sponsor, liquidator, and disdputer.",
        "@dev": "If the dispute SUCCEEDED: the sponsor, liquidator, and disputer are eligible for payment. * If the dispute FAILED: only the liquidator can receive payment. * This method will revert if rewards have already been dispersed.",
        "@param1": "liquidationId uniquely identifies the sponsor's liquidation.",
        "@param2": "sponsor address of the sponsor associated with the liquidation.",
        "@return1": "data about rewards paid out.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "getLiquidations",
        "visibility": "external",
        "args": [
            {
                "name": "sponsor",
                "type": "address"
            }
        ],
        "func": "function getLiquidations(address sponsor)\n        external\n        view\n        nonReentrantView()\n        returns (LiquidationData[] memory liquidationData)\n    {\n        return liquidations[sponsor];\n    }",
        "comments": [
            "/**",
            "     * @notice Gets all liquidation information for a given sponsor address.",
            "     * @param sponsor address of the position sponsor.",
            "     * @return liquidationData array of all liquidation information for the given sponsor address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets all liquidation information for a given sponsor address.\n     * @param sponsor address of the position sponsor.\n     * @return liquidationData array of all liquidation information for the given sponsor address.\n     */\n",
        "@notice": "Gets all liquidation information for a given sponsor address.",
        "@param1": "sponsor address of the position sponsor.",
        "@return1": "liquidationData array of all liquidation information for the given sponsor address.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transformCollateralRequirement",
        "visibility": "public",
        "args": [
            {
                "name": "price",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function transformCollateralRequirement(FixedPoint.Unsigned memory price)\n        public\n        view\n        nonReentrantView()\n        returns (FixedPoint.Unsigned memory)\n    {\n        return _transformCollateralRequirement(price);\n    }",
        "comments": [
            "/**",
            "     * @notice Accessor method to calculate a transformed collateral requirement using the finanical product library",
            "      specified during contract deployment. If no library was provided then no modification to the collateral requirement is done.",
            "     * @param price input price used as an input to transform the collateral requirement.",
            "     * @return transformedCollateralRequirement collateral requirement with transformation applied to it.",
            "     * @dev This method should never revert.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Accessor method to calculate a transformed collateral requirement using the finanical product library\n      specified during contract deployment. If no library was provided then no modification to the collateral requirement is done.\n     * @param price input price used as an input to transform the collateral requirement.\n     * @return transformedCollateralRequirement collateral requirement with transformation applied to it.\n     * @dev This method should never revert.\n     */\n",
        "@notice": "Accessor method to calculate a transformed collateral requirement using the finanical product library specified during contract deployment. If no library was provided then no modification to the collateral requirement is done.",
        "@param1": "price input price used as an input to transform the collateral requirement.",
        "@return1": "transformedCollateralRequirement collateral requirement with transformation applied to it.",
        "@dev": "This method should never revert.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "calculateEffectiveFundingRate",
        "visibility": "public",
        "args": [
            {
                "name": "paymentPeriodSeconds",
                "type": "uint256"
            },
            {
                "name": "fundingRatePerSecond",
                "type": "FixedPoint.Signed memory"
            },
            {
                "name": "currentCumulativeFundingRateMultiplier",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function calculateEffectiveFundingRate(\n        uint256 paymentPeriodSeconds,\n        FixedPoint.Signed memory fundingRatePerSecond,\n        FixedPoint.Unsigned memory currentCumulativeFundingRateMultiplier\n    ) public pure returns (FixedPoint.Unsigned memory) {\n        return\n            _calculateEffectiveFundingRate(\n                paymentPeriodSeconds,\n                fundingRatePerSecond,\n                currentCumulativeFundingRateMultiplier\n            );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "emergencyShutdown",
        "visibility": "external",
        "args": [],
        "func": "function emergencyShutdown() external override {}",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "remargin",
        "visibility": "external",
        "args": [],
        "func": "function remargin() external override {}",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "migrateTokens",
        "visibility": "external",
        "args": [
            {
                "name": "tokenHolder",
                "type": "address"
            }
        ],
        "func": "function migrateTokens(address tokenHolder) external {\n        require(!hasMigrated[tokenHolder], \"Already migrated tokens\");\n        hasMigrated[tokenHolder] = true;\n\n        FixedPoint.Unsigned memory oldBalance = FixedPoint.Unsigned(oldToken.balanceOfAt(tokenHolder, snapshotId));\n\n        if (!oldBalance.isGreaterThan(0)) {\n            return;\n        }\n\n        FixedPoint.Unsigned memory newBalance = oldBalance.div(rate);\n        require(newToken.mint(tokenHolder, newBalance.rawValue), \"Mint failed\");\n    }",
        "comments": [
            "/**",
            "     * @notice Migrates the tokenHolder's old tokens to new tokens.",
            "     * @dev This function can only be called once per `tokenHolder`. Anyone can call this method",
            "     * on behalf of any other token holder since there is no disadvantage to receiving the tokens earlier.",
            "     * @param tokenHolder address of the token holder to migrate.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Migrates the tokenHolder's old tokens to new tokens.\n     * @dev This function can only be called once per `tokenHolder`. Anyone can call this method\n     * on behalf of any other token holder since there is no disadvantage to receiving the tokens earlier.\n     * @param tokenHolder address of the token holder to migrate.\n     */\n",
        "@notice": "Migrates the tokenHolder's old tokens to new tokens.",
        "@dev": "This function can only be called once per `tokenHolder`. Anyone can call this method * on behalf of any other token holder since there is no disadvantage to receiving the tokens earlier.",
        "@param1": "tokenHolder address of the token holder to migrate.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setFinancialProductStrike",
        "visibility": "public",
        "args": [
            {
                "name": "financialProduct",
                "type": "address"
            },
            {
                "name": "strikePrice",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function setFinancialProductStrike(address financialProduct, FixedPoint.Unsigned memory strikePrice)\n        public\n        onlyOwner\n        nonReentrant()\n    {\n        require(strikePrice.isGreaterThan(0), \"Cant set 0 strike\");\n        require(financialProductStrikes[financialProduct].isEqual(0), \"Strike already set\");\n        require(ExpiringContractInterface(financialProduct).expirationTimestamp() != 0, \"Invalid EMP contract\");\n        financialProductStrikes[financialProduct] = strikePrice;\n    }",
        "comments": [
            "/**",
            "     * @notice Enables the deployer of the library to set the strike price for an associated financial product.",
            "     * @param financialProduct address of the financial product.",
            "     * @param strikePrice the strike price for the structured note to be applied to the financial product.",
            "     * @dev Note: a) Only the owner (deployer) of this library can set new strike prices b) A strike price cannot be 0.",
            "     * c) A strike price can only be set once to prevent the deployer from changing the strike after the fact.",
            "     * d)  financialProduct must exposes an expirationTimestamp method.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Enables the deployer of the library to set the strike price for an associated financial product.\n     * @param financialProduct address of the financial product.\n     * @param strikePrice the strike price for the structured note to be applied to the financial product.\n     * @dev Note: a) Only the owner (deployer) of this library can set new strike prices b) A strike price cannot be 0.\n     * c) A strike price can only be set once to prevent the deployer from changing the strike after the fact.\n     * d)  financialProduct must exposes an expirationTimestamp method.\n     */\n",
        "@notice": "Enables the deployer of the library to set the strike price for an associated financial product.",
        "@param1": "financialProduct address of the financial product.",
        "@param2": "strikePrice the strike price for the structured note to be applied to the financial product.",
        "@dev": "Note: a) Only the owner (deployer) of this library can set new strike prices b) A strike price cannot be 0. * c) A strike price can only be set once to prevent the deployer from changing the strike after the fact. * d) financialProduct must exposes an expirationTimestamp method.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getStrikeForFinancialProduct",
        "visibility": "public",
        "args": [
            {
                "name": "financialProduct",
                "type": "address"
            }
        ],
        "func": "function getStrikeForFinancialProduct(address financialProduct)\n        public\n        view\n        nonReentrantView()\n        returns (FixedPoint.Unsigned memory)\n    {\n        return financialProductStrikes[financialProduct];\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the strike price associated with a given financial product address.",
            "     * @param financialProduct address of the financial product.",
            "     * @return strikePrice for the associated financial product.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the strike price associated with a given financial product address.\n     * @param financialProduct address of the financial product.\n     * @return strikePrice for the associated financial product.\n     */\n",
        "@notice": "Returns the strike price associated with a given financial product address.",
        "@param1": "financialProduct address of the financial product.",
        "@return1": "strikePrice for the associated financial product.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transformPrice",
        "visibility": "public",
        "args": [
            {
                "name": "oraclePrice",
                "type": "FixedPoint.Unsigned memory"
            },
            {
                "name": "requestTime",
                "type": "uint256"
            }
        ],
        "func": "function transformPrice(FixedPoint.Unsigned memory oraclePrice, uint256 requestTime)\n        public\n        view\n        override\n        nonReentrantView()\n        returns (FixedPoint.Unsigned memory)\n    {\n        FixedPoint.Unsigned memory strike = financialProductStrikes[msg.sender];\n        require(strike.isGreaterThan(0), \"Caller has no strike\");\n        // If price request is made before expiry, return 1. Thus we can keep the contract 100% collateralized with\n        // each token backed 1:1 by collateral currency.\n        if (requestTime < ExpiringContractInterface(msg.sender).expirationTimestamp()) {\n            return FixedPoint.fromUnscaledUint(1);\n        }\n        if (oraclePrice.isLessThan(strike)) {\n            return FixedPoint.fromUnscaledUint(1);\n        } else {\n            // Token expires to be worth strike $ worth of collateral.\n            // eg if ETHUSD is $500 and strike is $400, token is redeemable for 400/500 = 0.8 WETH.\n            return strike.div(oraclePrice);\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Returns a transformed price by applying the structured note payout structure.",
            "     * @param oraclePrice price from the oracle to be transformed.",
            "     * @param requestTime timestamp the oraclePrice was requested at.",
            "     * @return transformedPrice the input oracle price with the price transformation logic applied to it.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns a transformed price by applying the structured note payout structure.\n     * @param oraclePrice price from the oracle to be transformed.\n     * @param requestTime timestamp the oraclePrice was requested at.\n     * @return transformedPrice the input oracle price with the price transformation logic applied to it.\n     */\n",
        "@notice": "Returns a transformed price by applying the structured note payout structure.",
        "@param1": "oraclePrice price from the oracle to be transformed.",
        "@param2": "requestTime timestamp the oraclePrice was requested at.",
        "@return1": "transformedPrice the input oracle price with the price transformation logic applied to it.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transformCollateralRequirement",
        "visibility": "public",
        "args": [
            {
                "name": "oraclePrice",
                "type": "FixedPoint.Unsigned memory"
            },
            {
                "name": "collateralRequirement",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function transformCollateralRequirement(\n        FixedPoint.Unsigned memory oraclePrice,\n        FixedPoint.Unsigned memory collateralRequirement\n    ) public view override nonReentrantView() returns (FixedPoint.Unsigned memory) {\n        FixedPoint.Unsigned memory strike = financialProductStrikes[msg.sender];\n        require(strike.isGreaterThan(0), \"Caller has no strike\");\n        // If the price is less than the strike than the original collateral requirement is used.\n        if (oraclePrice.isLessThan(strike)) {\n            return collateralRequirement;\n        } else {\n            // If the price is more than the strike then the collateral requirement is scaled by the strike. For example\n            // a strike of $400 and a CR of 1.2 would yield:\n            // ETHUSD = $350, payout is 1 WETH. CR is multiplied by 1. resulting CR = 1.2\n            // ETHUSD = $400, payout is 1 WETH. CR is multiplied by 1. resulting CR = 1.2\n            // ETHUSD = $425, payout is 0.941 WETH (worth $400). CR is multiplied by 0.941. resulting CR = 1.1292\n            // ETHUSD = $500, payout is 0.8 WETH (worth $400). CR multiplied by 0.8. resulting CR = 0.96\n            return collateralRequirement.mul(strike.div(oraclePrice));\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Returns a transformed collateral requirement by applying the structured note payout structure. If the price",
            "     * of the structured note is greater than the strike then the collateral requirement scales down accordingly.",
            "     * @param oraclePrice price from the oracle to transform the collateral requirement.",
            "     * @param collateralRequirement financial products collateral requirement to be scaled according to price and strike.",
            "     * @return transformedCollateralRequirement the input collateral requirement with the transformation logic applied to it.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns a transformed collateral requirement by applying the structured note payout structure. If the price\n     * of the structured note is greater than the strike then the collateral requirement scales down accordingly.\n     * @param oraclePrice price from the oracle to transform the collateral requirement.\n     * @param collateralRequirement financial products collateral requirement to be scaled according to price and strike.\n     * @return transformedCollateralRequirement the input collateral requirement with the transformation logic applied to it.\n     */\n",
        "@notice": "Returns a transformed collateral requirement by applying the structured note payout structure. If the price * of the structured note is greater than the strike then the collateral requirement scales down accordingly.",
        "@param1": "oraclePrice price from the oracle to transform the collateral requirement.",
        "@param2": "collateralRequirement financial products collateral requirement to be scaled according to price and strike.",
        "@return1": "transformedCollateralRequirement the input collateral requirement with the transformation logic applied to it.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setFinancialProductTransformedIdentifier",
        "visibility": "public",
        "args": [
            {
                "name": "financialProduct",
                "type": "address"
            },
            {
                "name": "transformedIdentifier",
                "type": "bytes32"
            }
        ],
        "func": "function setFinancialProductTransformedIdentifier(address financialProduct, bytes32 transformedIdentifier)\n        public\n        onlyOwner\n        nonReentrant()\n    {\n        require(transformedIdentifier != \"\", \"Cant set to empty transformation\");\n        require(financialProductTransformedIdentifiers[financialProduct] == \"\", \"Transformation already set\");\n        require(ExpiringContractInterface(financialProduct).expirationTimestamp() != 0, \"Invalid EMP contract\");\n        financialProductTransformedIdentifiers[financialProduct] = transformedIdentifier;\n    }",
        "comments": [
            "/**",
            "     * @notice Enables the deployer of the library to set the transformed identifier for an associated financial product.",
            "     * @param financialProduct address of the financial product.",
            "     * @param transformedIdentifier the identifier for the financial product to be used if the contract is post expiration.",
            "     * @dev Note: a) Only the owner (deployer) of this library can set identifier transformations b) The identifier can't",
            "     * be set to blank. c) A transformed price can only be set once to prevent the deployer from changing it after the fact.",
            "     * d)  financialProduct must expose an expirationTimestamp method.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Enables the deployer of the library to set the transformed identifier for an associated financial product.\n     * @param financialProduct address of the financial product.\n     * @param transformedIdentifier the identifier for the financial product to be used if the contract is post expiration.\n     * @dev Note: a) Only the owner (deployer) of this library can set identifier transformations b) The identifier can't\n     * be set to blank. c) A transformed price can only be set once to prevent the deployer from changing it after the fact.\n     * d)  financialProduct must expose an expirationTimestamp method.\n     */\n",
        "@notice": "Enables the deployer of the library to set the transformed identifier for an associated financial product.",
        "@param1": "financialProduct address of the financial product.",
        "@param2": "transformedIdentifier the identifier for the financial product to be used if the contract is post expiration.",
        "@dev": "Note: a) Only the owner (deployer) of this library can set identifier transformations b) The identifier can't * be set to blank. c) A transformed price can only be set once to prevent the deployer from changing it after the fact. * d) financialProduct must expose an expirationTimestamp method.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getTransformedIdentifierForFinancialProduct",
        "visibility": "public",
        "args": [
            {
                "name": "financialProduct",
                "type": "address"
            }
        ],
        "func": "function getTransformedIdentifierForFinancialProduct(address financialProduct)\n        public\n        view\n        nonReentrantView()\n        returns (bytes32)\n    {\n        return financialProductTransformedIdentifiers[financialProduct];\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the transformed identifier associated with a given financial product address.",
            "     * @param financialProduct address of the financial product.",
            "     * @return transformed identifier for the associated financial product.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the transformed identifier associated with a given financial product address.\n     * @param financialProduct address of the financial product.\n     * @return transformed identifier for the associated financial product.\n     */\n",
        "@notice": "Returns the transformed identifier associated with a given financial product address.",
        "@param1": "financialProduct address of the financial product.",
        "@return1": "transformed identifier for the associated financial product.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transformPriceIdentifier",
        "visibility": "public",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "requestTime",
                "type": "uint256"
            }
        ],
        "func": "function transformPriceIdentifier(bytes32 identifier, uint256 requestTime)\n        public\n        view\n        override\n        nonReentrantView()\n        returns (bytes32)\n    {\n        require(financialProductTransformedIdentifiers[msg.sender] != \"\", \"Caller has no transformation\");\n        // If the request time is before contract expiration then return the transformed identifier. Else, return the\n        // original price identifier.\n        if (requestTime < ExpiringContractInterface(msg.sender).expirationTimestamp()) {\n            return financialProductTransformedIdentifiers[msg.sender];\n        } else {\n            return identifier;\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Returns a transformed price identifier if the contract is pre-expiration and no transformation if post.",
            "     * @param identifier input price identifier to be transformed.",
            "     * @param requestTime timestamp the identifier is to be used at.",
            "     * @return transformedPriceIdentifier the input price identifier with the transformation logic applied to it.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns a transformed price identifier if the contract is pre-expiration and no transformation if post.\n     * @param identifier input price identifier to be transformed.\n     * @param requestTime timestamp the identifier is to be used at.\n     * @return transformedPriceIdentifier the input price identifier with the transformation logic applied to it.\n     */\n",
        "@notice": "Returns a transformed price identifier if the contract is pre-expiration and no transformation if post.",
        "@param1": "identifier input price identifier to be transformed.",
        "@param2": "requestTime timestamp the identifier is to be used at.",
        "@return1": "transformedPriceIdentifier the input price identifier with the transformation logic applied to it.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "callback",
        "visibility": "external",
        "args": [],
        "func": "function callback() external nonReentrant {\n        _count();\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "countAndSend",
        "visibility": "external",
        "args": [
            {
                "name": "attacker",
                "type": "ReentrancyAttack"
            }
        ],
        "func": "function countAndSend(ReentrancyAttack attacker) external nonReentrant {\n        _count();\n        bytes4 func = bytes4(keccak256(\"callback()\"));\n        attacker.callSender(func);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "countAndCall",
        "visibility": "external",
        "args": [
            {
                "name": "attacker",
                "type": "ReentrancyAttack"
            }
        ],
        "func": "function countAndCall(ReentrancyAttack attacker) external nonReentrant {\n        _count();\n        bytes4 func = bytes4(keccak256(\"getCount()\"));\n        attacker.callSender(func);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "countLocalRecursive",
        "visibility": "public",
        "args": [
            {
                "name": "n",
                "type": "uint256"
            }
        ],
        "func": "function countLocalRecursive(uint256 n) public nonReentrant {\n        if (n > 0) {\n            _count();\n            countLocalRecursive(n - 1);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "countThisRecursive",
        "visibility": "public",
        "args": [
            {
                "name": "n",
                "type": "uint256"
            }
        ],
        "func": "function countThisRecursive(uint256 n) public nonReentrant {\n        if (n > 0) {\n            _count();\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = address(this).call(abi.encodeWithSignature(\"countThisRecursive(uint256)\", n - 1));\n            require(success, \"ReentrancyMock: failed call\");\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "countLocalCall",
        "visibility": "public",
        "args": [],
        "func": "function countLocalCall() public nonReentrant {\n        getCount();\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "countThisCall",
        "visibility": "public",
        "args": [],
        "func": "function countThisCall() public nonReentrant {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = address(this).call(abi.encodeWithSignature(\"getCount()\"));\n        require(success, \"ReentrancyMock: failed call\");\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCount",
        "visibility": "public",
        "args": [],
        "func": "function getCount() public view nonReentrantView returns (uint256) {\n        return counter;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "callSender",
        "visibility": "public",
        "args": [
            {
                "name": "data",
                "type": "bytes4"
            }
        ],
        "func": "function callSender(bytes4 data) public {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = msg.sender.call(abi.encodeWithSelector(data));\n        require(success, \"ReentrancyAttack: failed call\");\n    }",
        "comments": [
            "",
            "// Tests reentrancy guards defined in Lockable.sol.",
            "// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.1/contracts/mocks/ReentrancyAttack.sol.",
            "contract ReentrancyAttack {",
            "    "
        ],
        "comt": "\n// Tests reentrancy guards defined in Lockable.sol.\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.1/contracts/mocks/ReentrancyAttack.sol.\ncontract ReentrancyAttack {\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapComputeCurrentRoundId",
        "visibility": "external",
        "args": [
            {
                "name": "currentTime",
                "type": "uint256"
            }
        ],
        "func": "function wrapComputeCurrentRoundId(uint256 currentTime) external view returns (uint256) {\n        return voteTiming.computeCurrentRoundId(currentTime);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapComputeCurrentPhase",
        "visibility": "external",
        "args": [
            {
                "name": "currentTime",
                "type": "uint256"
            }
        ],
        "func": "function wrapComputeCurrentPhase(uint256 currentTime) external view returns (VotingAncillaryInterface.Phase) {\n        return voteTiming.computeCurrentPhase(currentTime);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapInit",
        "visibility": "public",
        "args": [
            {
                "name": "phaseLength",
                "type": "uint256"
            }
        ],
        "func": "function wrapInit(uint256 phaseLength) public {\n        voteTiming.init(phaseLength);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createSharedRole",
        "visibility": "external",
        "args": [
            {
                "name": "roleId",
                "type": "uint256"
            },
            {
                "name": "managingRoleId",
                "type": "uint256"
            },
            {
                "name": "initialMembers",
                "type": "address[] calldata"
            }
        ],
        "func": "function createSharedRole(\n        uint256 roleId,\n        uint256 managingRoleId,\n        address[] calldata initialMembers\n    ) external {\n        _createSharedRole(roleId, managingRoleId, initialMembers);\n    }",
        "comments": [
            "",
            "// The purpose of this contract is to make the MultiRole creation methods externally callable for testing purposes.",
            "contract MultiRoleTest is MultiRole {",
            "    "
        ],
        "comt": "\n// The purpose of this contract is to make the MultiRole creation methods externally callable for testing purposes.\ncontract MultiRoleTest is MultiRole {\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createExclusiveRole",
        "visibility": "external",
        "args": [
            {
                "name": "roleId",
                "type": "uint256"
            },
            {
                "name": "managingRoleId",
                "type": "uint256"
            },
            {
                "name": "initialMember",
                "type": "address"
            }
        ],
        "func": "function createExclusiveRole(\n        uint256 roleId,\n        uint256 managingRoleId,\n        address initialMember\n    ) external {\n        _createExclusiveRole(roleId, managingRoleId, initialMember);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "revertIfNotHoldingRole",
        "visibility": "external",
        "args": [
            {
                "name": "roleId",
                "type": "uint256"
            }
        ],
        "func": "function revertIfNotHoldingRole(uint256 roleId) external view onlyRoleHolder(roleId) {}",
        "comments": [
            "",
            "    // solhint-disable-next-line no-empty-blocks",
            "    "
        ],
        "comt": "\n    // solhint-disable-next-line no-empty-blocks\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getTestableTimeAndBlockTime",
        "visibility": "external",
        "args": [],
        "func": "function getTestableTimeAndBlockTime() external view returns (uint256 testableTime, uint256 blockTime) {\n        // solhint-disable-next-line not-rely-on-time\n        return (getCurrentTime(), now);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapAddVote",
        "visibility": "external",
        "args": [
            {
                "name": "votePrice",
                "type": "int256"
            },
            {
                "name": "numberTokens",
                "type": "uint256"
            }
        ],
        "func": "function wrapAddVote(int256 votePrice, uint256 numberTokens) external {\n        data.addVote(votePrice, FixedPoint.Unsigned(numberTokens));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapGetResolvedPrice",
        "visibility": "external",
        "args": [
            {
                "name": "minVoteThreshold",
                "type": "uint256"
            }
        ],
        "func": "function wrapGetResolvedPrice(uint256 minVoteThreshold) external view returns (bool isResolved, int256 price) {\n        return data.getResolvedPrice(FixedPoint.Unsigned(minVoteThreshold));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapWasVoteCorrect",
        "visibility": "external",
        "args": [
            {
                "name": "revealHash",
                "type": "bytes32"
            }
        ],
        "func": "function wrapWasVoteCorrect(bytes32 revealHash) external view returns (bool) {\n        return data.wasVoteCorrect(revealHash);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapGetTotalCorrectlyVotedTokens",
        "visibility": "external",
        "args": [],
        "func": "function wrapGetTotalCorrectlyVotedTokens() external view returns (uint256) {\n        return data.getTotalCorrectlyVotedTokens().rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPendingPriceRequestsArray",
        "visibility": "external",
        "args": [],
        "func": "function getPendingPriceRequestsArray() external view returns (bytes32[] memory) {\n        return pendingPriceRequests;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapFromUnscaledUint",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            }
        ],
        "func": "function wrapFromUnscaledUint(uint256 a) external pure returns (uint256) {\n        return FixedPoint.fromUnscaledUint(a).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapIsEqual",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapIsEqual(uint256 a, uint256 b) external pure returns (bool) {\n        return FixedPoint.Unsigned(a).isEqual(FixedPoint.Unsigned(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsEqual",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedIsEqual(uint256 a, uint256 b) external pure returns (bool) {\n        return FixedPoint.Unsigned(a).isEqual(b);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapIsGreaterThan",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapIsGreaterThan(uint256 a, uint256 b) external pure returns (bool) {\n        return FixedPoint.Unsigned(a).isGreaterThan(FixedPoint.Unsigned(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapIsGreaterThanOrEqual",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapIsGreaterThanOrEqual(uint256 a, uint256 b) external pure returns (bool) {\n        return FixedPoint.Unsigned(a).isGreaterThanOrEqual(FixedPoint.Unsigned(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsGreaterThan",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedIsGreaterThan(uint256 a, uint256 b) external pure returns (bool) {\n        return FixedPoint.Unsigned(a).isGreaterThan(b);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsGreaterThanOrEqual",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedIsGreaterThanOrEqual(uint256 a, uint256 b) external pure returns (bool) {\n        return FixedPoint.Unsigned(a).isGreaterThanOrEqual(b);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsGreaterThanOpposite",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedIsGreaterThanOpposite(uint256 a, uint256 b) external pure returns (bool) {\n        return a.isGreaterThan(FixedPoint.Unsigned(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsGreaterThanOrEqualOpposite",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedIsGreaterThanOrEqualOpposite(uint256 a, uint256 b) external pure returns (bool) {\n        return a.isGreaterThanOrEqual(FixedPoint.Unsigned(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapIsLessThan",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapIsLessThan(uint256 a, uint256 b) external pure returns (bool) {\n        return FixedPoint.Unsigned(a).isLessThan(FixedPoint.Unsigned(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapIsLessThanOrEqual",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapIsLessThanOrEqual(uint256 a, uint256 b) external pure returns (bool) {\n        return FixedPoint.Unsigned(a).isLessThanOrEqual(FixedPoint.Unsigned(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsLessThan",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedIsLessThan(uint256 a, uint256 b) external pure returns (bool) {\n        return FixedPoint.Unsigned(a).isLessThan(b);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsLessThanOrEqual",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedIsLessThanOrEqual(uint256 a, uint256 b) external pure returns (bool) {\n        return FixedPoint.Unsigned(a).isLessThanOrEqual(b);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsLessThanOpposite",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedIsLessThanOpposite(uint256 a, uint256 b) external pure returns (bool) {\n        return a.isLessThan(FixedPoint.Unsigned(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsLessThanOrEqualOpposite",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedIsLessThanOrEqualOpposite(uint256 a, uint256 b) external pure returns (bool) {\n        return a.isLessThanOrEqual(FixedPoint.Unsigned(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMin",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMin(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).min(FixedPoint.Unsigned(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMax",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMax(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).max(FixedPoint.Unsigned(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapAdd",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapAdd(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).add(FixedPoint.Unsigned(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedAdd",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedAdd(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).add(b).rawValue;\n    }",
        "comments": [
            "",
            "    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.",
            "    "
        ],
        "comt": "\n    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapSub",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapSub(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).sub(FixedPoint.Unsigned(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedSub",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedSub(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).sub(b).rawValue;\n    }",
        "comments": [
            "",
            "    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.",
            "    "
        ],
        "comt": "\n    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedSubOpposite",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedSubOpposite(uint256 a, uint256 b) external pure returns (uint256) {\n        return a.sub(FixedPoint.Unsigned(b)).rawValue;\n    }",
        "comments": [
            "",
            "    // The second uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.",
            "    "
        ],
        "comt": "\n    // The second uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMul",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMul(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).mul(FixedPoint.Unsigned(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMulCeil",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMulCeil(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).mulCeil(FixedPoint.Unsigned(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedMul",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedMul(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).mul(b).rawValue;\n    }",
        "comments": [
            "",
            "    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.",
            "    "
        ],
        "comt": "\n    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedMulCeil",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedMulCeil(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).mulCeil(b).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapDiv",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapDiv(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).div(FixedPoint.Unsigned(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapDivCeil",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapDivCeil(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).divCeil(FixedPoint.Unsigned(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedDiv",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedDiv(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).div(b).rawValue;\n    }",
        "comments": [
            "",
            "    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.",
            "    "
        ],
        "comt": "\n    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedDivCeil",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedDivCeil(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).divCeil(b).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedDivOpposite",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedDivOpposite(uint256 a, uint256 b) external pure returns (uint256) {\n        return a.div(FixedPoint.Unsigned(b)).rawValue;\n    }",
        "comments": [
            "",
            "    // The second uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.",
            "    "
        ],
        "comt": "\n    // The second uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapPow",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapPow(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).pow(b).rawValue;\n    }",
        "comments": [
            "",
            "    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.",
            "    "
        ],
        "comt": "\n    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapFromSigned",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            }
        ],
        "func": "function wrapFromSigned(int256 a) external pure returns (uint256) {\n        return FixedPoint.fromSigned(FixedPoint.Signed(a)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapFromUnsigned",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            }
        ],
        "func": "function wrapFromUnsigned(uint256 a) external pure returns (int256) {\n        return FixedPoint.fromUnsigned(FixedPoint.Unsigned(a)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapFromUnscaledInt",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            }
        ],
        "func": "function wrapFromUnscaledInt(int256 a) external pure returns (int256) {\n        return FixedPoint.fromUnscaledInt(a).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapIsEqual",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapIsEqual(int256 a, int256 b) external pure returns (bool) {\n        return FixedPoint.Signed(a).isEqual(FixedPoint.Signed(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsEqual",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapMixedIsEqual(int256 a, int256 b) external pure returns (bool) {\n        return FixedPoint.Signed(a).isEqual(b);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapIsGreaterThan",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapIsGreaterThan(int256 a, int256 b) external pure returns (bool) {\n        return FixedPoint.Signed(a).isGreaterThan(FixedPoint.Signed(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapIsGreaterThanOrEqual",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapIsGreaterThanOrEqual(int256 a, int256 b) external pure returns (bool) {\n        return FixedPoint.Signed(a).isGreaterThanOrEqual(FixedPoint.Signed(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsGreaterThan",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapMixedIsGreaterThan(int256 a, int256 b) external pure returns (bool) {\n        return FixedPoint.Signed(a).isGreaterThan(b);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsGreaterThanOrEqual",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapMixedIsGreaterThanOrEqual(int256 a, int256 b) external pure returns (bool) {\n        return FixedPoint.Signed(a).isGreaterThanOrEqual(b);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsGreaterThanOpposite",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapMixedIsGreaterThanOpposite(int256 a, int256 b) external pure returns (bool) {\n        return a.isGreaterThan(FixedPoint.Signed(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsGreaterThanOrEqualOpposite",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapMixedIsGreaterThanOrEqualOpposite(int256 a, int256 b) external pure returns (bool) {\n        return a.isGreaterThanOrEqual(FixedPoint.Signed(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapIsLessThan",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapIsLessThan(int256 a, int256 b) external pure returns (bool) {\n        return FixedPoint.Signed(a).isLessThan(FixedPoint.Signed(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapIsLessThanOrEqual",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapIsLessThanOrEqual(int256 a, int256 b) external pure returns (bool) {\n        return FixedPoint.Signed(a).isLessThanOrEqual(FixedPoint.Signed(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsLessThan",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapMixedIsLessThan(int256 a, int256 b) external pure returns (bool) {\n        return FixedPoint.Signed(a).isLessThan(b);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsLessThanOrEqual",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapMixedIsLessThanOrEqual(int256 a, int256 b) external pure returns (bool) {\n        return FixedPoint.Signed(a).isLessThanOrEqual(b);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsLessThanOpposite",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapMixedIsLessThanOpposite(int256 a, int256 b) external pure returns (bool) {\n        return a.isLessThan(FixedPoint.Signed(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsLessThanOrEqualOpposite",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapMixedIsLessThanOrEqualOpposite(int256 a, int256 b) external pure returns (bool) {\n        return a.isLessThanOrEqual(FixedPoint.Signed(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMin",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapMin(int256 a, int256 b) external pure returns (int256) {\n        return FixedPoint.Signed(a).min(FixedPoint.Signed(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMax",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapMax(int256 a, int256 b) external pure returns (int256) {\n        return FixedPoint.Signed(a).max(FixedPoint.Signed(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapAdd",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapAdd(int256 a, int256 b) external pure returns (int256) {\n        return FixedPoint.Signed(a).add(FixedPoint.Signed(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedAdd",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapMixedAdd(int256 a, int256 b) external pure returns (int256) {\n        return FixedPoint.Signed(a).add(b).rawValue;\n    }",
        "comments": [
            "",
            "    // The first int256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.",
            "    "
        ],
        "comt": "\n    // The first int256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapSub",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapSub(int256 a, int256 b) external pure returns (int256) {\n        return FixedPoint.Signed(a).sub(FixedPoint.Signed(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedSub",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapMixedSub(int256 a, int256 b) external pure returns (int256) {\n        return FixedPoint.Signed(a).sub(b).rawValue;\n    }",
        "comments": [
            "",
            "    // The first int256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.",
            "    "
        ],
        "comt": "\n    // The first int256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedSubOpposite",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapMixedSubOpposite(int256 a, int256 b) external pure returns (int256) {\n        return a.sub(FixedPoint.Signed(b)).rawValue;\n    }",
        "comments": [
            "",
            "    // The second int256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.",
            "    "
        ],
        "comt": "\n    // The second int256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMul",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapMul(int256 a, int256 b) external pure returns (int256) {\n        return FixedPoint.Signed(a).mul(FixedPoint.Signed(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMulAwayFromZero",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapMulAwayFromZero(int256 a, int256 b) external pure returns (int256) {\n        return FixedPoint.Signed(a).mulAwayFromZero(FixedPoint.Signed(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedMul",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapMixedMul(int256 a, int256 b) external pure returns (int256) {\n        return FixedPoint.Signed(a).mul(b).rawValue;\n    }",
        "comments": [
            "",
            "    // The first int256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.",
            "    "
        ],
        "comt": "\n    // The first int256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedMulAwayFromZero",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapMixedMulAwayFromZero(int256 a, int256 b) external pure returns (int256) {\n        return FixedPoint.Signed(a).mulAwayFromZero(b).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapDiv",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapDiv(int256 a, int256 b) external pure returns (int256) {\n        return FixedPoint.Signed(a).div(FixedPoint.Signed(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapDivAwayFromZero",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapDivAwayFromZero(int256 a, int256 b) external pure returns (int256) {\n        return FixedPoint.Signed(a).divAwayFromZero(FixedPoint.Signed(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedDiv",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapMixedDiv(int256 a, int256 b) external pure returns (int256) {\n        return FixedPoint.Signed(a).div(b).rawValue;\n    }",
        "comments": [
            "",
            "    // The first int256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.",
            "    "
        ],
        "comt": "\n    // The first int256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedDivAwayFromZero",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapMixedDivAwayFromZero(int256 a, int256 b) external pure returns (int256) {\n        return FixedPoint.Signed(a).divAwayFromZero(b).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedDivOpposite",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "int256"
            }
        ],
        "func": "function wrapMixedDivOpposite(int256 a, int256 b) external pure returns (int256) {\n        return a.div(FixedPoint.Signed(b)).rawValue;\n    }",
        "comments": [
            "",
            "    // The second int256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.",
            "    "
        ],
        "comt": "\n    // The second int256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapPow",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "int256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapPow(int256 a, uint256 b) external pure returns (int256) {\n        return FixedPoint.Signed(a).pow(b).rawValue;\n    }",
        "comments": [
            "",
            "    // The first int256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.",
            "    "
        ],
        "comt": "\n    // The first int256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setPrice",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "price",
                "type": "uint256"
            }
        ],
        "func": "function setPrice(\n        address from,\n        address to,\n        uint256 price\n    ) external {\n        prices[keccak256(abi.encodePacked(from, to))] = price;\n    }",
        "comments": [
            "",
            "    // Sets price of 1 FROM = <PRICE> TO",
            "    "
        ],
        "comt": "\n    // Sets price of 1 FROM = <PRICE> TO\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getExpectedReturn",
        "visibility": "public",
        "args": [
            {
                "name": "fromToken",
                "type": "address"
            },
            {
                "name": "destToken",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            },
            {
                "name": "parts",
                "type": "uint256"
            },
            {
                "name": "IOneSplit.sol",
                "type": "uint256 flags // See constants in"
            }
        ],
        "func": "function getExpectedReturn(\n        address fromToken,\n        address destToken,\n        uint256 amount,\n        uint256 parts,\n        uint256 flags // See constants in IOneSplit.sol\n    ) public view override returns (uint256 returnAmount, uint256[] memory distribution) {\n        returnAmount = prices[keccak256(abi.encodePacked(fromToken, destToken))] * amount;\n\n        return (returnAmount, distribution);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swap",
        "visibility": "public",
        "args": [
            {
                "name": "fromToken",
                "type": "address"
            },
            {
                "name": "destToken",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            },
            {
                "name": "minReturn",
                "type": "uint256"
            },
            {
                "name": "distribution",
                "type": "uint256[] memory"
            },
            {
                "name": "flags",
                "type": "uint256"
            }
        ],
        "func": "function swap(\n        address fromToken,\n        address destToken,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] memory distribution,\n        uint256 flags\n    ) public payable override returns (uint256 returnAmount) {\n        uint256 amountReturn = prices[keccak256(abi.encodePacked(fromToken, destToken))] * amount;\n\n        require(amountReturn >= minReturn, \"Min Amount not reached\");\n\n        if (destToken == ETH_ADDRESS) {\n            msg.sender.transfer(amountReturn);\n        } else {\n            require(IERC20(destToken).transfer(msg.sender, amountReturn), \"erc20-send-failed\");\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "_to",
                "type": "address"
            },
            {
                "name": "_value",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address _to, uint256 _value) public override returns (bool success) {\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "_from",
                "type": "address"
            },
            {
                "name": "_to",
                "type": "address"
            },
            {
                "name": "_value",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public override returns (bool success) {\n        uint256 allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && allowance >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "_owner",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address _owner) public view override returns (uint256 balance) {\n        return balances[_owner];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "_spender",
                "type": "address"
            },
            {
                "name": "_value",
                "type": "uint256"
            }
        ],
        "func": "function approve(address _spender, uint256 _value) public override returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allowance",
        "visibility": "public",
        "args": [
            {
                "name": "_owner",
                "type": "address"
            },
            {
                "name": "_spender",
                "type": "address"
            }
        ],
        "func": "function allowance(address _owner, address _spender) public view override returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    }
]