[
    {
        "transactions": 97114,
        "function_num": 207
    },
    {
        "name": "closeEvent",
        "visibility": "public",
        "args": [],
        "func": "function closeEvent() public {\n    emit RequestData(req.buf.buf);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setBuffer",
        "visibility": "public",
        "args": [
            {
                "name": "data",
                "type": "bytes memory"
            }
        ],
        "func": "function setBuffer(bytes memory data) public {\n    Chainlink.Request memory r2 = req;\n    r2.setBuffer(data);\n    req = r2;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "add",
        "visibility": "public",
        "args": [
            {
                "name": "_key",
                "type": "string memory"
            },
            {
                "name": "_value",
                "type": "string memory"
            }
        ],
        "func": "function add(string memory _key, string memory _value) public {\n    Chainlink.Request memory r2 = req;\n    r2.add(_key, _value);\n    req = r2;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addBytes",
        "visibility": "public",
        "args": [
            {
                "name": "_key",
                "type": "string memory"
            },
            {
                "name": "_value",
                "type": "bytes memory"
            }
        ],
        "func": "function addBytes(string memory _key, bytes memory _value) public {\n    Chainlink.Request memory r2 = req;\n    r2.addBytes(_key, _value);\n    req = r2;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addInt",
        "visibility": "public",
        "args": [
            {
                "name": "_key",
                "type": "string memory"
            },
            {
                "name": "_value",
                "type": "int256"
            }
        ],
        "func": "function addInt(string memory _key, int256 _value) public {\n    Chainlink.Request memory r2 = req;\n    r2.addInt(_key, _value);\n    req = r2;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addUint",
        "visibility": "public",
        "args": [
            {
                "name": "_key",
                "type": "string memory"
            },
            {
                "name": "_value",
                "type": "uint256"
            }
        ],
        "func": "function addUint(string memory _key, uint256 _value) public {\n    Chainlink.Request memory r2 = req;\n    r2.addUint(_key, _value);\n    req = r2;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addStringArray",
        "visibility": "public",
        "args": [
            {
                "name": "_key",
                "type": "string memory"
            },
            {
                "name": "_values",
                "type": "string[] memory"
            }
        ],
        "func": "function addStringArray(string memory _key, string[] memory _values) public {\n    Chainlink.Request memory r2 = req;\n    r2.addStringArray(_key, _values);\n    req = r2;\n  }",
        "comments": [
            "",
            "  // Temporarily have method receive bytes32[] memory until experimental",
            "  // string[] memory can be invoked from truffle tests.",
            "  "
        ],
        "comt": "\n  // Temporarily have method receive bytes32[] memory until experimental\n  // string[] memory can be invoked from truffle tests.\n  ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "publicNewRequest",
        "visibility": "public",
        "args": [
            {
                "name": "_id",
                "type": "bytes32"
            },
            {
                "name": "_address",
                "type": "address"
            },
            {
                "name": "_fulfillmentSignature",
                "type": "bytes memory"
            }
        ],
        "func": "function publicNewRequest(\n    bytes32 _id,\n    address _address,\n    bytes memory _fulfillmentSignature\n  ) public {\n    Chainlink.Request memory req = buildChainlinkRequest(_id, _address, bytes4(keccak256(_fulfillmentSignature)));\n    emit Request(req.id, req.callbackAddress, req.callbackFunctionId, req.buf.buf);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "publicRequest",
        "visibility": "public",
        "args": [
            {
                "name": "_id",
                "type": "bytes32"
            },
            {
                "name": "_address",
                "type": "address"
            },
            {
                "name": "_fulfillmentSignature",
                "type": "bytes memory"
            },
            {
                "name": "_wei",
                "type": "uint256"
            }
        ],
        "func": "function publicRequest(\n    bytes32 _id,\n    address _address,\n    bytes memory _fulfillmentSignature,\n    uint256 _wei\n  ) public {\n    Chainlink.Request memory req = buildChainlinkRequest(_id, _address, bytes4(keccak256(_fulfillmentSignature)));\n    sendChainlinkRequest(req, _wei);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "publicRequestRunTo",
        "visibility": "public",
        "args": [
            {
                "name": "_oracle",
                "type": "address"
            },
            {
                "name": "_id",
                "type": "bytes32"
            },
            {
                "name": "_address",
                "type": "address"
            },
            {
                "name": "_fulfillmentSignature",
                "type": "bytes memory"
            },
            {
                "name": "_wei",
                "type": "uint256"
            }
        ],
        "func": "function publicRequestRunTo(\n    address _oracle,\n    bytes32 _id,\n    address _address,\n    bytes memory _fulfillmentSignature,\n    uint256 _wei\n  ) public {\n    Chainlink.Request memory run = buildChainlinkRequest(_id, _address, bytes4(keccak256(_fulfillmentSignature)));\n    sendChainlinkRequestTo(_oracle, run, _wei);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "publicRequestOracleData",
        "visibility": "public",
        "args": [
            {
                "name": "_id",
                "type": "bytes32"
            },
            {
                "name": "_fulfillmentSignature",
                "type": "bytes memory"
            },
            {
                "name": "_wei",
                "type": "uint256"
            }
        ],
        "func": "function publicRequestOracleData(\n    bytes32 _id,\n    bytes memory _fulfillmentSignature,\n    uint256 _wei\n  ) public {\n    Chainlink.Request memory req = buildOperatorRequest(_id, bytes4(keccak256(_fulfillmentSignature)));\n    sendOperatorRequest(req, _wei);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "publicRequestOracleDataFrom",
        "visibility": "public",
        "args": [
            {
                "name": "_oracle",
                "type": "address"
            },
            {
                "name": "_id",
                "type": "bytes32"
            },
            {
                "name": "_fulfillmentSignature",
                "type": "bytes memory"
            },
            {
                "name": "_wei",
                "type": "uint256"
            }
        ],
        "func": "function publicRequestOracleDataFrom(\n    address _oracle,\n    bytes32 _id,\n    bytes memory _fulfillmentSignature,\n    uint256 _wei\n  ) public {\n    Chainlink.Request memory run = buildOperatorRequest(_id, bytes4(keccak256(_fulfillmentSignature)));\n    sendOperatorRequestTo(_oracle, run, _wei);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "publicCancelRequest",
        "visibility": "public",
        "args": [
            {
                "name": "_requestId",
                "type": "bytes32"
            },
            {
                "name": "_payment",
                "type": "uint256"
            },
            {
                "name": "_callbackFunctionId",
                "type": "bytes4"
            },
            {
                "name": "_expiration",
                "type": "uint256"
            }
        ],
        "func": "function publicCancelRequest(\n    bytes32 _requestId,\n    uint256 _payment,\n    bytes4 _callbackFunctionId,\n    uint256 _expiration\n  ) public {\n    cancelChainlinkRequest(_requestId, _payment, _callbackFunctionId, _expiration);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "publicChainlinkToken",
        "visibility": "public",
        "args": [],
        "func": "function publicChainlinkToken() public view returns (address) {\n    return chainlinkTokenAddress();\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "publicFulfillChainlinkRequest",
        "visibility": "public",
        "args": [
            {
                "name": "_requestId",
                "type": "bytes32"
            },
            {
                "name": "bytes32",
                "type": "bytes32"
            }
        ],
        "func": "function publicFulfillChainlinkRequest(bytes32 _requestId, bytes32) public {\n    fulfillRequest(_requestId, bytes32(0));\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "fulfillRequest",
        "visibility": "public",
        "args": [
            {
                "name": "_requestId",
                "type": "bytes32"
            },
            {
                "name": "bytes32",
                "type": "bytes32"
            }
        ],
        "func": "function fulfillRequest(bytes32 _requestId, bytes32) public {\n    validateChainlinkCallback(_requestId);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "publicLINK",
        "visibility": "public",
        "args": [
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function publicLINK(uint256 _amount) public {\n    emit LinkAmount(LINK_DIVISIBILITY * _amount);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "publicOracleAddress",
        "visibility": "public",
        "args": [],
        "func": "function publicOracleAddress() public view returns (address) {\n    return chainlinkOracleAddress();\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "publicAddExternalRequest",
        "visibility": "public",
        "args": [
            {
                "name": "_oracle",
                "type": "address"
            },
            {
                "name": "_requestId",
                "type": "bytes32"
            }
        ],
        "func": "function publicAddExternalRequest(address _oracle, bytes32 _requestId) public {\n    addChainlinkExternalRequest(_oracle, _requestId);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "testCreateSubscriptionAndFund",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint96"
            }
        ],
        "func": "function testCreateSubscriptionAndFund(uint96 amount) external {\n    if (s_subId == 0) {\n      s_subId = COORDINATOR.createSubscription();\n      COORDINATOR.addConsumer(s_subId, address(this));\n    }\n    // Approve the link transfer.\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subId));\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "topUpSubscription",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint96"
            }
        ],
        "func": "function topUpSubscription(uint96 amount) external {\n    require(s_subId != 0, \"sub not set\");\n    // Approve the link transfer.\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subId));\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateSubscription",
        "visibility": "external",
        "args": [
            {
                "name": "consumers",
                "type": "address[] memory"
            }
        ],
        "func": "function updateSubscription(address[] memory consumers) external {\n    require(s_subId != 0, \"subID not set\");\n    for (uint256 i = 0; i < consumers.length; i++) {\n      COORDINATOR.addConsumer(s_subId, consumers[i]);\n    }\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "testRequestRandomness",
        "visibility": "external",
        "args": [
            {
                "name": "keyHash",
                "type": "bytes32"
            },
            {
                "name": "subId",
                "type": "uint64"
            },
            {
                "name": "minReqConfs",
                "type": "uint16"
            },
            {
                "name": "callbackGasLimit",
                "type": "uint32"
            },
            {
                "name": "numWords",
                "type": "uint32"
            }
        ],
        "func": "function testRequestRandomness(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 minReqConfs,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external returns (uint256) {\n    s_requestId = COORDINATOR.requestRandomWords(keyHash, subId, minReqConfs, callbackGasLimit, numWords);\n    return s_requestId;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "rawFulfillRandomWords",
        "visibility": "external",
        "args": [
            {
                "name": "requestId",
                "type": "uint256"
            },
            {
                "name": "randomWords",
                "type": "uint256[] memory"
            }
        ],
        "func": "function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\n    if (msg.sender != vrfCoordinator) {\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\n    }\n    fulfillRandomWords(requestId, randomWords);\n  }",
        "comments": [
            "",
            "  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF",
            "  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating",
            "  // the origin of the call",
            "  "
        ],
        "comt": "\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "requestRandomWords",
        "visibility": "external",
        "args": [],
        "func": "function requestRandomWords() external onlyOwner {\n    RequestConfig memory rc = s_requestConfig;\n    // Will revert if subscription is not set and funded.\n    s_requestId = COORDINATOR.requestRandomWords(\n      rc.keyHash,\n      rc.subId,\n      rc.requestConfirmations,\n      rc.callbackGasLimit,\n      rc.numWords\n    );\n  }",
        "comments": [
            "",
            "  // Assumes the subscription is funded sufficiently.",
            "  "
        ],
        "comt": "\n  // Assumes the subscription is funded sufficiently.\n  ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "fundAndRequestRandomWords",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function fundAndRequestRandomWords(uint256 amount) external onlyOwner {\n    RequestConfig memory rc = s_requestConfig;\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_requestConfig.subId));\n    // Will revert if subscription is not set and funded.\n    s_requestId = COORDINATOR.requestRandomWords(\n      rc.keyHash,\n      rc.subId,\n      rc.requestConfirmations,\n      rc.callbackGasLimit,\n      rc.numWords\n    );\n  }",
        "comments": [
            "",
            "  // Assumes this contract owns link",
            "  // This method is analogous to VRFv1, except the amount",
            "  // should be selected based on the keyHash (each keyHash functions like a \"gas lane\"",
            "  // with different link costs).",
            "  "
        ],
        "comt": "\n  // Assumes this contract owns link\n  // This method is analogous to VRFv1, except the amount\n  // should be selected based on the keyHash (each keyHash functions like a \"gas lane\"\n  // with different link costs).\n  ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "topUpSubscription",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function topUpSubscription(uint256 amount) external onlyOwner {\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_requestConfig.subId));\n  }",
        "comments": [
            "",
            "  // Assumes this contract owns link",
            "  "
        ],
        "comt": "\n  // Assumes this contract owns link\n  ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            },
            {
                "name": "to",
                "type": "address"
            }
        ],
        "func": "function withdraw(uint256 amount, address to) external onlyOwner {\n    LINKTOKEN.transfer(to, amount);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unsubscribe",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            }
        ],
        "func": "function unsubscribe(address to) external onlyOwner {\n    // Returns funds to this address\n    COORDINATOR.cancelSubscription(s_requestConfig.subId, to);\n    s_requestConfig.subId = 0;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "subscribe",
        "visibility": "public",
        "args": [],
        "func": "function subscribe() public onlyOwner {\n    // Create a subscription, current subId\n    address[] memory consumers = new address[](1);\n    consumers[0] = address(this);\n    s_requestConfig.subId = COORDINATOR.createSubscription();\n    COORDINATOR.addConsumer(s_requestConfig.subId, consumers[0]);\n  }",
        "comments": [
            "",
            "  // Keep this separate incase the contract want to unsubscribe and then",
            "  // resubscribe.",
            "  "
        ],
        "comt": "\n  // Keep this separate incase the contract want to unsubscribe and then\n  // resubscribe.\n  ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setKeyHash",
        "visibility": "public",
        "args": [
            {
                "name": "keyHash",
                "type": "bytes32"
            }
        ],
        "func": "function setKeyHash(bytes32 keyHash) public {\n    s_keyHash = keyHash;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "testCreateSubscriptionAndFund",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint96"
            }
        ],
        "func": "function testCreateSubscriptionAndFund(uint96 amount) external {\n    if (s_subId == 0) {\n      s_subId = COORDINATOR.createSubscription();\n      COORDINATOR.addConsumer(s_subId, address(this));\n    }\n    // Approve the link transfer.\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subId));\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateSubscription",
        "visibility": "external",
        "args": [
            {
                "name": "consumers",
                "type": "address[] memory"
            }
        ],
        "func": "function updateSubscription(address[] memory consumers) external {\n    require(s_subId != 0, \"subID not set\");\n    for (uint256 i = 0; i < consumers.length; i++) {\n      COORDINATOR.addConsumer(s_subId, consumers[i]);\n    }\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "testRequestRandomness",
        "visibility": "external",
        "args": [],
        "func": "function testRequestRandomness() external returns (uint256) {\n    return COORDINATOR.requestRandomWords(s_keyHash, s_subId, 1, 500000, 1);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "requestRandomWords",
        "visibility": "external",
        "args": [
            {
                "name": "subId",
                "type": "uint64"
            },
            {
                "name": "callbackGasLimit",
                "type": "uint32"
            },
            {
                "name": "requestConfirmations",
                "type": "uint16"
            },
            {
                "name": "numWords",
                "type": "uint32"
            },
            {
                "name": "keyHash",
                "type": "bytes32"
            }
        ],
        "func": "function requestRandomWords(\n    uint64 subId,\n    uint32 callbackGasLimit,\n    uint16 requestConfirmations,\n    uint32 numWords,\n    bytes32 keyHash\n  ) external onlyOwner {\n    // Will revert if subscription is not funded.\n    s_requestId = COORDINATOR.requestRandomWords(keyHash, subId, requestConfirmations, callbackGasLimit, numWords);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferOwnership",
        "visibility": "external",
        "args": [
            {
                "name": "newOwner",
                "type": "address"
            }
        ],
        "func": "function transferOwnership(address newOwner) external onlyOwner {\n    s_owner = newOwner;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "testCreateSubscriptionAndFund",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint96"
            }
        ],
        "func": "function testCreateSubscriptionAndFund(uint96 amount) external {\n    if (s_subId == 0) {\n      s_subId = COORDINATOR.createSubscription();\n      COORDINATOR.addConsumer(s_subId, address(this));\n    }\n    // Approve the link transfer.\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subId));\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "topUpSubscription",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint96"
            }
        ],
        "func": "function topUpSubscription(uint96 amount) external {\n    require(s_subId != 0, \"sub not set\");\n    // Approve the link transfer.\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subId));\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateSubscription",
        "visibility": "external",
        "args": [
            {
                "name": "consumers",
                "type": "address[] memory"
            }
        ],
        "func": "function updateSubscription(address[] memory consumers) external {\n    require(s_subId != 0, \"subID not set\");\n    for (uint256 i = 0; i < consumers.length; i++) {\n      COORDINATOR.addConsumer(s_subId, consumers[i]);\n    }\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "testRequestRandomness",
        "visibility": "external",
        "args": [
            {
                "name": "keyHash",
                "type": "bytes32"
            },
            {
                "name": "subId",
                "type": "uint64"
            },
            {
                "name": "minReqConfs",
                "type": "uint16"
            },
            {
                "name": "callbackGasLimit",
                "type": "uint32"
            },
            {
                "name": "numWords",
                "type": "uint32"
            }
        ],
        "func": "function testRequestRandomness(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 minReqConfs,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external returns (uint256) {\n    s_requestId = COORDINATOR.requestRandomWords(keyHash, subId, minReqConfs, callbackGasLimit, numWords);\n    return s_requestId;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "fulfillRandomWords",
        "visibility": "external",
        "args": [
            {
                "name": "_requestId",
                "type": "uint256"
            },
            {
                "name": "_consumer",
                "type": "address"
            }
        ],
        "func": "function fulfillRandomWords(uint256 _requestId, address _consumer) external {\n    uint256 startGas = gasleft();\n    if (s_requests[_requestId].subId == 0) {\n      revert(\"nonexistent request\");\n    }\n    Request memory req = s_requests[_requestId];\n\n    uint256[] memory words = new uint256[](req.numWords);\n    for (uint256 i = 0; i < req.numWords; i++) {\n      words[i] = uint256(keccak256(abi.encode(_requestId, i)));\n    }\n\n    VRFConsumerBaseV2 v;\n    bytes memory callReq = abi.encodeWithSelector(v.rawFulfillRandomWords.selector, _requestId, words);\n    (bool success, ) = _consumer.call{gas: req.callbackGasLimit}(callReq);\n\n    uint96 payment = uint96(BASE_FEE + ((startGas - gasleft()) * GAS_PRICE_LINK));\n    if (s_subscriptions[req.subId].balance < payment) {\n      revert InsufficientBalance();\n    }\n    s_subscriptions[req.subId].balance -= payment;\n    delete (s_requests[_requestId]);\n    emit RandomWordsFulfilled(_requestId, _requestId, payment, success);\n  }",
        "comments": [
            "/**",
            "   * @notice fulfillRandomWords fulfills the given request, sending the random words to the supplied",
            "   * @notice consumer.",
            "   *",
            "   * @dev This mock uses a simplified formula for calculating payment amount and gas usage, and does",
            "   * @dev not account for all edge cases handled in the real VRF coordinator. When making requests",
            "   * @dev against the real coordinator a small amount of additional LINK is required.",
            "   *",
            "   * @param _requestId the request to fulfill",
            "   * @param _consumer the VRF randomness consumer to send the result to",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice fulfillRandomWords fulfills the given request, sending the random words to the supplied\n   * @notice consumer.\n   *\n   * @dev This mock uses a simplified formula for calculating payment amount and gas usage, and does\n   * @dev not account for all edge cases handled in the real VRF coordinator. When making requests\n   * @dev against the real coordinator a small amount of additional LINK is required.\n   *\n   * @param _requestId the request to fulfill\n   * @param _consumer the VRF randomness consumer to send the result to\n   */\n",
        "@notice": "fulfillRandomWords fulfills the given request, sending the random words to the supplied * consumer.",
        "@dev": "This mock uses a simplified formula for calculating payment amount and gas usage, and does * not account for all edge cases handled in the real VRF coordinator. When making requests * against the real coordinator a small amount of additional LINK is required.",
        "@param1": "_requestId the request to fulfill",
        "@param2": "_consumer the VRF randomness consumer to send the result to",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "fundSubscription",
        "visibility": "public",
        "args": [
            {
                "name": "_subId",
                "type": "uint64"
            },
            {
                "name": "_amount",
                "type": "uint96"
            }
        ],
        "func": "function fundSubscription(uint64 _subId, uint96 _amount) public {\n    if (s_subscriptions[_subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    uint96 oldBalance = s_subscriptions[_subId].balance;\n    s_subscriptions[_subId].balance += _amount;\n    emit SubscriptionFunded(_subId, oldBalance, oldBalance + _amount);\n  }",
        "comments": [
            "/**",
            "   * @notice fundSubscription allows funding a subscription with an arbitrary amount for testing.",
            "   *",
            "   * @param _subId the subscription to fund",
            "   * @param _amount the amount to fund",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice fundSubscription allows funding a subscription with an arbitrary amount for testing.\n   *\n   * @param _subId the subscription to fund\n   * @param _amount the amount to fund\n   */\n",
        "@notice": "fundSubscription allows funding a subscription with an arbitrary amount for testing.",
        "@param1": "_subId the subscription to fund",
        "@param2": "_amount the amount to fund",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "requestRandomWords",
        "visibility": "external",
        "args": [
            {
                "name": "_keyHash",
                "type": "bytes32"
            },
            {
                "name": "_subId",
                "type": "uint64"
            },
            {
                "name": "_minimumRequestConfirmations",
                "type": "uint16"
            },
            {
                "name": "_callbackGasLimit",
                "type": "uint32"
            },
            {
                "name": "_numWords",
                "type": "uint32"
            }
        ],
        "func": "function requestRandomWords(\n    bytes32 _keyHash,\n    uint64 _subId,\n    uint16 _minimumRequestConfirmations,\n    uint32 _callbackGasLimit,\n    uint32 _numWords\n  ) external override returns (uint256) {\n    if (s_subscriptions[_subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n\n    uint256 requestId = s_nextRequestId++;\n    uint256 preSeed = s_nextPreSeed++;\n\n    s_requests[requestId] = Request({subId: _subId, callbackGasLimit: _callbackGasLimit, numWords: _numWords});\n\n    emit RandomWordsRequested(\n      _keyHash,\n      requestId,\n      preSeed,\n      _subId,\n      _minimumRequestConfirmations,\n      _callbackGasLimit,\n      _numWords,\n      msg.sender\n    );\n    return requestId;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createSubscription",
        "visibility": "external",
        "args": [],
        "func": "function createSubscription() external override returns (uint64 _subId) {\n    s_currentSubId++;\n    s_subscriptions[s_currentSubId] = Subscription({owner: msg.sender, balance: 0});\n    emit SubscriptionCreated(s_currentSubId, msg.sender);\n    return s_currentSubId;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getSubscription",
        "visibility": "external",
        "args": [
            {
                "name": "_subId",
                "type": "uint64"
            }
        ],
        "func": "function getSubscription(uint64 _subId)\n    external\n    view\n    override\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    )\n  {\n    if (s_subscriptions[_subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    return (s_subscriptions[_subId].balance, 0, s_subscriptions[_subId].owner, new address[](0));\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cancelSubscription",
        "visibility": "external",
        "args": [
            {
                "name": "_subId",
                "type": "uint64"
            },
            {
                "name": "_to",
                "type": "address"
            }
        ],
        "func": "function cancelSubscription(uint64 _subId, address _to) external override onlySubOwner(_subId) {\n    emit SubscriptionCanceled(_subId, _to, s_subscriptions[_subId].balance);\n    delete (s_subscriptions[_subId]);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getRequestConfig",
        "visibility": "external",
        "args": [],
        "func": "function getRequestConfig()\n    external\n    pure\n    override\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    )\n  {\n    return (3, 2000000, new bytes32[](0));\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addConsumer",
        "visibility": "external",
        "args": [
            {
                "name": "_subId",
                "type": "uint64"
            },
            {
                "name": "_consumer",
                "type": "address"
            }
        ],
        "func": "function addConsumer(uint64 _subId, address _consumer) external pure override {\n    revert(\"not implemented\");\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeConsumer",
        "visibility": "external",
        "args": [
            {
                "name": "_subId",
                "type": "uint64"
            },
            {
                "name": "_consumer",
                "type": "address"
            }
        ],
        "func": "function removeConsumer(uint64 _subId, address _consumer) external pure override {\n    revert(\"not implemented\");\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "requestSubscriptionOwnerTransfer",
        "visibility": "external",
        "args": [
            {
                "name": "_subId",
                "type": "uint64"
            },
            {
                "name": "_newOwner",
                "type": "address"
            }
        ],
        "func": "function requestSubscriptionOwnerTransfer(uint64 _subId, address _newOwner) external pure override {\n    revert(\"not implemented\");\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "acceptSubscriptionOwnerTransfer",
        "visibility": "external",
        "args": [
            {
                "name": "_subId",
                "type": "uint64"
            }
        ],
        "func": "function acceptSubscriptionOwnerTransfer(uint64 _subId) external pure override {\n    revert(\"not implemented\");\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "registerProvingKey",
        "visibility": "external",
        "args": [
            {
                "name": "oracle",
                "type": "address"
            },
            {
                "name": "publicProvingKey",
                "type": "uint256[2] calldata"
            }
        ],
        "func": "function registerProvingKey(address oracle, uint256[2] calldata publicProvingKey) external onlyOwner {\n    bytes32 kh = hashOfKey(publicProvingKey);\n    if (s_provingKeys[kh] != address(0)) {\n      revert ProvingKeyAlreadyRegistered(kh);\n    }\n    s_provingKeys[kh] = oracle;\n    s_provingKeyHashes.push(kh);\n    emit ProvingKeyRegistered(kh, oracle);\n  }",
        "comments": [
            "/**",
            "   * @notice Registers a proving key to an oracle.",
            "   * @param oracle address of the oracle",
            "   * @param publicProvingKey key that oracle can use to submit vrf fulfillments",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Registers a proving key to an oracle.\n   * @param oracle address of the oracle\n   * @param publicProvingKey key that oracle can use to submit vrf fulfillments\n   */\n",
        "@notice": "Registers a proving key to an oracle.",
        "@param1": "oracle address of the oracle",
        "@param2": "publicProvingKey key that oracle can use to submit vrf fulfillments",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "deregisterProvingKey",
        "visibility": "external",
        "args": [
            {
                "name": "publicProvingKey",
                "type": "uint256[2] calldata"
            }
        ],
        "func": "function deregisterProvingKey(uint256[2] calldata publicProvingKey) external onlyOwner {\n    bytes32 kh = hashOfKey(publicProvingKey);\n    address oracle = s_provingKeys[kh];\n    if (oracle == address(0)) {\n      revert NoSuchProvingKey(kh);\n    }\n    delete s_provingKeys[kh];\n    for (uint256 i = 0; i < s_provingKeyHashes.length; i++) {\n      if (s_provingKeyHashes[i] == kh) {\n        bytes32 last = s_provingKeyHashes[s_provingKeyHashes.length - 1];\n        // Copy last element and overwrite kh to be deleted with it\n        s_provingKeyHashes[i] = last;\n        s_provingKeyHashes.pop();\n      }\n    }\n    emit ProvingKeyDeregistered(kh, oracle);\n  }",
        "comments": [
            "/**",
            "   * @notice Deregisters a proving key to an oracle.",
            "   * @param publicProvingKey key that oracle can use to submit vrf fulfillments",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Deregisters a proving key to an oracle.\n   * @param publicProvingKey key that oracle can use to submit vrf fulfillments\n   */\n",
        "@notice": "Deregisters a proving key to an oracle.",
        "@param1": "publicProvingKey key that oracle can use to submit vrf fulfillments",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "hashOfKey",
        "visibility": "public",
        "args": [
            {
                "name": "publicKey",
                "type": "uint256[2] memory"
            }
        ],
        "func": "function hashOfKey(uint256[2] memory publicKey) public pure returns (bytes32) {\n    return keccak256(abi.encode(publicKey));\n  }",
        "comments": [
            "/**",
            "   * @notice Returns the proving key hash key associated with this public key",
            "   * @param publicKey the key to return the hash of",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Returns the proving key hash key associated with this public key\n   * @param publicKey the key to return the hash of\n   */\n",
        "@notice": "Returns the proving key hash key associated with this public key",
        "@param1": "publicKey the key to return the hash of",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setConfig",
        "visibility": "external",
        "args": [
            {
                "name": "minimumRequestConfirmations",
                "type": "uint16"
            },
            {
                "name": "maxGasLimit",
                "type": "uint32"
            },
            {
                "name": "stalenessSeconds",
                "type": "uint32"
            },
            {
                "name": "gasAfterPaymentCalculation",
                "type": "uint32"
            },
            {
                "name": "fallbackWeiPerUnitLink",
                "type": "int256"
            },
            {
                "name": "feeConfig",
                "type": "FeeConfig memory"
            }
        ],
        "func": "function setConfig(\n    uint16 minimumRequestConfirmations,\n    uint32 maxGasLimit,\n    uint32 stalenessSeconds,\n    uint32 gasAfterPaymentCalculation,\n    int256 fallbackWeiPerUnitLink,\n    FeeConfig memory feeConfig\n  ) external onlyOwner {\n    if (minimumRequestConfirmations > MAX_REQUEST_CONFIRMATIONS) {\n      revert InvalidRequestConfirmations(\n        minimumRequestConfirmations,\n        minimumRequestConfirmations,\n        MAX_REQUEST_CONFIRMATIONS\n      );\n    }\n    if (fallbackWeiPerUnitLink <= 0) {\n      revert InvalidLinkWeiPrice(fallbackWeiPerUnitLink);\n    }\n    s_config = Config({\n      minimumRequestConfirmations: minimumRequestConfirmations,\n      maxGasLimit: maxGasLimit,\n      stalenessSeconds: stalenessSeconds,\n      gasAfterPaymentCalculation: gasAfterPaymentCalculation,\n      reentrancyLock: false\n    });\n    s_feeConfig = feeConfig;\n    s_fallbackWeiPerUnitLink = fallbackWeiPerUnitLink;\n    emit ConfigSet(\n      minimumRequestConfirmations,\n      maxGasLimit,\n      stalenessSeconds,\n      gasAfterPaymentCalculation,\n      fallbackWeiPerUnitLink,\n      s_feeConfig\n    );\n  }",
        "comments": [
            "/**",
            "   * @notice Sets the configuration of the vrfv2 coordinator",
            "   * @param minimumRequestConfirmations global min for request confirmations",
            "   * @param maxGasLimit global max for request gas limit",
            "   * @param stalenessSeconds if the eth/link feed is more stale then this, use the fallback price",
            "   * @param gasAfterPaymentCalculation gas used in doing accounting after completing the gas measurement",
            "   * @param fallbackWeiPerUnitLink fallback eth/link price in the case of a stale feed",
            "   * @param feeConfig fee tier configuration",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Sets the configuration of the vrfv2 coordinator\n   * @param minimumRequestConfirmations global min for request confirmations\n   * @param maxGasLimit global max for request gas limit\n   * @param stalenessSeconds if the eth/link feed is more stale then this, use the fallback price\n   * @param gasAfterPaymentCalculation gas used in doing accounting after completing the gas measurement\n   * @param fallbackWeiPerUnitLink fallback eth/link price in the case of a stale feed\n   * @param feeConfig fee tier configuration\n   */\n",
        "@notice": "Sets the configuration of the vrfv2 coordinator",
        "@param1": "minimumRequestConfirmations global min for request confirmations",
        "@param2": "maxGasLimit global max for request gas limit",
        "@param3": "stalenessSeconds if the eth/link feed is more stale then this, use the fallback price",
        "@param4": "gasAfterPaymentCalculation gas used in doing accounting after completing the gas measurement",
        "@param5": "fallbackWeiPerUnitLink fallback eth/link price in the case of a stale feed",
        "@param6": "feeConfig fee tier configuration",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getConfig",
        "visibility": "external",
        "args": [],
        "func": "function getConfig()\n    external\n    view\n    returns (\n      uint16 minimumRequestConfirmations,\n      uint32 maxGasLimit,\n      uint32 stalenessSeconds,\n      uint32 gasAfterPaymentCalculation\n    )\n  {\n    return (\n      s_config.minimumRequestConfirmations,\n      s_config.maxGasLimit,\n      s_config.stalenessSeconds,\n      s_config.gasAfterPaymentCalculation\n    );\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getFeeConfig",
        "visibility": "external",
        "args": [],
        "func": "function getFeeConfig()\n    external\n    view\n    returns (\n      uint32 fulfillmentFlatFeeLinkPPMTier1,\n      uint32 fulfillmentFlatFeeLinkPPMTier2,\n      uint32 fulfillmentFlatFeeLinkPPMTier3,\n      uint32 fulfillmentFlatFeeLinkPPMTier4,\n      uint32 fulfillmentFlatFeeLinkPPMTier5,\n      uint24 reqsForTier2,\n      uint24 reqsForTier3,\n      uint24 reqsForTier4,\n      uint24 reqsForTier5\n    )\n  {\n    return (\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier1,\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier2,\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier3,\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier4,\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier5,\n      s_feeConfig.reqsForTier2,\n      s_feeConfig.reqsForTier3,\n      s_feeConfig.reqsForTier4,\n      s_feeConfig.reqsForTier5\n    );\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getTotalBalance",
        "visibility": "external",
        "args": [],
        "func": "function getTotalBalance() external view returns (uint256) {\n    return s_totalBalance;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getFallbackWeiPerUnitLink",
        "visibility": "external",
        "args": [],
        "func": "function getFallbackWeiPerUnitLink() external view returns (int256) {\n    return s_fallbackWeiPerUnitLink;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "ownerCancelSubscription",
        "visibility": "external",
        "args": [
            {
                "name": "subId",
                "type": "uint64"
            }
        ],
        "func": "function ownerCancelSubscription(uint64 subId) external onlyOwner {\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    cancelSubscriptionHelper(subId, s_subscriptionConfigs[subId].owner);\n  }",
        "comments": [
            "/**",
            "   * @notice Owner cancel subscription, sends remaining link directly to the subscription owner.",
            "   * @param subId subscription id",
            "   * @dev notably can be called even if there are pending requests, outstanding ones may fail onchain",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Owner cancel subscription, sends remaining link directly to the subscription owner.\n   * @param subId subscription id\n   * @dev notably can be called even if there are pending requests, outstanding ones may fail onchain\n   */\n",
        "@notice": "Owner cancel subscription, sends remaining link directly to the subscription owner.",
        "@param1": "subId subscription id",
        "@dev": "notably can be called even if there are pending requests, outstanding ones may fail onchain",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "recoverFunds",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            }
        ],
        "func": "function recoverFunds(address to) external onlyOwner {\n    uint256 externalBalance = LINK.balanceOf(address(this));\n    uint256 internalBalance = uint256(s_totalBalance);\n    if (internalBalance > externalBalance) {\n      revert BalanceInvariantViolated(internalBalance, externalBalance);\n    }\n    if (internalBalance < externalBalance) {\n      uint256 amount = externalBalance - internalBalance;\n      LINK.transfer(to, amount);\n      emit FundsRecovered(to, amount);\n    }\n    // If the balances are equal, nothing to be done.\n  }",
        "comments": [
            "/**",
            "   * @notice Recover link sent with transfer instead of transferAndCall.",
            "   * @param to address to send link to",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Recover link sent with transfer instead of transferAndCall.\n   * @param to address to send link to\n   */\n",
        "@notice": "Recover link sent with transfer instead of transferAndCall.",
        "@param1": "to address to send link to",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getRequestConfig",
        "visibility": "external",
        "args": [],
        "func": "function getRequestConfig()\n    external\n    view\n    override\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    )\n  {\n    return (s_config.minimumRequestConfirmations, s_config.maxGasLimit, s_provingKeyHashes);\n  }",
        "comments": [
            "/**",
            "   * @inheritdoc VRFCoordinatorV2Interface",
            "   */",
            ""
        ],
        "comt": "/**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n",
        "@inheritdoc": "VRFCoordinatorV2Interface",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "requestRandomWords",
        "visibility": "external",
        "args": [
            {
                "name": "keyHash",
                "type": "bytes32"
            },
            {
                "name": "subId",
                "type": "uint64"
            },
            {
                "name": "requestConfirmations",
                "type": "uint16"
            },
            {
                "name": "callbackGasLimit",
                "type": "uint32"
            },
            {
                "name": "numWords",
                "type": "uint32"
            }
        ],
        "func": "function requestRandomWords(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 requestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external override nonReentrant returns (uint256) {\n    // Input validation using the subscription storage.\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    // Its important to ensure that the consumer is in fact who they say they\n    // are, otherwise they could use someone else's subscription balance.\n    // A nonce of 0 indicates consumer is not allocated to the sub.\n    uint64 currentNonce = s_consumers[msg.sender][subId];\n    if (currentNonce == 0) {\n      revert InvalidConsumer(subId, msg.sender);\n    }\n    // Input validation using the config storage word.\n    if (\n      requestConfirmations < s_config.minimumRequestConfirmations || requestConfirmations > MAX_REQUEST_CONFIRMATIONS\n    ) {\n      revert InvalidRequestConfirmations(\n        requestConfirmations,\n        s_config.minimumRequestConfirmations,\n        MAX_REQUEST_CONFIRMATIONS\n      );\n    }\n    // No lower bound on the requested gas limit. A user could request 0\n    // and they would simply be billed for the proof verification and wouldn't be\n    // able to do anything with the random value.\n    if (callbackGasLimit > s_config.maxGasLimit) {\n      revert GasLimitTooBig(callbackGasLimit, s_config.maxGasLimit);\n    }\n    if (numWords > MAX_NUM_WORDS) {\n      revert NumWordsTooBig(numWords, MAX_NUM_WORDS);\n    }\n    // Note we do not check whether the keyHash is valid to save gas.\n    // The consequence for users is that they can send requests\n    // for invalid keyHashes which will simply not be fulfilled.\n    uint64 nonce = currentNonce + 1;\n    (uint256 requestId, uint256 preSeed) = computeRequestId(keyHash, msg.sender, subId, nonce);\n\n    s_requestCommitments[requestId] = keccak256(\n      abi.encode(requestId, block.number, subId, callbackGasLimit, numWords, msg.sender)\n    );\n    emit RandomWordsRequested(\n      keyHash,\n      requestId,\n      preSeed,\n      subId,\n      requestConfirmations,\n      callbackGasLimit,\n      numWords,\n      msg.sender\n    );\n    s_consumers[msg.sender][subId] = nonce;\n\n    return requestId;\n  }",
        "comments": [
            "/**",
            "   * @inheritdoc VRFCoordinatorV2Interface",
            "   */",
            ""
        ],
        "comt": "/**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n",
        "@inheritdoc": "VRFCoordinatorV2Interface",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCommitment",
        "visibility": "external",
        "args": [
            {
                "name": "requestId",
                "type": "uint256"
            }
        ],
        "func": "function getCommitment(uint256 requestId) external view returns (bytes32) {\n    return s_requestCommitments[requestId];\n  }",
        "comments": [
            "/**",
            "   * @notice Get request commitment",
            "   * @param requestId id of request",
            "   * @dev used to determine if a request is fulfilled or not",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Get request commitment\n   * @param requestId id of request\n   * @dev used to determine if a request is fulfilled or not\n   */\n",
        "@notice": "Get request commitment",
        "@param1": "requestId id of request",
        "@dev": "used to determine if a request is fulfilled or not",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getFeeTier",
        "visibility": "public",
        "args": [
            {
                "name": "reqCount",
                "type": "uint64"
            }
        ],
        "func": "function getFeeTier(uint64 reqCount) public view returns (uint32) {\n    FeeConfig memory fc = s_feeConfig;\n    if (0 <= reqCount && reqCount <= fc.reqsForTier2) {\n      return fc.fulfillmentFlatFeeLinkPPMTier1;\n    }\n    if (fc.reqsForTier2 < reqCount && reqCount <= fc.reqsForTier3) {\n      return fc.fulfillmentFlatFeeLinkPPMTier2;\n    }\n    if (fc.reqsForTier3 < reqCount && reqCount <= fc.reqsForTier4) {\n      return fc.fulfillmentFlatFeeLinkPPMTier3;\n    }\n    if (fc.reqsForTier4 < reqCount && reqCount <= fc.reqsForTier5) {\n      return fc.fulfillmentFlatFeeLinkPPMTier4;\n    }\n    return fc.fulfillmentFlatFeeLinkPPMTier5;\n  }",
        "comments": [
            "/*",
            "   * @notice Compute fee based on the request count",
            "   * @param reqCount number of requests",
            "   * @return feePPM fee in LINK PPM",
            "   */",
            ""
        ],
        "comt": "/*\n   * @notice Compute fee based on the request count\n   * @param reqCount number of requests\n   * @return feePPM fee in LINK PPM\n   */\n",
        "@notice": "Compute fee based on the request count",
        "@param1": "reqCount number of requests",
        "@return1": "feePPM fee in LINK PPM",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "fulfillRandomWords",
        "visibility": "external",
        "args": [
            {
                "name": "proof",
                "type": "Proof memory"
            },
            {
                "name": "rc",
                "type": "RequestCommitment memory"
            }
        ],
        "func": "function fulfillRandomWords(Proof memory proof, RequestCommitment memory rc) external nonReentrant returns (uint96) {\n    uint256 startGas = gasleft();\n    (bytes32 keyHash, uint256 requestId, uint256 randomness) = getRandomnessFromProof(proof, rc);\n\n    uint256[] memory randomWords = new uint256[](rc.numWords);\n    for (uint256 i = 0; i < rc.numWords; i++) {\n      randomWords[i] = uint256(keccak256(abi.encode(randomness, i)));\n    }\n\n    delete s_requestCommitments[requestId];\n    VRFConsumerBaseV2 v;\n    bytes memory resp = abi.encodeWithSelector(v.rawFulfillRandomWords.selector, requestId, randomWords);\n    // Call with explicitly the amount of callback gas requested\n    // Important to not let them exhaust the gas budget and avoid oracle payment.\n    // Do not allow any non-view/non-pure coordinator functions to be called\n    // during the consumers callback code via reentrancyLock.\n    // Note that callWithExactGas will revert if we do not have sufficient gas\n    // to give the callee their requested amount.\n    s_config.reentrancyLock = true;\n    bool success = callWithExactGas(rc.callbackGasLimit, rc.sender, resp);\n    s_config.reentrancyLock = false;\n\n    // Increment the req count for fee tier selection.\n    uint64 reqCount = s_subscriptions[rc.subId].reqCount;\n    s_subscriptions[rc.subId].reqCount += 1;\n\n    // We want to charge users exactly for how much gas they use in their callback.\n    // The gasAfterPaymentCalculation is meant to cover these additional operations where we\n    // decrement the subscription balance and increment the oracles withdrawable balance.\n    // We also add the flat link fee to the payment amount.\n    // Its specified in millionths of link, if s_config.fulfillmentFlatFeeLinkPPM = 1\n    // 1 link / 1e6 = 1e18 juels / 1e6 = 1e12 juels.\n    uint96 payment = calculatePaymentAmount(\n      startGas,\n      s_config.gasAfterPaymentCalculation,\n      getFeeTier(reqCount),\n      tx.gasprice\n    );\n    if (s_subscriptions[rc.subId].balance < payment) {\n      revert InsufficientBalance();\n    }\n    s_subscriptions[rc.subId].balance -= payment;\n    s_withdrawableTokens[s_provingKeys[keyHash]] += payment;\n    // Include payment in the event for tracking costs.\n    emit RandomWordsFulfilled(requestId, randomness, payment, success);\n    return payment;\n  }",
        "comments": [
            "/*",
            "   * @notice Fulfill a randomness request",
            "   * @param proof contains the proof and randomness",
            "   * @param rc request commitment pre-image, committed to at request time",
            "   * @return payment amount billed to the subscription",
            "   * @dev simulated offchain to determine if sufficient balance is present to fulfill the request",
            "   */",
            ""
        ],
        "comt": "/*\n   * @notice Fulfill a randomness request\n   * @param proof contains the proof and randomness\n   * @param rc request commitment pre-image, committed to at request time\n   * @return payment amount billed to the subscription\n   * @dev simulated offchain to determine if sufficient balance is present to fulfill the request\n   */\n",
        "@notice": "Fulfill a randomness request",
        "@param1": "proof contains the proof and randomness",
        "@param2": "rc request commitment pre-image, committed to at request time",
        "@return1": "payment amount billed to the subscription",
        "@dev": "simulated offchain to determine if sufficient balance is present to fulfill the request",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "oracleWithdraw",
        "visibility": "external",
        "args": [
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint96"
            }
        ],
        "func": "function oracleWithdraw(address recipient, uint96 amount) external nonReentrant {\n    if (s_withdrawableTokens[msg.sender] < amount) {\n      revert InsufficientBalance();\n    }\n    s_withdrawableTokens[msg.sender] -= amount;\n    s_totalBalance -= amount;\n    if (!LINK.transfer(recipient, amount)) {\n      revert InsufficientBalance();\n    }\n  }",
        "comments": [
            "/*",
            "   * @notice Oracle withdraw LINK earned through fulfilling requests",
            "   * @param recipient where to send the funds",
            "   * @param amount amount to withdraw",
            "   */",
            ""
        ],
        "comt": "/*\n   * @notice Oracle withdraw LINK earned through fulfilling requests\n   * @param recipient where to send the funds\n   * @param amount amount to withdraw\n   */\n",
        "@notice": "Oracle withdraw LINK earned through fulfilling requests",
        "@param1": "recipient where to send the funds",
        "@param2": "amount amount to withdraw",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "onTokenTransfer",
        "visibility": "external",
        "args": [
            {
                "name": "address",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "/* sender */\n    uint256"
            },
            {
                "name": "data",
                "type": "bytes calldata"
            }
        ],
        "func": "function onTokenTransfer(\n    address, /* sender */\n    uint256 amount,\n    bytes calldata data\n  ) external override nonReentrant {\n    if (msg.sender != address(LINK)) {\n      revert OnlyCallableFromLink();\n    }\n    if (data.length != 32) {\n      revert InvalidCalldata();\n    }\n    uint64 subId = abi.decode(data, (uint64));\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    // We do not check that the msg.sender is the subscription owner,\n    // anyone can fund a subscription.\n    uint256 oldBalance = s_subscriptions[subId].balance;\n    s_subscriptions[subId].balance += uint96(amount);\n    s_totalBalance += uint96(amount);\n    emit SubscriptionFunded(subId, oldBalance, oldBalance + amount);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentSubId",
        "visibility": "external",
        "args": [],
        "func": "function getCurrentSubId() external view returns (uint64) {\n    return s_currentSubId;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getSubscription",
        "visibility": "external",
        "args": [
            {
                "name": "subId",
                "type": "uint64"
            }
        ],
        "func": "function getSubscription(uint64 subId)\n    external\n    view\n    override\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    )\n  {\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    return (\n      s_subscriptions[subId].balance,\n      s_subscriptions[subId].reqCount,\n      s_subscriptionConfigs[subId].owner,\n      s_subscriptionConfigs[subId].consumers\n    );\n  }",
        "comments": [
            "/**",
            "   * @inheritdoc VRFCoordinatorV2Interface",
            "   */",
            ""
        ],
        "comt": "/**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n",
        "@inheritdoc": "VRFCoordinatorV2Interface",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createSubscription",
        "visibility": "external",
        "args": [],
        "func": "function createSubscription() external override nonReentrant returns (uint64) {\n    s_currentSubId++;\n    uint64 currentSubId = s_currentSubId;\n    address[] memory consumers = new address[](0);\n    s_subscriptions[currentSubId] = Subscription({balance: 0, reqCount: 0});\n    s_subscriptionConfigs[currentSubId] = SubscriptionConfig({\n      owner: msg.sender,\n      requestedOwner: address(0),\n      consumers: consumers\n    });\n\n    emit SubscriptionCreated(currentSubId, msg.sender);\n    return currentSubId;\n  }",
        "comments": [
            "/**",
            "   * @inheritdoc VRFCoordinatorV2Interface",
            "   */",
            ""
        ],
        "comt": "/**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n",
        "@inheritdoc": "VRFCoordinatorV2Interface",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "requestSubscriptionOwnerTransfer",
        "visibility": "external",
        "args": [
            {
                "name": "subId",
                "type": "uint64"
            },
            {
                "name": "newOwner",
                "type": "address"
            }
        ],
        "func": "function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner)\n    external\n    override\n    onlySubOwner(subId)\n    nonReentrant\n  {\n    // Proposing to address(0) would never be claimable so don't need to check.\n    if (s_subscriptionConfigs[subId].requestedOwner != newOwner) {\n      s_subscriptionConfigs[subId].requestedOwner = newOwner;\n      emit SubscriptionOwnerTransferRequested(subId, msg.sender, newOwner);\n    }\n  }",
        "comments": [
            "/**",
            "   * @inheritdoc VRFCoordinatorV2Interface",
            "   */",
            ""
        ],
        "comt": "/**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n",
        "@inheritdoc": "VRFCoordinatorV2Interface",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "acceptSubscriptionOwnerTransfer",
        "visibility": "external",
        "args": [
            {
                "name": "subId",
                "type": "uint64"
            }
        ],
        "func": "function acceptSubscriptionOwnerTransfer(uint64 subId) external override nonReentrant {\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    if (s_subscriptionConfigs[subId].requestedOwner != msg.sender) {\n      revert MustBeRequestedOwner(s_subscriptionConfigs[subId].requestedOwner);\n    }\n    address oldOwner = s_subscriptionConfigs[subId].owner;\n    s_subscriptionConfigs[subId].owner = msg.sender;\n    s_subscriptionConfigs[subId].requestedOwner = address(0);\n    emit SubscriptionOwnerTransferred(subId, oldOwner, msg.sender);\n  }",
        "comments": [
            "/**",
            "   * @inheritdoc VRFCoordinatorV2Interface",
            "   */",
            ""
        ],
        "comt": "/**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n",
        "@inheritdoc": "VRFCoordinatorV2Interface",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeConsumer",
        "visibility": "external",
        "args": [
            {
                "name": "subId",
                "type": "uint64"
            },
            {
                "name": "consumer",
                "type": "address"
            }
        ],
        "func": "function removeConsumer(uint64 subId, address consumer) external override onlySubOwner(subId) nonReentrant {\n    if (s_consumers[consumer][subId] == 0) {\n      revert InvalidConsumer(subId, consumer);\n    }\n    // Note bounded by MAX_CONSUMERS\n    address[] memory consumers = s_subscriptionConfigs[subId].consumers;\n    uint256 lastConsumerIndex = consumers.length - 1;\n    for (uint256 i = 0; i < consumers.length; i++) {\n      if (consumers[i] == consumer) {\n        address last = consumers[lastConsumerIndex];\n        // Storage write to preserve last element\n        s_subscriptionConfigs[subId].consumers[i] = last;\n        // Storage remove last element\n        s_subscriptionConfigs[subId].consumers.pop();\n        break;\n      }\n    }\n    delete s_consumers[consumer][subId];\n    emit SubscriptionConsumerRemoved(subId, consumer);\n  }",
        "comments": [
            "/**",
            "   * @inheritdoc VRFCoordinatorV2Interface",
            "   */",
            ""
        ],
        "comt": "/**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n",
        "@inheritdoc": "VRFCoordinatorV2Interface",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addConsumer",
        "visibility": "external",
        "args": [
            {
                "name": "subId",
                "type": "uint64"
            },
            {
                "name": "consumer",
                "type": "address"
            }
        ],
        "func": "function addConsumer(uint64 subId, address consumer) external override onlySubOwner(subId) nonReentrant {\n    // Already maxed, cannot add any more consumers.\n    if (s_subscriptionConfigs[subId].consumers.length == MAX_CONSUMERS) {\n      revert TooManyConsumers();\n    }\n    if (s_consumers[consumer][subId] != 0) {\n      // Idempotence - do nothing if already added.\n      // Ensures uniqueness in s_subscriptions[subId].consumers.\n      return;\n    }\n    // Initialize the nonce to 1, indicating the consumer is allocated.\n    s_consumers[consumer][subId] = 1;\n    s_subscriptionConfigs[subId].consumers.push(consumer);\n\n    emit SubscriptionConsumerAdded(subId, consumer);\n  }",
        "comments": [
            "/**",
            "   * @inheritdoc VRFCoordinatorV2Interface",
            "   */",
            ""
        ],
        "comt": "/**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n",
        "@inheritdoc": "VRFCoordinatorV2Interface",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cancelSubscription",
        "visibility": "external",
        "args": [
            {
                "name": "subId",
                "type": "uint64"
            },
            {
                "name": "to",
                "type": "address"
            }
        ],
        "func": "function cancelSubscription(uint64 subId, address to) external override onlySubOwner(subId) nonReentrant {\n    if (pendingRequestExists(subId)) {\n      revert PendingRequestExists();\n    }\n    cancelSubscriptionHelper(subId, to);\n  }",
        "comments": [
            "/**",
            "   * @inheritdoc VRFCoordinatorV2Interface",
            "   */",
            ""
        ],
        "comt": "/**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n",
        "@inheritdoc": "VRFCoordinatorV2Interface",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "pendingRequestExists",
        "visibility": "public",
        "args": [
            {
                "name": "subId",
                "type": "uint64"
            }
        ],
        "func": "function pendingRequestExists(uint64 subId) public view returns (bool) {\n    SubscriptionConfig memory subConfig = s_subscriptionConfigs[subId];\n    for (uint256 i = 0; i < subConfig.consumers.length; i++) {\n      for (uint256 j = 0; j < s_provingKeyHashes.length; j++) {\n        (uint256 reqId, ) = computeRequestId(\n          s_provingKeyHashes[j],\n          subConfig.consumers[i],\n          subId,\n          s_consumers[subConfig.consumers[i]][subId]\n        );\n        if (s_requestCommitments[reqId] != 0) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }",
        "comments": [
            "/*",
            "   * @noticeCheck to see if there exists a request commitment consumers",
            "   * for all consumers and keyhashes for a given sub.",
            "   * @param subId where to send the funds",
            "   * @return exits true if outstanding requests",
            "   * @dev Looping is bounded to MAX_CONSUMERS*(number of keyhashes).",
            "   * @dev Used to disable subscription canceling while outstanding request are present.",
            "   */",
            ""
        ],
        "comt": "/*\n   * @noticeCheck to see if there exists a request commitment consumers\n   * for all consumers and keyhashes for a given sub.\n   * @param subId where to send the funds\n   * @return exits true if outstanding requests\n   * @dev Looping is bounded to MAX_CONSUMERS*(number of keyhashes).\n   * @dev Used to disable subscription canceling while outstanding request are present.\n   */\n",
        "@noticeCheck": "to see if there exists a request commitment consumers * for all consumers and keyhashes for a given sub.",
        "@param1": "subId where to send the funds",
        "@return1": "exits true if outstanding requests",
        "@dev": "Looping is bounded to MAX_CONSUMERS*(number of keyhashes). * Used to disable subscription canceling while outstanding request are present.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "typeAndVersion",
        "visibility": "external",
        "args": [],
        "func": "function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"VRFCoordinatorV2 1.0.0\";\n  }",
        "comments": [
            "/**",
            "   * @notice The type and version of this contract",
            "   * @return Type and version string",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice The type and version of this contract\n   * @return Type and version string\n   */\n",
        "@notice": "The type and version of this contract",
        "@return1": "Type and version string",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferOwnership",
        "visibility": "public",
        "args": [
            {
                "name": "to",
                "type": "address"
            }
        ],
        "func": "function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }",
        "comments": [
            "/**",
            "   * @notice Allows an owner to begin transferring ownership to a new address,",
            "   * pending.",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n",
        "@notice": "Allows an owner to begin transferring ownership to a new address, * pending.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "acceptOwnership",
        "visibility": "external",
        "args": [],
        "func": "function acceptOwnership() external override {\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }",
        "comments": [
            "/**",
            "   * @notice Allows an ownership transfer to be completed by the recipient.",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Allows an ownership transfer to be completed by the recipient.\n   */\n",
        "@notice": "Allows an ownership transfer to be completed by the recipient.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "owner",
        "visibility": "public",
        "args": [],
        "func": "function owner() public view override returns (address) {\n    return s_owner;\n  }",
        "comments": [
            "/**",
            "   * @notice Get the current owner",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Get the current owner\n   */\n",
        "@notice": "Get the current owner",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "calculatePaymentAmountTest",
        "visibility": "external",
        "args": [
            {
                "name": "gasAfterPaymentCalculation",
                "type": "uint256"
            },
            {
                "name": "fulfillmentFlatFeeLinkPPM",
                "type": "uint32"
            },
            {
                "name": "weiPerUnitGas",
                "type": "uint256"
            }
        ],
        "func": "function calculatePaymentAmountTest(\n    uint256 gasAfterPaymentCalculation,\n    uint32 fulfillmentFlatFeeLinkPPM,\n    uint256 weiPerUnitGas\n  ) external {\n    s_paymentAmount = calculatePaymentAmount(\n      gasleft(),\n      gasAfterPaymentCalculation,\n      fulfillmentFlatFeeLinkPPM,\n      weiPerUnitGas\n    );\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPaymentAmount",
        "visibility": "public",
        "args": [],
        "func": "function getPaymentAmount() public view returns (uint96) {\n    return s_paymentAmount;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getGasStart",
        "visibility": "public",
        "args": [],
        "func": "function getGasStart() public view returns (uint256) {\n    return s_gasStart;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "validate",
        "visibility": "external",
        "args": [
            {
                "name": "previousRoundId",
                "type": "uint256"
            },
            {
                "name": "previousAnswer",
                "type": "int256"
            },
            {
                "name": "currentRoundId",
                "type": "uint256"
            },
            {
                "name": "currentAnswer",
                "type": "int256"
            }
        ],
        "func": "function validate(\n    uint256 previousRoundId,\n    int256 previousAnswer,\n    uint256 currentRoundId,\n    int256 currentAnswer\n  ) external override returns (bool) {\n    address currentAggregator = s_currentAggregator.target;\n    if (msg.sender != currentAggregator) {\n      address proposedAggregator = s_proposedAggregator;\n      require(msg.sender == proposedAggregator, \"Not a configured aggregator\");\n      // If the aggregator is still in proposed state, emit an event and don't push to any validator.\n      // This is to confirm that `validate` is being called prior to upgrade.\n      emit ProposedAggregatorValidateCall(\n        proposedAggregator,\n        previousRoundId,\n        previousAnswer,\n        currentRoundId,\n        currentAnswer\n      );\n      return true;\n    }\n\n    // Send the validate call to the current validator\n    ValidatorConfiguration memory currentValidator = s_currentValidator;\n    address currentValidatorAddress = address(currentValidator.target);\n    require(currentValidatorAddress != address(0), \"No validator set\");\n    currentValidatorAddress.call(\n      abi.encodeWithSelector(\n        AggregatorValidatorInterface.validate.selector,\n        previousRoundId,\n        previousAnswer,\n        currentRoundId,\n        currentAnswer\n      )\n    );\n    // If there is a new proposed validator, send the validate call to that validator also\n    if (currentValidator.hasNewProposal) {\n      address(s_proposedValidator).call(\n        abi.encodeWithSelector(\n          AggregatorValidatorInterface.validate.selector,\n          previousRoundId,\n          previousAnswer,\n          currentRoundId,\n          currentAnswer\n        )\n      );\n    }\n    return true;\n  }",
        "comments": [
            "/**",
            "   * @notice Validate a transmission",
            "   * @dev Must be called by either the `s_currentAggregator.target`, or the `s_proposedAggregator`.",
            "   * If called by the `s_currentAggregator.target` this function passes the call on to the `s_currentValidator.target`",
            "   * and the `s_proposedValidator`, if it is set.",
            "   * If called by the `s_proposedAggregator` this function emits a `ProposedAggregatorValidateCall` to signal that",
            "   * the call was received.",
            "   * @dev To guard against external `validate` calls reverting, we use raw calls here.",
            "   * We favour `call` over try-catch to ensure that failures are avoided even if the validator address is incorrectly",
            "   * set as a non-contract address.",
            "   * @dev If the `aggregator` and `validator` are the same contract or collude, this could exhibit reentrancy behavior.",
            "   * However, since that contract would have to be explicitly written for reentrancy and that the `owner` would have",
            "   * to configure this contract to use that malicious contract, we refrain from using mutex or check here.",
            "   * @dev This does not perform any checks on any roundId, so it is possible that a validator receive different reports",
            "   * for the same roundId at different points in time. Validator implementations should be aware of this.",
            "   * @param previousRoundId uint256",
            "   * @param previousAnswer int256",
            "   * @param currentRoundId uint256",
            "   * @param currentAnswer int256",
            "   * @return bool",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Validate a transmission\n   * @dev Must be called by either the `s_currentAggregator.target`, or the `s_proposedAggregator`.\n   * If called by the `s_currentAggregator.target` this function passes the call on to the `s_currentValidator.target`\n   * and the `s_proposedValidator`, if it is set.\n   * If called by the `s_proposedAggregator` this function emits a `ProposedAggregatorValidateCall` to signal that\n   * the call was received.\n   * @dev To guard against external `validate` calls reverting, we use raw calls here.\n   * We favour `call` over try-catch to ensure that failures are avoided even if the validator address is incorrectly\n   * set as a non-contract address.\n   * @dev If the `aggregator` and `validator` are the same contract or collude, this could exhibit reentrancy behavior.\n   * However, since that contract would have to be explicitly written for reentrancy and that the `owner` would have\n   * to configure this contract to use that malicious contract, we refrain from using mutex or check here.\n   * @dev This does not perform any checks on any roundId, so it is possible that a validator receive different reports\n   * for the same roundId at different points in time. Validator implementations should be aware of this.\n   * @param previousRoundId uint256\n   * @param previousAnswer int256\n   * @param currentRoundId uint256\n   * @param currentAnswer int256\n   * @return bool\n   */\n",
        "@notice": "Validate a transmission",
        "@dev": "Must be called by either the `s_currentAggregator.target`, or the `s_proposedAggregator`. * If called by the `s_currentAggregator.target` this function passes the call on to the `s_currentValidator.target` * and the `s_proposedValidator`, if it is set. * If called by the `s_proposedAggregator` this function emits a `ProposedAggregatorValidateCall` to signal that * the call was received. * To guard against external `validate` calls reverting, we use raw calls here. * We favour `call` over try-catch to ensure that failures are avoided even if the validator address is incorrectly * set as a non-contract address. * If the `aggregator` and `validator` are the same contract or collude, this could exhibit reentrancy behavior. * However, since that contract would have to be explicitly written for reentrancy and that the `owner` would have * to configure this contract to use that malicious contract, we refrain from using mutex or check here. * This does not perform any checks on any roundId, so it is possible that a validator receive different reports * for the same roundId at different points in time. Validator implementations should be aware of this.",
        "@param1": "previousRoundId uint256",
        "@param2": "previousAnswer int256",
        "@param3": "currentRoundId uint256",
        "@param4": "currentAnswer int256",
        "@return1": "bool",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "proposeNewAggregator",
        "visibility": "external",
        "args": [
            {
                "name": "proposed",
                "type": "address"
            }
        ],
        "func": "function proposeNewAggregator(address proposed) external onlyOwner {\n    require(s_proposedAggregator != proposed && s_currentAggregator.target != proposed, \"Invalid proposal\");\n    s_proposedAggregator = proposed;\n    // If proposed is zero address, hasNewProposal = false\n    s_currentAggregator.hasNewProposal = (proposed != address(0));\n    emit AggregatorProposed(proposed);\n  }",
        "comments": [
            "/**",
            "   * @notice Propose an aggregator",
            "   * @dev A zero address can be used to unset the proposed aggregator. Only owner can call.",
            "   * @param proposed address",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Propose an aggregator\n   * @dev A zero address can be used to unset the proposed aggregator. Only owner can call.\n   * @param proposed address\n   */\n",
        "@notice": "Propose an aggregator",
        "@dev": "A zero address can be used to unset the proposed aggregator. Only owner can call.",
        "@param1": "proposed address",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "upgradeAggregator",
        "visibility": "external",
        "args": [],
        "func": "function upgradeAggregator() external onlyOwner {\n    // Get configuration in memory\n    AggregatorConfiguration memory current = s_currentAggregator;\n    address previous = current.target;\n    address proposed = s_proposedAggregator;\n\n    // Perform the upgrade\n    require(current.hasNewProposal, \"No proposal\");\n    s_currentAggregator = AggregatorConfiguration({target: proposed, hasNewProposal: false});\n    delete s_proposedAggregator;\n\n    emit AggregatorUpgraded(previous, proposed);\n  }",
        "comments": [
            "/**",
            "   * @notice Upgrade the aggregator by setting the current aggregator as the proposed aggregator.",
            "   * @dev Must have a proposed aggregator. Only owner can call.",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Upgrade the aggregator by setting the current aggregator as the proposed aggregator.\n   * @dev Must have a proposed aggregator. Only owner can call.\n   */\n",
        "@notice": "Upgrade the aggregator by setting the current aggregator as the proposed aggregator.",
        "@dev": "Must have a proposed aggregator. Only owner can call.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAggregators",
        "visibility": "external",
        "args": [],
        "func": "function getAggregators()\n    external\n    view\n    returns (\n      address current,\n      bool hasProposal,\n      address proposed\n    )\n  {\n    current = s_currentAggregator.target;\n    hasProposal = s_currentAggregator.hasNewProposal;\n    proposed = s_proposedAggregator;\n  }",
        "comments": [
            "/**",
            "   * @notice Get aggregator details",
            "   * @return current address",
            "   * @return hasProposal bool",
            "   * @return proposed address",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Get aggregator details\n   * @return current address\n   * @return hasProposal bool\n   * @return proposed address\n   */\n",
        "@notice": "Get aggregator details",
        "@return1": "current address",
        "@return2": "hasProposal bool",
        "@return3": "proposed address",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "proposeNewValidator",
        "visibility": "external",
        "args": [
            {
                "name": "proposed",
                "type": "AggregatorValidatorInterface"
            }
        ],
        "func": "function proposeNewValidator(AggregatorValidatorInterface proposed) external onlyOwner {\n    require(s_proposedValidator != proposed && s_currentValidator.target != proposed, \"Invalid proposal\");\n    s_proposedValidator = proposed;\n    // If proposed is zero address, hasNewProposal = false\n    s_currentValidator.hasNewProposal = (address(proposed) != address(0));\n    emit ValidatorProposed(proposed);\n  }",
        "comments": [
            "/**",
            "   * @notice Propose an validator",
            "   * @dev A zero address can be used to unset the proposed validator. Only owner can call.",
            "   * @param proposed address",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Propose an validator\n   * @dev A zero address can be used to unset the proposed validator. Only owner can call.\n   * @param proposed address\n   */\n",
        "@notice": "Propose an validator",
        "@dev": "A zero address can be used to unset the proposed validator. Only owner can call.",
        "@param1": "proposed address",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "upgradeValidator",
        "visibility": "external",
        "args": [],
        "func": "function upgradeValidator() external onlyOwner {\n    // Get configuration in memory\n    ValidatorConfiguration memory current = s_currentValidator;\n    AggregatorValidatorInterface previous = current.target;\n    AggregatorValidatorInterface proposed = s_proposedValidator;\n\n    // Perform the upgrade\n    require(current.hasNewProposal, \"No proposal\");\n    s_currentValidator = ValidatorConfiguration({target: proposed, hasNewProposal: false});\n    delete s_proposedValidator;\n\n    emit ValidatorUpgraded(previous, proposed);\n  }",
        "comments": [
            "/**",
            "   * @notice Upgrade the validator by setting the current validator as the proposed validator.",
            "   * @dev Must have a proposed validator. Only owner can call.",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Upgrade the validator by setting the current validator as the proposed validator.\n   * @dev Must have a proposed validator. Only owner can call.\n   */\n",
        "@notice": "Upgrade the validator by setting the current validator as the proposed validator.",
        "@dev": "Must have a proposed validator. Only owner can call.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getValidators",
        "visibility": "external",
        "args": [],
        "func": "function getValidators()\n    external\n    view\n    returns (\n      AggregatorValidatorInterface current,\n      bool hasProposal,\n      AggregatorValidatorInterface proposed\n    )\n  {\n    current = s_currentValidator.target;\n    hasProposal = s_currentValidator.hasNewProposal;\n    proposed = s_proposedValidator;\n  }",
        "comments": [
            "/**",
            "   * @notice Get validator details",
            "   * @return current address",
            "   * @return hasProposal bool",
            "   * @return proposed address",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Get validator details\n   * @return current address\n   * @return hasProposal bool\n   * @return proposed address\n   */\n",
        "@notice": "Get validator details",
        "@return1": "current address",
        "@return2": "hasProposal bool",
        "@return3": "proposed address",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "typeAndVersion",
        "visibility": "external",
        "args": [],
        "func": "function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"ValidatorProxy 1.0.0\";\n  }",
        "comments": [
            "/**",
            "   * @notice The type and version of this contract",
            "   * @return Type and version string",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice The type and version of this contract\n   * @return Type and version string\n   */\n",
        "@notice": "The type and version of this contract",
        "@return1": "Type and version string",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "typeAndVersion",
        "visibility": "external",
        "args": [],
        "func": "function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"OptimismValidator 0.1.0\";\n  }",
        "comments": [
            "/**",
            "   * @notice versions:",
            "   *",
            "   * - OptimismValidator 0.1.0: initial release",
            "   *",
            "   * @inheritdoc TypeAndVersionInterface",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice versions:\n   *\n   * - OptimismValidator 0.1.0: initial release\n   *\n   * @inheritdoc TypeAndVersionInterface\n   */\n",
        "@notice": "versions: * * - OptimismValidator 0.1.0: initial release",
        "@inheritdoc": "TypeAndVersionInterface",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 1
    },
    {
        "name": "validate",
        "visibility": "external",
        "args": [
            {
                "name": "uint256",
                "type": "uint256"
            },
            {
                "name": "previousAnswer",
                "type": "/* previousRoundId */\n    int256"
            },
            {
                "name": "uint256",
                "type": "uint256"
            },
            {
                "name": "currentAnswer",
                "type": "/* currentRoundId */\n    int256"
            }
        ],
        "func": "function validate(\n    uint256, /* previousRoundId */\n    int256 previousAnswer,\n    uint256, /* currentRoundId */\n    int256 currentAnswer\n  ) external override checkAccess returns (bool) {\n    // Avoids resending to L2 the same tx on every call\n    if (previousAnswer == currentAnswer) {\n      return true; // noop\n    }\n\n    // Encode the Forwarder call\n    bytes4 selector = ForwarderInterface.forward.selector;\n    address target = L2_FLAGS;\n    // Choose and encode the underlying Flags call\n    bytes memory data = currentAnswer == ANSWER_SEQ_OFFLINE ? CALL_RAISE_FLAG : CALL_LOWER_FLAG;\n    bytes memory message = abi.encodeWithSelector(selector, target, data);\n    // Make the xDomain call\n    iOVM_CrossDomainMessenger(CROSS_DOMAIN_MESSENGER).sendMessage(L2_CROSS_DOMAIN_FORWARDER, message, CALL_GAS_LIMIT);\n    // return success\n    return true;\n  }",
        "comments": [
            "/**",
            "   * @notice validate method sends an xDomain L2 tx to update Flags contract, in case of change from `previousAnswer`.",
            "   * @dev A message is sent via the Optimism CrossDomainMessenger L1 contract. The \"payment\" for L2 execution happens on L1,",
            "   *   using the gas attached to this tx (some extra gas is burned by the Optimism bridge to avoid DoS attacks).",
            "   *   This method is accessed controlled.",
            "   * @param previousAnswer previous aggregator answer",
            "   * @param currentAnswer new aggregator answer - value of 1 considers the service offline.",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice validate method sends an xDomain L2 tx to update Flags contract, in case of change from `previousAnswer`.\n   * @dev A message is sent via the Optimism CrossDomainMessenger L1 contract. The \"payment\" for L2 execution happens on L1,\n   *   using the gas attached to this tx (some extra gas is burned by the Optimism bridge to avoid DoS attacks).\n   *   This method is accessed controlled.\n   * @param previousAnswer previous aggregator answer\n   * @param currentAnswer new aggregator answer - value of 1 considers the service offline.\n   */\n",
        "@notice": "validate method sends an xDomain L2 tx to update Flags contract, in case of change from `previousAnswer`.",
        "@dev": "A message is sent via the Optimism CrossDomainMessenger L1 contract. The \"payment\" for L2 execution happens on L1, * using the gas attached to this tx (some extra gas is burned by the Optimism bridge to avoid DoS attacks). * This method is accessed controlled.",
        "@param1": "previousAnswer previous aggregator answer",
        "@param2": "currentAnswer new aggregator answer - value of 1 considers the service offline.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "hasAccess",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            },
            {
                "name": "memory",
                "type": "bytes"
            }
        ],
        "func": "function hasAccess(address _user, bytes memory) public view virtual override returns (bool) {\n    return accessList[_user] || !checkEnabled;\n  }",
        "comments": [
            "/**",
            "   * @notice Returns the access of an address",
            "   * @param _user The address to query",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Returns the access of an address\n   * @param _user The address to query\n   */\n",
        "@notice": "Returns the access of an address",
        "@param1": "_user The address to query",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addAccess",
        "visibility": "external",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function addAccess(address _user) external onlyOwner {\n    if (!accessList[_user]) {\n      accessList[_user] = true;\n\n      emit AddedAccess(_user);\n    }\n  }",
        "comments": [
            "/**",
            "   * @notice Adds an address to the access list",
            "   * @param _user The address to add",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Adds an address to the access list\n   * @param _user The address to add\n   */\n",
        "@notice": "Adds an address to the access list",
        "@param1": "_user The address to add",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeAccess",
        "visibility": "external",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function removeAccess(address _user) external onlyOwner {\n    if (accessList[_user]) {\n      accessList[_user] = false;\n\n      emit RemovedAccess(_user);\n    }\n  }",
        "comments": [
            "/**",
            "   * @notice Removes an address from the access list",
            "   * @param _user The address to remove",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Removes an address from the access list\n   * @param _user The address to remove\n   */\n",
        "@notice": "Removes an address from the access list",
        "@param1": "_user The address to remove",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "enableAccessCheck",
        "visibility": "external",
        "args": [],
        "func": "function enableAccessCheck() external onlyOwner {\n    if (!checkEnabled) {\n      checkEnabled = true;\n\n      emit CheckAccessEnabled();\n    }\n  }",
        "comments": [
            "/**",
            "   * @notice makes the access check enforced",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice makes the access check enforced\n   */\n",
        "@notice": "makes the access check enforced",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "disableAccessCheck",
        "visibility": "external",
        "args": [],
        "func": "function disableAccessCheck() external onlyOwner {\n    if (checkEnabled) {\n      checkEnabled = false;\n\n      emit CheckAccessDisabled();\n    }\n  }",
        "comments": [
            "/**",
            "   * @notice makes the access check unenforced",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice makes the access check unenforced\n   */\n",
        "@notice": "makes the access check unenforced",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "typeAndVersion",
        "visibility": "external",
        "args": [],
        "func": "function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"OptimismCrossDomainForwarder 0.1.0\";\n  }",
        "comments": [
            "/**",
            "   * @notice versions:",
            "   *",
            "   * - OptimismCrossDomainForwarder 0.1.0: initial release",
            "   *",
            "   * @inheritdoc TypeAndVersionInterface",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice versions:\n   *\n   * - OptimismCrossDomainForwarder 0.1.0: initial release\n   *\n   * @inheritdoc TypeAndVersionInterface\n   */\n",
        "@notice": "versions: * * - OptimismCrossDomainForwarder 0.1.0: initial release",
        "@inheritdoc": "TypeAndVersionInterface",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 1
    },
    {
        "name": "forward",
        "visibility": "external",
        "args": [
            {
                "name": "target",
                "type": "address"
            },
            {
                "name": "data",
                "type": "bytes memory"
            }
        ],
        "func": "function forward(address target, bytes memory data) external override {\n    // 1. The call MUST come from the L1 Messenger\n    require(msg.sender == OVM_CROSS_DOMAIN_MESSENGER, \"Sender is not the L2 messenger\");\n    // 2. The L1 Messenger's caller MUST be the L1 Owner\n    require(\n      iOVM_CrossDomainMessenger(OVM_CROSS_DOMAIN_MESSENGER).xDomainMessageSender() == l1Owner(),\n      \"xDomain sender is not the L1 owner\"\n    );\n    // 3. Make the external call\n    (bool success, bytes memory res) = target.call(data);\n    require(success, string(abi.encode(\"xDomain call failed:\", res)));\n  }",
        "comments": [
            "/**",
            "   * @dev forwarded only if L2 Messenger calls with `xDomainMessageSender` beeing the L1 owner address",
            "   * @inheritdoc ForwarderInterface",
            "   */",
            ""
        ],
        "comt": "/**\n   * @dev forwarded only if L2 Messenger calls with `xDomainMessageSender` beeing the L1 owner address\n   * @inheritdoc ForwarderInterface\n   */\n",
        "@dev": "forwarded only if L2 Messenger calls with `xDomainMessageSender` beeing the L1 owner address",
        "@inheritdoc": "ForwarderInterface",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "crossDomainMessenger",
        "visibility": "public",
        "args": [],
        "func": "function crossDomainMessenger() public view virtual override returns (address) {\n    return OVM_CROSS_DOMAIN_MESSENGER;\n  }",
        "comments": [
            "/**",
            "   * @notice This is always the address of the OVM_L2CrossDomainMessenger contract",
            "   * @inheritdoc CrossDomainForwarder",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice This is always the address of the OVM_L2CrossDomainMessenger contract\n   * @inheritdoc CrossDomainForwarder\n   */\n",
        "@notice": "This is always the address of the OVM_L2CrossDomainMessenger contract",
        "@inheritdoc": "CrossDomainForwarder",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 1
    },
    {
        "name": "l1Owner",
        "visibility": "public",
        "args": [],
        "func": "function l1Owner() public view virtual returns (address) {\n    return s_l1Owner;\n  }",
        "comments": [
            "",
            "  /// @return L1 owner address",
            "  "
        ],
        "comt": "\n  /// @return L1 owner address\n  ",
        "@return1": "L1 owner address",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferL1Ownership",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            }
        ],
        "func": "function transferL1Ownership(address to) external virtual onlyOwner {\n    _setL1Owner(to);\n  }",
        "comments": [
            "/**",
            "   * @notice transfer ownership of this account to a new L1 owner",
            "   * @dev Forwarding can be disabled by setting the L1 owner as `address(0)`. Accessible only by owner.",
            "   * @param to new L1 owner that will be allowed to call the forward fn",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice transfer ownership of this account to a new L1 owner\n   * @dev Forwarding can be disabled by setting the L1 owner as `address(0)`. Accessible only by owner.\n   * @param to new L1 owner that will be allowed to call the forward fn\n   */\n",
        "@notice": "transfer ownership of this account to a new L1 owner",
        "@dev": "Forwarding can be disabled by setting the L1 owner as `address(0)`. Accessible only by owner.",
        "@param1": "to new L1 owner that will be allowed to call the forward fn",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "typeAndVersion",
        "visibility": "external",
        "args": [],
        "func": "function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"ArbitrumValidator 0.2.0\";\n  }",
        "comments": [
            "/**",
            "   * @notice versions:",
            "   *",
            "   * - ArbitrumValidator 0.1.0: initial release",
            "   * - ArbitrumValidator 0.2.0: critical Arbitrum network update",
            "   *   - xDomain `msg.sender` backwards incompatible change (now an alias address)",
            "   *   - new `withdrawFundsFromL2` fn that withdraws from L2 xDomain alias address",
            "   *   - approximation of `maxSubmissionCost` using a L1 gas price feed",
            "   *",
            "   * @inheritdoc TypeAndVersionInterface",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice versions:\n   *\n   * - ArbitrumValidator 0.1.0: initial release\n   * - ArbitrumValidator 0.2.0: critical Arbitrum network update\n   *   - xDomain `msg.sender` backwards incompatible change (now an alias address)\n   *   - new `withdrawFundsFromL2` fn that withdraws from L2 xDomain alias address\n   *   - approximation of `maxSubmissionCost` using a L1 gas price feed\n   *\n   * @inheritdoc TypeAndVersionInterface\n   */\n",
        "@notice": "versions: * * - ArbitrumValidator 0.1.0: initial release * - ArbitrumValidator 0.2.0: critical Arbitrum network update * - xDomain `msg.sender` backwards incompatible change (now an alias address) * - new `withdrawFundsFromL2` fn that withdraws from L2 xDomain alias address * - approximation of `maxSubmissionCost` using a L1 gas price feed",
        "@inheritdoc": "TypeAndVersionInterface",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 1
    },
    {
        "name": "paymentStrategy",
        "visibility": "external",
        "args": [],
        "func": "function paymentStrategy() external view virtual returns (PaymentStrategy) {\n    return s_paymentStrategy;\n  }",
        "comments": [
            "",
            "  /// @return stored PaymentStrategy",
            "  "
        ],
        "comt": "\n  /// @return stored PaymentStrategy\n  ",
        "@return1": "stored PaymentStrategy",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "gasConfig",
        "visibility": "external",
        "args": [],
        "func": "function gasConfig() external view virtual returns (GasConfig memory) {\n    return s_gasConfig;\n  }",
        "comments": [
            "",
            "  /// @return stored GasConfig",
            "  "
        ],
        "comt": "\n  /// @return stored GasConfig\n  ",
        "@return1": "stored GasConfig",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "configAC",
        "visibility": "external",
        "args": [],
        "func": "function configAC() external view virtual returns (address) {\n    return address(s_configAC);\n  }",
        "comments": [
            "",
            "  /// @return config AccessControllerInterface contract address",
            "  "
        ],
        "comt": "\n  /// @return config AccessControllerInterface contract address\n  ",
        "@return1": "config AccessControllerInterface contract address",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawFunds",
        "visibility": "external",
        "args": [],
        "func": "function withdrawFunds() external onlyOwner {\n    address payable recipient = payable(msg.sender);\n    uint256 amount = address(this).balance;\n    Address.sendValue(recipient, amount);\n  }",
        "comments": [
            "/**",
            "   * @notice withdraws all funds available in this contract to the msg.sender",
            "   * @dev only owner can call this",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice withdraws all funds available in this contract to the msg.sender\n   * @dev only owner can call this\n   */\n",
        "@notice": "withdraws all funds available in this contract to the msg.sender",
        "@dev": "only owner can call this",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawFundsTo",
        "visibility": "external",
        "args": [
            {
                "name": "recipient",
                "type": "address payable"
            }
        ],
        "func": "function withdrawFundsTo(address payable recipient) external onlyOwner {\n    uint256 amount = address(this).balance;\n    Address.sendValue(recipient, amount);\n  }",
        "comments": [
            "/**",
            "   * @notice withdraws all funds available in this contract to the address specified",
            "   * @dev only owner can call this",
            "   * @param recipient address where to send the funds",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice withdraws all funds available in this contract to the address specified\n   * @dev only owner can call this\n   * @param recipient address where to send the funds\n   */\n",
        "@notice": "withdraws all funds available in this contract to the address specified",
        "@dev": "only owner can call this",
        "@param1": "recipient address where to send the funds",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawFundsFromL2",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            },
            {
                "name": "refundAddr",
                "type": "address"
            }
        ],
        "func": "function withdrawFundsFromL2(uint256 amount, address refundAddr) external onlyOwner returns (uint256 id) {\n    // Build an xDomain message to trigger the ArbSys precompile, which will create a L2 -> L1 tx transferring `amount`\n    bytes memory message = abi.encodeWithSelector(ArbSys.withdrawEth.selector, address(this));\n    // Make the xDomain call\n    // NOTICE: We approximate the max submission cost of sending a retryable tx with specific calldata length.\n    uint256 maxSubmissionCost = _approximateMaxSubmissionCost(message.length);\n    uint256 maxGas = 120_000; // static `maxGas` for L2 -> L1 transfer\n    uint256 gasPriceBid = s_gasConfig.gasPriceBid;\n    uint256 l1PaymentValue = s_paymentStrategy == PaymentStrategy.L1\n      ? _maxRetryableTicketCost(maxSubmissionCost, maxGas, gasPriceBid)\n      : 0;\n    // NOTICE: In the case of PaymentStrategy.L2 the L2 xDomain alias address needs to be funded, as it will be paying the fee.\n    id = IInbox(CROSS_DOMAIN_MESSENGER).createRetryableTicketNoRefundAliasRewrite{value: l1PaymentValue}(\n      ARBSYS_ADDR, // target\n      amount, // L2 call value (requested)\n      maxSubmissionCost,\n      refundAddr, // excessFeeRefundAddress\n      refundAddr, // callValueRefundAddress\n      maxGas,\n      gasPriceBid,\n      message\n    );\n    emit L2WithdrawalRequested(id, amount, refundAddr);\n  }",
        "comments": [
            "/**",
            "   * @notice withdraws funds from L2 xDomain alias address (representing this L1 contract)",
            "   * @dev only owner can call this",
            "   * @param amount of funds to withdraws",
            "   * @param refundAddr address where gas excess on L2 will be sent",
            "   *   WARNING: `refundAddr` is not aliased! Make sure you can recover the refunded funds on L2.",
            "   * @return id unique id of the published retryable transaction (keccak256(requestID, uint(0))",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice withdraws funds from L2 xDomain alias address (representing this L1 contract)\n   * @dev only owner can call this\n   * @param amount of funds to withdraws\n   * @param refundAddr address where gas excess on L2 will be sent\n   *   WARNING: `refundAddr` is not aliased! Make sure you can recover the refunded funds on L2.\n   * @return id unique id of the published retryable transaction (keccak256(requestID, uint(0))\n   */\n",
        "@notice": "withdraws funds from L2 xDomain alias address (representing this L1 contract)",
        "@dev": "only owner can call this",
        "@param1": "amount of funds to withdraws",
        "@param2": "refundAddr address where gas excess on L2 will be sent * WARNING: `refundAddr` is not aliased! Make sure you can recover the refunded funds on L2.",
        "@return1": "id unique id of the published retryable transaction (keccak256(requestID, uint(0))",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setConfigAC",
        "visibility": "external",
        "args": [
            {
                "name": "accessController",
                "type": "address"
            }
        ],
        "func": "function setConfigAC(address accessController) external onlyOwner {\n    _setConfigAC(accessController);\n  }",
        "comments": [
            "/**",
            "   * @notice sets config AccessControllerInterface contract",
            "   * @dev only owner can call this",
            "   * @param accessController new AccessControllerInterface contract address",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice sets config AccessControllerInterface contract\n   * @dev only owner can call this\n   * @param accessController new AccessControllerInterface contract address\n   */\n",
        "@notice": "sets config AccessControllerInterface contract",
        "@dev": "only owner can call this",
        "@param1": "accessController new AccessControllerInterface contract address",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setGasConfig",
        "visibility": "external",
        "args": [
            {
                "name": "maxGas",
                "type": "uint256"
            },
            {
                "name": "gasPriceBid",
                "type": "uint256"
            },
            {
                "name": "gasPriceL1FeedAddr",
                "type": "address"
            }
        ],
        "func": "function setGasConfig(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    address gasPriceL1FeedAddr\n  ) external onlyOwnerOrConfigAccess {\n    _setGasConfig(maxGas, gasPriceBid, gasPriceL1FeedAddr);\n  }",
        "comments": [
            "/**",
            "   * @notice sets Arbitrum gas configuration",
            "   * @dev access control provided by `configAC`",
            "   * @param maxGas gas limit for immediate L2 execution attempt. A value around 1M should be sufficient",
            "   * @param gasPriceBid maximum L2 gas price to pay",
            "   * @param gasPriceL1FeedAddr address of the L1 gas price feed (used to approximate Arbitrum retryable ticket submission cost)",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice sets Arbitrum gas configuration\n   * @dev access control provided by `configAC`\n   * @param maxGas gas limit for immediate L2 execution attempt. A value around 1M should be sufficient\n   * @param gasPriceBid maximum L2 gas price to pay\n   * @param gasPriceL1FeedAddr address of the L1 gas price feed (used to approximate Arbitrum retryable ticket submission cost)\n   */\n",
        "@notice": "sets Arbitrum gas configuration",
        "@dev": "access control provided by `configAC`",
        "@param1": "maxGas gas limit for immediate L2 execution attempt. A value around 1M should be sufficient",
        "@param2": "gasPriceBid maximum L2 gas price to pay",
        "@param3": "gasPriceL1FeedAddr address of the L1 gas price feed (used to approximate Arbitrum retryable ticket submission cost)",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setPaymentStrategy",
        "visibility": "external",
        "args": [
            {
                "name": "paymentStrategy",
                "type": "PaymentStrategy"
            }
        ],
        "func": "function setPaymentStrategy(PaymentStrategy paymentStrategy) external onlyOwnerOrConfigAccess {\n    _setPaymentStrategy(paymentStrategy);\n  }",
        "comments": [
            "/**",
            "   * @notice sets the payment strategy",
            "   * @dev access control provided by `configAC`",
            "   * @param paymentStrategy strategy describing how the contract pays for xDomain calls",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice sets the payment strategy\n   * @dev access control provided by `configAC`\n   * @param paymentStrategy strategy describing how the contract pays for xDomain calls\n   */\n",
        "@notice": "sets the payment strategy",
        "@dev": "access control provided by `configAC`",
        "@param1": "paymentStrategy strategy describing how the contract pays for xDomain calls",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "validate",
        "visibility": "external",
        "args": [
            {
                "name": "uint256",
                "type": "uint256"
            },
            {
                "name": "previousAnswer",
                "type": "/* previousRoundId */\n    int256"
            },
            {
                "name": "uint256",
                "type": "uint256"
            },
            {
                "name": "currentAnswer",
                "type": "/* currentRoundId */\n    int256"
            }
        ],
        "func": "function validate(\n    uint256, /* previousRoundId */\n    int256 previousAnswer,\n    uint256, /* currentRoundId */\n    int256 currentAnswer\n  ) external override checkAccess returns (bool) {\n    // Avoids resending to L2 the same tx on every call\n    if (previousAnswer == currentAnswer) {\n      return true;\n    }\n\n    // Excess gas on L2 will be sent to the L2 xDomain alias address of this contract\n    address refundAddr = L2_ALIAS;\n    // Encode the Forwarder call\n    bytes4 selector = ForwarderInterface.forward.selector;\n    address target = L2_FLAGS;\n    // Choose and encode the underlying Flags call\n    bytes memory data = currentAnswer == ANSWER_SEQ_OFFLINE ? CALL_RAISE_FLAG : CALL_LOWER_FLAG;\n    bytes memory message = abi.encodeWithSelector(selector, target, data);\n    // Make the xDomain call\n    // NOTICE: We approximate the max submission cost of sending a retryable tx with specific calldata length.\n    uint256 maxSubmissionCost = _approximateMaxSubmissionCost(message.length);\n    uint256 maxGas = s_gasConfig.maxGas;\n    uint256 gasPriceBid = s_gasConfig.gasPriceBid;\n    uint256 l1PaymentValue = s_paymentStrategy == PaymentStrategy.L1\n      ? _maxRetryableTicketCost(maxSubmissionCost, maxGas, gasPriceBid)\n      : 0;\n    // NOTICE: In the case of PaymentStrategy.L2 the L2 xDomain alias address needs to be funded, as it will be paying the fee.\n    // We also ignore the returned msg number, that can be queried via the `InboxMessageDelivered` event.\n    IInbox(CROSS_DOMAIN_MESSENGER).createRetryableTicketNoRefundAliasRewrite{value: l1PaymentValue}(\n      L2_CROSS_DOMAIN_FORWARDER, // target\n      0, // L2 call value\n      maxSubmissionCost,\n      refundAddr, // excessFeeRefundAddress\n      refundAddr, // callValueRefundAddress\n      maxGas,\n      gasPriceBid,\n      message\n    );\n    // return success\n    return true;\n  }",
        "comments": [
            "/**",
            "   * @notice validate method sends an xDomain L2 tx to update Flags contract, in case of change from `previousAnswer`.",
            "   * @dev A retryable ticket is created on the Arbitrum L1 Inbox contract. The tx gas fee can be paid from this",
            "   *   contract providing a value, or if no L1 value is sent with the xDomain message the gas will be paid by",
            "   *   the L2 xDomain alias account (generated from `address(this)`). This method is accessed controlled.",
            "   * @param previousAnswer previous aggregator answer",
            "   * @param currentAnswer new aggregator answer - value of 1 considers the service offline.",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice validate method sends an xDomain L2 tx to update Flags contract, in case of change from `previousAnswer`.\n   * @dev A retryable ticket is created on the Arbitrum L1 Inbox contract. The tx gas fee can be paid from this\n   *   contract providing a value, or if no L1 value is sent with the xDomain message the gas will be paid by\n   *   the L2 xDomain alias account (generated from `address(this)`). This method is accessed controlled.\n   * @param previousAnswer previous aggregator answer\n   * @param currentAnswer new aggregator answer - value of 1 considers the service offline.\n   */\n",
        "@notice": "validate method sends an xDomain L2 tx to update Flags contract, in case of change from `previousAnswer`.",
        "@dev": "A retryable ticket is created on the Arbitrum L1 Inbox contract. The tx gas fee can be paid from this * contract providing a value, or if no L1 value is sent with the xDomain message the gas will be paid by * the L2 xDomain alias account (generated from `address(this)`). This method is accessed controlled.",
        "@param1": "previousAnswer previous aggregator answer",
        "@param2": "currentAnswer new aggregator answer - value of 1 considers the service offline.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "typeAndVersion",
        "visibility": "external",
        "args": [],
        "func": "function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"ArbitrumCrossDomainForwarder 0.1.0\";\n  }",
        "comments": [
            "/**",
            "   * @notice versions:",
            "   *",
            "   * - ArbitrumCrossDomainForwarder 0.1.0: initial release",
            "   *",
            "   * @inheritdoc TypeAndVersionInterface",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice versions:\n   *\n   * - ArbitrumCrossDomainForwarder 0.1.0: initial release\n   *\n   * @inheritdoc TypeAndVersionInterface\n   */\n",
        "@notice": "versions: * * - ArbitrumCrossDomainForwarder 0.1.0: initial release",
        "@inheritdoc": "TypeAndVersionInterface",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 1
    },
    {
        "name": "crossDomainMessenger",
        "visibility": "public",
        "args": [],
        "func": "function crossDomainMessenger() public view virtual override returns (address) {\n    return AddressAliasHelper.applyL1ToL2Alias(l1Owner());\n  }",
        "comments": [
            "/**",
            "   * @notice The L2 xDomain `msg.sender`, generated from L1 sender address",
            "   * @inheritdoc CrossDomainForwarder",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice The L2 xDomain `msg.sender`, generated from L1 sender address\n   * @inheritdoc CrossDomainForwarder\n   */\n",
        "@notice": "The L2 xDomain `msg.sender`, generated from L1 sender address",
        "@inheritdoc": "CrossDomainForwarder",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "forward",
        "visibility": "external",
        "args": [
            {
                "name": "target",
                "type": "address"
            },
            {
                "name": "data",
                "type": "bytes memory"
            }
        ],
        "func": "function forward(address target, bytes memory data) external override {\n    // 1. The call MUST come from the L2 Messenger (deterministically generated from the L1 xDomain sender address)\n    require(msg.sender == crossDomainMessenger(), \"Sender is not the L2 messenger\");\n    // 2. Make the external call\n    (bool success, bytes memory res) = target.call(data);\n    require(success, string(abi.encode(\"xDomain call failed:\", res)));\n  }",
        "comments": [
            "/**",
            "   * @dev forwarded only if L2 Messenger calls with `xDomainMessageSender` beeing the L1 owner address",
            "   * @inheritdoc ForwarderInterface",
            "   */",
            ""
        ],
        "comt": "/**\n   * @dev forwarded only if L2 Messenger calls with `xDomainMessageSender` beeing the L1 owner address\n   * @inheritdoc ForwarderInterface\n   */\n",
        "@dev": "forwarded only if L2 Messenger calls with `xDomainMessageSender` beeing the L1 owner address",
        "@inheritdoc": "ForwarderInterface",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "typeAndVersion",
        "visibility": "external",
        "args": [],
        "func": "function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"Flags 1.1.0\";\n  }",
        "comments": [
            "/**",
            "   * @notice versions:",
            "   *",
            "   * - Flags 1.1.0: upgraded to solc 0.8, added lowering access controller",
            "   * - Flags 1.0.0: initial release",
            "   *",
            "   * @inheritdoc TypeAndVersionInterface",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice versions:\n   *\n   * - Flags 1.1.0: upgraded to solc 0.8, added lowering access controller\n   * - Flags 1.0.0: initial release\n   *\n   * @inheritdoc TypeAndVersionInterface\n   */\n",
        "@notice": "versions: * * - Flags 1.1.0: upgraded to solc 0.8, added lowering access controller * - Flags 1.0.0: initial release",
        "@inheritdoc": "TypeAndVersionInterface",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 1
    },
    {
        "name": "getFlag",
        "visibility": "external",
        "args": [
            {
                "name": "subject",
                "type": "address"
            }
        ],
        "func": "function getFlag(address subject) external view override checkAccess returns (bool) {\n    return flags[subject];\n  }",
        "comments": [
            "/**",
            "   * @notice read the warning flag status of a contract address.",
            "   * @param subject The contract address being checked for a flag.",
            "   * @return A true value indicates that a flag was raised and a",
            "   * false value indicates that no flag was raised.",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice read the warning flag status of a contract address.\n   * @param subject The contract address being checked for a flag.\n   * @return A true value indicates that a flag was raised and a\n   * false value indicates that no flag was raised.\n   */\n",
        "@notice": "read the warning flag status of a contract address.",
        "@param1": "subject The contract address being checked for a flag.",
        "@return1": "A true value indicates that a flag was raised and a * false value indicates that no flag was raised.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getFlags",
        "visibility": "external",
        "args": [
            {
                "name": "subjects",
                "type": "address[] calldata"
            }
        ],
        "func": "function getFlags(address[] calldata subjects) external view override checkAccess returns (bool[] memory) {\n    bool[] memory responses = new bool[](subjects.length);\n    for (uint256 i = 0; i < subjects.length; i++) {\n      responses[i] = flags[subjects[i]];\n    }\n    return responses;\n  }",
        "comments": [
            "/**",
            "   * @notice read the warning flag status of a contract address.",
            "   * @param subjects An array of addresses being checked for a flag.",
            "   * @return An array of bools where a true value for any flag indicates that",
            "   * a flag was raised and a false value indicates that no flag was raised.",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice read the warning flag status of a contract address.\n   * @param subjects An array of addresses being checked for a flag.\n   * @return An array of bools where a true value for any flag indicates that\n   * a flag was raised and a false value indicates that no flag was raised.\n   */\n",
        "@notice": "read the warning flag status of a contract address.",
        "@param1": "subjects An array of addresses being checked for a flag.",
        "@return1": "An array of bools where a true value for any flag indicates that * a flag was raised and a false value indicates that no flag was raised.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "raiseFlag",
        "visibility": "external",
        "args": [
            {
                "name": "subject",
                "type": "address"
            }
        ],
        "func": "function raiseFlag(address subject) external override {\n    require(_allowedToRaiseFlags(), \"Not allowed to raise flags\");\n\n    _tryToRaiseFlag(subject);\n  }",
        "comments": [
            "/**",
            "   * @notice enable the warning flag for an address.",
            "   * Access is controlled by raisingAccessController, except for owner",
            "   * who always has access.",
            "   * @param subject The contract address whose flag is being raised",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice enable the warning flag for an address.\n   * Access is controlled by raisingAccessController, except for owner\n   * who always has access.\n   * @param subject The contract address whose flag is being raised\n   */\n",
        "@notice": "enable the warning flag for an address. * Access is controlled by raisingAccessController, except for owner * who always has access.",
        "@param1": "subject The contract address whose flag is being raised",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "raiseFlags",
        "visibility": "external",
        "args": [
            {
                "name": "subjects",
                "type": "address[] calldata"
            }
        ],
        "func": "function raiseFlags(address[] calldata subjects) external override {\n    require(_allowedToRaiseFlags(), \"Not allowed to raise flags\");\n\n    for (uint256 i = 0; i < subjects.length; i++) {\n      _tryToRaiseFlag(subjects[i]);\n    }\n  }",
        "comments": [
            "/**",
            "   * @notice enable the warning flags for multiple addresses.",
            "   * Access is controlled by raisingAccessController, except for owner",
            "   * who always has access.",
            "   * @param subjects List of the contract addresses whose flag is being raised",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice enable the warning flags for multiple addresses.\n   * Access is controlled by raisingAccessController, except for owner\n   * who always has access.\n   * @param subjects List of the contract addresses whose flag is being raised\n   */\n",
        "@notice": "enable the warning flags for multiple addresses. * Access is controlled by raisingAccessController, except for owner * who always has access.",
        "@param1": "subjects List of the contract addresses whose flag is being raised",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lowerFlag",
        "visibility": "external",
        "args": [
            {
                "name": "subject",
                "type": "address"
            }
        ],
        "func": "function lowerFlag(address subject) external override {\n    require(_allowedToLowerFlags(), \"Not allowed to lower flags\");\n\n    _tryToLowerFlag(subject);\n  }",
        "comments": [
            "/**",
            "   * @notice allows owner to disable the warning flags for an addresses.",
            "   * Access is controlled by loweringAccessController, except for owner",
            "   * who always has access.",
            "   * @param subject The contract address whose flag is being lowered",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice allows owner to disable the warning flags for an addresses.\n   * Access is controlled by loweringAccessController, except for owner\n   * who always has access.\n   * @param subject The contract address whose flag is being lowered\n   */\n",
        "@notice": "allows owner to disable the warning flags for an addresses. * Access is controlled by loweringAccessController, except for owner * who always has access.",
        "@param1": "subject The contract address whose flag is being lowered",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lowerFlags",
        "visibility": "external",
        "args": [
            {
                "name": "subjects",
                "type": "address[] calldata"
            }
        ],
        "func": "function lowerFlags(address[] calldata subjects) external override {\n    require(_allowedToLowerFlags(), \"Not allowed to lower flags\");\n\n    for (uint256 i = 0; i < subjects.length; i++) {\n      address subject = subjects[i];\n\n      _tryToLowerFlag(subject);\n    }\n  }",
        "comments": [
            "/**",
            "   * @notice allows owner to disable the warning flags for multiple addresses.",
            "   * Access is controlled by loweringAccessController, except for owner",
            "   * who always has access.",
            "   * @param subjects List of the contract addresses whose flag is being lowered",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice allows owner to disable the warning flags for multiple addresses.\n   * Access is controlled by loweringAccessController, except for owner\n   * who always has access.\n   * @param subjects List of the contract addresses whose flag is being lowered\n   */\n",
        "@notice": "allows owner to disable the warning flags for multiple addresses. * Access is controlled by loweringAccessController, except for owner * who always has access.",
        "@param1": "subjects List of the contract addresses whose flag is being lowered",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setRaisingAccessController",
        "visibility": "public",
        "args": [
            {
                "name": "racAddress",
                "type": "address"
            }
        ],
        "func": "function setRaisingAccessController(address racAddress) public override onlyOwner {\n    address previous = address(raisingAccessController);\n\n    if (previous != racAddress) {\n      raisingAccessController = AccessControllerInterface(racAddress);\n\n      emit RaisingAccessControllerUpdated(previous, racAddress);\n    }\n  }",
        "comments": [
            "/**",
            "   * @notice allows owner to change the access controller for raising flags.",
            "   * @param racAddress new address for the raising access controller.",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice allows owner to change the access controller for raising flags.\n   * @param racAddress new address for the raising access controller.\n   */\n",
        "@notice": "allows owner to change the access controller for raising flags.",
        "@param1": "racAddress new address for the raising access controller.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setLoweringAccessController",
        "visibility": "public",
        "args": [
            {
                "name": "lacAddress",
                "type": "address"
            }
        ],
        "func": "function setLoweringAccessController(address lacAddress) public override onlyOwner {\n    address previous = address(loweringAccessController);\n\n    if (previous != lacAddress) {\n      loweringAccessController = AccessControllerInterface(lacAddress);\n\n      emit LoweringAccessControllerUpdated(previous, lacAddress);\n    }\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "hasAccess",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            },
            {
                "name": "_calldata",
                "type": "bytes memory"
            }
        ],
        "func": "function hasAccess(address _user, bytes memory _calldata) public view virtual override returns (bool) {\n    return super.hasAccess(_user, _calldata) || _user == tx.origin;\n  }",
        "comments": [
            "/**",
            "   * @notice Returns the access of an address",
            "   * @param _user The address to query",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Returns the access of an address\n   * @param _user The address to query\n   */\n",
        "@notice": "Returns the access of an address",
        "@param1": "_user The address to query",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getFlag",
        "visibility": "external",
        "args": [
            {
                "name": "subject",
                "type": "address"
            }
        ],
        "func": "function getFlag(address subject) external view override checkAccess returns (bool) {\n    return flags[subject];\n  }",
        "comments": [
            "/**",
            "   * @notice read the warning flag status of a contract address.",
            "   * @param subject The contract address being checked for a flag.",
            "   * @return A true value indicates that a flag was raised and a",
            "   * false value indicates that no flag was raised.",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice read the warning flag status of a contract address.\n   * @param subject The contract address being checked for a flag.\n   * @return A true value indicates that a flag was raised and a\n   * false value indicates that no flag was raised.\n   */\n",
        "@notice": "read the warning flag status of a contract address.",
        "@param1": "subject The contract address being checked for a flag.",
        "@return1": "A true value indicates that a flag was raised and a * false value indicates that no flag was raised.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getFlags",
        "visibility": "external",
        "args": [
            {
                "name": "subjects",
                "type": "address[] calldata"
            }
        ],
        "func": "function getFlags(address[] calldata subjects) external view override checkAccess returns (bool[] memory) {\n    bool[] memory responses = new bool[](subjects.length);\n    for (uint256 i = 0; i < subjects.length; i++) {\n      responses[i] = flags[subjects[i]];\n    }\n    return responses;\n  }",
        "comments": [
            "/**",
            "   * @notice read the warning flag status of a contract address.",
            "   * @param subjects An array of addresses being checked for a flag.",
            "   * @return An array of bools where a true value for any flag indicates that",
            "   * a flag was raised and a false value indicates that no flag was raised.",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice read the warning flag status of a contract address.\n   * @param subjects An array of addresses being checked for a flag.\n   * @return An array of bools where a true value for any flag indicates that\n   * a flag was raised and a false value indicates that no flag was raised.\n   */\n",
        "@notice": "read the warning flag status of a contract address.",
        "@param1": "subjects An array of addresses being checked for a flag.",
        "@return1": "An array of bools where a true value for any flag indicates that * a flag was raised and a false value indicates that no flag was raised.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "raiseFlag",
        "visibility": "external",
        "args": [
            {
                "name": "subject",
                "type": "address"
            }
        ],
        "func": "function raiseFlag(address subject) external override {\n    require(allowedToRaiseFlags(), \"Not allowed to raise flags\");\n\n    tryToRaiseFlag(subject);\n  }",
        "comments": [
            "/**",
            "   * @notice enable the warning flag for an address.",
            "   * Access is controlled by raisingAccessController, except for owner",
            "   * who always has access.",
            "   * @param subject The contract address whose flag is being raised",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice enable the warning flag for an address.\n   * Access is controlled by raisingAccessController, except for owner\n   * who always has access.\n   * @param subject The contract address whose flag is being raised\n   */\n",
        "@notice": "enable the warning flag for an address. * Access is controlled by raisingAccessController, except for owner * who always has access.",
        "@param1": "subject The contract address whose flag is being raised",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "raiseFlags",
        "visibility": "external",
        "args": [
            {
                "name": "subjects",
                "type": "address[] calldata"
            }
        ],
        "func": "function raiseFlags(address[] calldata subjects) external override {\n    require(allowedToRaiseFlags(), \"Not allowed to raise flags\");\n\n    for (uint256 i = 0; i < subjects.length; i++) {\n      tryToRaiseFlag(subjects[i]);\n    }\n  }",
        "comments": [
            "/**",
            "   * @notice enable the warning flags for multiple addresses.",
            "   * Access is controlled by raisingAccessController, except for owner",
            "   * who always has access.",
            "   * @param subjects List of the contract addresses whose flag is being raised",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice enable the warning flags for multiple addresses.\n   * Access is controlled by raisingAccessController, except for owner\n   * who always has access.\n   * @param subjects List of the contract addresses whose flag is being raised\n   */\n",
        "@notice": "enable the warning flags for multiple addresses. * Access is controlled by raisingAccessController, except for owner * who always has access.",
        "@param1": "subjects List of the contract addresses whose flag is being raised",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lowerFlags",
        "visibility": "external",
        "args": [
            {
                "name": "subjects",
                "type": "address[] calldata"
            }
        ],
        "func": "function lowerFlags(address[] calldata subjects) external override onlyOwner {\n    for (uint256 i = 0; i < subjects.length; i++) {\n      address subject = subjects[i];\n\n      if (flags[subject]) {\n        flags[subject] = false;\n        emit FlagLowered(subject);\n      }\n    }\n  }",
        "comments": [
            "/**",
            "   * @notice allows owner to disable the warning flags for multiple addresses.",
            "   * @param subjects List of the contract addresses whose flag is being lowered",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice allows owner to disable the warning flags for multiple addresses.\n   * @param subjects List of the contract addresses whose flag is being lowered\n   */\n",
        "@notice": "allows owner to disable the warning flags for multiple addresses.",
        "@param1": "subjects List of the contract addresses whose flag is being lowered",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setRaisingAccessController",
        "visibility": "public",
        "args": [
            {
                "name": "racAddress",
                "type": "address"
            }
        ],
        "func": "function setRaisingAccessController(address racAddress) public override onlyOwner {\n    address previous = address(raisingAccessController);\n\n    if (previous != racAddress) {\n      raisingAccessController = AccessControllerInterface(racAddress);\n\n      emit RaisingAccessControllerUpdated(previous, racAddress);\n    }\n  }",
        "comments": [
            "/**",
            "   * @notice allows owner to change the access controller for raising flags.",
            "   * @param racAddress new address for the raising access controller.",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice allows owner to change the access controller for raising flags.\n   * @param racAddress new address for the raising access controller.\n   */\n",
        "@notice": "allows owner to change the access controller for raising flags.",
        "@param1": "racAddress new address for the raising access controller.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getFlag",
        "visibility": "external",
        "args": [
            {
                "name": "subject",
                "type": "address"
            }
        ],
        "func": "function getFlag(address subject) external view returns (bool) {\n    return flags.getFlag(subject);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getFlags",
        "visibility": "external",
        "args": [
            {
                "name": "subjects",
                "type": "address[] calldata"
            }
        ],
        "func": "function getFlags(address[] calldata subjects) external view returns (bool[] memory) {\n    return flags.getFlags(subjects);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "validate",
        "visibility": "external",
        "args": [
            {
                "name": "previousRoundId",
                "type": "uint256"
            },
            {
                "name": "previousAnswer",
                "type": "int256"
            },
            {
                "name": "currentRoundId",
                "type": "uint256"
            },
            {
                "name": "currentAnswer",
                "type": "int256"
            }
        ],
        "func": "function validate(\n    uint256 previousRoundId,\n    int256 previousAnswer,\n    uint256 currentRoundId,\n    int256 currentAnswer\n  ) external override returns (bool) {\n    emit ValidateCalled(id, previousRoundId, previousAnswer, currentRoundId, currentAnswer);\n    return true;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setWatchList",
        "visibility": "external",
        "args": [
            {
                "name": "addresses",
                "type": "address[] calldata"
            },
            {
                "name": "minBalancesWei",
                "type": "uint96[] calldata"
            },
            {
                "name": "topUpAmountsWei",
                "type": "uint96[] calldata"
            }
        ],
        "func": "function setWatchList(\n    address[] calldata addresses,\n    uint96[] calldata minBalancesWei,\n    uint96[] calldata topUpAmountsWei\n  ) external onlyOwner {\n    if (addresses.length != minBalancesWei.length || addresses.length != topUpAmountsWei.length) {\n      revert InvalidWatchList();\n    }\n    address[] memory oldWatchList = s_watchList;\n    for (uint256 idx = 0; idx < oldWatchList.length; idx++) {\n      s_targets[oldWatchList[idx]].isActive = false;\n    }\n    for (uint256 idx = 0; idx < addresses.length; idx++) {\n      if (s_targets[addresses[idx]].isActive) {\n        revert DuplicateAddress(addresses[idx]);\n      }\n      if (addresses[idx] == address(0)) {\n        revert InvalidWatchList();\n      }\n      if (topUpAmountsWei[idx] == 0) {\n        revert InvalidWatchList();\n      }\n      s_targets[addresses[idx]] = Target({\n        isActive: true,\n        minBalanceWei: minBalancesWei[idx],\n        topUpAmountWei: topUpAmountsWei[idx],\n        lastTopUpTimestamp: 0\n      });\n    }\n    s_watchList = addresses;\n  }",
        "comments": [
            "/**",
            "   * @notice Sets the list of addresses to watch and their funding parameters",
            "   * @param addresses the list of addresses to watch",
            "   * @param minBalancesWei the minimum balances for each address",
            "   * @param topUpAmountsWei the amount to top up each address",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Sets the list of addresses to watch and their funding parameters\n   * @param addresses the list of addresses to watch\n   * @param minBalancesWei the minimum balances for each address\n   * @param topUpAmountsWei the amount to top up each address\n   */\n",
        "@notice": "Sets the list of addresses to watch and their funding parameters",
        "@param1": "addresses the list of addresses to watch",
        "@param2": "minBalancesWei the minimum balances for each address",
        "@param3": "topUpAmountsWei the amount to top up each address",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getUnderfundedAddresses",
        "visibility": "public",
        "args": [],
        "func": "function getUnderfundedAddresses() public view returns (address[] memory) {\n    address[] memory watchList = s_watchList;\n    address[] memory needsFunding = new address[](watchList.length);\n    uint256 count = 0;\n    uint256 minWaitPeriod = s_minWaitPeriodSeconds;\n    uint256 balance = address(this).balance;\n    Target memory target;\n    for (uint256 idx = 0; idx < watchList.length; idx++) {\n      target = s_targets[watchList[idx]];\n      if (\n        target.lastTopUpTimestamp + minWaitPeriod <= block.timestamp &&\n        balance >= target.topUpAmountWei &&\n        watchList[idx].balance < target.minBalanceWei\n      ) {\n        needsFunding[count] = watchList[idx];\n        count++;\n        balance -= target.topUpAmountWei;\n      }\n    }\n    if (count != watchList.length) {\n      assembly {\n        mstore(needsFunding, count)\n      }\n    }\n    return needsFunding;\n  }",
        "comments": [
            "/**",
            "   * @notice Gets a list of addresses that are under funded",
            "   * @return list of addresses that are underfunded",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Gets a list of addresses that are under funded\n   * @return list of addresses that are underfunded\n   */\n",
        "@notice": "Gets a list of addresses that are under funded",
        "@return1": "list of addresses that are underfunded",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "topUp",
        "visibility": "public",
        "args": [
            {
                "name": "needsFunding",
                "type": "address[] memory"
            }
        ],
        "func": "function topUp(address[] memory needsFunding) public whenNotPaused {\n    uint256 minWaitPeriodSeconds = s_minWaitPeriodSeconds;\n    Target memory target;\n    for (uint256 idx = 0; idx < needsFunding.length; idx++) {\n      target = s_targets[needsFunding[idx]];\n      if (\n        target.isActive &&\n        target.lastTopUpTimestamp + minWaitPeriodSeconds <= block.timestamp &&\n        needsFunding[idx].balance < target.minBalanceWei\n      ) {\n        bool success = payable(needsFunding[idx]).send(target.topUpAmountWei);\n        if (success) {\n          s_targets[needsFunding[idx]].lastTopUpTimestamp = uint56(block.timestamp);\n          emit TopUpSucceeded(needsFunding[idx]);\n        } else {\n          emit TopUpFailed(needsFunding[idx]);\n        }\n      }\n      if (gasleft() < MIN_GAS_FOR_TRANSFER) {\n        return;\n      }\n    }\n  }",
        "comments": [
            "/**",
            "   * @notice Send funds to the addresses provided",
            "   * @param needsFunding the list of addresses to fund (addresses must be pre-approved)",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Send funds to the addresses provided\n   * @param needsFunding the list of addresses to fund (addresses must be pre-approved)\n   */\n",
        "@notice": "Send funds to the addresses provided",
        "@param1": "needsFunding the list of addresses to fund (addresses must be pre-approved)",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "checkUpkeep",
        "visibility": "external",
        "args": [
            {
                "name": "calldata",
                "type": "bytes"
            }
        ],
        "func": "function checkUpkeep(bytes calldata)\n    external\n    view\n    override\n    whenNotPaused\n    returns (bool upkeepNeeded, bytes memory performData)\n  {\n    address[] memory needsFunding = getUnderfundedAddresses();\n    upkeepNeeded = needsFunding.length > 0;\n    performData = abi.encode(needsFunding);\n    return (upkeepNeeded, performData);\n  }",
        "comments": [
            "/**",
            "   * @notice Get list of addresses that are underfunded and return keeper-compatible payload",
            "   * @return upkeepNeeded signals if upkeep is needed, performData is an abi encoded list of addresses that need funds",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Get list of addresses that are underfunded and return keeper-compatible payload\n   * @return upkeepNeeded signals if upkeep is needed, performData is an abi encoded list of addresses that need funds\n   */\n",
        "@notice": "Get list of addresses that are underfunded and return keeper-compatible payload",
        "@return1": "upkeepNeeded signals if upkeep is needed, performData is an abi encoded list of addresses that need funds",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "performUpkeep",
        "visibility": "external",
        "args": [
            {
                "name": "performData",
                "type": "bytes calldata"
            }
        ],
        "func": "function performUpkeep(bytes calldata performData) external override onlyKeeperRegistry whenNotPaused {\n    address[] memory needsFunding = abi.decode(performData, (address[]));\n    topUp(needsFunding);\n  }",
        "comments": [
            "/**",
            "   * @notice Called by keeper to send funds to underfunded addresses",
            "   * @param performData The abi encoded list of addresses to fund",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Called by keeper to send funds to underfunded addresses\n   * @param performData The abi encoded list of addresses to fund\n   */\n",
        "@notice": "Called by keeper to send funds to underfunded addresses",
        "@param1": "performData The abi encoded list of addresses to fund",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            },
            {
                "name": "payee",
                "type": "address payable"
            }
        ],
        "func": "function withdraw(uint256 amount, address payable payee) external onlyOwner {\n    require(payee != address(0));\n    emit FundsWithdrawn(amount, payee);\n    payee.transfer(amount);\n  }",
        "comments": [
            "/**",
            "   * @notice Withdraws the contract balance",
            "   * @param amount The amount of eth (in wei) to withdraw",
            "   * @param payee The address to pay",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Withdraws the contract balance\n   * @param amount The amount of eth (in wei) to withdraw\n   * @param payee The address to pay\n   */\n",
        "@notice": "Withdraws the contract balance",
        "@param1": "amount The amount of eth (in wei) to withdraw",
        "@param2": "payee The address to pay",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setKeeperRegistryAddress",
        "visibility": "public",
        "args": [
            {
                "name": "keeperRegistryAddress",
                "type": "address"
            }
        ],
        "func": "function setKeeperRegistryAddress(address keeperRegistryAddress) public onlyOwner {\n    require(keeperRegistryAddress != address(0));\n    emit KeeperRegistryAddressUpdated(s_keeperRegistryAddress, keeperRegistryAddress);\n    s_keeperRegistryAddress = keeperRegistryAddress;\n  }",
        "comments": [
            "/**",
            "   * @notice Sets the keeper registry address",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Sets the keeper registry address\n   */\n",
        "@notice": "Sets the keeper registry address",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setMinWaitPeriodSeconds",
        "visibility": "public",
        "args": [
            {
                "name": "period",
                "type": "uint256"
            }
        ],
        "func": "function setMinWaitPeriodSeconds(uint256 period) public onlyOwner {\n    emit MinWaitPeriodUpdated(s_minWaitPeriodSeconds, period);\n    s_minWaitPeriodSeconds = period;\n  }",
        "comments": [
            "/**",
            "   * @notice Sets the minimum wait period (in seconds) for addresses between funding",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Sets the minimum wait period (in seconds) for addresses between funding\n   */\n",
        "@notice": "Sets the minimum wait period (in seconds) for addresses between funding",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getKeeperRegistryAddress",
        "visibility": "external",
        "args": [],
        "func": "function getKeeperRegistryAddress() external view returns (address keeperRegistryAddress) {\n    return s_keeperRegistryAddress;\n  }",
        "comments": [
            "/**",
            "   * @notice Gets the keeper registry address",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Gets the keeper registry address\n   */\n",
        "@notice": "Gets the keeper registry address",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMinWaitPeriodSeconds",
        "visibility": "external",
        "args": [],
        "func": "function getMinWaitPeriodSeconds() external view returns (uint256) {\n    return s_minWaitPeriodSeconds;\n  }",
        "comments": [
            "/**",
            "   * @notice Gets the minimum wait period",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Gets the minimum wait period\n   */\n",
        "@notice": "Gets the minimum wait period",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getWatchList",
        "visibility": "external",
        "args": [],
        "func": "function getWatchList() external view returns (address[] memory) {\n    return s_watchList;\n  }",
        "comments": [
            "/**",
            "   * @notice Gets the list of addresses being watched",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Gets the list of addresses being watched\n   */\n",
        "@notice": "Gets the list of addresses being watched",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAccountInfo",
        "visibility": "external",
        "args": [
            {
                "name": "targetAddress",
                "type": "address"
            }
        ],
        "func": "function getAccountInfo(address targetAddress)\n    external\n    view\n    returns (\n      bool isActive,\n      uint96 minBalanceWei,\n      uint96 topUpAmountWei,\n      uint56 lastTopUpTimestamp\n    )\n  {\n    Target memory target = s_targets[targetAddress];\n    return (target.isActive, target.minBalanceWei, target.topUpAmountWei, target.lastTopUpTimestamp);\n  }",
        "comments": [
            "/**",
            "   * @notice Gets configuration information for an address on the watchlist",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Gets configuration information for an address on the watchlist\n   */\n",
        "@notice": "Gets configuration information for an address on the watchlist",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "pause",
        "visibility": "external",
        "args": [],
        "func": "function pause() external onlyOwner {\n    _pause();\n  }",
        "comments": [
            "/**",
            "   * @notice Pauses the contract, which prevents executing performUpkeep",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Pauses the contract, which prevents executing performUpkeep\n   */\n",
        "@notice": "Pauses the contract, which prevents executing performUpkeep",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unpause",
        "visibility": "external",
        "args": [],
        "func": "function unpause() external onlyOwner {\n    _unpause();\n  }",
        "comments": [
            "/**",
            "   * @notice Unpauses the contract",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Unpauses the contract\n   */\n",
        "@notice": "Unpauses the contract",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "paused",
        "visibility": "public",
        "args": [],
        "func": "function paused() public view virtual returns (bool) {\n        return _paused;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns true if the contract is paused, and false otherwise.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n",
        "@dev": "Returns true if the contract is paused, and false otherwise.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "performUpkeep",
        "visibility": "external",
        "args": [
            {
                "name": "performData",
                "type": "bytes calldata"
            }
        ],
        "func": "function performUpkeep(bytes calldata performData) external override whenNotPaused {\n    (uint256 id, uint256 tickTime, address target, bytes memory handler) = abi.decode(\n      performData,\n      (uint256, uint256, address, bytes)\n    );\n    validate(id, tickTime, target, handler);\n    s_lastRuns[id] = block.timestamp;\n    (bool success, bytes memory payload) = target.call(handler);\n    if (!success) {\n      revert CallFailed(id, getRevertMsg(payload));\n    }\n    emit CronJobExecuted(id, block.timestamp);\n  }",
        "comments": [
            "/**",
            "   * @notice Executes the cron job with id encoded in performData",
            "   * @param performData abi encoding of cron job ID and the cron job's next run-at datetime",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Executes the cron job with id encoded in performData\n   * @param performData abi encoding of cron job ID and the cron job's next run-at datetime\n   */\n",
        "@notice": "Executes the cron job with id encoded in performData",
        "@param1": "performData abi encoding of cron job ID and the cron job's next run-at datetime",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createCronJobFromEncodedSpec",
        "visibility": "external",
        "args": [
            {
                "name": "target",
                "type": "address"
            },
            {
                "name": "handler",
                "type": "bytes memory"
            },
            {
                "name": "encodedCronSpec",
                "type": "bytes memory"
            }
        ],
        "func": "function createCronJobFromEncodedSpec(\n    address target,\n    bytes memory handler,\n    bytes memory encodedCronSpec\n  ) external {\n    Spec memory spec = abi.decode(encodedCronSpec, (Spec));\n    createCronJobFromSpec(target, handler, spec);\n  }",
        "comments": [
            "/**",
            "   * @notice Creates a cron job from the given encoded spec",
            "   * @param target the destination contract of a cron job",
            "   * @param handler the function signature on the target contract to call",
            "   * @param encodedCronSpec abi encoding of a cron spec",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Creates a cron job from the given encoded spec\n   * @param target the destination contract of a cron job\n   * @param handler the function signature on the target contract to call\n   * @param encodedCronSpec abi encoding of a cron spec\n   */\n",
        "@notice": "Creates a cron job from the given encoded spec",
        "@param1": "target the destination contract of a cron job",
        "@param2": "handler the function signature on the target contract to call",
        "@param3": "encodedCronSpec abi encoding of a cron spec",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "deleteCronJob",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function deleteCronJob(uint256 id) external onlyOwner {\n    if (s_targets[id] == address(0)) {\n      revert CronJobIDNotFound(id);\n    }\n    uint256 existingID;\n    uint256 oldLength = s_activeCronJobIDs.length;\n    uint256 newLength = oldLength - 1;\n    uint256 idx;\n    for (idx = 0; idx < newLength; idx++) {\n      existingID = s_activeCronJobIDs[idx];\n      if (existingID == id) {\n        s_activeCronJobIDs[idx] = s_activeCronJobIDs[newLength];\n        break;\n      }\n    }\n    delete s_lastRuns[id];\n    delete s_specs[id];\n    delete s_targets[id];\n    delete s_handlers[id];\n    delete s_handlerSignatures[id];\n    s_activeCronJobIDs.pop();\n    emit CronJobDeleted(id);\n  }",
        "comments": [
            "/**",
            "   * @notice Deletes the cron job matching the provided id. Reverts if",
            "   * the id is not found.",
            "   * @param id the id of the cron job to delete",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Deletes the cron job matching the provided id. Reverts if\n   * the id is not found.\n   * @param id the id of the cron job to delete\n   */\n",
        "@notice": "Deletes the cron job matching the provided id. Reverts if * the id is not found.",
        "@param1": "id the id of the cron job to delete",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "pause",
        "visibility": "external",
        "args": [],
        "func": "function pause() external onlyOwner {\n    _pause();\n  }",
        "comments": [
            "/**",
            "   * @notice Pauses the contract, which prevents executing performUpkeep",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Pauses the contract, which prevents executing performUpkeep\n   */\n",
        "@notice": "Pauses the contract, which prevents executing performUpkeep",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unpause",
        "visibility": "external",
        "args": [],
        "func": "function unpause() external onlyOwner {\n    _unpause();\n  }",
        "comments": [
            "/**",
            "   * @notice Unpauses the contract",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Unpauses the contract\n   */\n",
        "@notice": "Unpauses the contract",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "checkUpkeep",
        "visibility": "external",
        "args": [
            {
                "name": "calldata",
                "type": "bytes"
            }
        ],
        "func": "function checkUpkeep(bytes calldata) external override whenNotPaused cannotExecute returns (bool, bytes memory) {\n    _delegate(s_delegate);\n  }",
        "comments": [
            "/**",
            "   * @notice Get the id of an eligible cron job",
            "   * @return upkeepNeeded signals if upkeep is needed, performData is an abi encoding",
            "   * of the id and \"next tick\" of the elligible cron job",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Get the id of an eligible cron job\n   * @return upkeepNeeded signals if upkeep is needed, performData is an abi encoding\n   * of the id and \"next tick\" of the elligible cron job\n   */\n",
        "@notice": "Get the id of an eligible cron job",
        "@return1": "upkeepNeeded signals if upkeep is needed, performData is an abi encoding * of the id and \"next tick\" of the elligible cron job",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getActiveCronJobIDs",
        "visibility": "external",
        "args": [],
        "func": "function getActiveCronJobIDs() external view returns (uint256[] memory) {\n    return s_activeCronJobIDs;\n  }",
        "comments": [
            "/**",
            "   * @notice gets a list of active cron job IDs",
            "   * @return list of active cron job IDs",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice gets a list of active cron job IDs\n   * @return list of active cron job IDs\n   */\n",
        "@notice": "gets a list of active cron job IDs",
        "@return1": "list of active cron job IDs",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCronJob",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function getCronJob(uint256 id)\n    external\n    view\n    returns (\n      address target,\n      bytes memory handler,\n      string memory cronString,\n      uint256 nextTick\n    )\n  {\n    Spec memory spec = s_specs[id];\n    return (s_targets[id], s_handlers[id], CronExternal.toCronString(spec), CronExternal.nextTick(spec));\n  }",
        "comments": [
            "/**",
            "   * @notice gets a cron job",
            "   * @param id the cron job ID",
            "   * @return target - the address a cron job forwards the eth tx to",
            "             handler - the encoded function sig to execute when forwarding a tx",
            "             cronString - the string representing the cron job",
            "             nextTick - the timestamp of the next time the cron job will run",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice gets a cron job\n   * @param id the cron job ID\n   * @return target - the address a cron job forwards the eth tx to\n             handler - the encoded function sig to execute when forwarding a tx\n             cronString - the string representing the cron job\n             nextTick - the timestamp of the next time the cron job will run\n   */\n",
        "@notice": "gets a cron job",
        "@param1": "id the cron job ID",
        "@return1": "target - the address a cron job forwards the eth tx to handler - the encoded function sig to execute when forwarding a tx cronString - the string representing the cron job nextTick - the timestamp of the next time the cron job will run",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cronStringToEncodedSpec",
        "visibility": "external",
        "args": [
            {
                "name": "cronString",
                "type": "string memory"
            }
        ],
        "func": "function cronStringToEncodedSpec(string memory cronString) external pure returns (bytes memory) {\n    return CronExternal.toEncodedSpec(cronString);\n  }",
        "comments": [
            "/**",
            "   * @notice Converts a cron string to a Spec, validates the spec, and encodes the spec.",
            "   * This should only be called off-chain, as it is gas expensive!",
            "   * @param cronString the cron string to convert and encode",
            "   * @return the abi encoding of the Spec struct representing the cron string",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Converts a cron string to a Spec, validates the spec, and encodes the spec.\n   * This should only be called off-chain, as it is gas expensive!\n   * @param cronString the cron string to convert and encode\n   * @return the abi encoding of the Spec struct representing the cron string\n   */\n",
        "@notice": "Converts a cron string to a Spec, validates the spec, and encodes the spec. * This should only be called off-chain, as it is gas expensive!",
        "@param1": "cronString the cron string to convert and encode",
        "@return1": "the abi encoding of the Spec struct representing the cron string",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "nextTick",
        "visibility": "public",
        "args": [
            {
                "name": "spec",
                "type": "Spec calldata"
            }
        ],
        "func": "function nextTick(Spec calldata spec) public view returns (uint256) {\n    return spec.nextTick();\n  }",
        "comments": [
            "/**",
            "   * @notice nextTick calculates the next datetime that a spec \"ticks\", starting",
            "   * from the current block timestamp. This is gas-intensive and therefore should",
            "   * only be called off-chain.",
            "   * @param spec the spec to evaluate",
            "   * @return the next tick",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice nextTick calculates the next datetime that a spec \"ticks\", starting\n   * from the current block timestamp. This is gas-intensive and therefore should\n   * only be called off-chain.\n   * @param spec the spec to evaluate\n   * @return the next tick\n   */\n",
        "@notice": "nextTick calculates the next datetime that a spec \"ticks\", starting * from the current block timestamp. This is gas-intensive and therefore should * only be called off-chain.",
        "@param1": "spec the spec to evaluate",
        "@return1": "the next tick",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lastTick",
        "visibility": "public",
        "args": [
            {
                "name": "spec",
                "type": "Spec calldata"
            }
        ],
        "func": "function lastTick(Spec calldata spec) public view returns (uint256) {\n    return spec.lastTick();\n  }",
        "comments": [
            "/**",
            "   * @notice lastTick calculates the previous datetime that a spec \"ticks\", starting",
            "   * from the current block timestamp. This is gas-intensive and therefore should",
            "   * only be called off-chain.",
            "   * @param spec the spec to evaluate",
            "   * @return the next tick",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice lastTick calculates the previous datetime that a spec \"ticks\", starting\n   * from the current block timestamp. This is gas-intensive and therefore should\n   * only be called off-chain.\n   * @param spec the spec to evaluate\n   * @return the next tick\n   */\n",
        "@notice": "lastTick calculates the previous datetime that a spec \"ticks\", starting * from the current block timestamp. This is gas-intensive and therefore should * only be called off-chain.",
        "@param1": "spec the spec to evaluate",
        "@return1": "the next tick",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "matches",
        "visibility": "public",
        "args": [
            {
                "name": "spec",
                "type": "Spec calldata"
            },
            {
                "name": "timestamp",
                "type": "uint256"
            }
        ],
        "func": "function matches(Spec calldata spec, uint256 timestamp) public view returns (bool) {\n    return spec.matches(timestamp);\n  }",
        "comments": [
            "/**",
            "   * @notice matches evaluates whether or not a spec \"ticks\" at a given timestamp",
            "   * @param spec the spec to evaluate",
            "   * @param timestamp the timestamp to compare against",
            "   * @return true / false if they match",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice matches evaluates whether or not a spec \"ticks\" at a given timestamp\n   * @param spec the spec to evaluate\n   * @param timestamp the timestamp to compare against\n   * @return true / false if they match\n   */\n",
        "@notice": "matches evaluates whether or not a spec \"ticks\" at a given timestamp",
        "@param1": "spec the spec to evaluate",
        "@param2": "timestamp the timestamp to compare against",
        "@return1": "true / false if they match",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "toSpec",
        "visibility": "public",
        "args": [
            {
                "name": "cronString",
                "type": "string calldata"
            }
        ],
        "func": "function toSpec(string calldata cronString) public pure returns (Spec memory) {\n    return cronString.toSpec();\n  }",
        "comments": [
            "/**",
            "   * @notice toSpec converts a cron string to a spec struct. This is gas-intensive",
            "   * and therefore should only be called off-chain.",
            "   * @param cronString the cron string",
            "   * @return the spec struct",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice toSpec converts a cron string to a spec struct. This is gas-intensive\n   * and therefore should only be called off-chain.\n   * @param cronString the cron string\n   * @return the spec struct\n   */\n",
        "@notice": "toSpec converts a cron string to a spec struct. This is gas-intensive * and therefore should only be called off-chain.",
        "@param1": "cronString the cron string",
        "@return1": "the spec struct",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "toEncodedSpec",
        "visibility": "public",
        "args": [
            {
                "name": "cronString",
                "type": "string calldata"
            }
        ],
        "func": "function toEncodedSpec(string calldata cronString) public pure returns (bytes memory) {\n    return cronString.toEncodedSpec();\n  }",
        "comments": [
            "/**",
            "   * @notice toEncodedSpec converts a cron string to an abi-encoded spec. This is gas-intensive",
            "   * and therefore should only be called off-chain.",
            "   * @param cronString the cron string",
            "   * @return the abi-encoded spec",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice toEncodedSpec converts a cron string to an abi-encoded spec. This is gas-intensive\n   * and therefore should only be called off-chain.\n   * @param cronString the cron string\n   * @return the abi-encoded spec\n   */\n",
        "@notice": "toEncodedSpec converts a cron string to an abi-encoded spec. This is gas-intensive * and therefore should only be called off-chain.",
        "@param1": "cronString the cron string",
        "@return1": "the abi-encoded spec",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "toCronString",
        "visibility": "public",
        "args": [
            {
                "name": "spec",
                "type": "Spec calldata"
            }
        ],
        "func": "function toCronString(Spec calldata spec) public pure returns (string memory) {\n    return spec.toCronString();\n  }",
        "comments": [
            "/**",
            "   * @notice toCronString converts a cron spec to a human-readable cron string. This is gas-intensive",
            "   * and therefore should only be called off-chain.",
            "   * @param spec the cron spec",
            "   * @return the corresponding cron string",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice toCronString converts a cron spec to a human-readable cron string. This is gas-intensive\n   * and therefore should only be called off-chain.\n   * @param spec the cron spec\n   * @return the corresponding cron string\n   */\n",
        "@notice": "toCronString converts a cron spec to a human-readable cron string. This is gas-intensive * and therefore should only be called off-chain.",
        "@param1": "spec the cron spec",
        "@return1": "the corresponding cron string",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createCronJobFromString",
        "visibility": "external",
        "args": [
            {
                "name": "target",
                "type": "address"
            },
            {
                "name": "handler",
                "type": "bytes memory"
            },
            {
                "name": "cronString",
                "type": "string memory"
            }
        ],
        "func": "function createCronJobFromString(\n    address target,\n    bytes memory handler,\n    string memory cronString\n  ) external {\n    Spec memory spec = cronString.toSpec();\n    createCronJobFromSpec(target, handler, spec);\n  }",
        "comments": [
            "/**",
            "   * @notice createCronJobFromString is a helper function for creating cron jobs",
            "   * directly from strings. This is gas-intensive and shouldn't be done outside",
            "   * of testing environments.",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice createCronJobFromString is a helper function for creating cron jobs\n   * directly from strings. This is gas-intensive and shouldn't be done outside\n   * of testing environments.\n   */\n",
        "@notice": "createCronJobFromString is a helper function for creating cron jobs * directly from strings. This is gas-intensive and shouldn't be done outside * of testing environments.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "txCheckUpkeep",
        "visibility": "external",
        "args": [
            {
                "name": "checkData",
                "type": "bytes calldata"
            }
        ],
        "func": "function txCheckUpkeep(bytes calldata checkData) external {\n    address(this).call(abi.encodeWithSelector(bytes4(keccak256(\"checkUpkeep(bytes)\")), checkData));\n  }",
        "comments": [
            "/**",
            "   * @notice txCheckUpkeep is a helper function for sending real txs to the",
            "   * checkUpkeep function. This allows us to do gas analysis on it.",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice txCheckUpkeep is a helper function for sending real txs to the\n   * checkUpkeep function. This allows us to do gas analysis on it.\n   */\n",
        "@notice": "txCheckUpkeep is a helper function for sending real txs to the * checkUpkeep function. This allows us to do gas analysis on it.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "encodeCronString",
        "visibility": "external",
        "args": [
            {
                "name": "cronString",
                "type": "string memory"
            }
        ],
        "func": "function encodeCronString(string memory cronString) external pure returns (bytes memory) {\n    return CronInternal.toEncodedSpec(cronString);\n  }",
        "comments": [
            "/**",
            "   * @notice Converts a cron string to a Spec, validates the spec, and encodes the spec.",
            "   * This should only be called off-chain, as it is gas expensive!",
            "   * @param cronString the cron string to convert and encode",
            "   * @return the abi encoding of the Spec struct representing the cron string",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Converts a cron string to a Spec, validates the spec, and encodes the spec.\n   * This should only be called off-chain, as it is gas expensive!\n   * @param cronString the cron string to convert and encode\n   * @return the abi encoding of the Spec struct representing the cron string\n   */\n",
        "@notice": "Converts a cron string to a Spec, validates the spec, and encodes the spec. * This should only be called off-chain, as it is gas expensive!",
        "@param1": "cronString the cron string to convert and encode",
        "@return1": "the abi encoding of the Spec struct representing the cron string",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "encodedSpecToString",
        "visibility": "public",
        "args": [
            {
                "name": "encodedSpec",
                "type": "bytes memory"
            }
        ],
        "func": "function encodedSpecToString(bytes memory encodedSpec) public pure returns (string memory) {\n    Spec memory spec = abi.decode(encodedSpec, (Spec));\n    return CronInternal.toCronString(spec);\n  }",
        "comments": [
            "/**",
            "   * @notice encodedSpecToString is a helper function for turning an",
            "   * encoded spec back into a string. There is limited or no use for this outside",
            "   * of tests.",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice encodedSpecToString is a helper function for turning an\n   * encoded spec back into a string. There is limited or no use for this outside\n   * of tests.\n   */\n",
        "@notice": "encodedSpecToString is a helper function for turning an * encoded spec back into a string. There is limited or no use for this outside * of tests.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cronStringtoEncodedSpec",
        "visibility": "public",
        "args": [
            {
                "name": "cronString",
                "type": "string memory"
            }
        ],
        "func": "function cronStringtoEncodedSpec(string memory cronString) public pure returns (Spec memory) {\n    return CronInternal.toSpec(cronString);\n  }",
        "comments": [
            "/**",
            "   * @notice encodedSpecToString is a helper function for turning a string",
            "   * into a spec struct.",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice encodedSpecToString is a helper function for turning a string\n   * into a spec struct.\n   */\n",
        "@notice": "encodedSpecToString is a helper function for turning a string * into a spec struct.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "calculateNextTick",
        "visibility": "external",
        "args": [
            {
                "name": "cronString",
                "type": "string memory"
            }
        ],
        "func": "function calculateNextTick(string memory cronString) external view returns (uint256) {\n    return CronInternal.nextTick(CronInternal.toSpec(cronString));\n  }",
        "comments": [
            "/**",
            "   * @notice calculateNextTick calculates the next time a cron job should \"tick\".",
            "   * This should only be called off-chain, as it is gas expensive!",
            "   * @param cronString the cron string to consider",
            "   * @return the timestamp in UTC of the next \"tick\"",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice calculateNextTick calculates the next time a cron job should \"tick\".\n   * This should only be called off-chain, as it is gas expensive!\n   * @param cronString the cron string to consider\n   * @return the timestamp in UTC of the next \"tick\"\n   */\n",
        "@notice": "calculateNextTick calculates the next time a cron job should \"tick\". * This should only be called off-chain, as it is gas expensive!",
        "@param1": "cronString the cron string to consider",
        "@return1": "the timestamp in UTC of the next \"tick\"",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "calculateLastTick",
        "visibility": "external",
        "args": [
            {
                "name": "cronString",
                "type": "string memory"
            }
        ],
        "func": "function calculateLastTick(string memory cronString) external view returns (uint256) {\n    return CronInternal.lastTick(CronInternal.toSpec(cronString));\n  }",
        "comments": [
            "/**",
            "   * @notice calculateLastTick calculates the last time a cron job \"ticked\".",
            "   * This should only be called off-chain, as it is gas expensive!",
            "   * @param cronString the cron string to consider",
            "   * @return the timestamp in UTC of the last \"tick\"",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice calculateLastTick calculates the last time a cron job \"ticked\".\n   * This should only be called off-chain, as it is gas expensive!\n   * @param cronString the cron string to consider\n   * @return the timestamp in UTC of the last \"tick\"\n   */\n",
        "@notice": "calculateLastTick calculates the last time a cron job \"ticked\". * This should only be called off-chain, as it is gas expensive!",
        "@param1": "cronString the cron string to consider",
        "@return1": "the timestamp in UTC of the last \"tick\"",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "encodeCronString",
        "visibility": "external",
        "args": [
            {
                "name": "cronString",
                "type": "string memory"
            }
        ],
        "func": "function encodeCronString(string memory cronString) external pure returns (bytes memory) {\n    return CronExternal.toEncodedSpec(cronString);\n  }",
        "comments": [
            "/**",
            "   * @notice Converts a cron string to a Spec, validates the spec, and encodes the spec.",
            "   * This should only be called off-chain, as it is gas expensive!",
            "   * @param cronString the cron string to convert and encode",
            "   * @return the abi encoding of the Spec struct representing the cron string",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Converts a cron string to a Spec, validates the spec, and encodes the spec.\n   * This should only be called off-chain, as it is gas expensive!\n   * @param cronString the cron string to convert and encode\n   * @return the abi encoding of the Spec struct representing the cron string\n   */\n",
        "@notice": "Converts a cron string to a Spec, validates the spec, and encodes the spec. * This should only be called off-chain, as it is gas expensive!",
        "@param1": "cronString the cron string to convert and encode",
        "@return1": "the abi encoding of the Spec struct representing the cron string",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "encodedSpecToString",
        "visibility": "public",
        "args": [
            {
                "name": "encodedSpec",
                "type": "bytes memory"
            }
        ],
        "func": "function encodedSpecToString(bytes memory encodedSpec) public pure returns (string memory) {\n    Spec memory spec = abi.decode(encodedSpec, (Spec));\n    return CronExternal.toCronString(spec);\n  }",
        "comments": [
            "/**",
            "   * @notice encodedSpecToString is a helper function for turning an",
            "   * encoded spec back into a string. There is limited or no use for this outside",
            "   * of tests.",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice encodedSpecToString is a helper function for turning an\n   * encoded spec back into a string. There is limited or no use for this outside\n   * of tests.\n   */\n",
        "@notice": "encodedSpecToString is a helper function for turning an * encoded spec back into a string. There is limited or no use for this outside * of tests.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cronStringtoEncodedSpec",
        "visibility": "public",
        "args": [
            {
                "name": "cronString",
                "type": "string memory"
            }
        ],
        "func": "function cronStringtoEncodedSpec(string memory cronString) public pure returns (Spec memory) {\n    return CronExternal.toSpec(cronString);\n  }",
        "comments": [
            "/**",
            "   * @notice encodedSpecToString is a helper function for turning a string",
            "   * into a spec struct.",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice encodedSpecToString is a helper function for turning a string\n   * into a spec struct.\n   */\n",
        "@notice": "encodedSpecToString is a helper function for turning a string * into a spec struct.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "calculateNextTick",
        "visibility": "external",
        "args": [
            {
                "name": "cronString",
                "type": "string memory"
            }
        ],
        "func": "function calculateNextTick(string memory cronString) external view returns (uint256) {\n    return CronExternal.nextTick(CronExternal.toSpec(cronString));\n  }",
        "comments": [
            "/**",
            "   * @notice calculateNextTick calculates the next time a cron job should \"tick\".",
            "   * This should only be called off-chain, as it is gas expensive!",
            "   * @param cronString the cron string to consider",
            "   * @return the timestamp in UTC of the next \"tick\"",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice calculateNextTick calculates the next time a cron job should \"tick\".\n   * This should only be called off-chain, as it is gas expensive!\n   * @param cronString the cron string to consider\n   * @return the timestamp in UTC of the next \"tick\"\n   */\n",
        "@notice": "calculateNextTick calculates the next time a cron job should \"tick\". * This should only be called off-chain, as it is gas expensive!",
        "@param1": "cronString the cron string to consider",
        "@return1": "the timestamp in UTC of the next \"tick\"",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "calculateLastTick",
        "visibility": "external",
        "args": [
            {
                "name": "cronString",
                "type": "string memory"
            }
        ],
        "func": "function calculateLastTick(string memory cronString) external view returns (uint256) {\n    return CronExternal.lastTick(CronExternal.toSpec(cronString));\n  }",
        "comments": [
            "/**",
            "   * @notice calculateLastTick calculates the last time a cron job \"ticked\".",
            "   * This should only be called off-chain, as it is gas expensive!",
            "   * @param cronString the cron string to consider",
            "   * @return the timestamp in UTC of the last \"tick\"",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice calculateLastTick calculates the last time a cron job \"ticked\".\n   * This should only be called off-chain, as it is gas expensive!\n   * @param cronString the cron string to consider\n   * @return the timestamp in UTC of the last \"tick\"\n   */\n",
        "@notice": "calculateLastTick calculates the last time a cron job \"ticked\". * This should only be called off-chain, as it is gas expensive!",
        "@param1": "cronString the cron string to consider",
        "@return1": "the timestamp in UTC of the last \"tick\"",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "checkUpkeep",
        "visibility": "external",
        "args": [
            {
                "name": "calldata",
                "type": "bytes"
            }
        ],
        "func": "function checkUpkeep(bytes calldata) external view returns (bool, bytes memory) {\n    // DEV: start at a random spot in the list so that checks are\n    // spread evenly among cron jobs\n    uint256 numCrons = s_activeCronJobIDs.length;\n    uint256 startIdx = block.number % numCrons;\n    bool result;\n    bytes memory payload;\n    (result, payload) = checkInRange(startIdx, numCrons);\n    if (result) {\n      return (result, payload);\n    }\n    (result, payload) = checkInRange(0, startIdx);\n    if (result) {\n      return (result, payload);\n    }\n    return (false, bytes(\"\"));\n  }",
        "comments": [
            "/**",
            "   * @notice Get the id of an eligible cron job",
            "   * @return upkeepNeeded signals if upkeep is needed, performData is an abi encoding",
            "   * of the id and \"next tick\" of the elligible cron job",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Get the id of an eligible cron job\n   * @return upkeepNeeded signals if upkeep is needed, performData is an abi encoding\n   * of the id and \"next tick\" of the elligible cron job\n   */\n",
        "@notice": "Get the id of an eligible cron job",
        "@return1": "upkeepNeeded signals if upkeep is needed, performData is an abi encoding * of the id and \"next tick\" of the elligible cron job",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "newCronUpkeep",
        "visibility": "public",
        "args": [],
        "func": "function newCronUpkeep() public {\n    emit NewCronUpkeepCreated(address(new CronUpkeep(msg.sender, s_cronDelegate)), msg.sender);\n  }",
        "comments": [
            "/**",
            "   * @notice Creates a new CronUpkeep contract, with msg.sender as the owner",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Creates a new CronUpkeep contract, with msg.sender as the owner\n   */\n",
        "@notice": "Creates a new CronUpkeep contract, with msg.sender as the owner",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cronDelegateAddress",
        "visibility": "public",
        "args": [],
        "func": "function cronDelegateAddress() public view returns (address) {\n    return s_cronDelegate;\n  }",
        "comments": [
            "/**",
            "   * @notice Gets the address of the delegate contract",
            "   * @return the address of the delegate contract",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Gets the address of the delegate contract\n   * @return the address of the delegate contract\n   */\n",
        "@notice": "Gets the address of the delegate contract",
        "@return1": "the address of the delegate contract",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "checkUpkeep",
        "visibility": "external",
        "args": [
            {
                "name": "calldata",
                "type": "bytes"
            }
        ],
        "func": "function checkUpkeep(bytes calldata) external override returns (bool, bytes memory) {}",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "performUpkeep",
        "visibility": "external",
        "args": [
            {
                "name": "calldata",
                "type": "bytes"
            }
        ],
        "func": "function performUpkeep(bytes calldata) external override {}",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "testCannotExecute",
        "visibility": "public",
        "args": [],
        "func": "function testCannotExecute() public view cannotExecute {}",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setLastTopUpXXXTestOnly",
        "visibility": "external",
        "args": [
            {
                "name": "target",
                "type": "address"
            },
            {
                "name": "lastTopUpTimestamp",
                "type": "uint56"
            }
        ],
        "func": "function setLastTopUpXXXTestOnly(address target, uint56 lastTopUpTimestamp) external {\n    s_targets[target].lastTopUpTimestamp = lastTopUpTimestamp;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "bigModExp_",
        "visibility": "public",
        "args": [
            {
                "name": "base",
                "type": "uint256"
            },
            {
                "name": "exponent",
                "type": "uint256"
            }
        ],
        "func": "function bigModExp_(uint256 base, uint256 exponent) public view returns (uint256) {\n    return super.bigModExp(base, exponent);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "squareRoot_",
        "visibility": "public",
        "args": [
            {
                "name": "x",
                "type": "uint256"
            }
        ],
        "func": "function squareRoot_(uint256 x) public view returns (uint256) {\n    return super.squareRoot(x);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "ySquared_",
        "visibility": "public",
        "args": [
            {
                "name": "x",
                "type": "uint256"
            }
        ],
        "func": "function ySquared_(uint256 x) public pure returns (uint256) {\n    return super.ySquared(x);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "fieldHash_",
        "visibility": "public",
        "args": [
            {
                "name": "b",
                "type": "bytes memory"
            }
        ],
        "func": "function fieldHash_(bytes memory b) public pure returns (uint256) {\n    return super.fieldHash(b);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "hashToCurve_",
        "visibility": "public",
        "args": [
            {
                "name": "pk",
                "type": "uint256[2] memory"
            },
            {
                "name": "x",
                "type": "uint256"
            }
        ],
        "func": "function hashToCurve_(uint256[2] memory pk, uint256 x) public view returns (uint256[2] memory) {\n    return super.hashToCurve(pk, x);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "ecmulVerify_",
        "visibility": "public",
        "args": [
            {
                "name": "x",
                "type": "uint256[2] memory"
            },
            {
                "name": "scalar",
                "type": "uint256"
            },
            {
                "name": "q",
                "type": "uint256[2] memory"
            }
        ],
        "func": "function ecmulVerify_(\n    uint256[2] memory x,\n    uint256 scalar,\n    uint256[2] memory q\n  ) public pure returns (bool) {\n    return super.ecmulVerify(x, scalar, q);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "projectiveECAdd_",
        "visibility": "public",
        "args": [
            {
                "name": "px",
                "type": "uint256"
            },
            {
                "name": "py",
                "type": "uint256"
            },
            {
                "name": "qx",
                "type": "uint256"
            },
            {
                "name": "qy",
                "type": "uint256"
            }
        ],
        "func": "function projectiveECAdd_(\n    uint256 px,\n    uint256 py,\n    uint256 qx,\n    uint256 qy\n  )\n    public\n    pure\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    return super.projectiveECAdd(px, py, qx, qy);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "affineECAdd_",
        "visibility": "public",
        "args": [
            {
                "name": "p1",
                "type": "uint256[2] memory"
            },
            {
                "name": "p2",
                "type": "uint256[2] memory"
            },
            {
                "name": "invZ",
                "type": "uint256"
            }
        ],
        "func": "function affineECAdd_(\n    uint256[2] memory p1,\n    uint256[2] memory p2,\n    uint256 invZ\n  ) public pure returns (uint256[2] memory) {\n    return super.affineECAdd(p1, p2, invZ);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "verifyLinearCombinationWithGenerator_",
        "visibility": "public",
        "args": [
            {
                "name": "c",
                "type": "uint256"
            },
            {
                "name": "p",
                "type": "uint256[2] memory"
            },
            {
                "name": "s",
                "type": "uint256"
            },
            {
                "name": "lcWitness",
                "type": "address"
            }
        ],
        "func": "function verifyLinearCombinationWithGenerator_(\n    uint256 c,\n    uint256[2] memory p,\n    uint256 s,\n    address lcWitness\n  ) public pure returns (bool) {\n    return super.verifyLinearCombinationWithGenerator(c, p, s, lcWitness);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "linearCombination_",
        "visibility": "public",
        "args": [
            {
                "name": "c",
                "type": "uint256"
            },
            {
                "name": "p1",
                "type": "uint256[2] memory"
            },
            {
                "name": "cp1Witness",
                "type": "uint256[2] memory"
            },
            {
                "name": "s",
                "type": "uint256"
            },
            {
                "name": "p2",
                "type": "uint256[2] memory"
            },
            {
                "name": "sp2Witness",
                "type": "uint256[2] memory"
            },
            {
                "name": "zInv",
                "type": "uint256"
            }
        ],
        "func": "function linearCombination_(\n    uint256 c,\n    uint256[2] memory p1,\n    uint256[2] memory cp1Witness,\n    uint256 s,\n    uint256[2] memory p2,\n    uint256[2] memory sp2Witness,\n    uint256 zInv\n  ) public pure returns (uint256[2] memory) {\n    return super.linearCombination(c, p1, cp1Witness, s, p2, sp2Witness, zInv);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "scalarFromCurvePoints_",
        "visibility": "public",
        "args": [
            {
                "name": "hash",
                "type": "uint256[2] memory"
            },
            {
                "name": "pk",
                "type": "uint256[2] memory"
            },
            {
                "name": "gamma",
                "type": "uint256[2] memory"
            },
            {
                "name": "uWitness",
                "type": "address"
            },
            {
                "name": "v",
                "type": "uint256[2] memory"
            }
        ],
        "func": "function scalarFromCurvePoints_(\n    uint256[2] memory hash,\n    uint256[2] memory pk,\n    uint256[2] memory gamma,\n    address uWitness,\n    uint256[2] memory v\n  ) public pure returns (uint256) {\n    return super.scalarFromCurvePoints(hash, pk, gamma, uWitness, v);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isOnCurve_",
        "visibility": "public",
        "args": [
            {
                "name": "p",
                "type": "uint256[2] memory"
            }
        ],
        "func": "function isOnCurve_(uint256[2] memory p) public pure returns (bool) {\n    return super.isOnCurve(p);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "verifyVRFProof_",
        "visibility": "public",
        "args": [
            {
                "name": "pk",
                "type": "uint256[2] memory"
            },
            {
                "name": "gamma",
                "type": "uint256[2] memory"
            },
            {
                "name": "c",
                "type": "uint256"
            },
            {
                "name": "s",
                "type": "uint256"
            },
            {
                "name": "seed",
                "type": "uint256"
            },
            {
                "name": "uWitness",
                "type": "address"
            },
            {
                "name": "cGammaWitness",
                "type": "uint256[2] memory"
            },
            {
                "name": "sHashWitness",
                "type": "uint256[2] memory"
            },
            {
                "name": "zInv",
                "type": "uint256"
            }
        ],
        "func": "function verifyVRFProof_(\n    uint256[2] memory pk,\n    uint256[2] memory gamma,\n    uint256 c,\n    uint256 s,\n    uint256 seed,\n    address uWitness,\n    uint256[2] memory cGammaWitness,\n    uint256[2] memory sHashWitness,\n    uint256 zInv\n  ) public view {\n    super.verifyVRFProof(pk, gamma, c, s, seed, uWitness, cGammaWitness, sHashWitness, zInv);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "randomValueFromVRFProof_",
        "visibility": "public",
        "args": [
            {
                "name": "proof",
                "type": "Proof memory"
            },
            {
                "name": "seed",
                "type": "uint256"
            }
        ],
        "func": "function randomValueFromVRFProof_(Proof memory proof, uint256 seed) public view returns (uint256 output) {\n    return super.randomValueFromVRFProof(proof, seed);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "onTokenTransfer",
        "visibility": "external",
        "args": [
            {
                "name": "address",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "/* sender */\n    uint256"
            },
            {
                "name": "_data",
                "type": "bytes calldata"
            }
        ],
        "func": "function onTokenTransfer(\n    address, /* sender */\n    uint256 _amount,\n    bytes calldata _data\n  ) external override {\n    if (msg.sender != address(LINK)) {\n      revert OnlyCallableFromLink();\n    }\n\n    bytes32 keyHash = abi.decode(_data, (bytes32));\n    s_requestId = requestRandomness(keyHash, _amount);\n  }",
        "comments": [
            "/**",
            "   * @dev Creates a new randomness request. This function can only be used by calling",
            "   * transferAndCall on the LinkToken contract.",
            "   * @param _amount The amount of LINK transferred to pay for this request.",
            "   * @param _data The data passed to transferAndCall on LinkToken. Must be an abi-encoded key hash.",
            "   */",
            ""
        ],
        "comt": "/**\n   * @dev Creates a new randomness request. This function can only be used by calling\n   * transferAndCall on the LinkToken contract.\n   * @param _amount The amount of LINK transferred to pay for this request.\n   * @param _data The data passed to transferAndCall on LinkToken. Must be an abi-encoded key hash.\n   */\n",
        "@dev": "Creates a new randomness request. This function can only be used by calling * transferAndCall on the LinkToken contract.",
        "@param1": "_amount The amount of LINK transferred to pay for this request.",
        "@param2": "_data The data passed to transferAndCall on LinkToken. Must be an abi-encoded key hash.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "rawFulfillRandomness",
        "visibility": "external",
        "args": [
            {
                "name": "requestId",
                "type": "bytes32"
            },
            {
                "name": "randomness",
                "type": "uint256"
            }
        ],
        "func": "function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\n    require(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\n    fulfillRandomness(requestId, randomness);\n  }",
        "comments": [
            "",
            "  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF",
            "  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating",
            "  // the origin of the call",
            "  "
        ],
        "comt": "\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "testRequestRandomness",
        "visibility": "external",
        "args": [
            {
                "name": "keyHash",
                "type": "bytes32"
            },
            {
                "name": "fee",
                "type": "uint256"
            }
        ],
        "func": "function testRequestRandomness(bytes32 keyHash, uint256 fee) external returns (bytes32) {\n    return requestRandomness(keyHash, fee);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "makeVRFInputSeed_",
        "visibility": "public",
        "args": [
            {
                "name": "_keyHash",
                "type": "bytes32"
            },
            {
                "name": "_userSeed",
                "type": "uint256"
            },
            {
                "name": "_requester",
                "type": "address"
            },
            {
                "name": "_nonce",
                "type": "uint256"
            }
        ],
        "func": "function makeVRFInputSeed_(\n    bytes32 _keyHash,\n    uint256 _userSeed,\n    address _requester,\n    uint256 _nonce\n  ) public pure returns (uint256) {\n    return makeVRFInputSeed(_keyHash, _userSeed, _requester, _nonce);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "makeRequestId_",
        "visibility": "public",
        "args": [
            {
                "name": "_keyHash",
                "type": "bytes32"
            },
            {
                "name": "_vRFInputSeed",
                "type": "uint256"
            }
        ],
        "func": "function makeRequestId_(bytes32 _keyHash, uint256 _vRFInputSeed) public pure returns (bytes32) {\n    return makeRequestId(_keyHash, _vRFInputSeed);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "onTokenTransfer",
        "visibility": "public",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "fee",
                "type": "uint256"
            },
            {
                "name": "_data",
                "type": "bytes memory"
            }
        ],
        "func": "function onTokenTransfer(\n    address sender,\n    uint256 fee,\n    bytes memory _data\n  ) public onlyLINK {\n    (bytes32 keyHash, uint256 seed) = abi.decode(_data, (bytes32, uint256));\n    emit RandomnessRequest(sender, keyHash, seed);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "callBackWithRandomness",
        "visibility": "public",
        "args": [
            {
                "name": "requestId",
                "type": "bytes32"
            },
            {
                "name": "randomness",
                "type": "uint256"
            },
            {
                "name": "consumerContract",
                "type": "address"
            }
        ],
        "func": "function callBackWithRandomness(\n    bytes32 requestId,\n    uint256 randomness,\n    address consumerContract\n  ) public {\n    VRFConsumerBase v;\n    bytes memory resp = abi.encodeWithSelector(v.rawFulfillRandomness.selector, requestId, randomness);\n    uint256 b = 206000;\n    require(gasleft() >= b, \"not enough gas for consumer\");\n    (bool success, ) = consumerContract.call(resp);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    }
]