[
    {
        "transactions": 115,
        "function_num": 375
    },
    {
        "name": "deposit",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function deposit(address _tokenAddr, uint256 _amount) public burnGas(5) payable {\n        address lendingPoolCore = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\n        uint ethValue = _amount;\n\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), _amount);\n            approveToken(_tokenAddr, lendingPoolCore);\n            ethValue = 0;\n        }\n\n        ILendingPool(lendingPool).deposit{value: ethValue}(_tokenAddr, _amount, AAVE_REFERRAL_CODE);\n\n        setUserUseReserveAsCollateralIfNeeded(_tokenAddr);\n    }",
        "comments": [
            "",
            "    /// @notice User deposits tokens to the Aave protocol",
            "    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens",
            "    /// @param _tokenAddr The address of the token to be deposited",
            "    /// @param _amount Amount of tokens to be deposited",
            "    "
        ],
        "comt": "\n    /// @notice User deposits tokens to the Aave protocol\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\n    /// @param _tokenAddr The address of the token to be deposited\n    /// @param _amount Amount of tokens to be deposited\n    ",
        "@notice": "User deposits tokens to the Aave protocol",
        "@dev": "User needs to approve the DSProxy to pull the _tokenAddr tokens",
        "@param1": "_tokenAddr The address of the token to be deposited",
        "@param2": "_amount Amount of tokens to be deposited",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_aTokenAddr",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            },
            {
                "name": "_wholeAmount",
                "type": "bool"
            }
        ],
        "func": "function withdraw(address _tokenAddr, address _aTokenAddr, uint256 _amount, bool _wholeAmount) public burnGas(8) {\n        uint256 amount = _wholeAmount ? ERC20(_aTokenAddr).balanceOf(address(this)) : _amount;\n\n        IAToken(_aTokenAddr).redeem(amount);\n\n        withdrawTokens(_tokenAddr);\n    }",
        "comments": [
            "",
            "    /// @notice User withdraws tokens from the Aave protocol",
            "    /// @param _tokenAddr The address of the token to be withdrawn",
            "    /// @param _aTokenAddr ATokens to be withdrawn",
            "    /// @param _amount Amount of tokens to be withdrawn",
            "    /// @param _wholeAmount If true we will take the whole amount on chain",
            "    "
        ],
        "comt": "\n    /// @notice User withdraws tokens from the Aave protocol\n    /// @param _tokenAddr The address of the token to be withdrawn\n    /// @param _aTokenAddr ATokens to be withdrawn\n    /// @param _amount Amount of tokens to be withdrawn\n    /// @param _wholeAmount If true we will take the whole amount on chain\n    ",
        "@notice": "User withdraws tokens from the Aave protocol",
        "@param1": "_tokenAddr The address of the token to be withdrawn",
        "@param2": "_aTokenAddr ATokens to be withdrawn",
        "@param3": "_amount Amount of tokens to be withdrawn",
        "@param4": "_wholeAmount If true we will take the whole amount on chain",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "borrow",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            },
            {
                "name": "_type",
                "type": "uint256"
            }
        ],
        "func": "function borrow(address _tokenAddr, uint256 _amount, uint256 _type) public burnGas(8) {\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\n        ILendingPool(lendingPool).borrow(_tokenAddr, _amount, _type, AAVE_REFERRAL_CODE);\n\n        withdrawTokens(_tokenAddr);\n    }",
        "comments": [
            "",
            "    /// @notice User borrows tokens to the Aave protocol",
            "    /// @param _tokenAddr The address of the token to be borrowed",
            "    /// @param _amount Amount of tokens to be borrowed",
            "    /// @param _type Send 1 for variable rate and 2 for fixed rate",
            "    "
        ],
        "comt": "\n    /// @notice User borrows tokens to the Aave protocol\n    /// @param _tokenAddr The address of the token to be borrowed\n    /// @param _amount Amount of tokens to be borrowed\n    /// @param _type Send 1 for variable rate and 2 for fixed rate\n    ",
        "@notice": "User borrows tokens to the Aave protocol",
        "@param1": "_tokenAddr The address of the token to be borrowed",
        "@param2": "_amount Amount of tokens to be borrowed",
        "@param3": "_type Send 1 for variable rate and 2 for fixed rate",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "payback",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_aTokenAddr",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            },
            {
                "name": "_wholeDebt",
                "type": "bool"
            }
        ],
        "func": "function payback(address _tokenAddr, address _aTokenAddr, uint256 _amount, bool _wholeDebt) public burnGas(3) payable {\n        address lendingPoolCore = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\n        uint256 amount = _amount;\n\n        (,uint256 borrowAmount,,,,,uint256 originationFee,,,) = ILendingPool(lendingPool).getUserReserveData(_tokenAddr, address(this));\n\n        if (_wholeDebt) {\n            amount = borrowAmount + originationFee;\n        }\n\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), amount);\n            approveToken(_tokenAddr, lendingPoolCore);\n        }\n\n        ILendingPool(lendingPool).repay{value: msg.value}(_tokenAddr, amount, payable(address(this)));\n\n        withdrawTokens(_tokenAddr);\n    }",
        "comments": [
            "",
            "    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens",
            "    /// @notice User paybacks tokens to the Aave protocol",
            "    /// @param _tokenAddr The address of the token to be paybacked",
            "    /// @param _aTokenAddr ATokens to be paybacked",
            "    /// @param _amount Amount of tokens to be payed back",
            "    /// @param _wholeDebt If true the _amount will be set to the whole amount of the debt",
            "    "
        ],
        "comt": "\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\n    /// @notice User paybacks tokens to the Aave protocol\n    /// @param _tokenAddr The address of the token to be paybacked\n    /// @param _aTokenAddr ATokens to be paybacked\n    /// @param _amount Amount of tokens to be payed back\n    /// @param _wholeDebt If true the _amount will be set to the whole amount of the debt\n    ",
        "@dev": "User needs to approve the DSProxy to pull the _tokenAddr tokens",
        "@notice": "User paybacks tokens to the Aave protocol",
        "@param1": "_tokenAddr The address of the token to be paybacked",
        "@param2": "_aTokenAddr ATokens to be paybacked",
        "@param3": "_amount Amount of tokens to be payed back",
        "@param4": "_wholeDebt If true the _amount will be set to the whole amount of the debt",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "paybackOnBehalf",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_aTokenAddr",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            },
            {
                "name": "_wholeDebt",
                "type": "bool"
            },
            {
                "name": "_onBehalf",
                "type": "address payable"
            }
        ],
        "func": "function paybackOnBehalf(address _tokenAddr, address _aTokenAddr, uint256 _amount, bool _wholeDebt, address payable _onBehalf) public burnGas(3) payable {\n        address lendingPoolCore = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\n        uint256 amount = _amount;\n\n        (,uint256 borrowAmount,,,,,uint256 originationFee,,,) = ILendingPool(lendingPool).getUserReserveData(_tokenAddr, _onBehalf);\n\n        if (_wholeDebt) {\n            amount = borrowAmount + originationFee;\n        }\n\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), amount);\n            if (originationFee > 0) {\n                ERC20(_tokenAddr).safeTransfer(_onBehalf, originationFee);\n            }\n            approveToken(_tokenAddr, lendingPoolCore);\n        }\n\n        ILendingPool(lendingPool).repay{value: msg.value}(_tokenAddr, amount, _onBehalf);\n\n        withdrawTokens(_tokenAddr);\n    }",
        "comments": [
            "",
            "    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens",
            "    /// @notice User paybacks tokens to the Aave protocol",
            "    /// @param _tokenAddr The address of the token to be paybacked",
            "    /// @param _aTokenAddr ATokens to be paybacked",
            "    /// @param _amount Amount of tokens to be payed back",
            "    /// @param _wholeDebt If true the _amount will be set to the whole amount of the debt",
            "    "
        ],
        "comt": "\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\n    /// @notice User paybacks tokens to the Aave protocol\n    /// @param _tokenAddr The address of the token to be paybacked\n    /// @param _aTokenAddr ATokens to be paybacked\n    /// @param _amount Amount of tokens to be payed back\n    /// @param _wholeDebt If true the _amount will be set to the whole amount of the debt\n    ",
        "@dev": "User needs to approve the DSProxy to pull the _tokenAddr tokens",
        "@notice": "User paybacks tokens to the Aave protocol",
        "@param1": "_tokenAddr The address of the token to be paybacked",
        "@param2": "_aTokenAddr ATokens to be paybacked",
        "@param3": "_amount Amount of tokens to be payed back",
        "@param4": "_wholeDebt If true the _amount will be set to the whole amount of the debt",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawTokens",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            }
        ],
        "func": "function withdrawTokens(address _tokenAddr) public {\n        uint256 amount = _tokenAddr == ETH_ADDR ? address(this).balance : ERC20(_tokenAddr).balanceOf(address(this));\n\n        if (amount > 0) {\n            if (_tokenAddr != ETH_ADDR) {\n                ERC20(_tokenAddr).safeTransfer(msg.sender, amount);\n            } else {\n                msg.sender.transfer(amount);\n            }\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Helper method to withdraw tokens from the DSProxy",
            "    /// @param _tokenAddr Address of the token to be withdrawn",
            "    "
        ],
        "comt": "\n    /// @notice Helper method to withdraw tokens from the DSProxy\n    /// @param _tokenAddr Address of the token to be withdrawn\n    ",
        "@notice": "Helper method to withdraw tokens from the DSProxy",
        "@param1": "_tokenAddr Address of the token to be withdrawn",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setUserUseReserveAsCollateralIfNeeded",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            }
        ],
        "func": "function setUserUseReserveAsCollateralIfNeeded(address _tokenAddr) public {\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n        (,,,,,,,,,bool collateralEnabled) = ILendingPool(lendingPool).getUserReserveData(_tokenAddr, address(this));\n\n        if (!collateralEnabled) {\n            ILendingPool(lendingPool).setUserUseReserveAsCollateral(_tokenAddr, true);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setUserUseReserveAsCollateral",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_true",
                "type": "bool"
            }
        ],
        "func": "function setUserUseReserveAsCollateral(address _tokenAddr, bool _true) public {\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\n        ILendingPool(lendingPool).setUserUseReserveAsCollateral(_tokenAddr, _true);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapBorrowRateMode",
        "visibility": "public",
        "args": [
            {
                "name": "_reserve",
                "type": "address"
            }
        ],
        "func": "function swapBorrowRateMode(address _reserve) public {\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\n        ILendingPool(lendingPool).swapBorrowRateMode(_reserve);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMaxCollateral",
        "visibility": "public",
        "args": [
            {
                "name": "_collateralAddress",
                "type": "address"
            },
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function getMaxCollateral(address _collateralAddress, address _user) public view returns (uint256) {\n        address lendingPoolAddressDataProvider = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolDataProvider();\n        address lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n\n        uint256 pow10 = 10 ** (18 - _getDecimals(_collateralAddress));\n\n        // fetch all needed data\n        (,uint256 totalCollateralETH, uint256 totalBorrowsETH,,uint256 currentLTV,,,) = ILendingPool(lendingPoolAddressDataProvider).calculateUserGlobalData(_user);\n        (,uint256 tokenLTV,,) = ILendingPool(lendingPoolCoreAddress).getReserveConfiguration(_collateralAddress);\n        uint256 collateralPrice = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_collateralAddress);\n        uint256 userTokenBalance = ILendingPool(lendingPoolCoreAddress).getUserUnderlyingAssetBalance(_collateralAddress, _user);\n        uint256 userTokenBalanceEth = wmul(userTokenBalance * pow10, collateralPrice);\n\n  // if borrow is 0, return whole user balance\n        if (totalBorrowsETH == 0) {\n         return userTokenBalance;\n        }\n\n        uint256 maxCollateralEth = div(sub(mul(currentLTV, totalCollateralETH), mul(totalBorrowsETH, 100)), currentLTV);\n  /// @dev final amount can't be higher than users token balance\n        maxCollateralEth = maxCollateralEth > userTokenBalanceEth ? userTokenBalanceEth : maxCollateralEth;\n\n        // might happen due to wmul precision\n        if (maxCollateralEth >= totalCollateralETH) {\n         return wdiv(totalCollateralETH, collateralPrice) / pow10;\n        }\n\n        // get sum of all other reserves multiplied with their liquidation thresholds by reversing formula\n        uint256 a = sub(wmul(currentLTV, totalCollateralETH), wmul(tokenLTV, userTokenBalanceEth));\n        // add new collateral amount multiplied by its threshold, and then divide with new total collateral\n        uint256 newLiquidationThreshold = wdiv(add(a, wmul(sub(userTokenBalanceEth, maxCollateralEth), tokenLTV)), sub(totalCollateralETH, maxCollateralEth));\n\n        // if new threshold is lower than first one, calculate new max collateral with newLiquidationThreshold\n        if (newLiquidationThreshold < currentLTV) {\n         maxCollateralEth = div(sub(mul(newLiquidationThreshold, totalCollateralETH), mul(totalBorrowsETH, 100)), newLiquidationThreshold);\n         maxCollateralEth = maxCollateralEth > userTokenBalanceEth ? userTokenBalanceEth : maxCollateralEth;\n        }\n\n  return wmul(wdiv(maxCollateralEth, collateralPrice) / pow10, NINETY_NINE_PERCENT_WEI);\n }",
        "comments": [
            "",
            "    /// @param _collateralAddress underlying token address",
            "    /// @param _user users address",
            " "
        ],
        "comt": "\n    /// @param _collateralAddress underlying token address\n    /// @param _user users address\n ",
        "@param1": "_collateralAddress underlying token address",
        "@param2": "_user users address",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMaxBorrow",
        "visibility": "public",
        "args": [
            {
                "name": "_borrowAddress",
                "type": "address"
            },
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function getMaxBorrow(address _borrowAddress, address _user) public view returns (uint256) {\n  address lendingPoolAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n  address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n\n  (,,,,uint256 availableBorrowsETH,,,) = ILendingPool(lendingPoolAddress).getUserAccountData(_user);\n\n  uint256 borrowPrice = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_borrowAddress);\n\n  return wmul(wdiv(availableBorrowsETH, borrowPrice) / (10 ** (18 - _getDecimals(_borrowAddress))), NINETY_NINE_PERCENT_WEI);\n }",
        "comments": [
            "",
            " /// @param _borrowAddress underlying token address",
            " /// @param _user users address",
            " "
        ],
        "comt": "\n /// @param _borrowAddress underlying token address\n /// @param _user users address\n ",
        "@param1": "_borrowAddress underlying token address",
        "@param2": "_user users address",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMaxBoost",
        "visibility": "public",
        "args": [
            {
                "name": "_borrowAddress",
                "type": "address"
            },
            {
                "name": "_collateralAddress",
                "type": "address"
            },
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function getMaxBoost(address _borrowAddress, address _collateralAddress, address _user) public view returns (uint256) {\n        address lendingPoolAddressDataProvider = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolDataProvider();\n        address lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n\n        (,uint256 totalCollateralETH, uint256 totalBorrowsETH,,uint256 currentLTV,,,) = ILendingPool(lendingPoolAddressDataProvider).calculateUserGlobalData(_user);\n        (,uint256 tokenLTV,,) = ILendingPool(lendingPoolCoreAddress).getReserveConfiguration(_collateralAddress);\n        totalCollateralETH = div(mul(totalCollateralETH, currentLTV), 100);\n\n        uint256 availableBorrowsETH = wmul(mul(div(sub(totalCollateralETH, totalBorrowsETH), sub(100, tokenLTV)), 100), NINETY_NINE_PERCENT_WEI);\n        uint256 borrowPrice = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_borrowAddress);\n\n        return wdiv(availableBorrowsETH, borrowPrice) / (10 ** (18 - _getDecimals(_borrowAddress)));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sendContractBalance",
        "visibility": "public",
        "args": [
            {
                "name": "_token",
                "type": "address"
            },
            {
                "name": "_user",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            }
        ],
        "func": "function sendContractBalance(address _token, address _user, uint _amount) public {\n        if (_amount == 0) return;\n\n        if (_token == ETH_ADDR) {\n            payable(_user).transfer(_amount);\n        } else {\n            ERC20(_token).safeTransfer(_user, _amount);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Send specific amount from contract to specific user",
            "    /// @param _token Token we are trying to send",
            "    /// @param _user User that should receive funds",
            "    /// @param _amount Amount that should be sent",
            "    "
        ],
        "comt": "\n    /// @notice Send specific amount from contract to specific user\n    /// @param _token Token we are trying to send\n    /// @param _user User that should receive funds\n    /// @param _amount Amount that should be sent\n    ",
        "@notice": "Send specific amount from contract to specific user",
        "@param1": "_token Token we are trying to send",
        "@param2": "_user User that should receive funds",
        "@param3": "_amount Amount that should be sent",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sendFullContractBalance",
        "visibility": "public",
        "args": [
            {
                "name": "_token",
                "type": "address"
            },
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function sendFullContractBalance(address _token, address _user) public {\n        if (_token == ETH_ADDR) {\n            sendContractBalance(_token, _user, address(this).balance);\n        } else {\n            sendContractBalance(_token, _user, ERC20(_token).balanceOf(address(this)));\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "read",
        "visibility": "public",
        "args": [
            {
                "name": "_code",
                "type": "bytes memory"
            }
        ],
        "func": "function read(bytes memory _code) public view returns (address) {\n        bytes32 hash = keccak256(_code);\n        return cache[hash];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "write",
        "visibility": "public",
        "args": [
            {
                "name": "_code",
                "type": "bytes memory"
            }
        ],
        "func": "function write(bytes memory _code) public returns (address target) {\n        assembly {\n            target := create(0, add(_code, 0x20), mload(_code))\n            switch iszero(extcodesize(target))\n                case 1 {\n                    // throw if contract failed to deploy\n                    revert(0, 0)\n                }\n        }\n        bytes32 hash = keccak256(_code);\n        cache[hash] = target;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setOwner",
        "visibility": "public",
        "args": [
            {
                "name": "owner_",
                "type": "address"
            }
        ],
        "func": "function setOwner(address owner_) public auth {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setAuthority",
        "visibility": "public",
        "args": [
            {
                "name": "authority_",
                "type": "DSAuthority"
            }
        ],
        "func": "function setAuthority(DSAuthority authority_) public auth {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isCustomFeeSet",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function isCustomFeeSet(address _user) public view returns (bool) {\n        return serviceFees[_user].active;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCustomServiceFee",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function getCustomServiceFee(address _user) public view returns (uint256) {\n        return serviceFees[_user].amount;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setServiceFee",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            },
            {
                "name": "_fee",
                "type": "uint256"
            }
        ],
        "func": "function setServiceFee(address _user, uint256 _fee) public {\n        require(msg.sender == owner, \"Only owner\");\n        require(_fee >= MAX_SERVICE_FEE || _fee == 0);\n\n        serviceFees[_user] = CustomServiceFee({active: true, amount: _fee});\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "disableServiceFee",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function disableServiceFee(address _user) public {\n        require(msg.sender == owner, \"Only owner\");\n\n        serviceFees[_user] = CustomServiceFee({active: false, amount: 0});\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setBot",
        "visibility": "public",
        "args": [
            {
                "name": "_botAddr",
                "type": "address"
            },
            {
                "name": "_state",
                "type": "bool"
            }
        ],
        "func": "function setBot(address _botAddr, bool _state) public onlyOwner {\n        botList[_botAddr] = _state;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setAdminByOwner",
        "visibility": "public",
        "args": [
            {
                "name": "_admin",
                "type": "address"
            }
        ],
        "func": "function setAdminByOwner(address _admin) public {\n        require(msg.sender == owner);\n        require(admin == address(0));\n\n        admin = _admin;\n    }",
        "comments": [
            "",
            "    /// @notice Admin is set by owner first time, after that admin is super role and has permission to change owner",
            "    /// @param _admin Address of multisig that becomes admin",
            "    "
        ],
        "comt": "\n    /// @notice Admin is set by owner first time, after that admin is super role and has permission to change owner\n    /// @param _admin Address of multisig that becomes admin\n    ",
        "@notice": "Admin is set by owner first time, after that admin is super role and has permission to change owner",
        "@param1": "_admin Address of multisig that becomes admin",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setAdminByAdmin",
        "visibility": "public",
        "args": [
            {
                "name": "_admin",
                "type": "address"
            }
        ],
        "func": "function setAdminByAdmin(address _admin) public {\n        require(msg.sender == admin);\n\n        admin = _admin;\n    }",
        "comments": [
            "",
            "    /// @notice Admin is able to set new admin",
            "    /// @param _admin Address of multisig that becomes new admin",
            "    "
        ],
        "comt": "\n    /// @notice Admin is able to set new admin\n    /// @param _admin Address of multisig that becomes new admin\n    ",
        "@notice": "Admin is able to set new admin",
        "@param1": "_admin Address of multisig that becomes new admin",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setOwnerByAdmin",
        "visibility": "public",
        "args": [
            {
                "name": "_owner",
                "type": "address"
            }
        ],
        "func": "function setOwnerByAdmin(address _owner) public {\n        require(msg.sender == admin);\n\n        owner = _owner;\n    }",
        "comments": [
            "",
            "    /// @notice Admin is able to change owner",
            "    /// @param _owner Address of new owner",
            "    "
        ],
        "comt": "\n    /// @notice Admin is able to change owner\n    /// @param _owner Address of new owner\n    ",
        "@notice": "Admin is able to change owner",
        "@param1": "_owner Address of new owner",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "kill",
        "visibility": "public",
        "args": [],
        "func": "function kill() public onlyOwner {\n        selfdestruct(payable(owner));\n    }",
        "comments": [
            "",
            "    /// @notice Destroy the contract",
            "    "
        ],
        "comt": "\n    /// @notice Destroy the contract\n    ",
        "@notice": "Destroy the contract",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawStuckFunds",
        "visibility": "public",
        "args": [
            {
                "name": "_token",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            }
        ],
        "func": "function withdrawStuckFunds(address _token, uint _amount) public onlyOwner {\n        if (_token == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n            payable(owner).transfer(_amount);\n        } else {\n            ERC20(_token).safeTransfer(owner, _amount);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice  withdraw stuck funds",
            "    "
        ],
        "comt": "\n    /// @notice  withdraw stuck funds\n    ",
        "@notice": "withdraw stuck funds",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getRatio",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function getRatio(address _user) public view returns (uint256) {\n        // For each asset the account is in\n        return getSafetyRatio(_user);\n    }",
        "comments": [
            "",
            "    /// @notice Calcualted the ratio of coll/debt for a compound user",
            "    /// @param _user Address of the user",
            "    "
        ],
        "comt": "\n    /// @notice Calcualted the ratio of coll/debt for a compound user\n    /// @param _user Address of the user\n    ",
        "@notice": "Calcualted the ratio of coll/debt for a compound user",
        "@param1": "_user Address of the user",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPrices",
        "visibility": "public",
        "args": [
            {
                "name": "_tokens",
                "type": "address[] memory"
            }
        ],
        "func": "function getPrices(address[] memory _tokens) public view returns (uint256[] memory prices) {\n        address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n        prices = new uint[](_tokens.length);\n\n        for (uint256 i = 0; i < _tokens.length; ++i) {\n            prices[i] = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_tokens[i]);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Fetches Aave prices for tokens",
            "    /// @param _tokens Arr. of tokens for which to get the prices",
            "    /// @return prices Array of prices",
            "    "
        ],
        "comt": "\n    /// @notice Fetches Aave prices for tokens\n    /// @param _tokens Arr. of tokens for which to get the prices\n    /// @return prices Array of prices\n    ",
        "@notice": "Fetches Aave prices for tokens",
        "@param1": "_tokens Arr. of tokens for which to get the prices",
        "@return1": "prices Array of prices",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCollFactors",
        "visibility": "public",
        "args": [
            {
                "name": "_tokens",
                "type": "address[] memory"
            }
        ],
        "func": "function getCollFactors(address[] memory _tokens) public view returns (uint256[] memory collFactors) {\n     address lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        collFactors = new uint256[](_tokens.length);\n\n        for (uint256 i = 0; i < _tokens.length; ++i) {\n         (,collFactors[i],,) = ILendingPool(lendingPoolCoreAddress).getReserveConfiguration(_tokens[i]);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Fetches Aave collateral factors for tokens",
            "    /// @param _tokens Arr. of tokens for which to get the coll. factors",
            "    /// @return collFactors Array of coll. factors",
            "    "
        ],
        "comt": "\n    /// @notice Fetches Aave collateral factors for tokens\n    /// @param _tokens Arr. of tokens for which to get the coll. factors\n    /// @return collFactors Array of coll. factors\n    ",
        "@notice": "Fetches Aave collateral factors for tokens",
        "@param1": "_tokens Arr. of tokens for which to get the coll. factors",
        "@return1": "collFactors Array of coll. factors",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getTokenBalances",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            },
            {
                "name": "_tokens",
                "type": "address[] memory"
            }
        ],
        "func": "function getTokenBalances(address _user, address[] memory _tokens) public view returns (uint256[] memory balances, uint256[] memory borrows, bool[] memory enabledAsCollateral) {\n     address lendingPoolAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\n        balances = new uint256[](_tokens.length);\n        borrows = new uint256[](_tokens.length);\n        enabledAsCollateral = new bool[](_tokens.length);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address asset = _tokens[i];\n\n            (balances[i], borrows[i],,,,,,,,enabledAsCollateral[i]) = ILendingPool(lendingPoolAddress).getUserReserveData(asset, _user);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getRatios",
        "visibility": "public",
        "args": [
            {
                "name": "_users",
                "type": "address[] memory"
            }
        ],
        "func": "function getRatios(address[] memory _users) public view returns (uint256[] memory ratios) {\n        ratios = new uint256[](_users.length);\n\n        for (uint256 i = 0; i < _users.length; ++i) {\n            ratios[i] = getSafetyRatio(_users[i]);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Calcualted the ratio of coll/debt for an aave user",
            "    /// @param _users Addresses of the user",
            "    /// @return ratios Array of ratios",
            "    "
        ],
        "comt": "\n    /// @notice Calcualted the ratio of coll/debt for an aave user\n    /// @param _users Addresses of the user\n    /// @return ratios Array of ratios\n    ",
        "@notice": "Calcualted the ratio of coll/debt for an aave user",
        "@param1": "_users Addresses of the user",
        "@return1": "ratios Array of ratios",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getTokensInfo",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddresses",
                "type": "address[] memory"
            }
        ],
        "func": "function getTokensInfo(address[] memory _tokenAddresses) public view returns(TokenInfo[] memory tokens) {\n     address lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n     address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n\n        tokens = new TokenInfo[](_tokenAddresses.length);\n\n        for (uint256 i = 0; i < _tokenAddresses.length; ++i) {\n         (,uint256 ltv,,) = ILendingPool(lendingPoolCoreAddress).getReserveConfiguration(_tokenAddresses[i]);\n\n            tokens[i] = TokenInfo({\n                aTokenAddress: ILendingPool(lendingPoolCoreAddress).getReserveATokenAddress(_tokenAddresses[i]),\n                underlyingTokenAddress: _tokenAddresses[i],\n                collateralFactor: ltv,\n                price: IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_tokenAddresses[i])\n            });\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Information about reserves",
            "    /// @param _tokenAddresses Array of tokens addresses",
            "    /// @return tokens Array of reserves infomartion",
            "    "
        ],
        "comt": "\n    /// @notice Information about reserves\n    /// @param _tokenAddresses Array of tokens addresses\n    /// @return tokens Array of reserves infomartion\n    ",
        "@notice": "Information about reserves",
        "@param1": "_tokenAddresses Array of tokens addresses",
        "@return1": "tokens Array of reserves infomartion",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getFullTokensInfo",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddresses",
                "type": "address[] memory"
            }
        ],
        "func": "function getFullTokensInfo(address[] memory _tokenAddresses) public view returns(TokenInfoFull[] memory tokens) {\n     address lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        address lendingPoolAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n     address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n\n        tokens = new TokenInfoFull[](_tokenAddresses.length);\n\n        for (uint256 i = 0; i < _tokenAddresses.length; ++i) {\n         (uint256 ltv, uint256 liqRatio,,, bool usageAsCollateralEnabled, bool borrowingEnabled, bool stableBorrowingEnabled,) = ILendingPool(lendingPoolAddress).getReserveConfigurationData(_tokenAddresses[i]);\n\n            tokens[i] = TokenInfoFull({\n             aTokenAddress: ILendingPool(lendingPoolCoreAddress).getReserveATokenAddress(_tokenAddresses[i]),\n                underlyingTokenAddress: _tokenAddresses[i],\n                supplyRate: ILendingPool(lendingPoolCoreAddress).getReserveCurrentLiquidityRate(_tokenAddresses[i]),\n                borrowRate: borrowingEnabled ? ILendingPool(lendingPoolCoreAddress).getReserveCurrentVariableBorrowRate(_tokenAddresses[i]) : 0,\n                borrowRateStable: stableBorrowingEnabled ? ILendingPool(lendingPoolCoreAddress).getReserveCurrentStableBorrowRate(_tokenAddresses[i]) : 0,\n                totalSupply: ILendingPool(lendingPoolCoreAddress).getReserveTotalLiquidity(_tokenAddresses[i]),\n                availableLiquidity: ILendingPool(lendingPoolCoreAddress).getReserveAvailableLiquidity(_tokenAddresses[i]),\n                totalBorrow: ILendingPool(lendingPoolCoreAddress).getReserveTotalBorrowsVariable(_tokenAddresses[i]),\n                collateralFactor: ltv,\n                liquidationRatio: liqRatio,\n                price: IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_tokenAddresses[i]),\n                usageAsCollateralEnabled: usageAsCollateralEnabled\n            });\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Information about reserves",
            "    /// @param _tokenAddresses Array of token addresses",
            "    /// @return tokens Array of reserves infomartion",
            "    "
        ],
        "comt": "\n    /// @notice Information about reserves\n    /// @param _tokenAddresses Array of token addresses\n    /// @return tokens Array of reserves infomartion\n    ",
        "@notice": "Information about reserves",
        "@param1": "_tokenAddresses Array of token addresses",
        "@return1": "tokens Array of reserves infomartion",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getLoanData",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function getLoanData(address _user) public view returns (LoanData memory data) {\n        address lendingPoolAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n        address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n\n        address[] memory reserves = ILendingPool(lendingPoolAddress).getReserves();\n\n        data = LoanData({\n            user: _user,\n            ratio: 0,\n            collAddr: new address[](reserves.length),\n            borrowAddr: new address[](reserves.length),\n            collAmounts: new uint[](reserves.length),\n            borrowAmounts: new uint[](reserves.length)\n        });\n\n        uint64 collPos = 0;\n        uint64 borrowPos = 0;\n\n        for (uint64 i = 0; i < reserves.length; i++) {\n            address reserve = reserves[i];\n\n            (uint256 aTokenBalance, uint256 borrowBalance,,,,,,,,) = ILendingPool(lendingPoolAddress).getUserReserveData(reserve, _user);\n            uint256 price = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(reserves[i]);\n\n            if (aTokenBalance > 0) {\n             uint256 userTokenBalanceEth = wmul(aTokenBalance, price) * (10 ** (18 - _getDecimals(reserve)));\n             data.collAddr[collPos] = reserve;\n                data.collAmounts[collPos] = userTokenBalanceEth;\n                collPos++;\n         }\n\n            // Sum up debt in Eth\n            if (borrowBalance > 0) {\n             uint256 userBorrowBalanceEth = wmul(borrowBalance, price) * (10 ** (18 - _getDecimals(reserve)));\n                data.borrowAddr[borrowPos] = reserve;\n                data.borrowAmounts[borrowPos] = userBorrowBalanceEth;\n                borrowPos++;\n            }\n        }\n\n        data.ratio = uint128(getSafetyRatio(_user));\n\n        return data;\n    }",
        "comments": [
            "",
            "",
            "    /// @notice Fetches all the collateral/debt address and amounts, denominated in ether",
            "    /// @param _user Address of the user",
            "    /// @return data LoanData information",
            "    "
        ],
        "comt": "\n\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in ether\n    /// @param _user Address of the user\n    /// @return data LoanData information\n    ",
        "@notice": "Fetches all the collateral/debt address and amounts, denominated in ether",
        "@param1": "_user Address of the user",
        "@return1": "data LoanData information",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getLoanDataArr",
        "visibility": "public",
        "args": [
            {
                "name": "_users",
                "type": "address[] memory"
            }
        ],
        "func": "function getLoanDataArr(address[] memory _users) public view returns (LoanData[] memory loans) {\n        loans = new LoanData[](_users.length);\n\n        for (uint i = 0; i < _users.length; ++i) {\n            loans[i] = getLoanData(_users[i]);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Fetches all the collateral/debt address and amounts, denominated in ether",
            "    /// @param _users Addresses of the user",
            "    /// @return loans Array of LoanData information",
            "    "
        ],
        "comt": "\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in ether\n    /// @param _users Addresses of the user\n    /// @return loans Array of LoanData information\n    ",
        "@notice": "Fetches all the collateral/debt address and amounts, denominated in ether",
        "@param1": "_users Addresses of the user",
        "@return1": "loans Array of LoanData information",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getSafetyRatio",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function getSafetyRatio(address _user) public view returns(uint256) {\n        address lendingPoolAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n        (,,uint256 totalBorrowsETH,,uint256 availableBorrowsETH,,,) = ILendingPool(lendingPoolAddress).getUserAccountData(_user);\n\n        if (totalBorrowsETH == 0) return uint256(0);\n\n        return wdiv(add(totalBorrowsETH, availableBorrowsETH), totalBorrowsETH);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repayFor",
        "visibility": "public",
        "args": [
            {
                "name": "_exData",
                "type": "SaverExchangeCore.ExchangeData memory"
            },
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function repayFor(\n        SaverExchangeCore.ExchangeData memory _exData,\n        address _user\n    ) public payable onlyApproved burnGas(REPAY_GAS_TOKEN) {\n\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Repay, _user);\n        require(isAllowed); // check if conditions are met\n\n        uint256 gasCost = calcGasCost(REPAY_GAS_COST);\n\n        aaveMonitorProxy.callExecute{value: msg.value}(\n            _user,\n            aaveSaverProxy,\n            abi.encodeWithSignature(\n                \"repay((address,address,uint256,uint256,uint256,address,address,bytes,uint256),uint256)\",\n                _exData,\n                gasCost\n            )\n        );\n\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Repay, _user);\n        require(isGoodRatio); // check if the after result of the actions is good\n\n        returnEth();\n\n        logger.Log(address(this), _user, \"AutomaticAaveRepay\", abi.encode(ratioBefore, ratioAfter));\n    }",
        "comments": [
            "",
            "    /// @notice Bots call this method to repay for user when conditions are met",
            "    /// @dev If the contract ownes gas token it will try and use it for gas price reduction",
            "    /// @param _exData Exchange data",
            "    /// @param _user The actual address that owns the Aave position",
            "    "
        ],
        "comt": "\n    /// @notice Bots call this method to repay for user when conditions are met\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\n    /// @param _exData Exchange data\n    /// @param _user The actual address that owns the Aave position\n    ",
        "@notice": "Bots call this method to repay for user when conditions are met",
        "@dev": "If the contract ownes gas token it will try and use it for gas price reduction",
        "@param1": "_exData Exchange data",
        "@param2": "_user The actual address that owns the Aave position",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "boostFor",
        "visibility": "public",
        "args": [
            {
                "name": "_exData",
                "type": "SaverExchangeCore.ExchangeData memory"
            },
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function boostFor(\n        SaverExchangeCore.ExchangeData memory _exData,\n        address _user\n    ) public payable onlyApproved burnGas(BOOST_GAS_TOKEN) {\n\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Boost, _user);\n        require(isAllowed); // check if conditions are met\n\n        uint256 gasCost = calcGasCost(BOOST_GAS_COST);\n\n        aaveMonitorProxy.callExecute{value: msg.value}(\n            _user,\n            aaveSaverProxy,\n            abi.encodeWithSignature(\n                \"boost((address,address,uint256,uint256,uint256,address,address,bytes,uint256),uint256)\",\n                _exData,\n                gasCost\n            )\n        );\n\n\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Boost, _user);\n        require(isGoodRatio);  // check if the after result of the actions is good\n\n        returnEth();\n\n        logger.Log(address(this), _user, \"AutomaticAaveBoost\", abi.encode(ratioBefore, ratioAfter));\n    }",
        "comments": [
            "",
            "    /// @notice Bots call this method to boost for user when conditions are met",
            "    /// @dev If the contract ownes gas token it will try and use it for gas price reduction",
            "    /// @param _exData Exchange data",
            "    /// @param _user The actual address that owns the Aave position",
            "    "
        ],
        "comt": "\n    /// @notice Bots call this method to boost for user when conditions are met\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\n    /// @param _exData Exchange data\n    /// @param _user The actual address that owns the Aave position\n    ",
        "@notice": "Bots call this method to boost for user when conditions are met",
        "@dev": "If the contract ownes gas token it will try and use it for gas price reduction",
        "@param1": "_exData Exchange data",
        "@param2": "_user The actual address that owns the Aave position",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "canCall",
        "visibility": "public",
        "args": [
            {
                "name": "_method",
                "type": "Method"
            },
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function canCall(Method _method, address _user) public view returns(bool, uint) {\n        bool subscribed = subscriptionsContract.isSubscribed(_user);\n        AaveSubscriptions.AaveHolder memory holder = subscriptionsContract.getHolder(_user);\n\n        // check if cdp is subscribed\n        if (!subscribed) return (false, 0);\n\n        // check if boost and boost allowed\n        if (_method == Method.Boost && !holder.boostEnabled) return (false, 0);\n\n        uint currRatio = getSafetyRatio(_user);\n\n        if (_method == Method.Repay) {\n            return (currRatio < holder.minRatio, currRatio);\n        } else if (_method == Method.Boost) {\n            return (currRatio > holder.maxRatio, currRatio);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "ratioGoodAfter",
        "visibility": "public",
        "args": [
            {
                "name": "_method",
                "type": "Method"
            },
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function ratioGoodAfter(Method _method, address _user) public view returns(bool, uint) {\n        AaveSubscriptions.AaveHolder memory holder;\n\n        holder= subscriptionsContract.getHolder(_user);\n\n        uint currRatio = getSafetyRatio(_user);\n\n        if (_method == Method.Repay) {\n            return (currRatio < holder.maxRatio, currRatio);\n        } else if (_method == Method.Boost) {\n            return (currRatio > holder.minRatio, currRatio);\n        }\n    }",
        "comments": [
            "",
            "    /// @dev After the Boost/Repay check if the ratio doesn't trigger another call",
            "    /// @param _method Type of action to be called",
            "    /// @param _user The actual address that owns the Aave position",
            "    /// @return Boolean if the recent action preformed correctly and the ratio",
            "    "
        ],
        "comt": "\n    /// @dev After the Boost/Repay check if the ratio doesn't trigger another call\n    /// @param _method Type of action to be called\n    /// @param _user The actual address that owns the Aave position\n    /// @return Boolean if the recent action preformed correctly and the ratio\n    ",
        "@dev": "After the Boost/Repay check if the ratio doesn't trigger another call",
        "@param1": "_method Type of action to be called",
        "@param2": "_user The actual address that owns the Aave position",
        "@return1": "Boolean if the recent action preformed correctly and the ratio",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "calcGasCost",
        "visibility": "public",
        "args": [
            {
                "name": "_gasAmount",
                "type": "uint"
            }
        ],
        "func": "function calcGasCost(uint _gasAmount) public view returns (uint) {\n        uint gasPrice = tx.gasprice <= MAX_GAS_PRICE ? tx.gasprice : MAX_GAS_PRICE;\n\n        return mul(gasPrice, _gasAmount);\n    }",
        "comments": [
            "",
            "    /// @notice Calculates gas cost (in Eth) of tx",
            "    /// @dev Gas price is limited to MAX_GAS_PRICE to prevent attack of draining user CDP",
            "    /// @param _gasAmount Amount of gas used for the tx",
            "    "
        ],
        "comt": "\n    /// @notice Calculates gas cost (in Eth) of tx\n    /// @dev Gas price is limited to MAX_GAS_PRICE to prevent attack of draining user CDP\n    /// @param _gasAmount Amount of gas used for the tx\n    ",
        "@notice": "Calculates gas cost (in Eth) of tx",
        "@dev": "Gas price is limited to MAX_GAS_PRICE to prevent attack of draining user CDP",
        "@param1": "_gasAmount Amount of gas used for the tx",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeBoostGasCost",
        "visibility": "public",
        "args": [
            {
                "name": "_gasCost",
                "type": "uint"
            }
        ],
        "func": "function changeBoostGasCost(uint _gasCost) public onlyOwner {\n        require(_gasCost < 3000000);\n\n        BOOST_GAS_COST = _gasCost;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeRepayGasCost",
        "visibility": "public",
        "args": [
            {
                "name": "_gasCost",
                "type": "uint"
            }
        ],
        "func": "function changeRepayGasCost(uint _gasCost) public onlyOwner {\n        require(_gasCost < 3000000);\n\n        REPAY_GAS_COST = _gasCost;\n    }",
        "comments": [
            "",
            "    /// @notice Allows owner to change gas cost for repay operation, but only up to 3 millions",
            "    /// @param _gasCost New gas cost for repay method",
            "    "
        ],
        "comt": "\n    /// @notice Allows owner to change gas cost for repay operation, but only up to 3 millions\n    /// @param _gasCost New gas cost for repay method\n    ",
        "@notice": "Allows owner to change gas cost for repay operation, but only up to 3 millions",
        "@param1": "_gasCost New gas cost for repay method",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeMaxGasPrice",
        "visibility": "public",
        "args": [
            {
                "name": "_maxGasPrice",
                "type": "uint"
            }
        ],
        "func": "function changeMaxGasPrice(uint _maxGasPrice) public onlyOwner {\n        require(_maxGasPrice < 500000000000);\n\n        MAX_GAS_PRICE = _maxGasPrice;\n    }",
        "comments": [
            "",
            "    /// @notice Allows owner to change max gas price",
            "    /// @param _maxGasPrice New max gas price",
            "    "
        ],
        "comt": "\n    /// @notice Allows owner to change max gas price\n    /// @param _maxGasPrice New max gas price\n    ",
        "@notice": "Allows owner to change max gas price",
        "@param1": "_maxGasPrice New max gas price",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeGasTokenAmount",
        "visibility": "public",
        "args": [
            {
                "name": "_gasTokenAmount",
                "type": "uint"
            },
            {
                "name": "_repay",
                "type": "bool"
            }
        ],
        "func": "function changeGasTokenAmount(uint _gasTokenAmount, bool _repay) public onlyOwner {\n        if (_repay) {\n            REPAY_GAS_TOKEN = _gasTokenAmount;\n        } else {\n            BOOST_GAS_TOKEN = _gasTokenAmount;\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Allows owner to change gas token amount",
            "    /// @param _gasTokenAmount New gas token amount",
            "    /// @param _repay true if repay gas token, false if boost gas token",
            "    "
        ],
        "comt": "\n    /// @notice Allows owner to change gas token amount\n    /// @param _gasTokenAmount New gas token amount\n    /// @param _repay true if repay gas token, false if boost gas token\n    ",
        "@notice": "Allows owner to change gas token amount",
        "@param1": "_gasTokenAmount New gas token amount",
        "@param2": "_repay true if repay gas token, false if boost gas token",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "callExecute",
        "visibility": "public",
        "args": [
            {
                "name": "_owner",
                "type": "address"
            },
            {
                "name": "_aaveSaverProxy",
                "type": "address"
            },
            {
                "name": "_data",
                "type": "bytes memory"
            }
        ],
        "func": "function callExecute(address _owner, address _aaveSaverProxy, bytes memory _data) public payable onlyMonitor {\n        // execute reverts if calling specific method fails\n        DSProxyInterface(_owner).execute{value: msg.value}(_aaveSaverProxy, _data);\n\n        // return if anything left\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Only monitor contract is able to call execute on users proxy",
            "    /// @param _owner Address of cdp owner (users DSProxy address)",
            "    /// @param _aaveSaverProxy Address of AaveSaverProxy",
            "    /// @param _data Data to send to AaveSaverProxy",
            "    "
        ],
        "comt": "\n    /// @notice Only monitor contract is able to call execute on users proxy\n    /// @param _owner Address of cdp owner (users DSProxy address)\n    /// @param _aaveSaverProxy Address of AaveSaverProxy\n    /// @param _data Data to send to AaveSaverProxy\n    ",
        "@notice": "Only monitor contract is able to call execute on users proxy",
        "@param1": "_owner Address of cdp owner (users DSProxy address)",
        "@param2": "_aaveSaverProxy Address of AaveSaverProxy",
        "@param3": "_data Data to send to AaveSaverProxy",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setMonitor",
        "visibility": "public",
        "args": [
            {
                "name": "_monitor",
                "type": "address"
            }
        ],
        "func": "function setMonitor(address _monitor) public onlyAllowed {\n        require(monitor == address(0));\n        monitor = _monitor;\n    }",
        "comments": [
            "",
            "    /// @notice Allowed users are able to set Monitor contract without any waiting period first time",
            "    /// @param _monitor Address of Monitor contract",
            "    "
        ],
        "comt": "\n    /// @notice Allowed users are able to set Monitor contract without any waiting period first time\n    /// @param _monitor Address of Monitor contract\n    ",
        "@notice": "Allowed users are able to set Monitor contract without any waiting period first time",
        "@param1": "_monitor Address of Monitor contract",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeMonitor",
        "visibility": "public",
        "args": [
            {
                "name": "_newMonitor",
                "type": "address"
            }
        ],
        "func": "function changeMonitor(address _newMonitor) public onlyAllowed {\n        require(changeRequestedTimestamp == 0);\n\n        changeRequestedTimestamp = now;\n        lastMonitor = monitor;\n        newMonitor = _newMonitor;\n\n        emit MonitorChangeInitiated(lastMonitor, newMonitor);\n    }",
        "comments": [
            "",
            "    /// @notice Allowed users are able to start procedure for changing monitor",
            "    /// @dev after CHANGE_PERIOD needs to call confirmNewMonitor to actually make a change",
            "    /// @param _newMonitor address of new monitor",
            "    "
        ],
        "comt": "\n    /// @notice Allowed users are able to start procedure for changing monitor\n    /// @dev after CHANGE_PERIOD needs to call confirmNewMonitor to actually make a change\n    /// @param _newMonitor address of new monitor\n    ",
        "@notice": "Allowed users are able to start procedure for changing monitor",
        "@dev": "after CHANGE_PERIOD needs to call confirmNewMonitor to actually make a change",
        "@param1": "_newMonitor address of new monitor",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cancelMonitorChange",
        "visibility": "public",
        "args": [],
        "func": "function cancelMonitorChange() public onlyAllowed {\n        require(changeRequestedTimestamp > 0);\n\n        changeRequestedTimestamp = 0;\n        newMonitor = address(0);\n\n        emit MonitorChangeCanceled();\n    }",
        "comments": [
            "",
            "    /// @notice At any point allowed users are able to cancel monitor change",
            "    "
        ],
        "comt": "\n    /// @notice At any point allowed users are able to cancel monitor change\n    ",
        "@notice": "At any point allowed users are able to cancel monitor change",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "confirmNewMonitor",
        "visibility": "public",
        "args": [],
        "func": "function confirmNewMonitor() public onlyAllowed {\n        require((changeRequestedTimestamp + CHANGE_PERIOD) < now);\n        require(changeRequestedTimestamp != 0);\n        require(newMonitor != address(0));\n\n        monitor = newMonitor;\n        newMonitor = address(0);\n        changeRequestedTimestamp = 0;\n\n        emit MonitorChangeFinished(monitor);\n    }",
        "comments": [
            "",
            "    /// @notice Anyone is able to confirm new monitor after CHANGE_PERIOD if process is started",
            "    "
        ],
        "comt": "\n    /// @notice Anyone is able to confirm new monitor after CHANGE_PERIOD if process is started\n    ",
        "@notice": "Anyone is able to confirm new monitor after CHANGE_PERIOD if process is started",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "revertMonitor",
        "visibility": "public",
        "args": [],
        "func": "function revertMonitor() public onlyAllowed {\n        require(lastMonitor != address(0));\n\n        monitor = lastMonitor;\n\n        emit MonitorChangeReverted(monitor);\n    }",
        "comments": [
            "",
            "    /// @notice Its possible to revert monitor to last used monitor",
            "    "
        ],
        "comt": "\n    /// @notice Its possible to revert monitor to last used monitor\n    ",
        "@notice": "Its possible to revert monitor to last used monitor",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addAllowed",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function addAllowed(address _user) public onlyAllowed {\n        allowed[_user] = true;\n    }",
        "comments": [
            "",
            "",
            "    /// @notice Allowed users are able to add new allowed user",
            "    /// @param _user Address of user that will be allowed",
            "    "
        ],
        "comt": "\n\n    /// @notice Allowed users are able to add new allowed user\n    /// @param _user Address of user that will be allowed\n    ",
        "@notice": "Allowed users are able to add new allowed user",
        "@param1": "_user Address of user that will be allowed",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeAllowed",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function removeAllowed(address _user) public onlyAllowed {\n        allowed[_user] = false;\n    }",
        "comments": [
            "",
            "    /// @notice Allowed users are able to remove allowed user",
            "    /// @dev owner is always allowed even if someone tries to remove it from allowed mapping",
            "    /// @param _user Address of allowed user",
            "    "
        ],
        "comt": "\n    /// @notice Allowed users are able to remove allowed user\n    /// @dev owner is always allowed even if someone tries to remove it from allowed mapping\n    /// @param _user Address of allowed user\n    ",
        "@notice": "Allowed users are able to remove allowed user",
        "@dev": "owner is always allowed even if someone tries to remove it from allowed mapping",
        "@param1": "_user Address of allowed user",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setChangePeriod",
        "visibility": "public",
        "args": [
            {
                "name": "_periodInDays",
                "type": "uint"
            }
        ],
        "func": "function setChangePeriod(uint _periodInDays) public onlyAllowed {\n        require(_periodInDays * 1 days > CHANGE_PERIOD);\n\n        CHANGE_PERIOD = _periodInDays * 1 days;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawToken",
        "visibility": "public",
        "args": [
            {
                "name": "_token",
                "type": "address"
            }
        ],
        "func": "function withdrawToken(address _token) public onlyOwner {\n        uint balance = ERC20(_token).balanceOf(address(this));\n        ERC20(_token).safeTransfer(msg.sender, balance);\n    }",
        "comments": [
            "",
            "    /// @notice In case something is left in contract, owner is able to withdraw it",
            "    /// @param _token address of token to withdraw balance",
            "    "
        ],
        "comt": "\n    /// @notice In case something is left in contract, owner is able to withdraw it\n    /// @param _token address of token to withdraw balance\n    ",
        "@notice": "In case something is left in contract, owner is able to withdraw it",
        "@param1": "_token address of token to withdraw balance",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawEth",
        "visibility": "public",
        "args": [],
        "func": "function withdrawEth() public onlyOwner {\n        uint balance = address(this).balance;\n        msg.sender.transfer(balance);\n    }",
        "comments": [
            "",
            "    /// @notice In case something is left in contract, owner is able to withdraw it",
            "    "
        ],
        "comt": "\n    /// @notice In case something is left in contract, owner is able to withdraw it\n    ",
        "@notice": "In case something is left in contract, owner is able to withdraw it",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "subscribe",
        "visibility": "external",
        "args": [
            {
                "name": "_minRatio",
                "type": "uint128"
            },
            {
                "name": "_maxRatio",
                "type": "uint128"
            },
            {
                "name": "_optimalBoost",
                "type": "uint128"
            },
            {
                "name": "_optimalRepay",
                "type": "uint128"
            },
            {
                "name": "_boostEnabled",
                "type": "bool"
            }
        ],
        "func": "function subscribe(uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled) external {\n\n        // if boost is not enabled, set max ratio to max uint\n        uint128 localMaxRatio = _boostEnabled ? _maxRatio : uint128(-1);\n        require(checkParams(_minRatio, localMaxRatio), \"Must be correct params\");\n\n        SubPosition storage subInfo = subscribersPos[msg.sender];\n\n        AaveHolder memory subscription = AaveHolder({\n                minRatio: _minRatio,\n                maxRatio: localMaxRatio,\n                optimalRatioBoost: _optimalBoost,\n                optimalRatioRepay: _optimalRepay,\n                user: msg.sender,\n                boostEnabled: _boostEnabled\n            });\n\n        changeIndex++;\n\n        if (subInfo.subscribed) {\n            subscribers[subInfo.arrPos] = subscription;\n\n            emit Updated(msg.sender);\n            emit ParamUpdates(msg.sender, _minRatio, localMaxRatio, _optimalBoost, _optimalRepay, _boostEnabled);\n        } else {\n            subscribers.push(subscription);\n\n            subInfo.arrPos = subscribers.length - 1;\n            subInfo.subscribed = true;\n\n            emit Subscribed(msg.sender);\n        }\n    }",
        "comments": [
            "",
            "    /// @dev Called by the DSProxy contract which owns the Aave position",
            "    /// @notice Adds the users Aave poistion in the list of subscriptions so it can be monitored",
            "    /// @param _minRatio Minimum ratio below which repay is triggered",
            "    /// @param _maxRatio Maximum ratio after which boost is triggered",
            "    /// @param _optimalBoost Ratio amount which boost should target",
            "    /// @param _optimalRepay Ratio amount which repay should target",
            "    /// @param _boostEnabled Boolean determing if boost is enabled",
            "    "
        ],
        "comt": "\n    /// @dev Called by the DSProxy contract which owns the Aave position\n    /// @notice Adds the users Aave poistion in the list of subscriptions so it can be monitored\n    /// @param _minRatio Minimum ratio below which repay is triggered\n    /// @param _maxRatio Maximum ratio after which boost is triggered\n    /// @param _optimalBoost Ratio amount which boost should target\n    /// @param _optimalRepay Ratio amount which repay should target\n    /// @param _boostEnabled Boolean determing if boost is enabled\n    ",
        "@dev": "Called by the DSProxy contract which owns the Aave position",
        "@notice": "Adds the users Aave poistion in the list of subscriptions so it can be monitored",
        "@param1": "_minRatio Minimum ratio below which repay is triggered",
        "@param2": "_maxRatio Maximum ratio after which boost is triggered",
        "@param3": "_optimalBoost Ratio amount which boost should target",
        "@param4": "_optimalRepay Ratio amount which repay should target",
        "@param5": "_boostEnabled Boolean determing if boost is enabled",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unsubscribe",
        "visibility": "external",
        "args": [],
        "func": "function unsubscribe() external {\n        _unsubscribe(msg.sender);\n    }",
        "comments": [
            "",
            "    /// @notice Called by the users DSProxy",
            "    /// @dev Owner who subscribed cancels his subscription",
            "    "
        ],
        "comt": "\n    /// @notice Called by the users DSProxy\n    /// @dev Owner who subscribed cancels his subscription\n    ",
        "@notice": "Called by the users DSProxy",
        "@dev": "Owner who subscribed cancels his subscription",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isSubscribed",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function isSubscribed(address _user) public view returns (bool) {\n        SubPosition storage subInfo = subscribersPos[_user];\n\n        return subInfo.subscribed;\n    }",
        "comments": [
            "",
            "    /// @dev Checks if the user is subscribed",
            "    /// @param _user The actual address that owns the Aave position",
            "    /// @return If the user is subscribed",
            "    "
        ],
        "comt": "\n    /// @dev Checks if the user is subscribed\n    /// @param _user The actual address that owns the Aave position\n    /// @return If the user is subscribed\n    ",
        "@dev": "Checks if the user is subscribed",
        "@param1": "_user The actual address that owns the Aave position",
        "@return1": "If the user is subscribed",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getHolder",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function getHolder(address _user) public view returns (AaveHolder memory) {\n        SubPosition storage subInfo = subscribersPos[_user];\n\n        return subscribers[subInfo.arrPos];\n    }",
        "comments": [
            "",
            "    /// @dev Returns subscribtion information about a user",
            "    /// @param _user The actual address that owns the Aave position",
            "    /// @return Subscription information about the user if exists",
            "    "
        ],
        "comt": "\n    /// @dev Returns subscribtion information about a user\n    /// @param _user The actual address that owns the Aave position\n    /// @return Subscription information about the user if exists\n    ",
        "@dev": "Returns subscribtion information about a user",
        "@param1": "_user The actual address that owns the Aave position",
        "@return1": "Subscription information about the user if exists",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getSubscribers",
        "visibility": "public",
        "args": [],
        "func": "function getSubscribers() public view returns (AaveHolder[] memory) {\n        return subscribers;\n    }",
        "comments": [
            "",
            "    /// @notice Helper method to return all the subscribed CDPs",
            "    /// @return List of all subscribers",
            "    "
        ],
        "comt": "\n    /// @notice Helper method to return all the subscribed CDPs\n    /// @return List of all subscribers\n    ",
        "@notice": "Helper method to return all the subscribed CDPs",
        "@return1": "List of all subscribers",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getSubscribersByPage",
        "visibility": "public",
        "args": [
            {
                "name": "_page",
                "type": "uint"
            },
            {
                "name": "_perPage",
                "type": "uint"
            }
        ],
        "func": "function getSubscribersByPage(uint _page, uint _perPage) public view returns (AaveHolder[] memory) {\n        AaveHolder[] memory holders = new AaveHolder[](_perPage);\n\n        uint start = _page * _perPage;\n        uint end = start + _perPage;\n\n        end = (end > holders.length) ? holders.length : end;\n\n        uint count = 0;\n        for (uint i = start; i < end; i++) {\n            holders[count] = subscribers[i];\n            count++;\n        }\n\n        return holders;\n    }",
        "comments": [
            "",
            "    /// @notice Helper method for the frontend, returns all the subscribed CDPs paginated",
            "    /// @param _page What page of subscribers you want",
            "    /// @param _perPage Number of entries per page",
            "    /// @return List of all subscribers for that page",
            "    "
        ],
        "comt": "\n    /// @notice Helper method for the frontend, returns all the subscribed CDPs paginated\n    /// @param _page What page of subscribers you want\n    /// @param _perPage Number of entries per page\n    /// @return List of all subscribers for that page\n    ",
        "@notice": "Helper method for the frontend, returns all the subscribed CDPs paginated",
        "@param1": "_page What page of subscribers you want",
        "@param2": "_perPage Number of entries per page",
        "@return1": "List of all subscribers for that page",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unsubscribeByAdmin",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function unsubscribeByAdmin(address _user) public onlyOwner {\n        SubPosition storage subInfo = subscribersPos[_user];\n\n        if (subInfo.subscribed) {\n            _unsubscribe(_user);\n        }\n    }",
        "comments": [
            "",
            "    ////////////// ADMIN METHODS ///////////////////",
            "",
            "    /// @notice Admin function to unsubscribe a position",
            "    /// @param _user The actual address that owns the Aave position",
            "    "
        ],
        "comt": "\n    ////////////// ADMIN METHODS ///////////////////\n\n    /// @notice Admin function to unsubscribe a position\n    /// @param _user The actual address that owns the Aave position\n    ",
        "@notice": "Admin function to unsubscribe a position",
        "@param1": "_user The actual address that owns the Aave position",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "Log",
        "visibility": "public",
        "args": [
            {
                "name": "_contract",
                "type": "address"
            },
            {
                "name": "_caller",
                "type": "address"
            },
            {
                "name": "_logName",
                "type": "string memory"
            },
            {
                "name": "_data",
                "type": "bytes memory"
            }
        ],
        "func": "function Log(address _contract, address _caller, string memory _logName, bytes memory _data)\n        public\n    {\n        emit LogEvent(_contract, _caller, _logName, _data);\n    }",
        "comments": [
            "",
            "    // solhint-disable-next-line func-name-mixedcase",
            "    "
        ],
        "comt": "\n    // solhint-disable-next-line func-name-mixedcase\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "packExchangeData",
        "visibility": "public",
        "args": [
            {
                "name": "_exData",
                "type": "ExchangeData memory"
            }
        ],
        "func": "function packExchangeData(ExchangeData memory _exData) public pure returns(bytes memory) {\n        // splitting in two different bytes and encoding all because of stack too deep in decoding part\n\n        bytes memory part1 = abi.encode(\n            _exData.srcAddr,\n            _exData.destAddr,\n            _exData.srcAmount,\n            _exData.destAmount\n        );\n\n        bytes memory part2 = abi.encode(\n            _exData.minPrice,\n            _exData.wrapper,\n            _exData.exchangeAddr,\n            _exData.callData,\n            _exData.price0x\n        );\n\n\n        return abi.encode(part1, part2);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unpackExchangeData",
        "visibility": "public",
        "args": [
            {
                "name": "_data",
                "type": "bytes memory"
            }
        ],
        "func": "function unpackExchangeData(bytes memory _data) public pure returns(ExchangeData memory _exData) {\n        (\n            bytes memory part1,\n            bytes memory part2\n        ) = abi.decode(_data, (bytes,bytes));\n\n        (\n            _exData.srcAddr,\n            _exData.destAddr,\n            _exData.srcAmount,\n            _exData.destAmount\n        ) = abi.decode(part1, (address,address,uint256,uint256));\n\n        (\n            _exData.minPrice,\n            _exData.wrapper,\n            _exData.exchangeAddr,\n            _exData.callData,\n            _exData.price0x\n        )\n        = abi.decode(part2, (uint256,address,address,bytes,uint256));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setAllowlistAddr",
        "visibility": "public",
        "args": [
            {
                "name": "_zrxAddr",
                "type": "address"
            },
            {
                "name": "_state",
                "type": "bool"
            }
        ],
        "func": "function setAllowlistAddr(address _zrxAddr, bool _state) public onlyOwner {\n        zrxAllowlist[_zrxAddr] = _state;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isZrxAddr",
        "visibility": "public",
        "args": [
            {
                "name": "_zrxAddr",
                "type": "address"
            }
        ],
        "func": "function isZrxAddr(address _zrxAddr) public view returns (bool) {\n        return zrxAllowlist[_zrxAddr];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addNonPayableAddr",
        "visibility": "public",
        "args": [
            {
                "name": "_nonPayableAddr",
                "type": "address"
            }
        ],
        "func": "function addNonPayableAddr(address _nonPayableAddr) public onlyOwner {\n  nonPayableAddrs[_nonPayableAddr] = true;\n }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeNonPayableAddr",
        "visibility": "public",
        "args": [
            {
                "name": "_nonPayableAddr",
                "type": "address"
            }
        ],
        "func": "function removeNonPayableAddr(address _nonPayableAddr) public onlyOwner {\n  nonPayableAddrs[_nonPayableAddr] = false;\n }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isNonPayableAddr",
        "visibility": "public",
        "args": [
            {
                "name": "_addr",
                "type": "address"
            }
        ],
        "func": "function isNonPayableAddr(address _addr) public view returns(bool) {\n  return nonPayableAddrs[_addr];\n }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addWrapper",
        "visibility": "public",
        "args": [
            {
                "name": "_wrapper",
                "type": "address"
            }
        ],
        "func": "function addWrapper(address _wrapper) public onlyOwner {\n  wrappers[_wrapper] = true;\n }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeWrapper",
        "visibility": "public",
        "args": [
            {
                "name": "_wrapper",
                "type": "address"
            }
        ],
        "func": "function removeWrapper(address _wrapper) public onlyOwner {\n  wrappers[_wrapper] = false;\n }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isWrapper",
        "visibility": "public",
        "args": [
            {
                "name": "_wrapper",
                "type": "address"
            }
        ],
        "func": "function isWrapper(address _wrapper) public view returns(bool) {\n  return wrappers[_wrapper];\n }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "subscribe",
        "visibility": "public",
        "args": [
            {
                "name": "_minRatio",
                "type": "uint128"
            },
            {
                "name": "_maxRatio",
                "type": "uint128"
            },
            {
                "name": "_optimalRatioBoost",
                "type": "uint128"
            },
            {
                "name": "_optimalRatioRepay",
                "type": "uint128"
            },
            {
                "name": "_boostEnabled",
                "type": "bool"
            }
        ],
        "func": "function subscribe(\n        uint128 _minRatio,\n        uint128 _maxRatio,\n        uint128 _optimalRatioBoost,\n        uint128 _optimalRatioRepay,\n        bool _boostEnabled\n    ) public {\n        givePermission(AAVE_MONITOR_PROXY);\n        IAaveSubscription(AAVE_SUBSCRIPTION_ADDRESS).subscribe(\n            _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled);\n    }",
        "comments": [
            "",
            "    /// @notice Calls subscription contract and creates a DSGuard if non existent",
            "    /// @param _minRatio Minimum ratio below which repay is triggered",
            "    /// @param _maxRatio Maximum ratio after which boost is triggered",
            "    /// @param _optimalRatioBoost Ratio amount which boost should target",
            "    /// @param _optimalRatioRepay Ratio amount which repay should target",
            "    /// @param _boostEnabled Boolean determing if boost is enabled",
            "    "
        ],
        "comt": "\n    /// @notice Calls subscription contract and creates a DSGuard if non existent\n    /// @param _minRatio Minimum ratio below which repay is triggered\n    /// @param _maxRatio Maximum ratio after which boost is triggered\n    /// @param _optimalRatioBoost Ratio amount which boost should target\n    /// @param _optimalRatioRepay Ratio amount which repay should target\n    /// @param _boostEnabled Boolean determing if boost is enabled\n    ",
        "@notice": "Calls subscription contract and creates a DSGuard if non existent",
        "@param1": "_minRatio Minimum ratio below which repay is triggered",
        "@param2": "_maxRatio Maximum ratio after which boost is triggered",
        "@param3": "_optimalRatioBoost Ratio amount which boost should target",
        "@param4": "_optimalRatioRepay Ratio amount which repay should target",
        "@param5": "_boostEnabled Boolean determing if boost is enabled",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "update",
        "visibility": "public",
        "args": [
            {
                "name": "_minRatio",
                "type": "uint128"
            },
            {
                "name": "_maxRatio",
                "type": "uint128"
            },
            {
                "name": "_optimalRatioBoost",
                "type": "uint128"
            },
            {
                "name": "_optimalRatioRepay",
                "type": "uint128"
            },
            {
                "name": "_boostEnabled",
                "type": "bool"
            }
        ],
        "func": "function update(\n        uint128 _minRatio,\n        uint128 _maxRatio,\n        uint128 _optimalRatioBoost,\n        uint128 _optimalRatioRepay,\n        bool _boostEnabled\n    ) public {\n        IAaveSubscription(AAVE_SUBSCRIPTION_ADDRESS).subscribe(_minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled);\n    }",
        "comments": [
            "",
            "    /// @notice Calls subscription contract and updated existing parameters",
            "    /// @dev If subscription is non existent this will create one",
            "    /// @param _minRatio Minimum ratio below which repay is triggered",
            "    /// @param _maxRatio Maximum ratio after which boost is triggered",
            "    /// @param _optimalRatioBoost Ratio amount which boost should target",
            "    /// @param _optimalRatioRepay Ratio amount which repay should target",
            "    /// @param _boostEnabled Boolean determing if boost is enabled",
            "    "
        ],
        "comt": "\n    /// @notice Calls subscription contract and updated existing parameters\n    /// @dev If subscription is non existent this will create one\n    /// @param _minRatio Minimum ratio below which repay is triggered\n    /// @param _maxRatio Maximum ratio after which boost is triggered\n    /// @param _optimalRatioBoost Ratio amount which boost should target\n    /// @param _optimalRatioRepay Ratio amount which repay should target\n    /// @param _boostEnabled Boolean determing if boost is enabled\n    ",
        "@notice": "Calls subscription contract and updated existing parameters",
        "@dev": "If subscription is non existent this will create one",
        "@param1": "_minRatio Minimum ratio below which repay is triggered",
        "@param2": "_maxRatio Maximum ratio after which boost is triggered",
        "@param3": "_optimalRatioBoost Ratio amount which boost should target",
        "@param4": "_optimalRatioRepay Ratio amount which repay should target",
        "@param5": "_boostEnabled Boolean determing if boost is enabled",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unsubscribe",
        "visibility": "public",
        "args": [],
        "func": "function unsubscribe() public {\n        removePermission(AAVE_MONITOR_PROXY);\n        IAaveSubscription(AAVE_SUBSCRIPTION_ADDRESS).unsubscribe();\n    }",
        "comments": [
            "",
            "    /// @notice Calls the subscription contract to unsubscribe the caller",
            "    "
        ],
        "comt": "\n    /// @notice Calls the subscription contract to unsubscribe the caller\n    ",
        "@notice": "Calls the subscription contract to unsubscribe the caller",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "givePermission",
        "visibility": "public",
        "args": [
            {
                "name": "_contractAddr",
                "type": "address"
            }
        ],
        "func": "function givePermission(address _contractAddr) public {\n        address currAuthority = address(DSAuth(address(this)).authority());\n        DSGuard guard = DSGuard(currAuthority);\n\n        if (currAuthority == address(0)) {\n            guard = DSGuardFactory(FACTORY_ADDRESS).newGuard();\n            DSAuth(address(this)).setAuthority(DSAuthority(address(guard)));\n        }\n\n        guard.permit(_contractAddr, address(this), bytes4(keccak256(\"execute(address,bytes)\")));\n    }",
        "comments": [
            "",
            "    /// @notice Called in the context of DSProxy to authorize an address",
            "    /// @param _contractAddr Address which will be authorized",
            "    "
        ],
        "comt": "\n    /// @notice Called in the context of DSProxy to authorize an address\n    /// @param _contractAddr Address which will be authorized\n    ",
        "@notice": "Called in the context of DSProxy to authorize an address",
        "@param1": "_contractAddr Address which will be authorized",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removePermission",
        "visibility": "public",
        "args": [
            {
                "name": "_contractAddr",
                "type": "address"
            }
        ],
        "func": "function removePermission(address _contractAddr) public {\n        address currAuthority = address(DSAuth(address(this)).authority());\n        \n        // if there is no authority, that means that contract doesn't have permission\n        if (currAuthority == address(0)) {\n            return;\n        }\n\n        DSGuard guard = DSGuard(currAuthority);\n        guard.forbid(_contractAddr, address(this), bytes4(keccak256(\"execute(address,bytes)\")));\n    }",
        "comments": [
            "",
            "    /// @notice Called in the context of DSProxy to remove authority of an address",
            "    /// @param _contractAddr Auth address which will be removed from authority list",
            "    "
        ],
        "comt": "\n    /// @notice Called in the context of DSProxy to remove authority of an address\n    /// @param _contractAddr Auth address which will be removed from authority list\n    ",
        "@notice": "Called in the context of DSProxy to remove authority of an address",
        "@param1": "_contractAddr Auth address which will be removed from authority list",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "callFunction",
        "visibility": "public",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "account",
                "type": "Account.Info memory"
            },
            {
                "name": "data",
                "type": "bytes memory"
            }
        ],
        "func": "function callFunction(\n        address sender,\n        Account.Info memory account,\n        bytes memory data\n    ) public {\n\n        (\n            address collateralToken,\n            address borrowToken,\n            uint256 ethAmount,\n            address user,\n            address proxy\n        )\n        = abi.decode(data, (address,address,uint256,address,address));\n\n        // withdraw eth\n        TokenInterface(WETH_ADDRESS).withdraw(ethAmount);\n\n        address lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n        address aCollateralToken = ILendingPool(lendingPoolCoreAddress).getReserveATokenAddress(collateralToken);\n        address aBorrowToken = ILendingPool(lendingPoolCoreAddress).getReserveATokenAddress(borrowToken);\n\n        // deposit eth on behalf of proxy\n        DSProxy(payable(proxy)).execute{value: ethAmount}(BASIC_PROXY, abi.encodeWithSignature(\"deposit(address,uint256)\", ETH_ADDR, ethAmount));\n        // borrow needed amount to repay users borrow\n        (,uint256 borrowAmount,,uint256 borrowRateMode,,,uint256 originationFee,,,) = ILendingPool(lendingPool).getUserReserveData(borrowToken, user);\n        borrowAmount += originationFee;\n        DSProxy(payable(proxy)).execute(BASIC_PROXY, abi.encodeWithSignature(\"borrow(address,uint256,uint256)\", borrowToken, borrowAmount, borrowRateMode));\n        // payback on behalf of user\n        ERC20(borrowToken).safeApprove(proxy, borrowAmount);\n        DSProxy(payable(proxy)).execute(BASIC_PROXY, abi.encodeWithSignature(\"paybackOnBehalf(address,address,uint256,bool,address)\", borrowToken, aBorrowToken, 0, true, user));\n        // pull tokens from user to proxy\n        ERC20(aCollateralToken).safeTransferFrom(user, proxy, ERC20(aCollateralToken).balanceOf(user));\n\n        // enable as collateral\n        DSProxy(payable(proxy)).execute(BASIC_PROXY, abi.encodeWithSignature(\"setUserUseReserveAsCollateralIfNeeded(address)\", collateralToken));\n\n        // withdraw deposited eth\n        DSProxy(payable(proxy)).execute(BASIC_PROXY, abi.encodeWithSignature(\"withdraw(address,address,uint256,bool)\", ETH_ADDR, AETH_ADDRESS, ethAmount, false));\n\n        // deposit eth, get weth and return to sender\n        TokenInterface(WETH_ADDRESS).deposit.value(address(this).balance)();\n        ERC20(WETH_ADDRESS).safeTransfer(proxy, ethAmount+2);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "importLoan",
        "visibility": "public",
        "args": [
            {
                "name": "_collateralToken",
                "type": "address"
            },
            {
                "name": "_borrowToken",
                "type": "address"
            },
            {
                "name": "_ethAmount",
                "type": "uint"
            }
        ],
        "func": "function importLoan(address _collateralToken, address _borrowToken, uint _ethAmount) public {\n        ISoloMargin solo = ISoloMargin(SOLO_MARGIN_ADDRESS);\n\n        // Get marketId from token address\n        uint256 marketId = _getMarketIdFromTokenAddress(WETH_ADDR);\n\n        // Calculate repay amount (_amount + (2 wei))\n        // Approve transfer from\n        uint256 repayAmount = _getRepaymentAmountInternal(_ethAmount);\n        ERC20(WETH_ADDR).approve(SOLO_MARGIN_ADDRESS, repayAmount);\n\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\n\n        operations[0] = _getWithdrawAction(marketId, _ethAmount, AAVE_IMPORT);\n        operations[1] = _getCallAction(\n            abi.encode(_collateralToken, _borrowToken, _ethAmount, msg.sender, address(this)),\n            AAVE_IMPORT\n        );\n        operations[2] = _getDepositAction(marketId, repayAmount, address(this));\n\n        Account.Info[] memory accountInfos = new Account.Info[](1);\n        accountInfos[0] = _getAccountInfo();\n\n        givePermission(AAVE_IMPORT);\n        solo.operate(accountInfos, operations);\n        removePermission(AAVE_IMPORT);\n\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"AaveImport\", abi.encode(_collateralToken, _borrowToken));\n    }",
        "comments": [
            "",
            "    /// @notice Starts the process to move users position 1 collateral and 1 borrow",
            "    /// @dev User must send 2 wei with this transaction",
            "    /// @dev User must approve AaveImport to pull _aCollateralToken",
            "    /// @param _collateralToken Collateral token we are moving to DSProxy",
            "    /// @param _borrowToken Borrow token we are moving to DSProxy",
            "    /// @param _ethAmount ETH amount that needs to be pulled from dydx",
            "    "
        ],
        "comt": "\n    /// @notice Starts the process to move users position 1 collateral and 1 borrow\n    /// @dev User must send 2 wei with this transaction\n    /// @dev User must approve AaveImport to pull _aCollateralToken\n    /// @param _collateralToken Collateral token we are moving to DSProxy\n    /// @param _borrowToken Borrow token we are moving to DSProxy\n    /// @param _ethAmount ETH amount that needs to be pulled from dydx\n    ",
        "@notice": "Starts the process to move users position 1 collateral and 1 borrow",
        "@dev": "User must send 2 wei with this transaction * User must approve AaveImport to pull _aCollateralToken",
        "@param1": "_collateralToken Collateral token we are moving to DSProxy",
        "@param2": "_borrowToken Borrow token we are moving to DSProxy",
        "@param3": "_ethAmount ETH amount that needs to be pulled from dydx",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repay",
        "visibility": "public",
        "args": [
            {
                "name": "_data",
                "type": "ExchangeData memory"
            },
            {
                "name": "_gasCost",
                "type": "uint"
            }
        ],
        "func": "function repay(ExchangeData memory _data, uint _gasCost) public payable burnGas(20) {\n\n  address lendingPoolCore = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n  address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n  address payable user = payable(getUserAddress());\n\n  // redeem collateral\n  address aTokenCollateral = ILendingPool(lendingPoolCore).getReserveATokenAddress(_data.srcAddr);\n  // uint256 maxCollateral = IAToken(aTokenCollateral).balanceOf(address(this)); \n  // don't swap more than maxCollateral\n  // _data.srcAmount = _data.srcAmount > maxCollateral ? maxCollateral : _data.srcAmount;\n  IAToken(aTokenCollateral).redeem(_data.srcAmount);\n\n  uint256 destAmount = _data.srcAmount;\n  if (_data.srcAddr != _data.destAddr) {\n   // swap\n   (, destAmount) = _sell(_data);\n   destAmount -= getFee(destAmount, user, _gasCost, _data.destAddr);\n  } else {\n   destAmount -= getGasCost(destAmount, user, _gasCost, _data.destAddr);\n  }\n\n  // payback\n  if (_data.destAddr == ETH_ADDR) {\n   ILendingPool(lendingPool).repay{value: destAmount}(_data.destAddr, destAmount, payable(address(this)));\n  } else {\n   approveToken(_data.destAddr, lendingPoolCore);\n   ILendingPool(lendingPool).repay(_data.destAddr, destAmount, payable(address(this)));\n  }\n\n  // first return 0x fee to msg.sender as it is the address that actually sent 0x fee\n  sendContractBalance(ETH_ADDR, tx.origin, min(address(this).balance, msg.value));\n  // send all leftovers from dest addr to proxy owner\n  sendFullContractBalance(_data.destAddr, user);\n\n  DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"AaveRepay\", abi.encode(_data.srcAddr, _data.destAddr, _data.srcAmount, destAmount));\n }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "boost",
        "visibility": "public",
        "args": [
            {
                "name": "_data",
                "type": "ExchangeData memory"
            },
            {
                "name": "_gasCost",
                "type": "uint"
            }
        ],
        "func": "function boost(ExchangeData memory _data, uint _gasCost) public payable burnGas(20) {\n  address lendingPoolCore = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n  address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n  (,,,uint256 borrowRateMode,,,,,,bool collateralEnabled) = ILendingPool(lendingPool).getUserReserveData(_data.destAddr, address(this));\n  address payable user = payable(getUserAddress());\n\n  // skipping this check as its too expensive\n  // uint256 maxBorrow = getMaxBoost(_data.srcAddr, _data.destAddr, address(this));\n  // _data.srcAmount = _data.srcAmount > maxBorrow ? maxBorrow : _data.srcAmount;\n\n  // borrow amount\n  ILendingPool(lendingPool).borrow(_data.srcAddr, _data.srcAmount, borrowRateMode == 0 ? VARIABLE_RATE : borrowRateMode, AAVE_REFERRAL_CODE);\n\n  uint256 destAmount;\n  if (_data.destAddr != _data.srcAddr) {\n   _data.srcAmount -= getFee(_data.srcAmount, user, _gasCost, _data.srcAddr);\n   // swap\n   (, destAmount) = _sell(_data);\n  } else {\n   _data.srcAmount -= getGasCost(_data.srcAmount, user, _gasCost, _data.srcAddr);\n   destAmount = _data.srcAmount;\n  }\n\n  if (_data.destAddr == ETH_ADDR) {\n   ILendingPool(lendingPool).deposit{value: destAmount}(_data.destAddr, destAmount, AAVE_REFERRAL_CODE);\n  } else {\n   approveToken(_data.destAddr, lendingPoolCore);\n   ILendingPool(lendingPool).deposit(_data.destAddr, destAmount, AAVE_REFERRAL_CODE);\n  }\n\n  if (!collateralEnabled) {\n            ILendingPool(lendingPool).setUserUseReserveAsCollateral(_data.destAddr, true);\n        }\n\n  // returning to msg.sender as it is the address that actually sent 0x fee\n  sendContractBalance(ETH_ADDR, tx.origin, min(address(this).balance, msg.value));\n  // send all leftovers from dest addr to proxy owner\n  sendFullContractBalance(_data.destAddr, user);\n\n  DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"AaveBoost\", abi.encode(_data.srcAddr, _data.destAddr, _data.srcAmount, destAmount));\n }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "callFunction",
        "visibility": "public",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "account",
                "type": "Account.Info memory"
            },
            {
                "name": "data",
                "type": "bytes memory"
            }
        ],
        "func": "function callFunction(\n        address sender,\n        Account.Info memory account,\n        bytes memory data\n    ) public {\n\n        (\n            bytes memory exchangeDataBytes,\n            uint256 gasCost,\n            bool isRepay,\n            uint256 ethAmount,\n            uint256 txValue,\n            address user,\n            address proxy\n        )\n        = abi.decode(data, (bytes,uint256,bool,uint256,uint256,address,address));\n\n        // withdraw eth\n        TokenInterface(WETH_ADDRESS).withdraw(ethAmount);\n\n        address lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n        \n        // deposit eth on behalf of proxy\n        DSProxy(payable(proxy)).execute{value: ethAmount}(AAVE_BASIC_PROXY, abi.encodeWithSignature(\"deposit(address,uint256)\", ETH_ADDR, ethAmount));\n        \n        bytes memory functionData = packFunctionCall(exchangeDataBytes, gasCost, isRepay);\n        DSProxy(payable(proxy)).execute{value: txValue}(AAVE_SAVER_PROXY, functionData);\n\n        // withdraw deposited eth\n        DSProxy(payable(proxy)).execute(AAVE_BASIC_PROXY, abi.encodeWithSignature(\"withdraw(address,address,uint256,bool)\", ETH_ADDR, AETH_ADDRESS, ethAmount, false));\n\n        // deposit eth, get weth and return to sender\n        TokenInterface(WETH_ADDRESS).deposit.value(address(this).balance)();\n        ERC20(WETH_ADDRESS).safeTransfer(proxy, ethAmount+2);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repay",
        "visibility": "public",
        "args": [
            {
                "name": "_data",
                "type": "ExchangeData memory"
            },
            {
                "name": "_gasCost",
                "type": "uint256"
            }
        ],
        "func": "function repay(ExchangeData memory _data, uint256 _gasCost) public payable {\n        _flashLoan(_data, _gasCost, true);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "boost",
        "visibility": "public",
        "args": [
            {
                "name": "_data",
                "type": "ExchangeData memory"
            },
            {
                "name": "_gasCost",
                "type": "uint256"
            }
        ],
        "func": "function boost(ExchangeData memory _data, uint256 _gasCost) public payable {\n        _flashLoan(_data, _gasCost, false);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setAuthorized",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            },
            {
                "name": "_approved",
                "type": "bool"
            }
        ],
        "func": "function setAuthorized(address _user, bool _approved) public onlyOwner {\n  authorized[_user] = _approved;\n }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setAllAuthorized",
        "visibility": "public",
        "args": [
            {
                "name": "_authorized",
                "type": "bool"
            }
        ],
        "func": "function setAllAuthorized(bool _authorized) public onlyOwner {\n  ALL_AUTHORIZED = _authorized;\n }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "executeAction",
        "visibility": "public",
        "args": [
            {
                "name": "_actionId",
                "type": "uint"
            },
            {
                "name": "_callData",
                "type": "bytes memory"
            },
            {
                "name": "_returnValues",
                "type": "bytes32[] memory"
            }
        ],
        "func": "function executeAction(uint _actionId, bytes memory _callData, bytes32[] memory _returnValues) override public payable returns (bytes32) {\n//         (uint cdpId, uint amount, address joinAddr) = parseParamData(_callData, _returnValues);\n\n//         uint frobAmount = amount;\n\n//         if (Join(joinAddr).dec() != 18) {\n//             frobAmount = amount * (10 ** (18 - Join(joinAddr).dec()));\n//         }\n\n//         manager.frob(cdpId, -toPositiveInt(frobAmount), 0);\n//         manager.flux(cdpId, address(this), frobAmount);\n\n//         Join(joinAddr).exit(address(this), amount);\n\n//         if (isEthJoinAddr(_joinAddr)) {\n//             Join(joinAddr).gem().withdraw(amount); // Weth -> Eth\n//         }\n\n//         return bytes32(amount);\n//     }",
        "comments": [
            "",
            "//     "
        ],
        "comt": "\n//     ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "actionType",
        "visibility": "public",
        "args": [],
        "func": "function actionType() override public returns (uint8) {\n//         return uint8(ActionType.STANDARD_ACTION);\n//     }",
        "comments": [
            "",
            "//     "
        ],
        "comt": "\n//     ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "parseParamData",
        "visibility": "public",
        "args": [
            {
                "name": "_data",
                "type": "//         bytes memory"
            },
            {
                "name": "_returnValues\n//",
                "type": "//         bytes32[] memory"
            }
        ],
        "func": "function parseParamData(\n//         bytes memory _data,\n//         bytes32[] memory _returnValues\n//     ) public pure returns (uint cdpId,uint amount, address joinAddr) {\n//         uint8[] memory inputMapping;\n\n//         (cdpId, amount, joinAddr, inputMapping) = abi.decode(_data, (uint256,uint256,address,uint8[]));\n\n//         // mapping return values to new inputs\n//         if (inputMapping.length > 0 && _returnValues.length > 0) {\n//             for (uint i = 0; i < inputMapping.length; i += 2) {\n//                 bytes32 returnValue = _returnValues[inputMapping[i + 1]];\n\n//                 if (inputMapping[i] == 0) {\n//                     cdpId = uint(returnValue);\n//                 } else if (inputMapping[i] == 1) {\n//                     amount = uint(returnValue);\n//                 } else if (inputMapping[i] == 2) {\n//                     joinAddr = address(bytes20(returnValue));\n//                 }\n//             }\n//         }\n//     }",
        "comments": [
            "",
            "//     "
        ],
        "comt": "\n//     ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repayFor",
        "visibility": "public",
        "args": [
            {
                "name": "_exData",
                "type": "SaverExchangeCore.ExchangeData memory"
            },
            {
                "name": "_cAddresses",
                "type": "address[2] memory"
            },
            {
                "name": "cCollAddress",
                "type": "//"
            },
            {
                "name": "_user",
                "type": "cBorrowAddress\n        address"
            }
        ],
        "func": "function repayFor(\n        SaverExchangeCore.ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        address _user\n    ) public payable onlyApproved burnGas(REPAY_GAS_TOKEN) {\n\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Repay, _user);\n        require(isAllowed); // check if conditions are met\n\n        uint256 gasCost = calcGasCost(REPAY_GAS_COST);\n\n        compoundMonitorProxy.callExecute{value: msg.value}(\n            _user,\n            compoundFlashLoanTakerAddress,\n            abi.encodeWithSignature(\n                \"repayWithLoan((address,address,uint256,uint256,uint256,address,address,bytes,uint256),address[2],uint256)\",\n                _exData,\n                _cAddresses,\n                gasCost\n            )\n        );\n\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Repay, _user);\n        require(isGoodRatio); // check if the after result of the actions is good\n\n        returnEth();\n\n        logger.Log(address(this), _user, \"AutomaticCompoundRepay\", abi.encode(ratioBefore, ratioAfter));\n    }",
        "comments": [
            "",
            "    /// @notice Bots call this method to repay for user when conditions are met",
            "    /// @dev If the contract ownes gas token it will try and use it for gas price reduction",
            "    /// @param _exData Exchange data",
            "    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]",
            "    /// @param _user The actual address that owns the Compound position",
            "    "
        ],
        "comt": "\n    /// @notice Bots call this method to repay for user when conditions are met\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\n    /// @param _exData Exchange data\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _user The actual address that owns the Compound position\n    ",
        "@notice": "Bots call this method to repay for user when conditions are met",
        "@dev": "If the contract ownes gas token it will try and use it for gas price reduction",
        "@param1": "_exData Exchange data",
        "@param2": "_cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]",
        "@param3": "_user The actual address that owns the Compound position",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "boostFor",
        "visibility": "public",
        "args": [
            {
                "name": "_exData",
                "type": "SaverExchangeCore.ExchangeData memory"
            },
            {
                "name": "_cAddresses",
                "type": "address[2] memory"
            },
            {
                "name": "cCollAddress",
                "type": "//"
            },
            {
                "name": "_user",
                "type": "cBorrowAddress\n        address"
            }
        ],
        "func": "function boostFor(\n        SaverExchangeCore.ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        address _user\n    ) public payable onlyApproved burnGas(BOOST_GAS_TOKEN) {\n\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Boost, _user);\n        require(isAllowed); // check if conditions are met\n\n        uint256 gasCost = calcGasCost(BOOST_GAS_COST);\n\n        compoundMonitorProxy.callExecute{value: msg.value}(\n            _user,\n            compoundFlashLoanTakerAddress,\n            abi.encodeWithSignature(\n                \"boostWithLoan((address,address,uint256,uint256,uint256,address,address,bytes,uint256),address[2],uint256)\",\n                _exData,\n                _cAddresses,\n                gasCost\n            )\n        );\n\n\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Boost, _user);\n        require(isGoodRatio);  // check if the after result of the actions is good\n\n        returnEth();\n\n        logger.Log(address(this), _user, \"AutomaticCompoundBoost\", abi.encode(ratioBefore, ratioAfter));\n    }",
        "comments": [
            "",
            "    /// @notice Bots call this method to boost for user when conditions are met",
            "    /// @dev If the contract ownes gas token it will try and use it for gas price reduction",
            "    /// @param _exData Exchange data",
            "    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]",
            "    /// @param _user The actual address that owns the Compound position",
            "    "
        ],
        "comt": "\n    /// @notice Bots call this method to boost for user when conditions are met\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\n    /// @param _exData Exchange data\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _user The actual address that owns the Compound position\n    ",
        "@notice": "Bots call this method to boost for user when conditions are met",
        "@dev": "If the contract ownes gas token it will try and use it for gas price reduction",
        "@param1": "_exData Exchange data",
        "@param2": "_cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]",
        "@param3": "_user The actual address that owns the Compound position",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "canCall",
        "visibility": "public",
        "args": [
            {
                "name": "_method",
                "type": "Method"
            },
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function canCall(Method _method, address _user) public view returns(bool, uint) {\n        bool subscribed = subscriptionsContract.isSubscribed(_user);\n        CompoundSubscriptions.CompoundHolder memory holder = subscriptionsContract.getHolder(_user);\n\n        // check if cdp is subscribed\n        if (!subscribed) return (false, 0);\n\n        // check if boost and boost allowed\n        if (_method == Method.Boost && !holder.boostEnabled) return (false, 0);\n\n        uint currRatio = getSafetyRatio(_user);\n\n        if (_method == Method.Repay) {\n            return (currRatio < holder.minRatio, currRatio);\n        } else if (_method == Method.Boost) {\n            return (currRatio > holder.maxRatio, currRatio);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "ratioGoodAfter",
        "visibility": "public",
        "args": [
            {
                "name": "_method",
                "type": "Method"
            },
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function ratioGoodAfter(Method _method, address _user) public view returns(bool, uint) {\n        CompoundSubscriptions.CompoundHolder memory holder;\n\n        holder= subscriptionsContract.getHolder(_user);\n\n        uint currRatio = getSafetyRatio(_user);\n\n        if (_method == Method.Repay) {\n            return (currRatio < holder.maxRatio, currRatio);\n        } else if (_method == Method.Boost) {\n            return (currRatio > holder.minRatio, currRatio);\n        }\n    }",
        "comments": [
            "",
            "    /// @dev After the Boost/Repay check if the ratio doesn't trigger another call",
            "    /// @param _method Type of action to be called",
            "    /// @param _user The actual address that owns the Compound position",
            "    /// @return Boolean if the recent action preformed correctly and the ratio",
            "    "
        ],
        "comt": "\n    /// @dev After the Boost/Repay check if the ratio doesn't trigger another call\n    /// @param _method Type of action to be called\n    /// @param _user The actual address that owns the Compound position\n    /// @return Boolean if the recent action preformed correctly and the ratio\n    ",
        "@dev": "After the Boost/Repay check if the ratio doesn't trigger another call",
        "@param1": "_method Type of action to be called",
        "@param2": "_user The actual address that owns the Compound position",
        "@return1": "Boolean if the recent action preformed correctly and the ratio",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "calcGasCost",
        "visibility": "public",
        "args": [
            {
                "name": "_gasAmount",
                "type": "uint"
            }
        ],
        "func": "function calcGasCost(uint _gasAmount) public view returns (uint) {\n        uint gasPrice = tx.gasprice <= MAX_GAS_PRICE ? tx.gasprice : MAX_GAS_PRICE;\n\n        return mul(gasPrice, _gasAmount);\n    }",
        "comments": [
            "",
            "    /// @notice Calculates gas cost (in Eth) of tx",
            "    /// @dev Gas price is limited to MAX_GAS_PRICE to prevent attack of draining user CDP",
            "    /// @param _gasAmount Amount of gas used for the tx",
            "    "
        ],
        "comt": "\n    /// @notice Calculates gas cost (in Eth) of tx\n    /// @dev Gas price is limited to MAX_GAS_PRICE to prevent attack of draining user CDP\n    /// @param _gasAmount Amount of gas used for the tx\n    ",
        "@notice": "Calculates gas cost (in Eth) of tx",
        "@dev": "Gas price is limited to MAX_GAS_PRICE to prevent attack of draining user CDP",
        "@param1": "_gasAmount Amount of gas used for the tx",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeBoostGasCost",
        "visibility": "public",
        "args": [
            {
                "name": "_gasCost",
                "type": "uint"
            }
        ],
        "func": "function changeBoostGasCost(uint _gasCost) public onlyOwner {\n        require(_gasCost < 3000000);\n\n        BOOST_GAS_COST = _gasCost;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeRepayGasCost",
        "visibility": "public",
        "args": [
            {
                "name": "_gasCost",
                "type": "uint"
            }
        ],
        "func": "function changeRepayGasCost(uint _gasCost) public onlyOwner {\n        require(_gasCost < 3000000);\n\n        REPAY_GAS_COST = _gasCost;\n    }",
        "comments": [
            "",
            "    /// @notice Allows owner to change gas cost for repay operation, but only up to 3 millions",
            "    /// @param _gasCost New gas cost for repay method",
            "    "
        ],
        "comt": "\n    /// @notice Allows owner to change gas cost for repay operation, but only up to 3 millions\n    /// @param _gasCost New gas cost for repay method\n    ",
        "@notice": "Allows owner to change gas cost for repay operation, but only up to 3 millions",
        "@param1": "_gasCost New gas cost for repay method",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferERC20",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddress",
                "type": "address"
            },
            {
                "name": "_to",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            }
        ],
        "func": "function transferERC20(address _tokenAddress, address _to, uint _amount) public onlyOwner {\n        ERC20(_tokenAddress).safeTransfer(_to, _amount);\n    }",
        "comments": [
            "",
            "    /// @notice If any tokens gets stuck in the contract owner can withdraw it",
            "    /// @param _tokenAddress Address of the ERC20 token",
            "    /// @param _to Address of the receiver",
            "    /// @param _amount The amount to be sent",
            "    "
        ],
        "comt": "\n    /// @notice If any tokens gets stuck in the contract owner can withdraw it\n    /// @param _tokenAddress Address of the ERC20 token\n    /// @param _to Address of the receiver\n    /// @param _amount The amount to be sent\n    ",
        "@notice": "If any tokens gets stuck in the contract owner can withdraw it",
        "@param1": "_tokenAddress Address of the ERC20 token",
        "@param2": "_to Address of the receiver",
        "@param3": "_amount The amount to be sent",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferEth",
        "visibility": "public",
        "args": [
            {
                "name": "_to",
                "type": "address payable"
            },
            {
                "name": "_amount",
                "type": "uint"
            }
        ],
        "func": "function transferEth(address payable _to, uint _amount) public onlyOwner {\n        _to.transfer(_amount);\n    }",
        "comments": [
            "",
            "    /// @notice If any Eth gets stuck in the contract owner can withdraw it",
            "    /// @param _to Address of the receiver",
            "    /// @param _amount The amount to be sent",
            "    "
        ],
        "comt": "\n    /// @notice If any Eth gets stuck in the contract owner can withdraw it\n    /// @param _to Address of the receiver\n    /// @param _amount The amount to be sent\n    ",
        "@notice": "If any Eth gets stuck in the contract owner can withdraw it",
        "@param1": "_to Address of the receiver",
        "@param2": "_amount The amount to be sent",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "callExecute",
        "visibility": "public",
        "args": [
            {
                "name": "_owner",
                "type": "address"
            },
            {
                "name": "_compoundSaverProxy",
                "type": "address"
            },
            {
                "name": "_data",
                "type": "bytes memory"
            }
        ],
        "func": "function callExecute(address _owner, address _compoundSaverProxy, bytes memory _data) public payable onlyMonitor {\n        // execute reverts if calling specific method fails\n        DSProxyInterface(_owner).execute{value: msg.value}(_compoundSaverProxy, _data);\n\n        // return if anything left\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Only monitor contract is able to call execute on users proxy",
            "    /// @param _owner Address of cdp owner (users DSProxy address)",
            "    /// @param _compoundSaverProxy Address of CompoundSaverProxy",
            "    /// @param _data Data to send to CompoundSaverProxy",
            "    "
        ],
        "comt": "\n    /// @notice Only monitor contract is able to call execute on users proxy\n    /// @param _owner Address of cdp owner (users DSProxy address)\n    /// @param _compoundSaverProxy Address of CompoundSaverProxy\n    /// @param _data Data to send to CompoundSaverProxy\n    ",
        "@notice": "Only monitor contract is able to call execute on users proxy",
        "@param1": "_owner Address of cdp owner (users DSProxy address)",
        "@param2": "_compoundSaverProxy Address of CompoundSaverProxy",
        "@param3": "_data Data to send to CompoundSaverProxy",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setMonitor",
        "visibility": "public",
        "args": [
            {
                "name": "_monitor",
                "type": "address"
            }
        ],
        "func": "function setMonitor(address _monitor) public onlyAllowed {\n        require(monitor == address(0));\n        monitor = _monitor;\n    }",
        "comments": [
            "",
            "    /// @notice Allowed users are able to set Monitor contract without any waiting period first time",
            "    /// @param _monitor Address of Monitor contract",
            "    "
        ],
        "comt": "\n    /// @notice Allowed users are able to set Monitor contract without any waiting period first time\n    /// @param _monitor Address of Monitor contract\n    ",
        "@notice": "Allowed users are able to set Monitor contract without any waiting period first time",
        "@param1": "_monitor Address of Monitor contract",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeMonitor",
        "visibility": "public",
        "args": [
            {
                "name": "_newMonitor",
                "type": "address"
            }
        ],
        "func": "function changeMonitor(address _newMonitor) public onlyAllowed {\n        require(changeRequestedTimestamp == 0);\n\n        changeRequestedTimestamp = now;\n        lastMonitor = monitor;\n        newMonitor = _newMonitor;\n\n        emit MonitorChangeInitiated(lastMonitor, newMonitor);\n    }",
        "comments": [
            "",
            "    /// @notice Allowed users are able to start procedure for changing monitor",
            "    /// @dev after CHANGE_PERIOD needs to call confirmNewMonitor to actually make a change",
            "    /// @param _newMonitor address of new monitor",
            "    "
        ],
        "comt": "\n    /// @notice Allowed users are able to start procedure for changing monitor\n    /// @dev after CHANGE_PERIOD needs to call confirmNewMonitor to actually make a change\n    /// @param _newMonitor address of new monitor\n    ",
        "@notice": "Allowed users are able to start procedure for changing monitor",
        "@dev": "after CHANGE_PERIOD needs to call confirmNewMonitor to actually make a change",
        "@param1": "_newMonitor address of new monitor",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cancelMonitorChange",
        "visibility": "public",
        "args": [],
        "func": "function cancelMonitorChange() public onlyAllowed {\n        require(changeRequestedTimestamp > 0);\n\n        changeRequestedTimestamp = 0;\n        newMonitor = address(0);\n\n        emit MonitorChangeCanceled();\n    }",
        "comments": [
            "",
            "    /// @notice At any point allowed users are able to cancel monitor change",
            "    "
        ],
        "comt": "\n    /// @notice At any point allowed users are able to cancel monitor change\n    ",
        "@notice": "At any point allowed users are able to cancel monitor change",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "confirmNewMonitor",
        "visibility": "public",
        "args": [],
        "func": "function confirmNewMonitor() public onlyAllowed {\n        require((changeRequestedTimestamp + CHANGE_PERIOD) < now);\n        require(changeRequestedTimestamp != 0);\n        require(newMonitor != address(0));\n\n        monitor = newMonitor;\n        newMonitor = address(0);\n        changeRequestedTimestamp = 0;\n\n        emit MonitorChangeFinished(monitor);\n    }",
        "comments": [
            "",
            "    /// @notice Anyone is able to confirm new monitor after CHANGE_PERIOD if process is started",
            "    "
        ],
        "comt": "\n    /// @notice Anyone is able to confirm new monitor after CHANGE_PERIOD if process is started\n    ",
        "@notice": "Anyone is able to confirm new monitor after CHANGE_PERIOD if process is started",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "revertMonitor",
        "visibility": "public",
        "args": [],
        "func": "function revertMonitor() public onlyAllowed {\n        require(lastMonitor != address(0));\n\n        monitor = lastMonitor;\n\n        emit MonitorChangeReverted(monitor);\n    }",
        "comments": [
            "",
            "    /// @notice Its possible to revert monitor to last used monitor",
            "    "
        ],
        "comt": "\n    /// @notice Its possible to revert monitor to last used monitor\n    ",
        "@notice": "Its possible to revert monitor to last used monitor",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addAllowed",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function addAllowed(address _user) public onlyAllowed {\n        allowed[_user] = true;\n    }",
        "comments": [
            "",
            "",
            "    /// @notice Allowed users are able to add new allowed user",
            "    /// @param _user Address of user that will be allowed",
            "    "
        ],
        "comt": "\n\n    /// @notice Allowed users are able to add new allowed user\n    /// @param _user Address of user that will be allowed\n    ",
        "@notice": "Allowed users are able to add new allowed user",
        "@param1": "_user Address of user that will be allowed",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeAllowed",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function removeAllowed(address _user) public onlyAllowed {\n        allowed[_user] = false;\n    }",
        "comments": [
            "",
            "    /// @notice Allowed users are able to remove allowed user",
            "    /// @dev owner is always allowed even if someone tries to remove it from allowed mapping",
            "    /// @param _user Address of allowed user",
            "    "
        ],
        "comt": "\n    /// @notice Allowed users are able to remove allowed user\n    /// @dev owner is always allowed even if someone tries to remove it from allowed mapping\n    /// @param _user Address of allowed user\n    ",
        "@notice": "Allowed users are able to remove allowed user",
        "@dev": "owner is always allowed even if someone tries to remove it from allowed mapping",
        "@param1": "_user Address of allowed user",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setChangePeriod",
        "visibility": "public",
        "args": [
            {
                "name": "_periodInDays",
                "type": "uint"
            }
        ],
        "func": "function setChangePeriod(uint _periodInDays) public onlyAllowed {\n        require(_periodInDays * 1 days > CHANGE_PERIOD);\n\n        CHANGE_PERIOD = _periodInDays * 1 days;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawToken",
        "visibility": "public",
        "args": [
            {
                "name": "_token",
                "type": "address"
            }
        ],
        "func": "function withdrawToken(address _token) public onlyOwner {\n        uint balance = ERC20(_token).balanceOf(address(this));\n        ERC20(_token).safeTransfer(msg.sender, balance);\n    }",
        "comments": [
            "",
            "    /// @notice In case something is left in contract, owner is able to withdraw it",
            "    /// @param _token address of token to withdraw balance",
            "    "
        ],
        "comt": "\n    /// @notice In case something is left in contract, owner is able to withdraw it\n    /// @param _token address of token to withdraw balance\n    ",
        "@notice": "In case something is left in contract, owner is able to withdraw it",
        "@param1": "_token address of token to withdraw balance",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawEth",
        "visibility": "public",
        "args": [],
        "func": "function withdrawEth() public onlyOwner {\n        uint balance = address(this).balance;\n        msg.sender.transfer(balance);\n    }",
        "comments": [
            "",
            "    /// @notice In case something is left in contract, owner is able to withdraw it",
            "    "
        ],
        "comt": "\n    /// @notice In case something is left in contract, owner is able to withdraw it\n    ",
        "@notice": "In case something is left in contract, owner is able to withdraw it",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "subscribe",
        "visibility": "external",
        "args": [
            {
                "name": "_minRatio",
                "type": "uint128"
            },
            {
                "name": "_maxRatio",
                "type": "uint128"
            },
            {
                "name": "_optimalBoost",
                "type": "uint128"
            },
            {
                "name": "_optimalRepay",
                "type": "uint128"
            },
            {
                "name": "_boostEnabled",
                "type": "bool"
            }
        ],
        "func": "function subscribe(uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled) external {\n\n        // if boost is not enabled, set max ratio to max uint\n        uint128 localMaxRatio = _boostEnabled ? _maxRatio : uint128(-1);\n        require(checkParams(_minRatio, localMaxRatio), \"Must be correct params\");\n\n        SubPosition storage subInfo = subscribersPos[msg.sender];\n\n        CompoundHolder memory subscription = CompoundHolder({\n                minRatio: _minRatio,\n                maxRatio: localMaxRatio,\n                optimalRatioBoost: _optimalBoost,\n                optimalRatioRepay: _optimalRepay,\n                user: msg.sender,\n                boostEnabled: _boostEnabled\n            });\n\n        changeIndex++;\n\n        if (subInfo.subscribed) {\n            subscribers[subInfo.arrPos] = subscription;\n\n            emit Updated(msg.sender);\n            emit ParamUpdates(msg.sender, _minRatio, localMaxRatio, _optimalBoost, _optimalRepay, _boostEnabled);\n        } else {\n            subscribers.push(subscription);\n\n            subInfo.arrPos = subscribers.length - 1;\n            subInfo.subscribed = true;\n\n            emit Subscribed(msg.sender);\n        }\n    }",
        "comments": [
            "",
            "    /// @dev Called by the DSProxy contract which owns the Compound position",
            "    /// @notice Adds the users Compound poistion in the list of subscriptions so it can be monitored",
            "    /// @param _minRatio Minimum ratio below which repay is triggered",
            "    /// @param _maxRatio Maximum ratio after which boost is triggered",
            "    /// @param _optimalBoost Ratio amount which boost should target",
            "    /// @param _optimalRepay Ratio amount which repay should target",
            "    /// @param _boostEnabled Boolean determing if boost is enabled",
            "    "
        ],
        "comt": "\n    /// @dev Called by the DSProxy contract which owns the Compound position\n    /// @notice Adds the users Compound poistion in the list of subscriptions so it can be monitored\n    /// @param _minRatio Minimum ratio below which repay is triggered\n    /// @param _maxRatio Maximum ratio after which boost is triggered\n    /// @param _optimalBoost Ratio amount which boost should target\n    /// @param _optimalRepay Ratio amount which repay should target\n    /// @param _boostEnabled Boolean determing if boost is enabled\n    ",
        "@dev": "Called by the DSProxy contract which owns the Compound position",
        "@notice": "Adds the users Compound poistion in the list of subscriptions so it can be monitored",
        "@param1": "_minRatio Minimum ratio below which repay is triggered",
        "@param2": "_maxRatio Maximum ratio after which boost is triggered",
        "@param3": "_optimalBoost Ratio amount which boost should target",
        "@param4": "_optimalRepay Ratio amount which repay should target",
        "@param5": "_boostEnabled Boolean determing if boost is enabled",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unsubscribe",
        "visibility": "external",
        "args": [],
        "func": "function unsubscribe() external {\n        _unsubscribe(msg.sender);\n    }",
        "comments": [
            "",
            "    /// @notice Called by the users DSProxy",
            "    /// @dev Owner who subscribed cancels his subscription",
            "    "
        ],
        "comt": "\n    /// @notice Called by the users DSProxy\n    /// @dev Owner who subscribed cancels his subscription\n    ",
        "@notice": "Called by the users DSProxy",
        "@dev": "Owner who subscribed cancels his subscription",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isSubscribed",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function isSubscribed(address _user) public view returns (bool) {\n        SubPosition storage subInfo = subscribersPos[_user];\n\n        return subInfo.subscribed;\n    }",
        "comments": [
            "",
            "    /// @dev Checks if the user is subscribed",
            "    /// @param _user The actual address that owns the Compound position",
            "    /// @return If the user is subscribed",
            "    "
        ],
        "comt": "\n    /// @dev Checks if the user is subscribed\n    /// @param _user The actual address that owns the Compound position\n    /// @return If the user is subscribed\n    ",
        "@dev": "Checks if the user is subscribed",
        "@param1": "_user The actual address that owns the Compound position",
        "@return1": "If the user is subscribed",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getHolder",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function getHolder(address _user) public view returns (CompoundHolder memory) {\n        SubPosition storage subInfo = subscribersPos[_user];\n\n        return subscribers[subInfo.arrPos];\n    }",
        "comments": [
            "",
            "    /// @dev Returns subscribtion information about a user",
            "    /// @param _user The actual address that owns the Compound position",
            "    /// @return Subscription information about the user if exists",
            "    "
        ],
        "comt": "\n    /// @dev Returns subscribtion information about a user\n    /// @param _user The actual address that owns the Compound position\n    /// @return Subscription information about the user if exists\n    ",
        "@dev": "Returns subscribtion information about a user",
        "@param1": "_user The actual address that owns the Compound position",
        "@return1": "Subscription information about the user if exists",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getSubscribers",
        "visibility": "public",
        "args": [],
        "func": "function getSubscribers() public view returns (CompoundHolder[] memory) {\n        return subscribers;\n    }",
        "comments": [
            "",
            "    /// @notice Helper method to return all the subscribed CDPs",
            "    /// @return List of all subscribers",
            "    "
        ],
        "comt": "\n    /// @notice Helper method to return all the subscribed CDPs\n    /// @return List of all subscribers\n    ",
        "@notice": "Helper method to return all the subscribed CDPs",
        "@return1": "List of all subscribers",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getSubscribersByPage",
        "visibility": "public",
        "args": [
            {
                "name": "_page",
                "type": "uint"
            },
            {
                "name": "_perPage",
                "type": "uint"
            }
        ],
        "func": "function getSubscribersByPage(uint _page, uint _perPage) public view returns (CompoundHolder[] memory) {\n        CompoundHolder[] memory holders = new CompoundHolder[](_perPage);\n\n        uint start = _page * _perPage;\n        uint end = start + _perPage;\n\n        end = (end > holders.length) ? holders.length : end;\n\n        uint count = 0;\n        for (uint i = start; i < end; i++) {\n            holders[count] = subscribers[i];\n            count++;\n        }\n\n        return holders;\n    }",
        "comments": [
            "",
            "    /// @notice Helper method for the frontend, returns all the subscribed CDPs paginated",
            "    /// @param _page What page of subscribers you want",
            "    /// @param _perPage Number of entries per page",
            "    /// @return List of all subscribers for that page",
            "    "
        ],
        "comt": "\n    /// @notice Helper method for the frontend, returns all the subscribed CDPs paginated\n    /// @param _page What page of subscribers you want\n    /// @param _perPage Number of entries per page\n    /// @return List of all subscribers for that page\n    ",
        "@notice": "Helper method for the frontend, returns all the subscribed CDPs paginated",
        "@param1": "_page What page of subscribers you want",
        "@param2": "_perPage Number of entries per page",
        "@return1": "List of all subscribers for that page",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unsubscribeByAdmin",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function unsubscribeByAdmin(address _user) public onlyOwner {\n        SubPosition storage subInfo = subscribersPos[_user];\n\n        if (subInfo.subscribed) {\n            _unsubscribe(_user);\n        }\n    }",
        "comments": [
            "",
            "    ////////////// ADMIN METHODS ///////////////////",
            "",
            "    /// @notice Admin function to unsubscribe a CDP",
            "    /// @param _user The actual address that owns the Compound position",
            "    "
        ],
        "comt": "\n    ////////////// ADMIN METHODS ///////////////////\n\n    /// @notice Admin function to unsubscribe a CDP\n    /// @param _user The actual address that owns the Compound position\n    ",
        "@notice": "Admin function to unsubscribe a CDP",
        "@param1": "_user The actual address that owns the Compound position",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getSafetyRatio",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function getSafetyRatio(address _user) public view returns (uint) {\n        // For each asset the account is in\n        address[] memory assets = comp.getAssetsIn(_user);\n        address oracleAddr = comp.oracle();\n\n\n        uint sumCollateral = 0;\n        uint sumBorrow = 0;\n\n        for (uint i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n\n            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\n                                        = CTokenInterface(asset).getAccountSnapshot(_user);\n\n            Exp memory oraclePrice;\n\n            if (cTokenBalance != 0 || borrowBalance != 0) {\n                oraclePrice = Exp({mantissa: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(asset)});\n            }\n\n            // Sum up collateral in Usd\n            if (cTokenBalance != 0) {\n\n                (, uint collFactorMantissa) = comp.markets(address(asset));\n\n                Exp memory collateralFactor = Exp({mantissa: collFactorMantissa});\n                Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\n\n                (, Exp memory tokensToUsd) = mulExp3(collateralFactor, exchangeRate, oraclePrice);\n\n                (, sumCollateral) = mulScalarTruncateAddUInt(tokensToUsd, cTokenBalance, sumCollateral);\n            }\n\n            // Sum up debt in Usd\n            if (borrowBalance != 0) {\n                (, sumBorrow) = mulScalarTruncateAddUInt(oraclePrice, borrowBalance, sumBorrow);\n            }\n        }\n\n        if (sumBorrow == 0) return uint(-1);\n\n        uint borrowPowerUsed = (sumBorrow * 10**18) / sumCollateral;\n        return wdiv(1e18, borrowPowerUsed);\n    }",
        "comments": [
            "",
            "    /// @notice Calcualted the ratio of debt / adjusted collateral",
            "    /// @param _user Address of the user",
            "    "
        ],
        "comt": "\n    /// @notice Calcualted the ratio of debt / adjusted collateral\n    /// @param _user Address of the user\n    ",
        "@notice": "Calcualted the ratio of debt / adjusted collateral",
        "@param1": "_user Address of the user",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "subscribe",
        "visibility": "public",
        "args": [
            {
                "name": "_minRatio",
                "type": "uint128"
            },
            {
                "name": "_maxRatio",
                "type": "uint128"
            },
            {
                "name": "_optimalRatioBoost",
                "type": "uint128"
            },
            {
                "name": "_optimalRatioRepay",
                "type": "uint128"
            },
            {
                "name": "_boostEnabled",
                "type": "bool"
            }
        ],
        "func": "function subscribe(\n        uint128 _minRatio,\n        uint128 _maxRatio,\n        uint128 _optimalRatioBoost,\n        uint128 _optimalRatioRepay,\n        bool _boostEnabled\n    ) public {\n        givePermission(COMPOUND_MONITOR_PROXY);\n        ICompoundSubscription(COMPOUND_SUBSCRIPTION_ADDRESS).subscribe(\n            _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled);\n    }",
        "comments": [
            "",
            "    /// @notice Calls subscription contract and creates a DSGuard if non existent",
            "    /// @param _minRatio Minimum ratio below which repay is triggered",
            "    /// @param _maxRatio Maximum ratio after which boost is triggered",
            "    /// @param _optimalRatioBoost Ratio amount which boost should target",
            "    /// @param _optimalRatioRepay Ratio amount which repay should target",
            "    /// @param _boostEnabled Boolean determing if boost is enabled",
            "    "
        ],
        "comt": "\n    /// @notice Calls subscription contract and creates a DSGuard if non existent\n    /// @param _minRatio Minimum ratio below which repay is triggered\n    /// @param _maxRatio Maximum ratio after which boost is triggered\n    /// @param _optimalRatioBoost Ratio amount which boost should target\n    /// @param _optimalRatioRepay Ratio amount which repay should target\n    /// @param _boostEnabled Boolean determing if boost is enabled\n    ",
        "@notice": "Calls subscription contract and creates a DSGuard if non existent",
        "@param1": "_minRatio Minimum ratio below which repay is triggered",
        "@param2": "_maxRatio Maximum ratio after which boost is triggered",
        "@param3": "_optimalRatioBoost Ratio amount which boost should target",
        "@param4": "_optimalRatioRepay Ratio amount which repay should target",
        "@param5": "_boostEnabled Boolean determing if boost is enabled",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "update",
        "visibility": "public",
        "args": [
            {
                "name": "_minRatio",
                "type": "uint128"
            },
            {
                "name": "_maxRatio",
                "type": "uint128"
            },
            {
                "name": "_optimalRatioBoost",
                "type": "uint128"
            },
            {
                "name": "_optimalRatioRepay",
                "type": "uint128"
            },
            {
                "name": "_boostEnabled",
                "type": "bool"
            }
        ],
        "func": "function update(\n        uint128 _minRatio,\n        uint128 _maxRatio,\n        uint128 _optimalRatioBoost,\n        uint128 _optimalRatioRepay,\n        bool _boostEnabled\n    ) public {\n        ICompoundSubscription(COMPOUND_SUBSCRIPTION_ADDRESS).subscribe(_minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled);\n    }",
        "comments": [
            "",
            "    /// @notice Calls subscription contract and updated existing parameters",
            "    /// @dev If subscription is non existent this will create one",
            "    /// @param _minRatio Minimum ratio below which repay is triggered",
            "    /// @param _maxRatio Maximum ratio after which boost is triggered",
            "    /// @param _optimalRatioBoost Ratio amount which boost should target",
            "    /// @param _optimalRatioRepay Ratio amount which repay should target",
            "    /// @param _boostEnabled Boolean determing if boost is enabled",
            "    "
        ],
        "comt": "\n    /// @notice Calls subscription contract and updated existing parameters\n    /// @dev If subscription is non existent this will create one\n    /// @param _minRatio Minimum ratio below which repay is triggered\n    /// @param _maxRatio Maximum ratio after which boost is triggered\n    /// @param _optimalRatioBoost Ratio amount which boost should target\n    /// @param _optimalRatioRepay Ratio amount which repay should target\n    /// @param _boostEnabled Boolean determing if boost is enabled\n    ",
        "@notice": "Calls subscription contract and updated existing parameters",
        "@dev": "If subscription is non existent this will create one",
        "@param1": "_minRatio Minimum ratio below which repay is triggered",
        "@param2": "_maxRatio Maximum ratio after which boost is triggered",
        "@param3": "_optimalRatioBoost Ratio amount which boost should target",
        "@param4": "_optimalRatioRepay Ratio amount which repay should target",
        "@param5": "_boostEnabled Boolean determing if boost is enabled",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unsubscribe",
        "visibility": "public",
        "args": [],
        "func": "function unsubscribe() public {\n        removePermission(COMPOUND_MONITOR_PROXY);\n        ICompoundSubscription(COMPOUND_SUBSCRIPTION_ADDRESS).unsubscribe();\n    }",
        "comments": [
            "",
            "    /// @notice Calls the subscription contract to unsubscribe the caller",
            "    "
        ],
        "comt": "\n    /// @notice Calls the subscription contract to unsubscribe the caller\n    ",
        "@notice": "Calls the subscription contract to unsubscribe the caller",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "deposit",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_cTokenAddr",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            },
            {
                "name": "_inMarket",
                "type": "bool"
            }
        ],
        "func": "function deposit(address _tokenAddr, address _cTokenAddr, uint _amount, bool _inMarket) public burnGas(5) payable {\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), _amount);\n        }\n\n        approveToken(_tokenAddr, _cTokenAddr);\n\n        if (!_inMarket) {\n            enterMarket(_cTokenAddr);\n        }\n\n        if (_tokenAddr != ETH_ADDR) {\n            require(CTokenInterface(_cTokenAddr).mint(_amount) == 0);\n        } else {\n            CEtherInterface(_cTokenAddr).mint{value: msg.value}(); // reverts on fail\n        }\n    }",
        "comments": [
            "",
            "    /// @notice User deposits tokens to the Compound protocol",
            "    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens",
            "    /// @param _tokenAddr The address of the token to be deposited",
            "    /// @param _cTokenAddr CTokens to be deposited",
            "    /// @param _amount Amount of tokens to be deposited",
            "    /// @param _inMarket True if the token is already in market for that address",
            "    "
        ],
        "comt": "\n    /// @notice User deposits tokens to the Compound protocol\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\n    /// @param _tokenAddr The address of the token to be deposited\n    /// @param _cTokenAddr CTokens to be deposited\n    /// @param _amount Amount of tokens to be deposited\n    /// @param _inMarket True if the token is already in market for that address\n    ",
        "@notice": "User deposits tokens to the Compound protocol",
        "@dev": "User needs to approve the DSProxy to pull the _tokenAddr tokens",
        "@param1": "_tokenAddr The address of the token to be deposited",
        "@param2": "_cTokenAddr CTokens to be deposited",
        "@param3": "_amount Amount of tokens to be deposited",
        "@param4": "_inMarket True if the token is already in market for that address",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_cTokenAddr",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            },
            {
                "name": "_isCAmount",
                "type": "bool"
            }
        ],
        "func": "function withdraw(address _tokenAddr, address _cTokenAddr, uint _amount, bool _isCAmount) public burnGas(5) {\n\n        if (_isCAmount) {\n            require(CTokenInterface(_cTokenAddr).redeem(_amount) == 0);\n        } else {\n            require(CTokenInterface(_cTokenAddr).redeemUnderlying(_amount) == 0);\n        }\n\n        // withdraw funds to msg.sender\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransfer(msg.sender, ERC20(_tokenAddr).balanceOf(address(this)));\n        } else {\n            msg.sender.transfer(address(this).balance);\n        }\n\n    }",
        "comments": [
            "",
            "    /// @notice User withdraws tokens to the Compound protocol",
            "    /// @param _tokenAddr The address of the token to be withdrawn",
            "    /// @param _cTokenAddr CTokens to be withdrawn",
            "    /// @param _amount Amount of tokens to be withdrawn",
            "    /// @param _isCAmount If true _amount is cTokens if falls _amount is underlying tokens",
            "    "
        ],
        "comt": "\n    /// @notice User withdraws tokens to the Compound protocol\n    /// @param _tokenAddr The address of the token to be withdrawn\n    /// @param _cTokenAddr CTokens to be withdrawn\n    /// @param _amount Amount of tokens to be withdrawn\n    /// @param _isCAmount If true _amount is cTokens if falls _amount is underlying tokens\n    ",
        "@notice": "User withdraws tokens to the Compound protocol",
        "@param1": "_tokenAddr The address of the token to be withdrawn",
        "@param2": "_cTokenAddr CTokens to be withdrawn",
        "@param3": "_amount Amount of tokens to be withdrawn",
        "@param4": "_isCAmount If true _amount is cTokens if falls _amount is underlying tokens",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "borrow",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_cTokenAddr",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            },
            {
                "name": "_inMarket",
                "type": "bool"
            }
        ],
        "func": "function borrow(address _tokenAddr, address _cTokenAddr, uint _amount, bool _inMarket) public burnGas(8) {\n        if (!_inMarket) {\n            enterMarket(_cTokenAddr);\n        }\n\n        require(CTokenInterface(_cTokenAddr).borrow(_amount) == 0);\n\n        // withdraw funds to msg.sender\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransfer(msg.sender, ERC20(_tokenAddr).balanceOf(address(this)));\n        } else {\n            msg.sender.transfer(address(this).balance);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice User borrows tokens to the Compound protocol",
            "    /// @param _tokenAddr The address of the token to be borrowed",
            "    /// @param _cTokenAddr CTokens to be borrowed",
            "    /// @param _amount Amount of tokens to be borrowed",
            "    /// @param _inMarket True if the token is already in market for that address",
            "    "
        ],
        "comt": "\n    /// @notice User borrows tokens to the Compound protocol\n    /// @param _tokenAddr The address of the token to be borrowed\n    /// @param _cTokenAddr CTokens to be borrowed\n    /// @param _amount Amount of tokens to be borrowed\n    /// @param _inMarket True if the token is already in market for that address\n    ",
        "@notice": "User borrows tokens to the Compound protocol",
        "@param1": "_tokenAddr The address of the token to be borrowed",
        "@param2": "_cTokenAddr CTokens to be borrowed",
        "@param3": "_amount Amount of tokens to be borrowed",
        "@param4": "_inMarket True if the token is already in market for that address",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "payback",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_cTokenAddr",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            },
            {
                "name": "_wholeDebt",
                "type": "bool"
            }
        ],
        "func": "function payback(address _tokenAddr, address _cTokenAddr, uint _amount, bool _wholeDebt) public burnGas(5) payable {\n        approveToken(_tokenAddr, _cTokenAddr);\n\n        if (_wholeDebt) {\n            _amount = CTokenInterface(_cTokenAddr).borrowBalanceCurrent(address(this));\n        }\n\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), _amount);\n\n            require(CTokenInterface(_cTokenAddr).repayBorrow(_amount) == 0);\n        } else {\n            CEtherInterface(_cTokenAddr).repayBorrow{value: msg.value}();\n            msg.sender.transfer(address(this).balance); // send back the extra eth\n        }\n    }",
        "comments": [
            "",
            "    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens",
            "    /// @notice User paybacks tokens to the Compound protocol",
            "    /// @param _tokenAddr The address of the token to be paybacked",
            "    /// @param _cTokenAddr CTokens to be paybacked",
            "    /// @param _amount Amount of tokens to be payedback",
            "    /// @param _wholeDebt If true the _amount will be set to the whole amount of the debt",
            "    "
        ],
        "comt": "\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\n    /// @notice User paybacks tokens to the Compound protocol\n    /// @param _tokenAddr The address of the token to be paybacked\n    /// @param _cTokenAddr CTokens to be paybacked\n    /// @param _amount Amount of tokens to be payedback\n    /// @param _wholeDebt If true the _amount will be set to the whole amount of the debt\n    ",
        "@dev": "User needs to approve the DSProxy to pull the _tokenAddr tokens",
        "@notice": "User paybacks tokens to the Compound protocol",
        "@param1": "_tokenAddr The address of the token to be paybacked",
        "@param2": "_cTokenAddr CTokens to be paybacked",
        "@param3": "_amount Amount of tokens to be payedback",
        "@param4": "_wholeDebt If true the _amount will be set to the whole amount of the debt",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawTokens",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            }
        ],
        "func": "function withdrawTokens(address _tokenAddr) public {\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransfer(msg.sender, ERC20(_tokenAddr).balanceOf(address(this)));\n        } else {\n            msg.sender.transfer(address(this).balance);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Helper method to withdraw tokens from the DSProxy",
            "    /// @param _tokenAddr Address of the token to be withdrawn",
            "    "
        ],
        "comt": "\n    /// @notice Helper method to withdraw tokens from the DSProxy\n    /// @param _tokenAddr Address of the token to be withdrawn\n    ",
        "@notice": "Helper method to withdraw tokens from the DSProxy",
        "@param1": "_tokenAddr Address of the token to be withdrawn",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "enterMarket",
        "visibility": "public",
        "args": [
            {
                "name": "_cTokenAddr",
                "type": "address"
            }
        ],
        "func": "function enterMarket(address _cTokenAddr) public {\n        address[] memory markets = new address[](1);\n        markets[0] = _cTokenAddr;\n\n        ComptrollerInterface(COMPTROLLER_ADDR).enterMarkets(markets);\n    }",
        "comments": [
            "",
            "    /// @notice Enters the Compound market so it can be deposited/borrowed",
            "    /// @param _cTokenAddr CToken address of the token",
            "    "
        ],
        "comt": "\n    /// @notice Enters the Compound market so it can be deposited/borrowed\n    /// @param _cTokenAddr CToken address of the token\n    ",
        "@notice": "Enters the Compound market so it can be deposited/borrowed",
        "@param1": "_cTokenAddr CToken address of the token",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "exitMarket",
        "visibility": "public",
        "args": [
            {
                "name": "_cTokenAddr",
                "type": "address"
            }
        ],
        "func": "function exitMarket(address _cTokenAddr) public {\n        ComptrollerInterface(COMPTROLLER_ADDR).exitMarket(_cTokenAddr);\n    }",
        "comments": [
            "",
            "    /// @notice Exits the Compound market so it can't be deposited/borrowed",
            "    /// @param _cTokenAddr CToken address of the token",
            "    "
        ],
        "comt": "\n    /// @notice Exits the Compound market so it can't be deposited/borrowed\n    /// @param _cTokenAddr CToken address of the token\n    ",
        "@notice": "Exits the Compound market so it can't be deposited/borrowed",
        "@param1": "_cTokenAddr CToken address of the token",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getRatio",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function getRatio(address _user) public view returns (uint) {\n        // For each asset the account is in\n        return getSafetyRatio(_user);\n    }",
        "comments": [
            "",
            "",
            "    /// @notice Calcualted the ratio of coll/debt for a compound user",
            "    /// @param _user Address of the user",
            "    "
        ],
        "comt": "\n\n    /// @notice Calcualted the ratio of coll/debt for a compound user\n    /// @param _user Address of the user\n    ",
        "@notice": "Calcualted the ratio of coll/debt for a compound user",
        "@param1": "_user Address of the user",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPrices",
        "visibility": "public",
        "args": [
            {
                "name": "_cTokens",
                "type": "address[] memory"
            }
        ],
        "func": "function getPrices(address[] memory _cTokens) public view returns (uint[] memory prices) {\n        prices = new uint[](_cTokens.length);\n        address oracleAddr = comp.oracle();\n\n        for (uint i = 0; i < _cTokens.length; ++i) {\n            prices[i] = CompoundOracleInterface(oracleAddr).getUnderlyingPrice(_cTokens[i]);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Fetches Compound prices for tokens",
            "    /// @param _cTokens Arr. of cTokens for which to get the prices",
            "    /// @return prices Array of prices",
            "    "
        ],
        "comt": "\n    /// @notice Fetches Compound prices for tokens\n    /// @param _cTokens Arr. of cTokens for which to get the prices\n    /// @return prices Array of prices\n    ",
        "@notice": "Fetches Compound prices for tokens",
        "@param1": "_cTokens Arr. of cTokens for which to get the prices",
        "@return1": "prices Array of prices",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCollFactors",
        "visibility": "public",
        "args": [
            {
                "name": "_cTokens",
                "type": "address[] memory"
            }
        ],
        "func": "function getCollFactors(address[] memory _cTokens) public view returns (uint[] memory collFactors) {\n        collFactors = new uint[](_cTokens.length);\n\n        for (uint i = 0; i < _cTokens.length; ++i) {\n            (, collFactors[i]) = comp.markets(_cTokens[i]);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Fetches Compound collateral factors for tokens",
            "    /// @param _cTokens Arr. of cTokens for which to get the coll. factors",
            "    /// @return collFactors Array of coll. factors",
            "    "
        ],
        "comt": "\n    /// @notice Fetches Compound collateral factors for tokens\n    /// @param _cTokens Arr. of cTokens for which to get the coll. factors\n    /// @return collFactors Array of coll. factors\n    ",
        "@notice": "Fetches Compound collateral factors for tokens",
        "@param1": "_cTokens Arr. of cTokens for which to get the coll. factors",
        "@return1": "collFactors Array of coll. factors",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getLoanData",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function getLoanData(address _user) public view returns (LoanData memory data) {\n        address[] memory assets = comp.getAssetsIn(_user);\n        address oracleAddr = comp.oracle();\n\n        data = LoanData({\n            user: _user,\n            ratio: 0,\n            collAddr: new address[](assets.length),\n            borrowAddr: new address[](assets.length),\n            collAmounts: new uint[](assets.length),\n            borrowAmounts: new uint[](assets.length)\n        });\n\n        uint collPos = 0;\n        uint borrowPos = 0;\n\n        for (uint i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n\n            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\n                                        = CTokenInterface(asset).getAccountSnapshot(_user);\n\n            Exp memory oraclePrice;\n\n            if (cTokenBalance != 0 || borrowBalance != 0) {\n                oraclePrice = Exp({mantissa: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(asset)});\n            }\n\n            // Sum up collateral in Usd\n            if (cTokenBalance != 0) {\n                Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\n                (, Exp memory tokensToUsd) = mulExp(exchangeRate, oraclePrice);\n\n                data.collAddr[collPos] = asset;\n                (, data.collAmounts[collPos]) = mulScalarTruncate(tokensToUsd, cTokenBalance);\n                collPos++;\n            }\n\n            // Sum up debt in Usd\n            if (borrowBalance != 0) {\n                data.borrowAddr[borrowPos] = asset;\n                (, data.borrowAmounts[borrowPos]) = mulScalarTruncate(oraclePrice, borrowBalance);\n                borrowPos++;\n            }\n        }\n\n        data.ratio = uint128(getSafetyRatio(_user));\n\n        return data;\n    }",
        "comments": [
            "",
            "    /// @notice Fetches all the collateral/debt address and amounts, denominated in usd",
            "    /// @param _user Address of the user",
            "    /// @return data LoanData information",
            "    "
        ],
        "comt": "\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in usd\n    /// @param _user Address of the user\n    /// @return data LoanData information\n    ",
        "@notice": "Fetches all the collateral/debt address and amounts, denominated in usd",
        "@param1": "_user Address of the user",
        "@return1": "data LoanData information",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getTokenBalances",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            },
            {
                "name": "_cTokens",
                "type": "address[] memory"
            }
        ],
        "func": "function getTokenBalances(address _user, address[] memory _cTokens) public view returns (uint[] memory balances, uint[] memory borrows) {\n        balances = new uint[](_cTokens.length);\n        borrows = new uint[](_cTokens.length);\n\n        for (uint i = 0; i < _cTokens.length; i++) {\n            address asset = _cTokens[i];\n\n            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\n                                        = CTokenInterface(asset).getAccountSnapshot(_user);\n\n            Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\n            (, balances[i]) = mulScalarTruncate(exchangeRate, cTokenBalance);\n\n            borrows[i] = borrowBalance;\n        }\n\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getLoanDataArr",
        "visibility": "public",
        "args": [
            {
                "name": "_users",
                "type": "address[] memory"
            }
        ],
        "func": "function getLoanDataArr(address[] memory _users) public view returns (LoanData[] memory loans) {\n        loans = new LoanData[](_users.length);\n\n        for (uint i = 0; i < _users.length; ++i) {\n            loans[i] = getLoanData(_users[i]);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Fetches all the collateral/debt address and amounts, denominated in usd",
            "    /// @param _users Addresses of the user",
            "    /// @return loans Array of LoanData information",
            "    "
        ],
        "comt": "\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in usd\n    /// @param _users Addresses of the user\n    /// @return loans Array of LoanData information\n    ",
        "@notice": "Fetches all the collateral/debt address and amounts, denominated in usd",
        "@param1": "_users Addresses of the user",
        "@return1": "loans Array of LoanData information",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getRatios",
        "visibility": "public",
        "args": [
            {
                "name": "_users",
                "type": "address[] memory"
            }
        ],
        "func": "function getRatios(address[] memory _users) public view returns (uint[] memory ratios) {\n        ratios = new uint[](_users.length);\n\n        for (uint i = 0; i < _users.length; ++i) {\n            ratios[i] = getSafetyRatio(_users[i]);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Calcualted the ratio of coll/debt for a compound user",
            "    /// @param _users Addresses of the user",
            "    /// @return ratios Array of ratios",
            "    "
        ],
        "comt": "\n    /// @notice Calcualted the ratio of coll/debt for a compound user\n    /// @param _users Addresses of the user\n    /// @return ratios Array of ratios\n    ",
        "@notice": "Calcualted the ratio of coll/debt for a compound user",
        "@param1": "_users Addresses of the user",
        "@return1": "ratios Array of ratios",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getTokensInfo",
        "visibility": "public",
        "args": [
            {
                "name": "_cTokenAddresses",
                "type": "address[] memory"
            }
        ],
        "func": "function getTokensInfo(address[] memory _cTokenAddresses) public returns(TokenInfo[] memory tokens) {\n        tokens = new TokenInfo[](_cTokenAddresses.length);\n        address oracleAddr = comp.oracle();\n\n        for (uint i = 0; i < _cTokenAddresses.length; ++i) {\n            (, uint collFactor) = comp.markets(_cTokenAddresses[i]);\n\n            tokens[i] = TokenInfo({\n                cTokenAddress: _cTokenAddresses[i],\n                underlyingTokenAddress: getUnderlyingAddr(_cTokenAddresses[i]),\n                collateralFactor: collFactor,\n                price: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(_cTokenAddresses[i])\n            });\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Information about cTokens",
            "    /// @param _cTokenAddresses Array of cTokens addresses",
            "    /// @return tokens Array of cTokens infomartion",
            "    "
        ],
        "comt": "\n    /// @notice Information about cTokens\n    /// @param _cTokenAddresses Array of cTokens addresses\n    /// @return tokens Array of cTokens infomartion\n    ",
        "@notice": "Information about cTokens",
        "@param1": "_cTokenAddresses Array of cTokens addresses",
        "@return1": "tokens Array of cTokens infomartion",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getFullTokensInfo",
        "visibility": "public",
        "args": [
            {
                "name": "_cTokenAddresses",
                "type": "address[] memory"
            }
        ],
        "func": "function getFullTokensInfo(address[] memory _cTokenAddresses) public returns(TokenInfoFull[] memory tokens) {\n        tokens = new TokenInfoFull[](_cTokenAddresses.length);\n        address oracleAddr = comp.oracle();\n\n        for (uint i = 0; i < _cTokenAddresses.length; ++i) {\n            (, uint collFactor) = comp.markets(_cTokenAddresses[i]);\n            CTokenInterface cToken = CTokenInterface(_cTokenAddresses[i]);\n\n            tokens[i] = TokenInfoFull({\n                underlyingTokenAddress: getUnderlyingAddr(_cTokenAddresses[i]),\n                supplyRate: cToken.supplyRatePerBlock(),\n                borrowRate: cToken.borrowRatePerBlock(),\n                exchangeRate: cToken.exchangeRateCurrent(),\n                marketLiquidity: cToken.getCash(),\n                totalSupply: cToken.totalSupply(),\n                totalBorrow: cToken.totalBorrowsCurrent(),\n                collateralFactor: collFactor,\n                price: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(_cTokenAddresses[i])\n            });\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Information about cTokens",
            "    /// @param _cTokenAddresses Array of cTokens addresses",
            "    /// @return tokens Array of cTokens infomartion",
            "    "
        ],
        "comt": "\n    /// @notice Information about cTokens\n    /// @param _cTokenAddresses Array of cTokens addresses\n    /// @return tokens Array of cTokens infomartion\n    ",
        "@notice": "Information about cTokens",
        "@param1": "_cTokenAddresses Array of cTokens addresses",
        "@return1": "tokens Array of cTokens infomartion",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMaxCollateral",
        "visibility": "public",
        "args": [
            {
                "name": "_cCollAddress",
                "type": "address"
            },
            {
                "name": "_account",
                "type": "address"
            }
        ],
        "func": "function getMaxCollateral(address _cCollAddress, address _account) public returns (uint) {\n        (, uint liquidityInUsd, ) = ComptrollerInterface(COMPTROLLER).getAccountLiquidity(_account);\n        uint usersBalance = CTokenInterface(_cCollAddress).balanceOfUnderlying(_account);\n        address oracle = ComptrollerInterface(COMPTROLLER).oracle();\n\n        if (liquidityInUsd == 0) return usersBalance;\n\n        CTokenInterface(_cCollAddress).accrueInterest();\n\n        (, uint collFactorMantissa) = ComptrollerInterface(COMPTROLLER).markets(_cCollAddress);\n        Exp memory collateralFactor = Exp({mantissa: collFactorMantissa});\n\n        (, uint tokensToUsd) = divScalarByExpTruncate(liquidityInUsd, collateralFactor);\n\n        uint usdPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(_cCollAddress);\n        uint liqInToken = wdiv(tokensToUsd, usdPrice);\n\n        if (liqInToken > usersBalance) return usersBalance;\n\n        return sub(liqInToken, (liqInToken / 100)); // cut off 1% due to rounding issues\n    }",
        "comments": [
            "",
            "    /// @notice Returns the maximum amount of collateral available to withdraw",
            "    /// @dev Due to rounding errors the result is - 1% wei from the exact amount",
            "    /// @param _cCollAddress Collateral we are getting the max value of",
            "    /// @param _account Users account",
            "    /// @return Returns the max. collateral amount in that token",
            "    "
        ],
        "comt": "\n    /// @notice Returns the maximum amount of collateral available to withdraw\n    /// @dev Due to rounding errors the result is - 1% wei from the exact amount\n    /// @param _cCollAddress Collateral we are getting the max value of\n    /// @param _account Users account\n    /// @return Returns the max. collateral amount in that token\n    ",
        "@notice": "Returns the maximum amount of collateral available to withdraw",
        "@dev": "Due to rounding errors the result is - 1% wei from the exact amount",
        "@param1": "_cCollAddress Collateral we are getting the max value of",
        "@param2": "_account Users account",
        "@return1": "Returns the max. collateral amount in that token",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMaxBorrow",
        "visibility": "public",
        "args": [
            {
                "name": "_cBorrowAddress",
                "type": "address"
            },
            {
                "name": "_account",
                "type": "address"
            }
        ],
        "func": "function getMaxBorrow(address _cBorrowAddress, address _account) public returns (uint) {\n        (, uint liquidityInUsd, ) = ComptrollerInterface(COMPTROLLER).getAccountLiquidity(_account);\n        address oracle = ComptrollerInterface(COMPTROLLER).oracle();\n\n        CTokenInterface(_cBorrowAddress).accrueInterest();\n\n        uint usdPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(_cBorrowAddress);\n        uint liquidityInToken = wdiv(liquidityInUsd, usdPrice);\n\n        return sub(liquidityInToken, (liquidityInToken / 100)); // cut off 1% due to rounding issues\n    }",
        "comments": [
            "",
            "    /// @notice Returns the maximum amount of borrow amount available",
            "    /// @dev Due to rounding errors the result is - 1% wei from the exact amount",
            "    /// @param _cBorrowAddress Borrow token we are getting the max value of",
            "    /// @param _account Users account",
            "    /// @return Returns the max. borrow amount in that token",
            "    "
        ],
        "comt": "\n    /// @notice Returns the maximum amount of borrow amount available\n    /// @dev Due to rounding errors the result is - 1% wei from the exact amount\n    /// @param _cBorrowAddress Borrow token we are getting the max value of\n    /// @param _account Users account\n    /// @return Returns the max. borrow amount in that token\n    ",
        "@notice": "Returns the maximum amount of borrow amount available",
        "@dev": "Due to rounding errors the result is - 1% wei from the exact amount",
        "@param1": "_cBorrowAddress Borrow token we are getting the max value of",
        "@param2": "_account Users account",
        "@return1": "Returns the max. borrow amount in that token",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "executeOperation",
        "visibility": "external",
        "args": [
            {
                "name": "_reserve",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            },
            {
                "name": "_fee",
                "type": "uint256"
            },
            {
                "name": "_params",
                "type": "bytes calldata"
            }
        ],
        "func": "function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n        // Format the call data for DSProxy\n        (CompCreateData memory compCreate, ExchangeData memory exchangeData)\n                                 = packFunctionCall(_amount, _fee, _params);\n\n\n        address leveragedAsset = _reserve;\n\n        // If the assets are different\n        if (compCreate.cCollAddr != compCreate.cDebtAddr) {\n            (, uint sellAmount) = _sell(exchangeData);\n            getFee(sellAmount, exchangeData.destAddr, compCreate.proxyAddr);\n\n            leveragedAsset = exchangeData.destAddr;\n        }\n\n        // Send amount to DSProxy\n        sendToProxy(compCreate.proxyAddr, leveragedAsset);\n\n        address compOpenProxy = shifterRegistry.getAddr(\"COMP_SHIFTER\");\n\n        // Execute the DSProxy call\n        DSProxyInterface(compCreate.proxyAddr).execute(compOpenProxy, compCreate.proxyData);\n\n        // Repay the loan with the money DSProxy sent back\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            // solhint-disable-next-line avoid-tx-origin\n            tx.origin.transfer(address(this).balance);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Called by Aave when sending back the FL amount",
            "    /// @param _reserve The address of the borrowed token",
            "    /// @param _amount Amount of FL tokens received",
            "    /// @param _fee FL Aave fee",
            "    /// @param _params The params that are sent from the original FL caller contract",
            "   "
        ],
        "comt": "\n    /// @notice Called by Aave when sending back the FL amount\n    /// @param _reserve The address of the borrowed token\n    /// @param _amount Amount of FL tokens received\n    /// @param _fee FL Aave fee\n    /// @param _params The params that are sent from the original FL caller contract\n   ",
        "@notice": "Called by Aave when sending back the FL amount",
        "@param1": "_reserve The address of the borrowed token",
        "@param2": "_amount Amount of FL tokens received",
        "@param3": "_fee FL Aave fee",
        "@param4": "_params The params that are sent from the original FL caller contract",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeContractAddr",
        "visibility": "public",
        "args": [
            {
                "name": "_contractName",
                "type": "string memory"
            },
            {
                "name": "_protoAddr",
                "type": "address"
            }
        ],
        "func": "function changeContractAddr(string memory _contractName, address _protoAddr) public onlyOwner {\n        require(!finalized);\n        contractAddresses[_contractName] = _protoAddr;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lock",
        "visibility": "public",
        "args": [],
        "func": "function lock() public onlyOwner {\n        finalized = true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAddr",
        "visibility": "public",
        "args": [
            {
                "name": "_contractName",
                "type": "string memory"
            }
        ],
        "func": "function getAddr(string memory _contractName) public view returns (address contractAddr) {\n        contractAddr = contractAddresses[_contractName];\n\n        require(contractAddr != address(0), \"No contract address registred\");\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "openLeveragedLoan",
        "visibility": "public",
        "args": [
            {
                "name": "_createInfo",
                "type": "CreateInfo memory"
            },
            {
                "name": "_exchangeData",
                "type": "SaverExchangeCore.ExchangeData memory"
            },
            {
                "name": "_compReceiver",
                "type": "address payable"
            }
        ],
        "func": "function openLeveragedLoan(\n        CreateInfo memory _createInfo,\n        SaverExchangeCore.ExchangeData memory _exchangeData,\n        address payable _compReceiver\n    ) public payable {\n        uint loanAmount = _exchangeData.srcAmount;\n\n        // Pull tokens from user\n        if (_exchangeData.destAddr != ETH_ADDRESS) {\n            ERC20(_exchangeData.destAddr).safeTransferFrom(msg.sender, address(this), _createInfo.depositAmount);\n        } else {\n            require(msg.value >= _createInfo.depositAmount, \"Must send correct amount of eth\");\n        }\n\n        // Send tokens to FL receiver\n        sendDeposit(_compReceiver, _exchangeData.destAddr);\n\n        // Pack the struct data\n        (uint[4] memory numData, address[6] memory cAddresses, bytes memory callData)\n                                            = _packData(_createInfo, _exchangeData);\n        bytes memory paramsData = abi.encode(numData, cAddresses, callData, address(this));\n\n        givePermission(_compReceiver);\n\n        lendingPool.flashLoan(_compReceiver, _exchangeData.srcAddr, loanAmount, paramsData);\n\n        removePermission(_compReceiver);\n\n        logger.Log(address(this), msg.sender, \"CompoundLeveragedLoan\",\n            abi.encode(_exchangeData.srcAddr, _exchangeData.destAddr, _exchangeData.srcAmount, _exchangeData.destAmount));\n    }",
        "comments": [
            "",
            "    /// @notice Main function which will take a FL and open a leverage position",
            "    /// @dev Call through DSProxy, if _exchangeData.destAddr is a token approve DSProxy",
            "    /// @param _createInfo [cCollAddress, cBorrowAddress, depositAmount]",
            "    /// @param _exchangeData Exchange data struct",
            "    "
        ],
        "comt": "\n    /// @notice Main function which will take a FL and open a leverage position\n    /// @dev Call through DSProxy, if _exchangeData.destAddr is a token approve DSProxy\n    /// @param _createInfo [cCollAddress, cBorrowAddress, depositAmount]\n    /// @param _exchangeData Exchange data struct\n    ",
        "@notice": "Main function which will take a FL and open a leverage position",
        "@dev": "Call through DSProxy, if _exchangeData.destAddr is a token approve DSProxy",
        "@param1": "_createInfo [cCollAddress, cBorrowAddress, depositAmount]",
        "@param2": "_exchangeData Exchange data struct",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "borrow",
        "visibility": "public",
        "args": [
            {
                "name": "_cCollToken",
                "type": "address"
            },
            {
                "name": "_cBorrowToken",
                "type": "address"
            },
            {
                "name": "_borrowToken",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            }
        ],
        "func": "function borrow(address _cCollToken, address _cBorrowToken, address _borrowToken, uint _amount) public {\n        address[] memory markets = new address[](2);\n        markets[0] = _cCollToken;\n        markets[1] = _cBorrowToken;\n\n        ComptrollerInterface(COMPTROLLER_ADDR).enterMarkets(markets);\n\n        require(CTokenInterface(_cBorrowToken).borrow(_amount) == 0);\n\n        // withdraw funds to msg.sender\n        if (_borrowToken != ETH_ADDR) {\n            ERC20(_borrowToken).safeTransfer(msg.sender, ERC20(_borrowToken).balanceOf(address(this)));\n        } else {\n            msg.sender.transfer(address(this).balance);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "executeOperation",
        "visibility": "external",
        "args": [
            {
                "name": "_reserve",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            },
            {
                "name": "_fee",
                "type": "uint256"
            },
            {
                "name": "_params",
                "type": "bytes calldata"
            }
        ],
        "func": "function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n\n        (\n            address cCollateralToken,\n            address cBorrowToken,\n            address user,\n            address proxy\n        )\n        = abi.decode(_params, (address,address,address,address));\n\n        // approve FL tokens so we can repay them\n        ERC20(_reserve).safeApprove(cBorrowToken, 0);\n        ERC20(_reserve).safeApprove(cBorrowToken, uint(-1));\n\n        // repay compound debt\n        require(CTokenInterface(cBorrowToken).repayBorrowBehalf(user, uint(-1)) == 0, \"Repay borrow behalf fail\");\n\n        // transfer cTokens to proxy\n        uint cTokenBalance = CTokenInterface(cCollateralToken).balanceOf(user);\n        require(CTokenInterface(cCollateralToken).transferFrom(user, proxy, cTokenBalance));\n\n        // borrow\n        bytes memory proxyData = getProxyData(cCollateralToken, cBorrowToken, _reserve, (_amount + _fee));\n        DSProxyInterface(proxy).execute(COMPOUND_BORROW_PROXY, proxyData);\n\n        // Repay the loan with the money DSProxy sent back\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n    }",
        "comments": [
            "",
            "    /// @notice Called by Aave when sending back the FL amount",
            "    /// @param _reserve The address of the borrowed token",
            "    /// @param _amount Amount of FL tokens received",
            "    /// @param _fee FL Aave fee",
            "    /// @param _params The params that are sent from the original FL caller contract",
            "    "
        ],
        "comt": "\n    /// @notice Called by Aave when sending back the FL amount\n    /// @param _reserve The address of the borrowed token\n    /// @param _amount Amount of FL tokens received\n    /// @param _fee FL Aave fee\n    /// @param _params The params that are sent from the original FL caller contract\n    ",
        "@notice": "Called by Aave when sending back the FL amount",
        "@param1": "_reserve The address of the borrowed token",
        "@param2": "_amount Amount of FL tokens received",
        "@param3": "_fee FL Aave fee",
        "@param4": "_params The params that are sent from the original FL caller contract",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawStuckFunds",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            }
        ],
        "func": "function withdrawStuckFunds(address _tokenAddr, uint _amount) public {\n        require(owner == msg.sender, \"Must be owner\");\n\n        if (_tokenAddr == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n            msg.sender.transfer(_amount);\n        } else {\n            ERC20(_tokenAddr).safeTransfer(owner, _amount);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "importLoan",
        "visibility": "external",
        "args": [
            {
                "name": "_cCollateralToken",
                "type": "address"
            },
            {
                "name": "_cBorrowToken",
                "type": "address"
            }
        ],
        "func": "function importLoan(address _cCollateralToken, address _cBorrowToken) external burnGas(20) {\n        address proxy = getProxy();\n\n        uint loanAmount = CTokenInterface(_cBorrowToken).borrowBalanceCurrent(msg.sender);\n        bytes memory paramsData = abi.encode(_cCollateralToken, _cBorrowToken, msg.sender, proxy);\n\n        givePermission(COMPOUND_IMPORT_FLASH_LOAN);\n\n        lendingPool.flashLoan(COMPOUND_IMPORT_FLASH_LOAN, getUnderlyingAddr(_cBorrowToken), loanAmount, paramsData);\n\n        removePermission(COMPOUND_IMPORT_FLASH_LOAN);\n\n        logger.Log(address(this), msg.sender, \"CompoundImport\", abi.encode(loanAmount, 0, _cCollateralToken));\n    }",
        "comments": [
            "",
            "    /// @notice Starts the process to move users position 1 collateral and 1 borrow",
            "    /// @dev User must approve COMPOUND_IMPORT_FLASH_LOAN to pull _cCollateralToken",
            "    /// @param _cCollateralToken Collateral we are moving to DSProxy",
            "    /// @param _cBorrowToken Borrow token we are moving to DSProxy",
            "    "
        ],
        "comt": "\n    /// @notice Starts the process to move users position 1 collateral and 1 borrow\n    /// @dev User must approve COMPOUND_IMPORT_FLASH_LOAN to pull _cCollateralToken\n    /// @param _cCollateralToken Collateral we are moving to DSProxy\n    /// @param _cBorrowToken Borrow token we are moving to DSProxy\n    ",
        "@notice": "Starts the process to move users position 1 collateral and 1 borrow",
        "@dev": "User must approve COMPOUND_IMPORT_FLASH_LOAN to pull _cCollateralToken",
        "@param1": "_cCollateralToken Collateral we are moving to DSProxy",
        "@param2": "_cBorrowToken Borrow token we are moving to DSProxy",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repayWithLoan",
        "visibility": "public",
        "args": [
            {
                "name": "_exData",
                "type": "ExchangeData memory"
            },
            {
                "name": "_cAddresses",
                "type": "address[2] memory"
            },
            {
                "name": "cCollAddress",
                "type": "//"
            },
            {
                "name": "_gasCost",
                "type": "cBorrowAddress\n        uint256"
            }
        ],
        "func": "function repayWithLoan(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost\n    ) public payable burnGas(25) {\n        uint maxColl = getMaxCollateral(_cAddresses[0], address(this));\n        uint availableLiquidity = getAvailableLiquidity(_exData.srcAddr);\n\n        if (_exData.srcAmount <= maxColl || availableLiquidity == 0) {\n            repay(_exData, _cAddresses, _gasCost);\n        } else {\n            // 0x fee\n            COMPOUND_SAVER_FLASH_LOAN.transfer(msg.value);\n\n            uint loanAmount = (_exData.srcAmount - maxColl);\n            if (loanAmount > availableLiquidity) loanAmount = availableLiquidity;\n            bytes memory encoded = packExchangeData(_exData);\n            bytes memory paramsData = abi.encode(encoded, _cAddresses, _gasCost, true, address(this));\n\n            givePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            lendingPool.flashLoan(COMPOUND_SAVER_FLASH_LOAN, getUnderlyingAddr(_cAddresses[0]), loanAmount, paramsData);\n\n            removePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            logger.Log(address(this), msg.sender, \"CompoundFlashRepay\", abi.encode(loanAmount, _exData.srcAmount, _cAddresses[0]));\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Repays the position with it's own fund or with FL if needed",
            "    /// @param _exData Exchange data",
            "    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]",
            "    /// @param _gasCost Gas cost for specific transaction",
            "    "
        ],
        "comt": "\n    /// @notice Repays the position with it's own fund or with FL if needed\n    /// @param _exData Exchange data\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _gasCost Gas cost for specific transaction\n    ",
        "@notice": "Repays the position with it's own fund or with FL if needed",
        "@param1": "_exData Exchange data",
        "@param2": "_cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]",
        "@param3": "_gasCost Gas cost for specific transaction",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "boostWithLoan",
        "visibility": "public",
        "args": [
            {
                "name": "_exData",
                "type": "ExchangeData memory"
            },
            {
                "name": "_cAddresses",
                "type": "address[2] memory"
            },
            {
                "name": "cCollAddress",
                "type": "//"
            },
            {
                "name": "_gasCost",
                "type": "cBorrowAddress\n        uint256"
            }
        ],
        "func": "function boostWithLoan(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost\n    ) public payable burnGas(20) {\n        uint maxBorrow = getMaxBorrow(_cAddresses[1], address(this));\n        uint availableLiquidity = getAvailableLiquidity(_exData.srcAddr);\n\n        if (_exData.srcAmount <= maxBorrow || availableLiquidity == 0) {\n            boost(_exData, _cAddresses, _gasCost);\n        } else {\n            // 0x fee\n            COMPOUND_SAVER_FLASH_LOAN.transfer(msg.value);\n\n            uint loanAmount = (_exData.srcAmount - maxBorrow);\n            if (loanAmount > availableLiquidity) loanAmount = availableLiquidity;\n            bytes memory paramsData = abi.encode(packExchangeData(_exData), _cAddresses, _gasCost, false, address(this));\n\n            givePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            lendingPool.flashLoan(COMPOUND_SAVER_FLASH_LOAN, getUnderlyingAddr(_cAddresses[1]), loanAmount, paramsData);\n\n            removePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            logger.Log(address(this), msg.sender, \"CompoundFlashBoost\", abi.encode(loanAmount, _exData.srcAmount, _cAddresses[1]));\n        }\n\n    }",
        "comments": [
            "",
            "    /// @notice Boosts the position with it's own fund or with FL if needed",
            "    /// @param _exData Exchange data",
            "    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]",
            "    /// @param _gasCost Gas cost for specific transaction",
            "    "
        ],
        "comt": "\n    /// @notice Boosts the position with it's own fund or with FL if needed\n    /// @param _exData Exchange data\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _gasCost Gas cost for specific transaction\n    ",
        "@notice": "Boosts the position with it's own fund or with FL if needed",
        "@param1": "_exData Exchange data",
        "@param2": "_cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]",
        "@param3": "_gasCost Gas cost for specific transaction",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repay",
        "visibility": "public",
        "args": [
            {
                "name": "_exData",
                "type": "ExchangeData memory"
            },
            {
                "name": "_cAddresses",
                "type": "address[2] memory"
            },
            {
                "name": "cCollAddress",
                "type": "//"
            },
            {
                "name": "_gasCost",
                "type": "cBorrowAddress\n        uint256"
            }
        ],
        "func": "function repay(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost\n    ) public payable {\n        enterMarket(_cAddresses[0], _cAddresses[1]);\n\n        address payable user = payable(getUserAddress());\n\n        uint maxColl = getMaxCollateral(_cAddresses[0], address(this));\n\n        uint collAmount = (_exData.srcAmount > maxColl) ? maxColl : _exData.srcAmount;\n\n        require(CTokenInterface(_cAddresses[0]).redeemUnderlying(collAmount) == 0);\n\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\n\n        uint swapAmount = 0;\n\n        if (collToken != borrowToken) {\n            _exData.srcAmount = collAmount;\n\n            (, swapAmount) = _sell(_exData);\n            swapAmount -= getFee(swapAmount, user, _gasCost, _cAddresses[1]);\n        } else {\n            swapAmount = collAmount;\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\n        }\n\n        paybackDebt(swapAmount, _cAddresses[1], borrowToken, user);\n\n        // handle 0x fee\n        tx.origin.transfer(address(this).balance);\n\n        // log amount, collToken, borrowToken\n        logger.Log(address(this), msg.sender, \"CompoundRepay\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\n    }",
        "comments": [
            "",
            "    /// @notice Withdraws collateral, converts to borrowed token and repays debt",
            "    /// @dev Called through the DSProxy",
            "    /// @param _exData Exchange data",
            "    /// @param _cAddresses Coll/Debt addresses [cCollAddress, cBorrowAddress]",
            "    /// @param _gasCost Gas cost for specific transaction",
            "    "
        ],
        "comt": "\n    /// @notice Withdraws collateral, converts to borrowed token and repays debt\n    /// @dev Called through the DSProxy\n    /// @param _exData Exchange data\n    /// @param _cAddresses Coll/Debt addresses [cCollAddress, cBorrowAddress]\n    /// @param _gasCost Gas cost for specific transaction\n    ",
        "@notice": "Withdraws collateral, converts to borrowed token and repays debt",
        "@dev": "Called through the DSProxy",
        "@param1": "_exData Exchange data",
        "@param2": "_cAddresses Coll/Debt addresses [cCollAddress, cBorrowAddress]",
        "@param3": "_gasCost Gas cost for specific transaction",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "boost",
        "visibility": "public",
        "args": [
            {
                "name": "_exData",
                "type": "ExchangeData memory"
            },
            {
                "name": "_cAddresses",
                "type": "address[2] memory"
            },
            {
                "name": "cCollAddress",
                "type": "//"
            },
            {
                "name": "_gasCost",
                "type": "cBorrowAddress\n        uint256"
            }
        ],
        "func": "function boost(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost\n    ) public payable {\n        enterMarket(_cAddresses[0], _cAddresses[1]);\n\n        address payable user = payable(getUserAddress());\n\n        uint maxBorrow = getMaxBorrow(_cAddresses[1], address(this));\n        uint borrowAmount = (_exData.srcAmount > maxBorrow) ? maxBorrow : _exData.srcAmount;\n\n        require(CTokenInterface(_cAddresses[1]).borrow(borrowAmount) == 0);\n\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\n\n        uint swapAmount = 0;\n\n        if (collToken != borrowToken) {\n            borrowAmount -= getFee(borrowAmount, user, _gasCost, _cAddresses[1]);\n\n            _exData.srcAmount = borrowAmount;\n            (,swapAmount) = _sell(_exData);\n        } else {\n            swapAmount = borrowAmount;\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\n        }\n\n        approveCToken(collToken, _cAddresses[0]);\n\n        if (collToken != ETH_ADDRESS) {\n            require(CTokenInterface(_cAddresses[0]).mint(swapAmount) == 0);\n        } else {\n            CEtherInterface(_cAddresses[0]).mint{value: swapAmount}(); // reverts on fail\n        }\n\n        // handle 0x fee\n        tx.origin.transfer(address(this).balance);\n\n        // log amount, collToken, borrowToken\n        logger.Log(address(this), msg.sender, \"CompoundBoost\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\n    }",
        "comments": [
            "",
            "    /// @notice Borrows token, converts to collateral, and adds to position",
            "    /// @dev Called through the DSProxy",
            "    /// @param _exData Exchange data",
            "    /// @param _cAddresses Coll/Debt addresses [cCollAddress, cBorrowAddress]",
            "    /// @param _gasCost Gas cost for specific transaction",
            "    "
        ],
        "comt": "\n    /// @notice Borrows token, converts to collateral, and adds to position\n    /// @dev Called through the DSProxy\n    /// @param _exData Exchange data\n    /// @param _cAddresses Coll/Debt addresses [cCollAddress, cBorrowAddress]\n    /// @param _gasCost Gas cost for specific transaction\n    ",
        "@notice": "Borrows token, converts to collateral, and adds to position",
        "@dev": "Called through the DSProxy",
        "@param1": "_exData Exchange data",
        "@param2": "_cAddresses Coll/Debt addresses [cCollAddress, cBorrowAddress]",
        "@param3": "_gasCost Gas cost for specific transaction",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "executeOperation",
        "visibility": "external",
        "args": [
            {
                "name": "_reserve",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            },
            {
                "name": "_fee",
                "type": "uint256"
            },
            {
                "name": "_params",
                "type": "bytes calldata"
            }
        ],
        "func": "function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n        // Format the call data for DSProxy\n        (bytes memory proxyData, address payable proxyAddr) = packFunctionCall(_amount, _fee, _params);\n\n        // Send Flash loan amount to DSProxy\n        sendLoanToProxy(proxyAddr, _reserve, _amount);\n\n        // Execute the DSProxy call\n        DSProxyInterface(proxyAddr).execute(COMPOUND_SAVER_FLASH_PROXY, proxyData);\n\n        // Repay the loan with the money DSProxy sent back\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Called by Aave when sending back the FL amount",
            "    /// @param _reserve The address of the borrowed token",
            "    /// @param _amount Amount of FL tokens received",
            "    /// @param _fee FL Aave fee",
            "    /// @param _params The params that are sent from the original FL caller contract",
            "   "
        ],
        "comt": "\n    /// @notice Called by Aave when sending back the FL amount\n    /// @param _reserve The address of the borrowed token\n    /// @param _amount Amount of FL tokens received\n    /// @param _fee FL Aave fee\n    /// @param _params The params that are sent from the original FL caller contract\n   ",
        "@notice": "Called by Aave when sending back the FL amount",
        "@param1": "_reserve The address of the borrowed token",
        "@param2": "_amount Amount of FL tokens received",
        "@param3": "_fee FL Aave fee",
        "@param4": "_params The params that are sent from the original FL caller contract",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "flashRepay",
        "visibility": "public",
        "args": [
            {
                "name": "_exData",
                "type": "ExchangeData memory"
            },
            {
                "name": "_cAddresses",
                "type": "address[2] memory"
            },
            {
                "name": "cCollAddress",
                "type": "//"
            },
            {
                "name": "_gasCost",
                "type": "cBorrowAddress\n        uint256"
            },
            {
                "name": "amount",
                "type": "uint[2] memory _flashLoanData //"
            },
            {
                "name": "fee",
                "type": "fee"
            }
        ],
        "func": "function flashRepay(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost,\n        uint[2] memory _flashLoanData // amount, fee\n    ) public payable {\n        enterMarket(_cAddresses[0], _cAddresses[1]);\n\n        address payable user = payable(getUserAddress());\n        uint flashBorrowed = _flashLoanData[0] + _flashLoanData[1];\n\n        uint maxColl = getMaxCollateral(_cAddresses[0], address(this));\n\n        // draw max coll\n        require(CTokenInterface(_cAddresses[0]).redeemUnderlying(maxColl) == 0);\n\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\n\n        uint swapAmount = 0;\n\n        if (collToken != borrowToken) {\n            // swap max coll + loanAmount\n            _exData.srcAmount = maxColl + _flashLoanData[0];\n            (,swapAmount) = _sell(_exData);\n\n            // get fee\n            swapAmount -= getFee(swapAmount, user, _gasCost, _cAddresses[1]);\n        } else {\n            swapAmount = (maxColl + _flashLoanData[0]);\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\n        }\n\n        // payback debt\n        paybackDebt(swapAmount, _cAddresses[1], borrowToken, user);\n\n        // draw collateral for loanAmount + loanFee\n        require(CTokenInterface(_cAddresses[0]).redeemUnderlying(flashBorrowed) == 0);\n\n        // repay flash loan\n        returnFlashLoan(collToken, flashBorrowed);\n\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"CompoundRepay\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\n    }",
        "comments": [
            "",
            "    /// @notice Repays the position and sends tokens back for FL",
            "    /// @param _exData Exchange data",
            "    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress]",
            "    /// @param _gasCost Gas cost for transaction",
            "    /// @param _flashLoanData Data about FL [amount, fee]",
            "    "
        ],
        "comt": "\n    /// @notice Repays the position and sends tokens back for FL\n    /// @param _exData Exchange data\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress]\n    /// @param _gasCost Gas cost for transaction\n    /// @param _flashLoanData Data about FL [amount, fee]\n    ",
        "@notice": "Repays the position and sends tokens back for FL",
        "@param1": "_exData Exchange data",
        "@param2": "_cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress]",
        "@param3": "_gasCost Gas cost for transaction",
        "@param4": "_flashLoanData Data about FL [amount, fee]",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "flashBoost",
        "visibility": "public",
        "args": [
            {
                "name": "_exData",
                "type": "ExchangeData memory"
            },
            {
                "name": "_cAddresses",
                "type": "address[2] memory"
            },
            {
                "name": "cCollAddress",
                "type": "//"
            },
            {
                "name": "_gasCost",
                "type": "cBorrowAddress\n        uint256"
            },
            {
                "name": "amount",
                "type": "uint[2] memory _flashLoanData //"
            },
            {
                "name": "fee",
                "type": "fee"
            }
        ],
        "func": "function flashBoost(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost,\n        uint[2] memory _flashLoanData // amount, fee\n    ) public payable {\n        enterMarket(_cAddresses[0], _cAddresses[1]);\n\n        address payable user = payable(getUserAddress());\n        uint flashBorrowed = _flashLoanData[0] + _flashLoanData[1];\n\n        // borrow max amount\n        uint borrowAmount = getMaxBorrow(_cAddresses[1], address(this));\n        require(CTokenInterface(_cAddresses[1]).borrow(borrowAmount) == 0);\n\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\n\n        uint swapAmount = 0;\n\n        if (collToken != borrowToken) {\n            // get dfs fee\n            borrowAmount -= getFee((borrowAmount + _flashLoanData[0]), user, _gasCost, _cAddresses[1]);\n            _exData.srcAmount = (borrowAmount + _flashLoanData[0]);\n\n            (,swapAmount) = _sell(_exData);\n        } else {\n            swapAmount = (borrowAmount + _flashLoanData[0]);\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\n        }\n\n        // deposit swaped collateral\n        depositCollateral(collToken, _cAddresses[0], swapAmount);\n\n        // borrow token to repay flash loan\n        require(CTokenInterface(_cAddresses[1]).borrow(flashBorrowed) == 0);\n\n        // repay flash loan\n        returnFlashLoan(borrowToken, flashBorrowed);\n\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"CompoundBoost\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\n    }",
        "comments": [
            "",
            "    /// @notice Boosts the position and sends tokens back for FL",
            "    /// @param _exData Exchange data",
            "    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress]",
            "    /// @param _gasCost Gas cost for specific transaction",
            "    /// @param _flashLoanData Data about FL [amount, fee]",
            "    "
        ],
        "comt": "\n    /// @notice Boosts the position and sends tokens back for FL\n    /// @param _exData Exchange data\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress]\n    /// @param _gasCost Gas cost for specific transaction\n    /// @param _flashLoanData Data about FL [amount, fee]\n    ",
        "@notice": "Boosts the position and sends tokens back for FL",
        "@param1": "_exData Exchange data",
        "@param2": "_cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress]",
        "@param3": "_gasCost Gas cost for specific transaction",
        "@param4": "_flashLoanData Data about FL [amount, fee]",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "deposit",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_cTokenAddr",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            },
            {
                "name": "_inMarket",
                "type": "bool"
            }
        ],
        "func": "function deposit(address _tokenAddr, address _cTokenAddr, uint _amount, bool _inMarket) public burnGas(5) payable {\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), _amount);\n        }\n\n        approveToken(_tokenAddr, _cTokenAddr);\n\n        if (!_inMarket) {\n            enterMarket(_cTokenAddr);\n        }\n\n        if (_tokenAddr != ETH_ADDR) {\n            require(CTokenInterface(_cTokenAddr).mint(_amount) == 0);\n        } else {\n            CEtherInterface(_cTokenAddr).mint{value: msg.value}(); // reverts on fail\n        }\n    }",
        "comments": [
            "",
            "    /// @notice User deposits tokens to the cream protocol",
            "    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens",
            "    /// @param _tokenAddr The address of the token to be deposited",
            "    /// @param _cTokenAddr CTokens to be deposited",
            "    /// @param _amount Amount of tokens to be deposited",
            "    /// @param _inMarket True if the token is already in market for that address",
            "    "
        ],
        "comt": "\n    /// @notice User deposits tokens to the cream protocol\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\n    /// @param _tokenAddr The address of the token to be deposited\n    /// @param _cTokenAddr CTokens to be deposited\n    /// @param _amount Amount of tokens to be deposited\n    /// @param _inMarket True if the token is already in market for that address\n    ",
        "@notice": "User deposits tokens to the cream protocol",
        "@dev": "User needs to approve the DSProxy to pull the _tokenAddr tokens",
        "@param1": "_tokenAddr The address of the token to be deposited",
        "@param2": "_cTokenAddr CTokens to be deposited",
        "@param3": "_amount Amount of tokens to be deposited",
        "@param4": "_inMarket True if the token is already in market for that address",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_cTokenAddr",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            },
            {
                "name": "_isCAmount",
                "type": "bool"
            }
        ],
        "func": "function withdraw(address _tokenAddr, address _cTokenAddr, uint _amount, bool _isCAmount) public burnGas(5) {\n\n        if (_isCAmount) {\n            require(CTokenInterface(_cTokenAddr).redeem(_amount) == 0);\n        } else {\n            require(CTokenInterface(_cTokenAddr).redeemUnderlying(_amount) == 0);\n        }\n\n        // withdraw funds to msg.sender\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransfer(msg.sender, ERC20(_tokenAddr).balanceOf(address(this)));\n        } else {\n            msg.sender.transfer(address(this).balance);\n        }\n\n    }",
        "comments": [
            "",
            "    /// @notice User withdraws tokens to the cream protocol",
            "    /// @param _tokenAddr The address of the token to be withdrawn",
            "    /// @param _cTokenAddr CTokens to be withdrawn",
            "    /// @param _amount Amount of tokens to be withdrawn",
            "    /// @param _isCAmount If true _amount is cTokens if falls _amount is underlying tokens",
            "    "
        ],
        "comt": "\n    /// @notice User withdraws tokens to the cream protocol\n    /// @param _tokenAddr The address of the token to be withdrawn\n    /// @param _cTokenAddr CTokens to be withdrawn\n    /// @param _amount Amount of tokens to be withdrawn\n    /// @param _isCAmount If true _amount is cTokens if falls _amount is underlying tokens\n    ",
        "@notice": "User withdraws tokens to the cream protocol",
        "@param1": "_tokenAddr The address of the token to be withdrawn",
        "@param2": "_cTokenAddr CTokens to be withdrawn",
        "@param3": "_amount Amount of tokens to be withdrawn",
        "@param4": "_isCAmount If true _amount is cTokens if falls _amount is underlying tokens",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "borrow",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_cTokenAddr",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            },
            {
                "name": "_inMarket",
                "type": "bool"
            }
        ],
        "func": "function borrow(address _tokenAddr, address _cTokenAddr, uint _amount, bool _inMarket) public burnGas(8) {\n        if (!_inMarket) {\n            enterMarket(_cTokenAddr);\n        }\n\n        require(CTokenInterface(_cTokenAddr).borrow(_amount) == 0);\n\n        // withdraw funds to msg.sender\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransfer(msg.sender, ERC20(_tokenAddr).balanceOf(address(this)));\n        } else {\n            msg.sender.transfer(address(this).balance);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice User borrows tokens to the cream protocol",
            "    /// @param _tokenAddr The address of the token to be borrowed",
            "    /// @param _cTokenAddr CTokens to be borrowed",
            "    /// @param _amount Amount of tokens to be borrowed",
            "    /// @param _inMarket True if the token is already in market for that address",
            "    "
        ],
        "comt": "\n    /// @notice User borrows tokens to the cream protocol\n    /// @param _tokenAddr The address of the token to be borrowed\n    /// @param _cTokenAddr CTokens to be borrowed\n    /// @param _amount Amount of tokens to be borrowed\n    /// @param _inMarket True if the token is already in market for that address\n    ",
        "@notice": "User borrows tokens to the cream protocol",
        "@param1": "_tokenAddr The address of the token to be borrowed",
        "@param2": "_cTokenAddr CTokens to be borrowed",
        "@param3": "_amount Amount of tokens to be borrowed",
        "@param4": "_inMarket True if the token is already in market for that address",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "payback",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_cTokenAddr",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            },
            {
                "name": "_wholeDebt",
                "type": "bool"
            }
        ],
        "func": "function payback(address _tokenAddr, address _cTokenAddr, uint _amount, bool _wholeDebt) public burnGas(5) payable {\n        approveToken(_tokenAddr, _cTokenAddr);\n\n        if (_wholeDebt) {\n            _amount = CTokenInterface(_cTokenAddr).borrowBalanceCurrent(address(this));\n        }\n\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), _amount);\n\n            require(CTokenInterface(_cTokenAddr).repayBorrow(_amount) == 0);\n        } else {\n            CEtherInterface(_cTokenAddr).repayBorrow{value: msg.value}();\n            msg.sender.transfer(address(this).balance); // send back the extra eth\n        }\n    }",
        "comments": [
            "",
            "    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens",
            "    /// @notice User paybacks tokens to the cream protocol",
            "    /// @param _tokenAddr The address of the token to be paybacked",
            "    /// @param _cTokenAddr CTokens to be paybacked",
            "    /// @param _amount Amount of tokens to be payedback",
            "    /// @param _wholeDebt If true the _amount will be set to the whole amount of the debt",
            "    "
        ],
        "comt": "\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\n    /// @notice User paybacks tokens to the cream protocol\n    /// @param _tokenAddr The address of the token to be paybacked\n    /// @param _cTokenAddr CTokens to be paybacked\n    /// @param _amount Amount of tokens to be payedback\n    /// @param _wholeDebt If true the _amount will be set to the whole amount of the debt\n    ",
        "@dev": "User needs to approve the DSProxy to pull the _tokenAddr tokens",
        "@notice": "User paybacks tokens to the cream protocol",
        "@param1": "_tokenAddr The address of the token to be paybacked",
        "@param2": "_cTokenAddr CTokens to be paybacked",
        "@param3": "_amount Amount of tokens to be payedback",
        "@param4": "_wholeDebt If true the _amount will be set to the whole amount of the debt",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawTokens",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            }
        ],
        "func": "function withdrawTokens(address _tokenAddr) public {\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransfer(msg.sender, ERC20(_tokenAddr).balanceOf(address(this)));\n        } else {\n            msg.sender.transfer(address(this).balance);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Helper method to withdraw tokens from the DSProxy",
            "    /// @param _tokenAddr Address of the token to be withdrawn",
            "    "
        ],
        "comt": "\n    /// @notice Helper method to withdraw tokens from the DSProxy\n    /// @param _tokenAddr Address of the token to be withdrawn\n    ",
        "@notice": "Helper method to withdraw tokens from the DSProxy",
        "@param1": "_tokenAddr Address of the token to be withdrawn",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "enterMarket",
        "visibility": "public",
        "args": [
            {
                "name": "_cTokenAddr",
                "type": "address"
            }
        ],
        "func": "function enterMarket(address _cTokenAddr) public {\n        address[] memory markets = new address[](1);\n        markets[0] = _cTokenAddr;\n\n        ComptrollerInterface(COMPTROLLER_ADDR).enterMarkets(markets);\n    }",
        "comments": [
            "",
            "    /// @notice Enters the cream market so it can be deposited/borrowed",
            "    /// @param _cTokenAddr CToken address of the token",
            "    "
        ],
        "comt": "\n    /// @notice Enters the cream market so it can be deposited/borrowed\n    /// @param _cTokenAddr CToken address of the token\n    ",
        "@notice": "Enters the cream market so it can be deposited/borrowed",
        "@param1": "_cTokenAddr CToken address of the token",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "exitMarket",
        "visibility": "public",
        "args": [
            {
                "name": "_cTokenAddr",
                "type": "address"
            }
        ],
        "func": "function exitMarket(address _cTokenAddr) public {\n        ComptrollerInterface(COMPTROLLER_ADDR).exitMarket(_cTokenAddr);\n    }",
        "comments": [
            "",
            "    /// @notice Exits the cream market so it can't be deposited/borrowed",
            "    /// @param _cTokenAddr CToken address of the token",
            "    "
        ],
        "comt": "\n    /// @notice Exits the cream market so it can't be deposited/borrowed\n    /// @param _cTokenAddr CToken address of the token\n    ",
        "@notice": "Exits the cream market so it can't be deposited/borrowed",
        "@param1": "_cTokenAddr CToken address of the token",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getRatio",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function getRatio(address _user) public view returns (uint) {\n        // For each asset the account is in\n        return getSafetyRatio(_user);\n    }",
        "comments": [
            "",
            "",
            "    /// @notice Calcualted the ratio of coll/debt for a cream user",
            "    /// @param _user Address of the user",
            "    "
        ],
        "comt": "\n\n    /// @notice Calcualted the ratio of coll/debt for a cream user\n    /// @param _user Address of the user\n    ",
        "@notice": "Calcualted the ratio of coll/debt for a cream user",
        "@param1": "_user Address of the user",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPrices",
        "visibility": "public",
        "args": [
            {
                "name": "_cTokens",
                "type": "address[] memory"
            }
        ],
        "func": "function getPrices(address[] memory _cTokens) public view returns (uint[] memory prices) {\n        prices = new uint[](_cTokens.length);\n        address oracleAddr = comp.oracle();\n\n        for (uint i = 0; i < _cTokens.length; ++i) {\n            prices[i] = CompoundOracleInterface(oracleAddr).getUnderlyingPrice(_cTokens[i]);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Fetches cream prices for tokens",
            "    /// @param _cTokens Arr. of cTokens for which to get the prices",
            "    /// @return prices Array of prices",
            "    "
        ],
        "comt": "\n    /// @notice Fetches cream prices for tokens\n    /// @param _cTokens Arr. of cTokens for which to get the prices\n    /// @return prices Array of prices\n    ",
        "@notice": "Fetches cream prices for tokens",
        "@param1": "_cTokens Arr. of cTokens for which to get the prices",
        "@return1": "prices Array of prices",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCollFactors",
        "visibility": "public",
        "args": [
            {
                "name": "_cTokens",
                "type": "address[] memory"
            }
        ],
        "func": "function getCollFactors(address[] memory _cTokens) public view returns (uint[] memory collFactors) {\n        collFactors = new uint[](_cTokens.length);\n\n        for (uint i = 0; i < _cTokens.length; ++i) {\n            (, collFactors[i]) = comp.markets(_cTokens[i]);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Fetches cream collateral factors for tokens",
            "    /// @param _cTokens Arr. of cTokens for which to get the coll. factors",
            "    /// @return collFactors Array of coll. factors",
            "    "
        ],
        "comt": "\n    /// @notice Fetches cream collateral factors for tokens\n    /// @param _cTokens Arr. of cTokens for which to get the coll. factors\n    /// @return collFactors Array of coll. factors\n    ",
        "@notice": "Fetches cream collateral factors for tokens",
        "@param1": "_cTokens Arr. of cTokens for which to get the coll. factors",
        "@return1": "collFactors Array of coll. factors",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getLoanData",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function getLoanData(address _user) public view returns (LoanData memory data) {\n        address[] memory assets = comp.getAssetsIn(_user);\n        address oracleAddr = comp.oracle();\n\n        data = LoanData({\n            user: _user,\n            ratio: 0,\n            collAddr: new address[](assets.length),\n            borrowAddr: new address[](assets.length),\n            collAmounts: new uint[](assets.length),\n            borrowAmounts: new uint[](assets.length)\n        });\n\n        uint collPos = 0;\n        uint borrowPos = 0;\n\n        for (uint i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n\n            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\n                                        = CTokenInterface(asset).getAccountSnapshot(_user);\n\n            Exp memory oraclePrice;\n\n            if (cTokenBalance != 0 || borrowBalance != 0) {\n                oraclePrice = Exp({mantissa: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(asset)});\n            }\n\n            // Sum up collateral in eth\n            if (cTokenBalance != 0) {\n                Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\n                (, Exp memory tokensToEth) = mulExp(exchangeRate, oraclePrice);\n\n                data.collAddr[collPos] = asset;\n                (, data.collAmounts[collPos]) = mulScalarTruncate(tokensToEth, cTokenBalance);\n                collPos++;\n            }\n\n            // Sum up debt in eth\n            if (borrowBalance != 0) {\n                data.borrowAddr[borrowPos] = asset;\n                (, data.borrowAmounts[borrowPos]) = mulScalarTruncate(oraclePrice, borrowBalance);\n                borrowPos++;\n            }\n        }\n\n        data.ratio = uint128(getSafetyRatio(_user));\n\n        return data;\n    }",
        "comments": [
            "",
            "    /// @notice Fetches all the collateral/debt address and amounts, denominated in eth",
            "    /// @param _user Address of the user",
            "    /// @return data LoanData information",
            "    "
        ],
        "comt": "\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in eth\n    /// @param _user Address of the user\n    /// @return data LoanData information\n    ",
        "@notice": "Fetches all the collateral/debt address and amounts, denominated in eth",
        "@param1": "_user Address of the user",
        "@return1": "data LoanData information",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getTokenBalances",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            },
            {
                "name": "_cTokens",
                "type": "address[] memory"
            }
        ],
        "func": "function getTokenBalances(address _user, address[] memory _cTokens) public view returns (uint[] memory balances, uint[] memory borrows) {\n        balances = new uint[](_cTokens.length);\n        borrows = new uint[](_cTokens.length);\n\n        for (uint i = 0; i < _cTokens.length; i++) {\n            address asset = _cTokens[i];\n\n            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\n                                        = CTokenInterface(asset).getAccountSnapshot(_user);\n\n            Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\n            (, balances[i]) = mulScalarTruncate(exchangeRate, cTokenBalance);\n\n            borrows[i] = borrowBalance;\n        }\n\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getLoanDataArr",
        "visibility": "public",
        "args": [
            {
                "name": "_users",
                "type": "address[] memory"
            }
        ],
        "func": "function getLoanDataArr(address[] memory _users) public view returns (LoanData[] memory loans) {\n        loans = new LoanData[](_users.length);\n\n        for (uint i = 0; i < _users.length; ++i) {\n            loans[i] = getLoanData(_users[i]);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Fetches all the collateral/debt address and amounts, denominated in eth",
            "    /// @param _users Addresses of the user",
            "    /// @return loans Array of LoanData information",
            "    "
        ],
        "comt": "\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in eth\n    /// @param _users Addresses of the user\n    /// @return loans Array of LoanData information\n    ",
        "@notice": "Fetches all the collateral/debt address and amounts, denominated in eth",
        "@param1": "_users Addresses of the user",
        "@return1": "loans Array of LoanData information",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getRatios",
        "visibility": "public",
        "args": [
            {
                "name": "_users",
                "type": "address[] memory"
            }
        ],
        "func": "function getRatios(address[] memory _users) public view returns (uint[] memory ratios) {\n        ratios = new uint[](_users.length);\n\n        for (uint i = 0; i < _users.length; ++i) {\n            ratios[i] = getSafetyRatio(_users[i]);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Calcualted the ratio of coll/debt for a cream user",
            "    /// @param _users Addresses of the user",
            "    /// @return ratios Array of ratios",
            "    "
        ],
        "comt": "\n    /// @notice Calcualted the ratio of coll/debt for a cream user\n    /// @param _users Addresses of the user\n    /// @return ratios Array of ratios\n    ",
        "@notice": "Calcualted the ratio of coll/debt for a cream user",
        "@param1": "_users Addresses of the user",
        "@return1": "ratios Array of ratios",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getTokensInfo",
        "visibility": "public",
        "args": [
            {
                "name": "_cTokenAddresses",
                "type": "address[] memory"
            }
        ],
        "func": "function getTokensInfo(address[] memory _cTokenAddresses) public returns(TokenInfo[] memory tokens) {\n        tokens = new TokenInfo[](_cTokenAddresses.length);\n        address oracleAddr = comp.oracle();\n\n        for (uint i = 0; i < _cTokenAddresses.length; ++i) {\n            (, uint collFactor) = comp.markets(_cTokenAddresses[i]);\n\n            tokens[i] = TokenInfo({\n                cTokenAddress: _cTokenAddresses[i],\n                underlyingTokenAddress: getUnderlyingAddr(_cTokenAddresses[i]),\n                collateralFactor: collFactor,\n                price: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(_cTokenAddresses[i])\n            });\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Information about cTokens",
            "    /// @param _cTokenAddresses Array of cTokens addresses",
            "    /// @return tokens Array of cTokens infomartion",
            "    "
        ],
        "comt": "\n    /// @notice Information about cTokens\n    /// @param _cTokenAddresses Array of cTokens addresses\n    /// @return tokens Array of cTokens infomartion\n    ",
        "@notice": "Information about cTokens",
        "@param1": "_cTokenAddresses Array of cTokens addresses",
        "@return1": "tokens Array of cTokens infomartion",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getFullTokensInfo",
        "visibility": "public",
        "args": [
            {
                "name": "_cTokenAddresses",
                "type": "address[] memory"
            }
        ],
        "func": "function getFullTokensInfo(address[] memory _cTokenAddresses) public returns(TokenInfoFull[] memory tokens) {\n        tokens = new TokenInfoFull[](_cTokenAddresses.length);\n        address oracleAddr = comp.oracle();\n\n        for (uint i = 0; i < _cTokenAddresses.length; ++i) {\n            (, uint collFactor) = comp.markets(_cTokenAddresses[i]);\n            CTokenInterface cToken = CTokenInterface(_cTokenAddresses[i]);\n\n            tokens[i] = TokenInfoFull({\n                underlyingTokenAddress: getUnderlyingAddr(_cTokenAddresses[i]),\n                supplyRate: cToken.supplyRatePerBlock(),\n                borrowRate: cToken.borrowRatePerBlock(),\n                exchangeRate: cToken.exchangeRateCurrent(),\n                marketLiquidity: cToken.getCash(),\n                totalSupply: cToken.totalSupply(),\n                totalBorrow: cToken.totalBorrowsCurrent(),\n                collateralFactor: collFactor,\n                price: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(_cTokenAddresses[i])\n            });\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Information about cTokens",
            "    /// @param _cTokenAddresses Array of cTokens addresses",
            "    /// @return tokens Array of cTokens infomartion",
            "    "
        ],
        "comt": "\n    /// @notice Information about cTokens\n    /// @param _cTokenAddresses Array of cTokens addresses\n    /// @return tokens Array of cTokens infomartion\n    ",
        "@notice": "Information about cTokens",
        "@param1": "_cTokenAddresses Array of cTokens addresses",
        "@return1": "tokens Array of cTokens infomartion",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getSafetyRatio",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function getSafetyRatio(address _user) public view returns (uint) {\n        // For each asset the account is in\n        address[] memory assets = comp.getAssetsIn(_user);\n        address oracleAddr = comp.oracle();\n\n\n        uint sumCollateral = 0;\n        uint sumBorrow = 0;\n\n        for (uint i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n\n            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\n                                        = CTokenInterface(asset).getAccountSnapshot(_user);\n\n            Exp memory oraclePrice;\n\n            if (cTokenBalance != 0 || borrowBalance != 0) {\n                oraclePrice = Exp({mantissa: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(asset)});\n            }\n\n            // Sum up collateral in Eth\n            if (cTokenBalance != 0) {\n\n                (, uint collFactorMantissa) = comp.markets(address(asset));\n\n                Exp memory collateralFactor = Exp({mantissa: collFactorMantissa});\n                Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\n\n                (, Exp memory tokensToEther) = mulExp3(collateralFactor, exchangeRate, oraclePrice);\n\n                (, sumCollateral) = mulScalarTruncateAddUInt(tokensToEther, cTokenBalance, sumCollateral);\n            }\n\n            // Sum up debt in Eth\n            if (borrowBalance != 0) {\n                (, sumBorrow) = mulScalarTruncateAddUInt(oraclePrice, borrowBalance, sumBorrow);\n            }\n        }\n\n        if (sumBorrow == 0) return uint(-1);\n\n        uint borrowPowerUsed = (sumBorrow * 10**18) / sumCollateral;\n        return wdiv(1e18, borrowPowerUsed);\n    }",
        "comments": [
            "",
            "    /// @notice Calcualted the ratio of debt / adjusted collateral",
            "    /// @param _user Address of the user",
            "    "
        ],
        "comt": "\n    /// @notice Calcualted the ratio of debt / adjusted collateral\n    /// @param _user Address of the user\n    ",
        "@notice": "Calcualted the ratio of debt / adjusted collateral",
        "@param1": "_user Address of the user",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMaxCollateral",
        "visibility": "public",
        "args": [
            {
                "name": "_cCollAddress",
                "type": "address"
            },
            {
                "name": "_account",
                "type": "address"
            }
        ],
        "func": "function getMaxCollateral(address _cCollAddress, address _account) public returns (uint) {\n        (, uint liquidityInEth, ) = ComptrollerInterface(COMPTROLLER).getAccountLiquidity(_account);\n        uint usersBalance = CTokenInterface(_cCollAddress).balanceOfUnderlying(_account);\n        address oracle = ComptrollerInterface(COMPTROLLER).oracle();\n\n        if (liquidityInEth == 0) return usersBalance;\n\n        CTokenInterface(_cCollAddress).accrueInterest();\n\n         if (_cCollAddress == CETH_ADDRESS) {\n             if (liquidityInEth > usersBalance) return usersBalance;\n\n             return sub(liquidityInEth, (liquidityInEth / 100));\n         }\n\n        uint ethPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(_cCollAddress);\n        uint liquidityInToken = wdiv(liquidityInEth, ethPrice);\n\n        if (liquidityInToken > usersBalance) return usersBalance;\n\n        return sub(liquidityInToken, (liquidityInToken / 100)); // cut off 1% due to rounding issues\n    }",
        "comments": [
            "",
            "    /// @notice Returns the maximum amount of collateral available to withdraw",
            "    /// @dev Due to rounding errors the result is - 1% wei from the exact amount",
            "    /// @param _cCollAddress Collateral we are getting the max value of",
            "    /// @param _account Users account",
            "    /// @return Returns the max. collateral amount in that token",
            "    "
        ],
        "comt": "\n    /// @notice Returns the maximum amount of collateral available to withdraw\n    /// @dev Due to rounding errors the result is - 1% wei from the exact amount\n    /// @param _cCollAddress Collateral we are getting the max value of\n    /// @param _account Users account\n    /// @return Returns the max. collateral amount in that token\n    ",
        "@notice": "Returns the maximum amount of collateral available to withdraw",
        "@dev": "Due to rounding errors the result is - 1% wei from the exact amount",
        "@param1": "_cCollAddress Collateral we are getting the max value of",
        "@param2": "_account Users account",
        "@return1": "Returns the max. collateral amount in that token",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMaxBorrow",
        "visibility": "public",
        "args": [
            {
                "name": "_cBorrowAddress",
                "type": "address"
            },
            {
                "name": "_account",
                "type": "address"
            }
        ],
        "func": "function getMaxBorrow(address _cBorrowAddress, address _account) public returns (uint) {\n        (, uint liquidityInEth, ) = ComptrollerInterface(COMPTROLLER).getAccountLiquidity(_account);\n        address oracle = ComptrollerInterface(COMPTROLLER).oracle();\n\n        CTokenInterface(_cBorrowAddress).accrueInterest();\n\n        if (_cBorrowAddress == CETH_ADDRESS) return sub(liquidityInEth, (liquidityInEth / 100));\n\n        uint ethPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(_cBorrowAddress);\n        uint liquidityInToken = wdiv(liquidityInEth, ethPrice);\n\n        return sub(liquidityInToken, (liquidityInToken / 100)); // cut off 1% due to rounding issues\n    }",
        "comments": [
            "",
            "    /// @notice Returns the maximum amount of borrow amount available",
            "    /// @dev Due to rounding errors the result is - 1% wei from the exact amount",
            "    /// @param _cBorrowAddress Borrow token we are getting the max value of",
            "    /// @param _account Users account",
            "    /// @return Returns the max. borrow amount in that token",
            "    "
        ],
        "comt": "\n    /// @notice Returns the maximum amount of borrow amount available\n    /// @dev Due to rounding errors the result is - 1% wei from the exact amount\n    /// @param _cBorrowAddress Borrow token we are getting the max value of\n    /// @param _account Users account\n    /// @return Returns the max. borrow amount in that token\n    ",
        "@notice": "Returns the maximum amount of borrow amount available",
        "@dev": "Due to rounding errors the result is - 1% wei from the exact amount",
        "@param1": "_cBorrowAddress Borrow token we are getting the max value of",
        "@param2": "_account Users account",
        "@return1": "Returns the max. borrow amount in that token",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "borrow",
        "visibility": "public",
        "args": [
            {
                "name": "_cCollToken",
                "type": "address"
            },
            {
                "name": "_cBorrowToken",
                "type": "address"
            },
            {
                "name": "_borrowToken",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            }
        ],
        "func": "function borrow(address _cCollToken, address _cBorrowToken, address _borrowToken, uint _amount) public {\n        address[] memory markets = new address[](2);\n        markets[0] = _cCollToken;\n        markets[1] = _cBorrowToken;\n\n        ComptrollerInterface(COMPTROLLER_ADDR).enterMarkets(markets);\n\n        require(CTokenInterface(_cBorrowToken).borrow(_amount) == 0);\n\n        // withdraw funds to msg.sender\n        if (_borrowToken != ETH_ADDR) {\n            ERC20(_borrowToken).safeTransfer(msg.sender, ERC20(_borrowToken).balanceOf(address(this)));\n        } else {\n            msg.sender.transfer(address(this).balance);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "executeOperation",
        "visibility": "external",
        "args": [
            {
                "name": "_reserve",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            },
            {
                "name": "_fee",
                "type": "uint256"
            },
            {
                "name": "_params",
                "type": "bytes calldata"
            }
        ],
        "func": "function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n\n        (\n            address cCollateralToken,\n            address cBorrowToken,\n            address user,\n            address proxy\n        )\n        = abi.decode(_params, (address,address,address,address));\n\n        // approve FL tokens so we can repay them\n        ERC20(_reserve).safeApprove(cBorrowToken, 0);\n        ERC20(_reserve).safeApprove(cBorrowToken, uint(-1));\n\n        // repay cream debt\n        require(CTokenInterface(cBorrowToken).repayBorrowBehalf(user, uint(-1)) == 0, \"Repay borrow behalf fail\");\n\n        // transfer cTokens to proxy\n        uint cTokenBalance = CTokenInterface(cCollateralToken).balanceOf(user);\n        require(CTokenInterface(cCollateralToken).transferFrom(user, proxy, cTokenBalance));\n\n        // borrow\n        bytes memory proxyData = getProxyData(cCollateralToken, cBorrowToken, _reserve, (_amount + _fee));\n        DSProxyInterface(proxy).execute(CREAM_BORROW_PROXY, proxyData);\n\n        // Repay the loan with the money DSProxy sent back\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n    }",
        "comments": [
            "",
            "    /// @notice Called by Aave when sending back the FL amount",
            "    /// @param _reserve The address of the borrowed token",
            "    /// @param _amount Amount of FL tokens received",
            "    /// @param _fee FL Aave fee",
            "    /// @param _params The params that are sent from the original FL caller contract",
            "    "
        ],
        "comt": "\n    /// @notice Called by Aave when sending back the FL amount\n    /// @param _reserve The address of the borrowed token\n    /// @param _amount Amount of FL tokens received\n    /// @param _fee FL Aave fee\n    /// @param _params The params that are sent from the original FL caller contract\n    ",
        "@notice": "Called by Aave when sending back the FL amount",
        "@param1": "_reserve The address of the borrowed token",
        "@param2": "_amount Amount of FL tokens received",
        "@param3": "_fee FL Aave fee",
        "@param4": "_params The params that are sent from the original FL caller contract",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawStuckFunds",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            }
        ],
        "func": "function withdrawStuckFunds(address _tokenAddr, uint _amount) public {\n        require(owner == msg.sender, \"Must be owner\");\n\n        if (_tokenAddr == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n            msg.sender.transfer(_amount);\n        } else {\n            ERC20(_tokenAddr).safeTransfer(owner, _amount);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "importLoan",
        "visibility": "external",
        "args": [
            {
                "name": "_cCollateralToken",
                "type": "address"
            },
            {
                "name": "_cBorrowToken",
                "type": "address"
            }
        ],
        "func": "function importLoan(address _cCollateralToken, address _cBorrowToken) external burnGas(20) {\n        address proxy = getProxy();\n\n        uint loanAmount = CTokenInterface(_cBorrowToken).borrowBalanceCurrent(msg.sender);\n        bytes memory paramsData = abi.encode(_cCollateralToken, _cBorrowToken, msg.sender, proxy);\n\n        givePermission(CREAM_IMPORT_FLASH_LOAN);\n\n        lendingPool.flashLoan(CREAM_IMPORT_FLASH_LOAN, getUnderlyingAddr(_cBorrowToken), loanAmount, paramsData);\n\n        removePermission(CREAM_IMPORT_FLASH_LOAN);\n\n        logger.Log(address(this), msg.sender, \"CreamImport\", abi.encode(loanAmount, 0, _cCollateralToken));\n    }",
        "comments": [
            "",
            "    /// @notice Starts the process to move users position 1 collateral and 1 borrow",
            "    /// @dev User must approve cream_IMPORT_FLASH_LOAN to pull _cCollateralToken",
            "    /// @param _cCollateralToken Collateral we are moving to DSProxy",
            "    /// @param _cBorrowToken Borrow token we are moving to DSProxy",
            "    "
        ],
        "comt": "\n    /// @notice Starts the process to move users position 1 collateral and 1 borrow\n    /// @dev User must approve cream_IMPORT_FLASH_LOAN to pull _cCollateralToken\n    /// @param _cCollateralToken Collateral we are moving to DSProxy\n    /// @param _cBorrowToken Borrow token we are moving to DSProxy\n    ",
        "@notice": "Starts the process to move users position 1 collateral and 1 borrow",
        "@dev": "User must approve cream_IMPORT_FLASH_LOAN to pull _cCollateralToken",
        "@param1": "_cCollateralToken Collateral we are moving to DSProxy",
        "@param2": "_cBorrowToken Borrow token we are moving to DSProxy",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repayWithLoan",
        "visibility": "public",
        "args": [
            {
                "name": "_exData",
                "type": "ExchangeData memory"
            },
            {
                "name": "_cAddresses",
                "type": "address[2] memory"
            },
            {
                "name": "cCollAddress",
                "type": "//"
            },
            {
                "name": "_gasCost",
                "type": "cBorrowAddress\n        uint256"
            }
        ],
        "func": "function repayWithLoan(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost\n    ) public payable burnGas(25) {\n        uint maxColl = getMaxCollateral(_cAddresses[0], address(this));\n        uint availableLiquidity = getAvailableLiquidity(_exData.srcAddr);\n\n        if (_exData.srcAmount <= maxColl || availableLiquidity == 0) {\n            repay(_exData, _cAddresses, _gasCost);\n        } else {\n            // 0x fee\n            COMPOUND_SAVER_FLASH_LOAN.transfer(msg.value);\n\n            uint loanAmount = (_exData.srcAmount - maxColl);\n            bytes memory encoded = packExchangeData(_exData);\n            bytes memory paramsData = abi.encode(encoded, _cAddresses, _gasCost, true, address(this));\n\n            givePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            lendingPool.flashLoan(COMPOUND_SAVER_FLASH_LOAN, getUnderlyingAddr(_cAddresses[0]), loanAmount, paramsData);\n\n            removePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            logger.Log(address(this), msg.sender, \"CreamFlashRepay\", abi.encode(loanAmount, _exData.srcAmount, _cAddresses[0]));\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Repays the position with it's own fund or with FL if needed",
            "    /// @param _exData Exchange data",
            "    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]",
            "    /// @param _gasCost Gas cost for specific transaction",
            "    "
        ],
        "comt": "\n    /// @notice Repays the position with it's own fund or with FL if needed\n    /// @param _exData Exchange data\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _gasCost Gas cost for specific transaction\n    ",
        "@notice": "Repays the position with it's own fund or with FL if needed",
        "@param1": "_exData Exchange data",
        "@param2": "_cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]",
        "@param3": "_gasCost Gas cost for specific transaction",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "boostWithLoan",
        "visibility": "public",
        "args": [
            {
                "name": "_exData",
                "type": "ExchangeData memory"
            },
            {
                "name": "_cAddresses",
                "type": "address[2] memory"
            },
            {
                "name": "cCollAddress",
                "type": "//"
            },
            {
                "name": "_gasCost",
                "type": "cBorrowAddress\n        uint256"
            }
        ],
        "func": "function boostWithLoan(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost\n    ) public payable burnGas(20) {\n        uint maxBorrow = getMaxBorrow(_cAddresses[1], address(this));\n        uint availableLiquidity = getAvailableLiquidity(_exData.srcAddr);\n\n        if (_exData.srcAmount <= maxBorrow || availableLiquidity == 0) {\n            boost(_exData, _cAddresses, _gasCost);\n        } else {\n            // 0x fee\n            COMPOUND_SAVER_FLASH_LOAN.transfer(msg.value);\n\n            uint loanAmount = (_exData.srcAmount - maxBorrow);\n            bytes memory paramsData = abi.encode(packExchangeData(_exData), _cAddresses, _gasCost, false, address(this));\n\n            givePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            lendingPool.flashLoan(COMPOUND_SAVER_FLASH_LOAN, getUnderlyingAddr(_cAddresses[1]), loanAmount, paramsData);\n\n            removePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            logger.Log(address(this), msg.sender, \"CreamFlashBoost\", abi.encode(loanAmount, _exData.srcAmount, _cAddresses[1]));\n        }\n\n    }",
        "comments": [
            "",
            "    /// @notice Boosts the position with it's own fund or with FL if needed",
            "    /// @param _exData Exchange data",
            "    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]",
            "    /// @param _gasCost Gas cost for specific transaction",
            "    "
        ],
        "comt": "\n    /// @notice Boosts the position with it's own fund or with FL if needed\n    /// @param _exData Exchange data\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _gasCost Gas cost for specific transaction\n    ",
        "@notice": "Boosts the position with it's own fund or with FL if needed",
        "@param1": "_exData Exchange data",
        "@param2": "_cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]",
        "@param3": "_gasCost Gas cost for specific transaction",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repay",
        "visibility": "public",
        "args": [
            {
                "name": "_exData",
                "type": "ExchangeData memory"
            },
            {
                "name": "_cAddresses",
                "type": "address[2] memory"
            },
            {
                "name": "cCollAddress",
                "type": "//"
            },
            {
                "name": "_gasCost",
                "type": "cBorrowAddress\n        uint256"
            }
        ],
        "func": "function repay(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost\n    ) public payable {\n        enterMarket(_cAddresses[0], _cAddresses[1]);\n\n        address payable user = payable(getUserAddress());\n\n        uint maxColl = getMaxCollateral(_cAddresses[0], address(this));\n\n        uint collAmount = (_exData.srcAmount > maxColl) ? maxColl : _exData.srcAmount;\n\n        require(CTokenInterface(_cAddresses[0]).redeemUnderlying(collAmount) == 0);\n\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\n\n        uint swapAmount = 0;\n\n        if (collToken != borrowToken) {\n            (, swapAmount) = _sell(_exData);\n            swapAmount -= getFee(swapAmount, user, _gasCost, _cAddresses[1]);\n        } else {\n            swapAmount = collAmount;\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\n        }\n\n        paybackDebt(swapAmount, _cAddresses[1], borrowToken, user);\n\n        // handle 0x fee\n        tx.origin.transfer(address(this).balance);\n\n        // log amount, collToken, borrowToken\n        logger.Log(address(this), msg.sender, \"CreamRepay\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\n    }",
        "comments": [
            "",
            "    /// @notice Withdraws collateral, converts to borrowed token and repays debt",
            "    /// @dev Called through the DSProxy",
            "    /// @param _exData Exchange data",
            "    /// @param _cAddresses Coll/Debt addresses [cCollAddress, cBorrowAddress]",
            "    /// @param _gasCost Gas cost for specific transaction",
            "    "
        ],
        "comt": "\n    /// @notice Withdraws collateral, converts to borrowed token and repays debt\n    /// @dev Called through the DSProxy\n    /// @param _exData Exchange data\n    /// @param _cAddresses Coll/Debt addresses [cCollAddress, cBorrowAddress]\n    /// @param _gasCost Gas cost for specific transaction\n    ",
        "@notice": "Withdraws collateral, converts to borrowed token and repays debt",
        "@dev": "Called through the DSProxy",
        "@param1": "_exData Exchange data",
        "@param2": "_cAddresses Coll/Debt addresses [cCollAddress, cBorrowAddress]",
        "@param3": "_gasCost Gas cost for specific transaction",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "boost",
        "visibility": "public",
        "args": [
            {
                "name": "_exData",
                "type": "ExchangeData memory"
            },
            {
                "name": "_cAddresses",
                "type": "address[2] memory"
            },
            {
                "name": "cCollAddress",
                "type": "//"
            },
            {
                "name": "_gasCost",
                "type": "cBorrowAddress\n        uint256"
            }
        ],
        "func": "function boost(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost\n    ) public payable {\n        enterMarket(_cAddresses[0], _cAddresses[1]);\n\n        address payable user = payable(getUserAddress());\n\n        uint maxBorrow = getMaxBorrow(_cAddresses[1], address(this));\n        uint borrowAmount = (_exData.srcAmount > maxBorrow) ? maxBorrow : _exData.srcAmount;\n\n        require(CTokenInterface(_cAddresses[1]).borrow(borrowAmount) == 0);\n\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\n\n        uint swapAmount = 0;\n\n        if (collToken != borrowToken) {\n            borrowAmount -= getFee(borrowAmount, user, _gasCost, _cAddresses[1]);\n\n            _exData.srcAmount = borrowAmount;\n            (,swapAmount) = _sell(_exData);\n        } else {\n            swapAmount = borrowAmount;\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\n        }\n\n        approveCToken(collToken, _cAddresses[0]);\n\n        if (collToken != ETH_ADDRESS) {\n            require(CTokenInterface(_cAddresses[0]).mint(swapAmount) == 0);\n        } else {\n            CEtherInterface(_cAddresses[0]).mint{value: swapAmount}(); // reverts on fail\n        }\n\n        // handle 0x fee\n        tx.origin.transfer(address(this).balance);\n\n        // log amount, collToken, borrowToken\n        logger.Log(address(this), msg.sender, \"CreamBoost\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\n    }",
        "comments": [
            "",
            "    /// @notice Borrows token, converts to collateral, and adds to position",
            "    /// @dev Called through the DSProxy",
            "    /// @param _exData Exchange data",
            "    /// @param _cAddresses Coll/Debt addresses [cCollAddress, cBorrowAddress]",
            "    /// @param _gasCost Gas cost for specific transaction",
            "    "
        ],
        "comt": "\n    /// @notice Borrows token, converts to collateral, and adds to position\n    /// @dev Called through the DSProxy\n    /// @param _exData Exchange data\n    /// @param _cAddresses Coll/Debt addresses [cCollAddress, cBorrowAddress]\n    /// @param _gasCost Gas cost for specific transaction\n    ",
        "@notice": "Borrows token, converts to collateral, and adds to position",
        "@dev": "Called through the DSProxy",
        "@param1": "_exData Exchange data",
        "@param2": "_cAddresses Coll/Debt addresses [cCollAddress, cBorrowAddress]",
        "@param3": "_gasCost Gas cost for specific transaction",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "executeOperation",
        "visibility": "external",
        "args": [
            {
                "name": "_reserve",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            },
            {
                "name": "_fee",
                "type": "uint256"
            },
            {
                "name": "_params",
                "type": "bytes calldata"
            }
        ],
        "func": "function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n        // Format the call data for DSProxy\n        (bytes memory proxyData, address payable proxyAddr) = packFunctionCall(_amount, _fee, _params);\n\n        // Send Flash loan amount to DSProxy\n        sendLoanToProxy(proxyAddr, _reserve, _amount);\n\n        // Execute the DSProxy call\n        DSProxyInterface(proxyAddr).execute(COMPOUND_SAVER_FLASH_PROXY, proxyData);\n\n        // Repay the loan with the money DSProxy sent back\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Called by Aave when sending back the FL amount",
            "    /// @param _reserve The address of the borrowed token",
            "    /// @param _amount Amount of FL tokens received",
            "    /// @param _fee FL Aave fee",
            "    /// @param _params The params that are sent from the original FL caller contract",
            "   "
        ],
        "comt": "\n    /// @notice Called by Aave when sending back the FL amount\n    /// @param _reserve The address of the borrowed token\n    /// @param _amount Amount of FL tokens received\n    /// @param _fee FL Aave fee\n    /// @param _params The params that are sent from the original FL caller contract\n   ",
        "@notice": "Called by Aave when sending back the FL amount",
        "@param1": "_reserve The address of the borrowed token",
        "@param2": "_amount Amount of FL tokens received",
        "@param3": "_fee FL Aave fee",
        "@param4": "_params The params that are sent from the original FL caller contract",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "flashRepay",
        "visibility": "public",
        "args": [
            {
                "name": "_exData",
                "type": "ExchangeData memory"
            },
            {
                "name": "_cAddresses",
                "type": "address[2] memory"
            },
            {
                "name": "cCollAddress",
                "type": "//"
            },
            {
                "name": "_gasCost",
                "type": "cBorrowAddress\n        uint256"
            },
            {
                "name": "amount",
                "type": "uint[2] memory _flashLoanData //"
            },
            {
                "name": "fee",
                "type": "fee"
            }
        ],
        "func": "function flashRepay(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost,\n        uint[2] memory _flashLoanData // amount, fee\n    ) public payable {\n        enterMarket(_cAddresses[0], _cAddresses[1]);\n\n        address payable user = payable(getUserAddress());\n        uint flashBorrowed = _flashLoanData[0] + _flashLoanData[1];\n\n        uint maxColl = getMaxCollateral(_cAddresses[0], address(this));\n\n        // draw max coll\n        require(CTokenInterface(_cAddresses[0]).redeemUnderlying(maxColl) == 0);\n\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\n\n        uint swapAmount = 0;\n\n        if (collToken != borrowToken) {\n            // swap max coll + loanAmount\n            _exData.srcAmount = maxColl + _flashLoanData[0];\n            (,swapAmount) = _sell(_exData);\n\n            // get fee\n            swapAmount -= getFee(swapAmount, user, _gasCost, _cAddresses[1]);\n        } else {\n            swapAmount = (maxColl + _flashLoanData[0]);\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\n        }\n\n        // payback debt\n        paybackDebt(swapAmount, _cAddresses[1], borrowToken, user);\n\n        // draw collateral for loanAmount + loanFee\n        require(CTokenInterface(_cAddresses[0]).redeemUnderlying(flashBorrowed) == 0);\n\n        // repay flash loan\n        returnFlashLoan(collToken, flashBorrowed);\n\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"CreamRepay\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\n    }",
        "comments": [
            "",
            "    /// @notice Repays the position and sends tokens back for FL",
            "    /// @param _exData Exchange data",
            "    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress]",
            "    /// @param _gasCost Gas cost for transaction",
            "    /// @param _flashLoanData Data about FL [amount, fee]",
            "    "
        ],
        "comt": "\n    /// @notice Repays the position and sends tokens back for FL\n    /// @param _exData Exchange data\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress]\n    /// @param _gasCost Gas cost for transaction\n    /// @param _flashLoanData Data about FL [amount, fee]\n    ",
        "@notice": "Repays the position and sends tokens back for FL",
        "@param1": "_exData Exchange data",
        "@param2": "_cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress]",
        "@param3": "_gasCost Gas cost for transaction",
        "@param4": "_flashLoanData Data about FL [amount, fee]",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "flashBoost",
        "visibility": "public",
        "args": [
            {
                "name": "_exData",
                "type": "ExchangeData memory"
            },
            {
                "name": "_cAddresses",
                "type": "address[2] memory"
            },
            {
                "name": "cCollAddress",
                "type": "//"
            },
            {
                "name": "_gasCost",
                "type": "cBorrowAddress\n        uint256"
            },
            {
                "name": "amount",
                "type": "uint[2] memory _flashLoanData //"
            },
            {
                "name": "fee",
                "type": "fee"
            }
        ],
        "func": "function flashBoost(\n        ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        uint256 _gasCost,\n        uint[2] memory _flashLoanData // amount, fee\n    ) public payable {\n        enterMarket(_cAddresses[0], _cAddresses[1]);\n\n        address payable user = payable(getUserAddress());\n        uint flashBorrowed = _flashLoanData[0] + _flashLoanData[1];\n\n        // borrow max amount\n        uint borrowAmount = getMaxBorrow(_cAddresses[1], address(this));\n        require(CTokenInterface(_cAddresses[1]).borrow(borrowAmount) == 0);\n\n        address collToken = getUnderlyingAddr(_cAddresses[0]);\n        address borrowToken = getUnderlyingAddr(_cAddresses[1]);\n\n        uint swapAmount = 0;\n\n        if (collToken != borrowToken) {\n            // get dfs fee\n            borrowAmount -= getFee((borrowAmount + _flashLoanData[0]), user, _gasCost, _cAddresses[1]);\n            _exData.srcAmount = (borrowAmount + _flashLoanData[0]);\n\n            (,swapAmount) = _sell(_exData);\n        } else {\n            swapAmount = (borrowAmount + _flashLoanData[0]);\n            swapAmount -= getGasCost(swapAmount, _gasCost, _cAddresses[1]);\n        }\n\n        // deposit swaped collateral\n        depositCollateral(collToken, _cAddresses[0], swapAmount);\n\n        // borrow token to repay flash loan\n        require(CTokenInterface(_cAddresses[1]).borrow(flashBorrowed) == 0);\n\n        // repay flash loan\n        returnFlashLoan(borrowToken, flashBorrowed);\n\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"CreamBoost\", abi.encode(_exData.srcAmount, swapAmount, collToken, borrowToken));\n    }",
        "comments": [
            "",
            "    /// @notice Boosts the position and sends tokens back for FL",
            "    /// @param _exData Exchange data",
            "    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress]",
            "    /// @param _gasCost Gas cost for specific transaction",
            "    /// @param _flashLoanData Data about FL [amount, fee]",
            "    "
        ],
        "comt": "\n    /// @notice Boosts the position and sends tokens back for FL\n    /// @param _exData Exchange data\n    /// @param _cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress]\n    /// @param _gasCost Gas cost for specific transaction\n    /// @param _flashLoanData Data about FL [amount, fee]\n    ",
        "@notice": "Boosts the position and sends tokens back for FL",
        "@param1": "_exData Exchange data",
        "@param2": "_cAddresses cTokens addreses and exchange [cCollAddress, cBorrowAddress]",
        "@param3": "_gasCost Gas cost for specific transaction",
        "@param4": "_flashLoanData Data about FL [amount, fee]",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "callSell",
        "visibility": "public",
        "args": [
            {
                "name": "exData",
                "type": "SaverExchangeCore.ExchangeData memory"
            }
        ],
        "func": "function callSell(SaverExchangeCore.ExchangeData memory exData) public payable {\n        pullAndSendTokens(exData.srcAddr, exData.srcAmount);\n\n        saverExchange.sell{value: msg.value}(exData, msg.sender);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "callBuy",
        "visibility": "public",
        "args": [
            {
                "name": "exData",
                "type": "SaverExchangeCore.ExchangeData memory"
            }
        ],
        "func": "function callBuy(SaverExchangeCore.ExchangeData memory exData) public payable {\n        pullAndSendTokens(exData.srcAddr, exData.srcAmount);\n\n        saverExchange.buy{value: msg.value}(exData, msg.sender);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "ownerChangeExchange",
        "visibility": "public",
        "args": [
            {
                "name": "_newExchange",
                "type": "address payable"
            }
        ],
        "func": "function ownerChangeExchange(address payable _newExchange) public onlyOwner {\n        saverExchange = SaverExchange(_newExchange);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sell",
        "visibility": "public",
        "args": [
            {
                "name": "exData",
                "type": "ExchangeData memory"
            },
            {
                "name": "_user",
                "type": "address payable"
            }
        ],
        "func": "function sell(ExchangeData memory exData, address payable _user) public payable burnGas(burnAmount) {\n\n        // take fee\n        uint dfsFee = getFee(exData.srcAmount, exData.srcAddr);\n        exData.srcAmount = sub(exData.srcAmount, dfsFee);\n\n        // Perform the exchange\n        (address wrapper, uint destAmount) = _sell(exData);\n\n        // send back any leftover ether or tokens\n        sendLeftover(exData.srcAddr, exData.destAddr, _user);\n\n        // log the event\n        logger.Log(address(this), msg.sender, \"ExchangeSell\", abi.encode(wrapper, exData.srcAddr, exData.destAddr, exData.srcAmount, destAmount));\n    }",
        "comments": [
            "",
            "    /// @notice Takes a src amount of tokens and converts it into the dest token",
            "    /// @dev Takes fee from the _srcAmount before the exchange",
            "    /// @param exData [srcAddr, destAddr, srcAmount, destAmount, minPrice, exchangeType, exchangeAddr, callData, price0x]",
            "    /// @param _user User address who called the exchange",
            "    "
        ],
        "comt": "\n    /// @notice Takes a src amount of tokens and converts it into the dest token\n    /// @dev Takes fee from the _srcAmount before the exchange\n    /// @param exData [srcAddr, destAddr, srcAmount, destAmount, minPrice, exchangeType, exchangeAddr, callData, price0x]\n    /// @param _user User address who called the exchange\n    ",
        "@notice": "Takes a src amount of tokens and converts it into the dest token",
        "@dev": "Takes fee from the _srcAmount before the exchange",
        "@param1": "exData [srcAddr, destAddr, srcAmount, destAmount, minPrice, exchangeType, exchangeAddr, callData, price0x]",
        "@param2": "_user User address who called the exchange",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "buy",
        "visibility": "public",
        "args": [
            {
                "name": "exData",
                "type": "ExchangeData memory"
            },
            {
                "name": "_user",
                "type": "address payable"
            }
        ],
        "func": "function buy(ExchangeData memory exData, address payable _user) public payable burnGas(burnAmount){\n\n        uint dfsFee = getFee(exData.srcAmount, exData.srcAddr);\n        exData.srcAmount = sub(exData.srcAmount, dfsFee);\n\n        // Perform the exchange\n        (address wrapper, uint srcAmount) = _buy(exData);\n\n        // send back any leftover ether or tokens\n        sendLeftover(exData.srcAddr, exData.destAddr, _user);\n\n        // log the event\n        logger.Log(address(this), msg.sender, \"ExchangeBuy\", abi.encode(wrapper, exData.srcAddr, exData.destAddr, srcAmount, exData.destAmount));\n\n    }",
        "comments": [
            "",
            "    /// @notice Takes a dest amount of tokens and converts it from the src token",
            "    /// @dev Send always more than needed for the swap, extra will be returned",
            "    /// @param exData [srcAddr, destAddr, srcAmount, destAmount, minPrice, exchangeType, exchangeAddr, callData, price0x]",
            "    /// @param _user User address who called the exchange",
            "    "
        ],
        "comt": "\n    /// @notice Takes a dest amount of tokens and converts it from the src token\n    /// @dev Send always more than needed for the swap, extra will be returned\n    /// @param exData [srcAddr, destAddr, srcAmount, destAmount, minPrice, exchangeType, exchangeAddr, callData, price0x]\n    /// @param _user User address who called the exchange\n    ",
        "@notice": "Takes a dest amount of tokens and converts it from the src token",
        "@dev": "Send always more than needed for the swap, extra will be returned",
        "@param1": "exData [srcAddr, destAddr, srcAmount, destAmount, minPrice, exchangeType, exchangeAddr, callData, price0x]",
        "@param2": "_user User address who called the exchange",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeBurnAmount",
        "visibility": "public",
        "args": [
            {
                "name": "_newBurnAmount",
                "type": "uint"
            }
        ],
        "func": "function changeBurnAmount(uint _newBurnAmount) public {\n        require(owner == msg.sender);\n\n        burnAmount = _newBurnAmount;\n    }",
        "comments": [
            "",
            "    /// @notice Changes the amount of gas token we burn for each call",
            "    /// @dev Only callable by the owner",
            "    /// @param _newBurnAmount New amount of gas tokens to be burned",
            "    "
        ],
        "comt": "\n    /// @notice Changes the amount of gas token we burn for each call\n    /// @dev Only callable by the owner\n    /// @param _newBurnAmount New amount of gas tokens to be burned\n    ",
        "@notice": "Changes the amount of gas token we burn for each call",
        "@dev": "Only callable by the owner",
        "@param1": "_newBurnAmount New amount of gas tokens to be burned",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getBestPrice",
        "visibility": "public",
        "args": [
            {
                "name": "_amount",
                "type": "uint256"
            },
            {
                "name": "_srcToken",
                "type": "address"
            },
            {
                "name": "_destToken",
                "type": "address"
            },
            {
                "name": "_type",
                "type": "ActionType"
            },
            {
                "name": "_wrappers",
                "type": "address[] memory"
            }
        ],
        "func": "function getBestPrice(\n        uint256 _amount,\n        address _srcToken,\n        address _destToken,\n        ActionType _type,\n        address[] memory _wrappers\n    ) public returns (address, uint256) {\n\n        uint256[] memory rates = new uint256[](_wrappers.length);\n        for (uint i=0; i<_wrappers.length; i++) {\n            rates[i] = getExpectedRate(_wrappers[i], _srcToken, _destToken, _amount, _type);\n        }\n\n        return getBiggestRate(_wrappers, rates);\n    }",
        "comments": [
            "",
            "",
            "    /// @notice Returns the best estimated price from 2 exchanges",
            "    /// @param _amount Amount of source tokens you want to exchange",
            "    /// @param _srcToken Address of the source token",
            "    /// @param _destToken Address of the destination token",
            "    /// @param _type Type of action SELL|BUY",
            "    /// @param _wrappers Array of wrapper addresses to compare",
            "    /// @return (address, uint) The address of the best exchange and the exchange price",
            "    "
        ],
        "comt": "\n\n    /// @notice Returns the best estimated price from 2 exchanges\n    /// @param _amount Amount of source tokens you want to exchange\n    /// @param _srcToken Address of the source token\n    /// @param _destToken Address of the destination token\n    /// @param _type Type of action SELL|BUY\n    /// @param _wrappers Array of wrapper addresses to compare\n    /// @return (address, uint) The address of the best exchange and the exchange price\n    ",
        "@notice": "Returns the best estimated price from 2 exchanges",
        "@param1": "_amount Amount of source tokens you want to exchange",
        "@param2": "_srcToken Address of the source token",
        "@param3": "_destToken Address of the destination token",
        "@param4": "_type Type of action SELL|BUY",
        "@param5": "_wrappers Array of wrapper addresses to compare",
        "@return1": "(address, uint) The address of the best exchange and the exchange price",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getExpectedRate",
        "visibility": "public",
        "args": [
            {
                "name": "_wrapper",
                "type": "address"
            },
            {
                "name": "_srcToken",
                "type": "address"
            },
            {
                "name": "_destToken",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            },
            {
                "name": "_type",
                "type": "ActionType"
            }
        ],
        "func": "function getExpectedRate(\n        address _wrapper,\n        address _srcToken,\n        address _destToken,\n        uint256 _amount,\n        ActionType _type\n    ) public returns (uint256) {\n        bool success;\n        bytes memory result;\n\n        if (_type == ActionType.SELL) {\n            (success, result) = _wrapper.call(abi.encodeWithSignature(\n                \"getSellRate(address,address,uint256)\",\n                _srcToken,\n                _destToken,\n                _amount\n            ));\n\n        } else {\n            (success, result) = _wrapper.call(abi.encodeWithSignature(\n                \"getBuyRate(address,address,uint256)\",\n                _srcToken,\n                _destToken,\n                _amount\n            ));\n        }\n\n        if (success) {\n            return sliceUint(result, 0);\n        }\n\n        return 0;\n    }",
        "comments": [
            "",
            "    /// @notice Return the expected rate from the exchange wrapper",
            "    /// @dev In case of Oasis/Uniswap handles the different precision tokens",
            "    /// @param _wrapper Address of exchange wrapper",
            "    /// @param _srcToken From token",
            "    /// @param _destToken To token",
            "    /// @param _amount Amount to be exchanged",
            "    /// @param _type Type of action SELL|BUY",
            "    "
        ],
        "comt": "\n    /// @notice Return the expected rate from the exchange wrapper\n    /// @dev In case of Oasis/Uniswap handles the different precision tokens\n    /// @param _wrapper Address of exchange wrapper\n    /// @param _srcToken From token\n    /// @param _destToken To token\n    /// @param _amount Amount to be exchanged\n    /// @param _type Type of action SELL|BUY\n    ",
        "@notice": "Return the expected rate from the exchange wrapper",
        "@dev": "In case of Oasis/Uniswap handles the different precision tokens",
        "@param1": "_wrapper Address of exchange wrapper",
        "@param2": "_srcToken From token",
        "@param3": "_destToken To token",
        "@param4": "_amount Amount to be exchanged",
        "@param5": "_type Type of action SELL|BUY",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sell",
        "visibility": "external",
        "args": [
            {
                "name": "_srcAddr",
                "type": "address"
            },
            {
                "name": "_destAddr",
                "type": "address"
            },
            {
                "name": "_srcAmount",
                "type": "uint"
            }
        ],
        "func": "function sell(address _srcAddr, address _destAddr, uint _srcAmount) external override payable returns (uint) {\n        ERC20 srcToken = ERC20(_srcAddr);\n        ERC20 destToken = ERC20(_destAddr);\n\n        KyberNetworkProxyInterface kyberNetworkProxy = KyberNetworkProxyInterface(KYBER_INTERFACE);\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            srcToken.safeApprove(address(kyberNetworkProxy), _srcAmount);\n        }\n\n        uint destAmount = kyberNetworkProxy.trade{value: msg.value}(\n            srcToken,\n            _srcAmount,\n            destToken,\n            msg.sender,\n            uint(-1),\n            0,\n            WALLET_ID\n        );\n\n        return destAmount;\n    }",
        "comments": [
            "",
            "    /// @notice Sells a _srcAmount of tokens at Kyber",
            "    /// @param _srcAddr From token",
            "    /// @param _destAddr To token",
            "    /// @param _srcAmount From amount",
            "    /// @return uint Destination amount",
            "    "
        ],
        "comt": "\n    /// @notice Sells a _srcAmount of tokens at Kyber\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Destination amount\n    ",
        "@notice": "Sells a _srcAmount of tokens at Kyber",
        "@param1": "_srcAddr From token",
        "@param2": "_destAddr To token",
        "@param3": "_srcAmount From amount",
        "@return1": "uint Destination amount",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "buy",
        "visibility": "external",
        "args": [
            {
                "name": "_srcAddr",
                "type": "address"
            },
            {
                "name": "_destAddr",
                "type": "address"
            },
            {
                "name": "_destAmount",
                "type": "uint"
            }
        ],
        "func": "function buy(address _srcAddr, address _destAddr, uint _destAmount) external override payable returns(uint) {\n        ERC20 srcToken = ERC20(_srcAddr);\n        ERC20 destToken = ERC20(_destAddr);\n\n        uint srcAmount = 0;\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            srcAmount = srcToken.balanceOf(address(this));\n        } else {\n            srcAmount = msg.value;\n        }\n\n        KyberNetworkProxyInterface kyberNetworkProxy = KyberNetworkProxyInterface(KYBER_INTERFACE);\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            srcToken.safeApprove(address(kyberNetworkProxy), srcAmount);\n        }\n\n        uint destAmount = kyberNetworkProxy.trade{value: msg.value}(\n            srcToken,\n            srcAmount,\n            destToken,\n            msg.sender,\n            _destAmount,\n            0,\n            WALLET_ID\n        );\n\n        require(destAmount == _destAmount, \"Wrong dest amount\");\n\n        uint srcAmountAfter = 0;\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            srcAmountAfter = srcToken.balanceOf(address(this));\n        } else {\n            srcAmountAfter = address(this).balance;\n        }\n\n        // Send the leftover from the source token back\n        sendLeftOver(_srcAddr);\n\n        return (srcAmount - srcAmountAfter);\n    }",
        "comments": [
            "",
            "    /// @notice Buys a _destAmount of tokens at Kyber",
            "    /// @param _srcAddr From token",
            "    /// @param _destAddr To token",
            "    /// @param _destAmount To amount",
            "    /// @return uint srcAmount",
            "    "
        ],
        "comt": "\n    /// @notice Buys a _destAmount of tokens at Kyber\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint srcAmount\n    ",
        "@notice": "Buys a _destAmount of tokens at Kyber",
        "@param1": "_srcAddr From token",
        "@param2": "_destAddr To token",
        "@param3": "_destAmount To amount",
        "@return1": "uint srcAmount",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getSellRate",
        "visibility": "public",
        "args": [
            {
                "name": "_srcAddr",
                "type": "address"
            },
            {
                "name": "_destAddr",
                "type": "address"
            },
            {
                "name": "_srcAmount",
                "type": "uint"
            }
        ],
        "func": "function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) public override view returns (uint rate) {\n        (rate, ) = KyberNetworkProxyInterface(KYBER_INTERFACE)\n            .getExpectedRate(ERC20(_srcAddr), ERC20(_destAddr), _srcAmount);\n\n        // multiply with decimal difference in src token\n        rate = rate * (10**(18 - getDecimals(_srcAddr)));\n        // divide with decimal difference in dest token\n        rate = rate / (10**(18 - getDecimals(_destAddr)));\n    }",
        "comments": [
            "",
            "    /// @notice Return a rate for which we can sell an amount of tokens",
            "    /// @param _srcAddr From token",
            "    /// @param _destAddr To token",
            "    /// @param _srcAmount From amount",
            "    /// @return rate Rate",
            "    "
        ],
        "comt": "\n    /// @notice Return a rate for which we can sell an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return rate Rate\n    ",
        "@notice": "Return a rate for which we can sell an amount of tokens",
        "@param1": "_srcAddr From token",
        "@param2": "_destAddr To token",
        "@param3": "_srcAmount From amount",
        "@return1": "rate Rate",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getBuyRate",
        "visibility": "public",
        "args": [
            {
                "name": "_srcAddr",
                "type": "address"
            },
            {
                "name": "_destAddr",
                "type": "address"
            },
            {
                "name": "_destAmount",
                "type": "uint"
            }
        ],
        "func": "function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount) public override view returns (uint rate) {\n        uint256 srcRate = getSellRate(_destAddr, _srcAddr, _destAmount);\n        uint256 srcAmount = wmul(srcRate, _destAmount);\n\n        rate = getSellRate(_srcAddr, _destAddr, srcAmount);\n\n        // increase rate by 3% too account for inaccuracy between sell/buy conversion\n        rate = rate + (rate / 30);\n    }",
        "comments": [
            "",
            "    /// @notice Return a rate for which we can buy an amount of tokens",
            "    /// @param _srcAddr From token",
            "    /// @param _destAddr To token",
            "    /// @param _destAmount To amount",
            "    /// @return rate Rate",
            "    "
        ],
        "comt": "\n    /// @notice Return a rate for which we can buy an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return rate Rate\n    ",
        "@notice": "Return a rate for which we can buy an amount of tokens",
        "@param1": "_srcAddr From token",
        "@param2": "_destAddr To token",
        "@param3": "_destAmount To amount",
        "@return1": "rate Rate",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sell",
        "visibility": "external",
        "args": [
            {
                "name": "_srcAddr",
                "type": "address"
            },
            {
                "name": "_destAddr",
                "type": "address"
            },
            {
                "name": "_srcAmount",
                "type": "uint"
            }
        ],
        "func": "function sell(address _srcAddr, address _destAddr, uint _srcAmount) external override payable returns (uint) {\n        address srcAddr = ethToWethAddr(_srcAddr);\n        address destAddr = ethToWethAddr(_destAddr);\n\n        ERC20(srcAddr).safeApprove(OTC_ADDRESS, _srcAmount);\n\n        uint destAmount = OasisInterface(OTC_ADDRESS).sellAllAmount(srcAddr, _srcAmount, destAddr, 0);\n\n        // convert weth -> eth and send back\n        if (destAddr == WETH_ADDRESS) {\n            TokenInterface(WETH_ADDRESS).withdraw(destAmount);\n            msg.sender.transfer(destAmount);\n        } else {\n            ERC20(destAddr).safeTransfer(msg.sender, destAmount);\n        }\n\n        return destAmount;\n    }",
        "comments": [
            "",
            "    /// @notice Sells a _srcAmount of tokens at Oasis",
            "    /// @param _srcAddr From token",
            "    /// @param _destAddr To token",
            "    /// @param _srcAmount From amount",
            "    /// @return uint Destination amount",
            "    "
        ],
        "comt": "\n    /// @notice Sells a _srcAmount of tokens at Oasis\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Destination amount\n    ",
        "@notice": "Sells a _srcAmount of tokens at Oasis",
        "@param1": "_srcAddr From token",
        "@param2": "_destAddr To token",
        "@param3": "_srcAmount From amount",
        "@return1": "uint Destination amount",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "buy",
        "visibility": "external",
        "args": [
            {
                "name": "_srcAddr",
                "type": "address"
            },
            {
                "name": "_destAddr",
                "type": "address"
            },
            {
                "name": "_destAmount",
                "type": "uint"
            }
        ],
        "func": "function buy(address _srcAddr, address _destAddr, uint _destAmount) external override payable returns(uint) {\n        address srcAddr = ethToWethAddr(_srcAddr);\n        address destAddr = ethToWethAddr(_destAddr);\n\n        ERC20(srcAddr).safeApprove(OTC_ADDRESS, uint(-1));\n\n        uint srcAmount = OasisInterface(OTC_ADDRESS).buyAllAmount(destAddr, _destAmount, srcAddr, uint(-1));\n\n        // convert weth -> eth and send back\n        if (destAddr == WETH_ADDRESS) {\n            TokenInterface(WETH_ADDRESS).withdraw(_destAmount);\n            msg.sender.transfer(_destAmount);\n        } else {\n            ERC20(destAddr).safeTransfer(msg.sender, _destAmount);\n        }\n\n        // Send the leftover from the source token back\n        sendLeftOver(srcAddr);\n\n        return srcAmount;\n    }",
        "comments": [
            "",
            "    /// @notice Buys a _destAmount of tokens at Oasis",
            "    /// @param _srcAddr From token",
            "    /// @param _destAddr To token",
            "    /// @param _destAmount To amount",
            "    /// @return uint srcAmount",
            "    "
        ],
        "comt": "\n    /// @notice Buys a _destAmount of tokens at Oasis\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint srcAmount\n    ",
        "@notice": "Buys a _destAmount of tokens at Oasis",
        "@param1": "_srcAddr From token",
        "@param2": "_destAddr To token",
        "@param3": "_destAmount To amount",
        "@return1": "uint srcAmount",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getSellRate",
        "visibility": "public",
        "args": [
            {
                "name": "_srcAddr",
                "type": "address"
            },
            {
                "name": "_destAddr",
                "type": "address"
            },
            {
                "name": "_srcAmount",
                "type": "uint"
            }
        ],
        "func": "function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) public override view returns (uint) {\n        address srcAddr = ethToWethAddr(_srcAddr);\n        address destAddr = ethToWethAddr(_destAddr);\n\n        return wdiv(OasisInterface(OTC_ADDRESS).getBuyAmount(destAddr, srcAddr, _srcAmount), _srcAmount);\n    }",
        "comments": [
            "",
            "    /// @notice Return a rate for which we can sell an amount of tokens",
            "    /// @param _srcAddr From token",
            "    /// @param _destAddr To token",
            "    /// @param _srcAmount From amount",
            "    /// @return uint Rate",
            "    "
        ],
        "comt": "\n    /// @notice Return a rate for which we can sell an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Rate\n    ",
        "@notice": "Return a rate for which we can sell an amount of tokens",
        "@param1": "_srcAddr From token",
        "@param2": "_destAddr To token",
        "@param3": "_srcAmount From amount",
        "@return1": "uint Rate",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getBuyRate",
        "visibility": "public",
        "args": [
            {
                "name": "_srcAddr",
                "type": "address"
            },
            {
                "name": "_destAddr",
                "type": "address"
            },
            {
                "name": "_destAmount",
                "type": "uint"
            }
        ],
        "func": "function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount) public override view returns (uint) {\n        address srcAddr = ethToWethAddr(_srcAddr);\n        address destAddr = ethToWethAddr(_destAddr);\n\n        return wdiv(1 ether, wdiv(OasisInterface(OTC_ADDRESS).getPayAmount(srcAddr, destAddr, _destAmount), _destAmount));\n    }",
        "comments": [
            "",
            "",
            "    /// @notice Return a rate for which we can buy an amount of tokens",
            "    /// @param _srcAddr From token",
            "    /// @param _destAddr To token",
            "    /// @param _destAmount To amount",
            "    /// @return uint Rate",
            "    "
        ],
        "comt": "\n\n    /// @notice Return a rate for which we can buy an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint Rate\n    ",
        "@notice": "Return a rate for which we can buy an amount of tokens",
        "@param1": "_srcAddr From token",
        "@param2": "_destAddr To token",
        "@param3": "_destAmount To amount",
        "@return1": "uint Rate",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sell",
        "visibility": "external",
        "args": [
            {
                "name": "_srcAddr",
                "type": "address"
            },
            {
                "name": "_destAddr",
                "type": "address"
            },
            {
                "name": "_srcAmount",
                "type": "uint"
            }
        ],
        "func": "function sell(address _srcAddr, address _destAddr, uint _srcAmount) external payable override returns (uint) {\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n        uint[] memory amounts;\n        address[] memory path = new address[](2);\n        path[0] = _srcAddr;\n        path[1] = _destAddr;\n\n        ERC20(_srcAddr).safeApprove(address(router), _srcAmount);\n\n        // if we are buying ether\n        if (_destAddr == WETH_ADDRESS) {\n            amounts = router.swapExactTokensForETH(_srcAmount, 1, path, msg.sender, block.timestamp + 1);\n        }\n        // if we are selling token to token\n        else {\n            amounts = router.swapExactTokensForTokens(_srcAmount, 1, path, msg.sender, block.timestamp + 1);\n        }\n\n        return amounts[amounts.length - 1];\n    }",
        "comments": [
            "",
            "    /// @notice Sells a _srcAmount of tokens at UniswapV2",
            "    /// @param _srcAddr From token",
            "    /// @param _destAddr To token",
            "    /// @param _srcAmount From amount",
            "    /// @return uint Destination amount",
            "    "
        ],
        "comt": "\n    /// @notice Sells a _srcAmount of tokens at UniswapV2\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Destination amount\n    ",
        "@notice": "Sells a _srcAmount of tokens at UniswapV2",
        "@param1": "_srcAddr From token",
        "@param2": "_destAddr To token",
        "@param3": "_srcAmount From amount",
        "@return1": "uint Destination amount",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "buy",
        "visibility": "external",
        "args": [
            {
                "name": "_srcAddr",
                "type": "address"
            },
            {
                "name": "_destAddr",
                "type": "address"
            },
            {
                "name": "_destAmount",
                "type": "uint"
            }
        ],
        "func": "function buy(address _srcAddr, address _destAddr, uint _destAmount) external override payable returns(uint) {\n\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n        uint[] memory amounts;\n        address[] memory path = new address[](2);\n        path[0] = _srcAddr;\n        path[1] = _destAddr;\n\n        ERC20(_srcAddr).safeApprove(address(router), uint(-1));\n\n\n         // if we are buying ether\n        if (_destAddr == WETH_ADDRESS) {\n            amounts = router.swapTokensForExactETH(_destAmount, uint(-1), path, msg.sender, block.timestamp + 1);\n        }\n        // if we are buying token to token\n        else {\n            amounts = router.swapTokensForExactTokens(_destAmount, uint(-1), path, msg.sender, block.timestamp + 1);\n        }\n\n        // Send the leftover from the source token back\n        sendLeftOver(_srcAddr);\n\n        return amounts[0];\n    }",
        "comments": [
            "",
            "    /// @notice Buys a _destAmount of tokens at UniswapV2",
            "    /// @param _srcAddr From token",
            "    /// @param _destAddr To token",
            "    /// @param _destAmount To amount",
            "    /// @return uint srcAmount",
            "    "
        ],
        "comt": "\n    /// @notice Buys a _destAmount of tokens at UniswapV2\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint srcAmount\n    ",
        "@notice": "Buys a _destAmount of tokens at UniswapV2",
        "@param1": "_srcAddr From token",
        "@param2": "_destAddr To token",
        "@param3": "_destAmount To amount",
        "@return1": "uint srcAmount",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getSellRate",
        "visibility": "public",
        "args": [
            {
                "name": "_srcAddr",
                "type": "address"
            },
            {
                "name": "_destAddr",
                "type": "address"
            },
            {
                "name": "_srcAmount",
                "type": "uint"
            }
        ],
        "func": "function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) public override view returns (uint) {\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n        address[] memory path = new address[](2);\n        path[0] = _srcAddr;\n        path[1] = _destAddr;\n\n        uint[] memory amounts = router.getAmountsOut(_srcAmount, path);\n        return wdiv(amounts[amounts.length - 1], _srcAmount);\n    }",
        "comments": [
            "",
            "    /// @notice Return a rate for which we can sell an amount of tokens",
            "    /// @param _srcAddr From token",
            "    /// @param _destAddr To token",
            "    /// @param _srcAmount From amount",
            "    /// @return uint Rate",
            "    "
        ],
        "comt": "\n    /// @notice Return a rate for which we can sell an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Rate\n    ",
        "@notice": "Return a rate for which we can sell an amount of tokens",
        "@param1": "_srcAddr From token",
        "@param2": "_destAddr To token",
        "@param3": "_srcAmount From amount",
        "@return1": "uint Rate",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getBuyRate",
        "visibility": "public",
        "args": [
            {
                "name": "_srcAddr",
                "type": "address"
            },
            {
                "name": "_destAddr",
                "type": "address"
            },
            {
                "name": "_destAmount",
                "type": "uint"
            }
        ],
        "func": "function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount) public override view returns (uint) {\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n        address[] memory path = new address[](2);\n        path[0] = _srcAddr;\n        path[1] = _destAddr;\n\n        uint[] memory amounts = router.getAmountsIn(_destAmount, path);\n        return wdiv(_destAmount, amounts[0]);\n    }",
        "comments": [
            "",
            "    /// @notice Return a rate for which we can buy an amount of tokens",
            "    /// @param _srcAddr From token",
            "    /// @param _destAddr To token",
            "    /// @param _destAmount To amount",
            "    /// @return uint Rate",
            "    "
        ],
        "comt": "\n    /// @notice Return a rate for which we can buy an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint Rate\n    ",
        "@notice": "Return a rate for which we can buy an amount of tokens",
        "@param1": "_srcAddr From token",
        "@param2": "_destAddr To token",
        "@param3": "_destAmount To amount",
        "@return1": "uint Rate",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sell",
        "visibility": "external",
        "args": [
            {
                "name": "_srcAddr",
                "type": "address"
            },
            {
                "name": "_destAddr",
                "type": "address"
            },
            {
                "name": "_srcAmount",
                "type": "uint"
            }
        ],
        "func": "function sell(address _srcAddr, address _destAddr, uint _srcAmount) external payable override returns (uint) {\n        address uniswapExchangeAddr;\n        uint destAmount;\n\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n        // if we are buying ether\n        if (_destAddr == WETH_ADDRESS) {\n            uniswapExchangeAddr = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\n\n            ERC20(_srcAddr).safeApprove(uniswapExchangeAddr, _srcAmount);\n\n            destAmount = UniswapExchangeInterface(uniswapExchangeAddr).\n                tokenToEthTransferInput(_srcAmount, 1, block.timestamp + 1, msg.sender);\n        }\n        // if we are selling token to token\n        else {\n            uniswapExchangeAddr = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\n\n            ERC20(_srcAddr).safeApprove(uniswapExchangeAddr, _srcAmount);\n\n            destAmount = UniswapExchangeInterface(uniswapExchangeAddr).\n                tokenToTokenTransferInput(_srcAmount, 1, 1, block.timestamp + 1, msg.sender, _destAddr);\n        }\n\n        return destAmount;\n    }",
        "comments": [
            "",
            "    /// @notice Sells a _srcAmount of tokens at Uniswap",
            "    /// @param _srcAddr From token",
            "    /// @param _destAddr To token",
            "    /// @param _srcAmount From amount",
            "    /// @return uint Destination amount",
            "    "
        ],
        "comt": "\n    /// @notice Sells a _srcAmount of tokens at Uniswap\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Destination amount\n    ",
        "@notice": "Sells a _srcAmount of tokens at Uniswap",
        "@param1": "_srcAddr From token",
        "@param2": "_destAddr To token",
        "@param3": "_srcAmount From amount",
        "@return1": "uint Destination amount",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "buy",
        "visibility": "external",
        "args": [
            {
                "name": "_srcAddr",
                "type": "address"
            },
            {
                "name": "_destAddr",
                "type": "address"
            },
            {
                "name": "_destAmount",
                "type": "uint"
            }
        ],
        "func": "function buy(address _srcAddr, address _destAddr, uint _destAmount) external override payable returns(uint) {\n        address uniswapExchangeAddr;\n        uint srcAmount;\n\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n         // if we are buying ether\n        if (_destAddr == WETH_ADDRESS) {\n            uniswapExchangeAddr = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\n\n            ERC20(_srcAddr).safeApprove(uniswapExchangeAddr, uint(-1));\n\n            srcAmount = UniswapExchangeInterface(uniswapExchangeAddr).\n                tokenToEthTransferOutput(_destAmount, uint(-1), block.timestamp + 1, msg.sender);\n        }\n        // if we are buying token to token\n        else {\n            uniswapExchangeAddr = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\n\n            ERC20(_srcAddr).safeApprove(uniswapExchangeAddr, uint(-1));\n\n            srcAmount = UniswapExchangeInterface(uniswapExchangeAddr).\n                tokenToTokenTransferOutput(_destAmount, uint(-1), uint(-1), block.timestamp + 1, msg.sender, _destAddr);\n        }\n\n        // Send the leftover from the source token back\n        sendLeftOver(_srcAddr);\n\n        return srcAmount;\n    }",
        "comments": [
            "",
            "    /// @notice Buys a _destAmount of tokens at Uniswap",
            "    /// @param _srcAddr From token",
            "    /// @param _destAddr To token",
            "    /// @param _destAmount To amount",
            "    /// @return uint srcAmount",
            "    "
        ],
        "comt": "\n    /// @notice Buys a _destAmount of tokens at Uniswap\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint srcAmount\n    ",
        "@notice": "Buys a _destAmount of tokens at Uniswap",
        "@param1": "_srcAddr From token",
        "@param2": "_destAddr To token",
        "@param3": "_destAmount To amount",
        "@return1": "uint srcAmount",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getSellRate",
        "visibility": "public",
        "args": [
            {
                "name": "_srcAddr",
                "type": "address"
            },
            {
                "name": "_destAddr",
                "type": "address"
            },
            {
                "name": "_srcAmount",
                "type": "uint"
            }
        ],
        "func": "function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) public override view returns (uint) {\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n        if(_srcAddr == WETH_ADDRESS) {\n            address uniswapTokenAddress = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_destAddr);\n            return wdiv(UniswapExchangeInterface(uniswapTokenAddress).getEthToTokenInputPrice(_srcAmount), _srcAmount);\n        } else if (_destAddr == WETH_ADDRESS) {\n            address uniswapTokenAddress = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\n            return wdiv(UniswapExchangeInterface(uniswapTokenAddress).getTokenToEthInputPrice(_srcAmount), _srcAmount);\n        } else {\n            uint ethBought = UniswapExchangeInterface(UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr)).getTokenToEthInputPrice(_srcAmount);\n            return wdiv(UniswapExchangeInterface(UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_destAddr)).getEthToTokenInputPrice(ethBought), _srcAmount);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Return a rate for which we can sell an amount of tokens",
            "    /// @param _srcAddr From token",
            "    /// @param _destAddr To token",
            "    /// @param _srcAmount From amount",
            "    /// @return uint Rate",
            "    "
        ],
        "comt": "\n    /// @notice Return a rate for which we can sell an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Rate\n    ",
        "@notice": "Return a rate for which we can sell an amount of tokens",
        "@param1": "_srcAddr From token",
        "@param2": "_destAddr To token",
        "@param3": "_srcAmount From amount",
        "@return1": "uint Rate",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getBuyRate",
        "visibility": "public",
        "args": [
            {
                "name": "_srcAddr",
                "type": "address"
            },
            {
                "name": "_destAddr",
                "type": "address"
            },
            {
                "name": "_destAmount",
                "type": "uint"
            }
        ],
        "func": "function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount) public override view returns (uint) {\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n        if(_srcAddr == WETH_ADDRESS) {\n            address uniswapTokenAddress = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_destAddr);\n            return wdiv(1 ether, wdiv(UniswapExchangeInterface(uniswapTokenAddress).getEthToTokenOutputPrice(_destAmount), _destAmount));\n        } else if (_destAddr == WETH_ADDRESS) {\n            address uniswapTokenAddress = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\n            return wdiv(1 ether, wdiv(UniswapExchangeInterface(uniswapTokenAddress).getTokenToEthOutputPrice(_destAmount), _destAmount));\n        } else {\n            uint ethNeeded = UniswapExchangeInterface(UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_destAddr)).getTokenToEthOutputPrice(_destAmount);\n            return wdiv(1 ether, wdiv(UniswapExchangeInterface(UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr)).getEthToTokenOutputPrice(ethNeeded), _destAmount));\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Return a rate for which we can buy an amount of tokens",
            "    /// @param _srcAddr From token",
            "    /// @param _destAddr To token",
            "    /// @param _destAmount To amount",
            "    /// @return uint Rate",
            "    "
        ],
        "comt": "\n    /// @notice Return a rate for which we can buy an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint Rate\n    ",
        "@notice": "Return a rate for which we can buy an amount of tokens",
        "@param1": "_srcAddr From token",
        "@param2": "_destAddr To token",
        "@param3": "_destAmount To amount",
        "@return1": "uint Rate",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "takeLoan",
        "visibility": "public",
        "args": [
            {
                "name": "_receiver",
                "type": "address"
            },
            {
                "name": "_ethAmount",
                "type": "uint256"
            },
            {
                "name": "_encodedData",
                "type": "bytes memory"
            }
        ],
        "func": "function takeLoan(address _receiver, uint256 _ethAmount, bytes memory _encodedData) public {\n        ISoloMargin solo = ISoloMargin(SOLO_MARGIN_ADDRESS);\n\n        // Get marketId from token address\n        uint256 marketId = _getMarketIdFromTokenAddress(WETH_ADDR);\n\n        // Calculate repay amount (_amount + (2 wei))\n        // Approve transfer from\n        uint256 repayAmount = _getRepaymentAmountInternal(_ethAmount);\n        ERC20(WETH_ADDR).approve(SOLO_MARGIN_ADDRESS, repayAmount);\n\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\n\n        operations[0] = _getWithdrawAction(marketId, _ethAmount, _receiver);\n        operations[1] = _getCallAction(\n            _encodedData,\n            _receiver\n        );\n        operations[2] = _getDepositAction(marketId, repayAmount, address(this));\n\n        Account.Info[] memory accountInfos = new Account.Info[](1);\n        accountInfos[0] = _getAccountInfo();\n\n        givePermission(_receiver);\n        solo.operate(accountInfos, operations);\n        removePermission(_receiver);\n\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"DyDxFlashLoanTaken\", abi.encode(_receiver, _ethAmount, _encodedData));\n    }",
        "comments": [
            "",
            "    /// @notice Takes flash loan for _receiver",
            "    /// @dev Receiver must send back WETH + 2 wei after executing transaction",
            "    /// @dev Method is meant to be called from proxy and proxy will give authorization to _receiver",
            "    /// @param _receiver Address of funds receiver",
            "    /// @param _ethAmount ETH amount that needs to be pulled from dydx    ",
            "    /// @param _encodedData Bytes with packed data",
            "    "
        ],
        "comt": "\n    /// @notice Takes flash loan for _receiver\n    /// @dev Receiver must send back WETH + 2 wei after executing transaction\n    /// @dev Method is meant to be called from proxy and proxy will give authorization to _receiver\n    /// @param _receiver Address of funds receiver\n    /// @param _ethAmount ETH amount that needs to be pulled from dydx    \n    /// @param _encodedData Bytes with packed data\n    ",
        "@notice": "Takes flash loan for _receiver",
        "@dev": "Receiver must send back WETH + 2 wei after executing transaction * Method is meant to be called from proxy and proxy will give authorization to _receiver",
        "@param1": "_receiver Address of funds receiver",
        "@param2": "_ethAmount ETH amount that needs to be pulled from dydx",
        "@param3": "_encodedData Bytes with packed data",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "callExecute",
        "visibility": "public",
        "args": [
            {
                "name": "_owner",
                "type": "address"
            },
            {
                "name": "_saverProxy",
                "type": "address"
            },
            {
                "name": "_data",
                "type": "bytes memory"
            }
        ],
        "func": "function callExecute(address _owner, address _saverProxy, bytes memory _data) public payable onlyMonitor {\n        // execute reverts if calling specific method fails\n        DSProxyInterface(_owner).execute{value: msg.value}(_saverProxy, _data);\n\n        // return if anything left\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Only monitor contract is able to call execute on users proxy",
            "    /// @param _owner Address of cdp owner (users DSProxy address)",
            "    /// @param _saverProxy Address of MCDSaverProxy",
            "    /// @param _data Data to send to MCDSaverProxy",
            "    "
        ],
        "comt": "\n    /// @notice Only monitor contract is able to call execute on users proxy\n    /// @param _owner Address of cdp owner (users DSProxy address)\n    /// @param _saverProxy Address of MCDSaverProxy\n    /// @param _data Data to send to MCDSaverProxy\n    ",
        "@notice": "Only monitor contract is able to call execute on users proxy",
        "@param1": "_owner Address of cdp owner (users DSProxy address)",
        "@param2": "_saverProxy Address of MCDSaverProxy",
        "@param3": "_data Data to send to MCDSaverProxy",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setMonitor",
        "visibility": "public",
        "args": [
            {
                "name": "_monitor",
                "type": "address"
            }
        ],
        "func": "function setMonitor(address _monitor) public onlyAllowed {\n        require(monitor == address(0));\n        monitor = _monitor;\n    }",
        "comments": [
            "",
            "    /// @notice Allowed users are able to set Monitor contract without any waiting period first time",
            "    /// @param _monitor Address of Monitor contract",
            "    "
        ],
        "comt": "\n    /// @notice Allowed users are able to set Monitor contract without any waiting period first time\n    /// @param _monitor Address of Monitor contract\n    ",
        "@notice": "Allowed users are able to set Monitor contract without any waiting period first time",
        "@param1": "_monitor Address of Monitor contract",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeMonitor",
        "visibility": "public",
        "args": [
            {
                "name": "_newMonitor",
                "type": "address"
            }
        ],
        "func": "function changeMonitor(address _newMonitor) public onlyAllowed {\n        require(changeRequestedTimestamp == 0);\n\n        changeRequestedTimestamp = now;\n        lastMonitor = monitor;\n        newMonitor = _newMonitor;\n\n        emit MonitorChangeInitiated(lastMonitor, newMonitor);\n    }",
        "comments": [
            "",
            "    /// @notice Allowed users are able to start procedure for changing monitor",
            "    /// @dev after CHANGE_PERIOD needs to call confirmNewMonitor to actually make a change",
            "    /// @param _newMonitor address of new monitor",
            "    "
        ],
        "comt": "\n    /// @notice Allowed users are able to start procedure for changing monitor\n    /// @dev after CHANGE_PERIOD needs to call confirmNewMonitor to actually make a change\n    /// @param _newMonitor address of new monitor\n    ",
        "@notice": "Allowed users are able to start procedure for changing monitor",
        "@dev": "after CHANGE_PERIOD needs to call confirmNewMonitor to actually make a change",
        "@param1": "_newMonitor address of new monitor",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cancelMonitorChange",
        "visibility": "public",
        "args": [],
        "func": "function cancelMonitorChange() public onlyAllowed {\n        require(changeRequestedTimestamp > 0);\n\n        changeRequestedTimestamp = 0;\n        newMonitor = address(0);\n\n        emit MonitorChangeCanceled();\n    }",
        "comments": [
            "",
            "    /// @notice At any point allowed users are able to cancel monitor change",
            "    "
        ],
        "comt": "\n    /// @notice At any point allowed users are able to cancel monitor change\n    ",
        "@notice": "At any point allowed users are able to cancel monitor change",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "confirmNewMonitor",
        "visibility": "public",
        "args": [],
        "func": "function confirmNewMonitor() public onlyAllowed {\n        require((changeRequestedTimestamp + CHANGE_PERIOD) < now);\n        require(changeRequestedTimestamp != 0);\n        require(newMonitor != address(0));\n\n        monitor = newMonitor;\n        newMonitor = address(0);\n        changeRequestedTimestamp = 0;\n\n        emit MonitorChangeFinished(monitor);\n    }",
        "comments": [
            "",
            "    /// @notice Anyone is able to confirm new monitor after CHANGE_PERIOD if process is started",
            "    "
        ],
        "comt": "\n    /// @notice Anyone is able to confirm new monitor after CHANGE_PERIOD if process is started\n    ",
        "@notice": "Anyone is able to confirm new monitor after CHANGE_PERIOD if process is started",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "revertMonitor",
        "visibility": "public",
        "args": [],
        "func": "function revertMonitor() public onlyAllowed {\n        require(lastMonitor != address(0));\n\n        monitor = lastMonitor;\n\n        emit MonitorChangeReverted(monitor);\n    }",
        "comments": [
            "",
            "    /// @notice Its possible to revert monitor to last used monitor",
            "    "
        ],
        "comt": "\n    /// @notice Its possible to revert monitor to last used monitor\n    ",
        "@notice": "Its possible to revert monitor to last used monitor",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addAllowed",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function addAllowed(address _user) public onlyAllowed {\n        allowed[_user] = true;\n    }",
        "comments": [
            "",
            "",
            "    /// @notice Allowed users are able to add new allowed user",
            "    /// @param _user Address of user that will be allowed",
            "    "
        ],
        "comt": "\n\n    /// @notice Allowed users are able to add new allowed user\n    /// @param _user Address of user that will be allowed\n    ",
        "@notice": "Allowed users are able to add new allowed user",
        "@param1": "_user Address of user that will be allowed",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeAllowed",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            }
        ],
        "func": "function removeAllowed(address _user) public onlyAllowed {\n        allowed[_user] = false;\n    }",
        "comments": [
            "",
            "    /// @notice Allowed users are able to remove allowed user",
            "    /// @dev owner is always allowed even if someone tries to remove it from allowed mapping",
            "    /// @param _user Address of allowed user",
            "    "
        ],
        "comt": "\n    /// @notice Allowed users are able to remove allowed user\n    /// @dev owner is always allowed even if someone tries to remove it from allowed mapping\n    /// @param _user Address of allowed user\n    ",
        "@notice": "Allowed users are able to remove allowed user",
        "@dev": "owner is always allowed even if someone tries to remove it from allowed mapping",
        "@param1": "_user Address of allowed user",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setChangePeriod",
        "visibility": "public",
        "args": [
            {
                "name": "_periodInDays",
                "type": "uint"
            }
        ],
        "func": "function setChangePeriod(uint _periodInDays) public onlyAllowed {\n        require(_periodInDays * 1 days > CHANGE_PERIOD);\n\n        CHANGE_PERIOD = _periodInDays * 1 days;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repayFor",
        "visibility": "public",
        "args": [
            {
                "name": "_exchangeData",
                "type": "SaverExchangeCore.ExchangeData memory"
            },
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_nextPrice",
                "type": "uint"
            },
            {
                "name": "_joinAddr",
                "type": "address"
            }
        ],
        "func": "function repayFor(\n        SaverExchangeCore.ExchangeData memory _exchangeData,\n        uint _cdpId,\n        uint _nextPrice,\n        address _joinAddr\n    ) public payable onlyApproved burnGas(REPAY_GAS_TOKEN) {\n\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Repay, _cdpId, _nextPrice);\n        require(isAllowed);\n\n        uint gasCost = calcGasCost(REPAY_GAS_COST);\n\n        address owner = subscriptionsContract.getOwner(_cdpId);\n\n        monitorProxyContract.callExecute{value: msg.value}(\n            owner,\n            mcdSaverTakerAddress,\n            abi.encodeWithSignature(\n            \"repayWithLoan((address,address,uint256,uint256,uint256,address,address,bytes,uint256),uint256,uint256,address)\",\n            _exchangeData, _cdpId, gasCost, _joinAddr));\n\n\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Repay, _cdpId, _nextPrice);\n        require(isGoodRatio);\n\n        returnEth();\n\n        logger.Log(address(this), owner, \"AutomaticMCDRepay\", abi.encode(ratioBefore, ratioAfter));\n    }",
        "comments": [
            "",
            "    /// @notice Bots call this method to repay for user when conditions are met",
            "    /// @dev If the contract ownes gas token it will try and use it for gas price reduction",
            "    "
        ],
        "comt": "\n    /// @notice Bots call this method to repay for user when conditions are met\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\n    ",
        "@notice": "Bots call this method to repay for user when conditions are met",
        "@dev": "If the contract ownes gas token it will try and use it for gas price reduction",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "boostFor",
        "visibility": "public",
        "args": [
            {
                "name": "_exchangeData",
                "type": "SaverExchangeCore.ExchangeData memory"
            },
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_nextPrice",
                "type": "uint"
            },
            {
                "name": "_joinAddr",
                "type": "address"
            }
        ],
        "func": "function boostFor(\n        SaverExchangeCore.ExchangeData memory _exchangeData,\n        uint _cdpId,\n        uint _nextPrice,\n        address _joinAddr\n    ) public payable onlyApproved burnGas(BOOST_GAS_TOKEN)  {\n\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Boost, _cdpId, _nextPrice);\n        require(isAllowed);\n\n        uint gasCost = calcGasCost(BOOST_GAS_COST);\n\n        address owner = subscriptionsContract.getOwner(_cdpId);\n\n        monitorProxyContract.callExecute{value: msg.value}(\n            owner,\n            mcdSaverTakerAddress,\n            abi.encodeWithSignature(\n            \"boostWithLoan((address,address,uint256,uint256,uint256,address,address,bytes,uint256),uint256,uint256,address)\",\n            _exchangeData, _cdpId, gasCost, _joinAddr));\n\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Boost, _cdpId, _nextPrice);\n        require(isGoodRatio);\n\n        returnEth();\n\n        logger.Log(address(this), owner, \"AutomaticMCDBoost\", abi.encode(ratioBefore, ratioAfter));\n    }",
        "comments": [
            "",
            "    /// @notice Bots call this method to boost for user when conditions are met",
            "    /// @dev If the contract ownes gas token it will try and use it for gas price reduction",
            "    "
        ],
        "comt": "\n    /// @notice Bots call this method to boost for user when conditions are met\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\n    ",
        "@notice": "Bots call this method to boost for user when conditions are met",
        "@dev": "If the contract ownes gas token it will try and use it for gas price reduction",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getOwner",
        "visibility": "public",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            }
        ],
        "func": "function getOwner(uint _cdpId) public view returns(address) {\n        return manager.owns(_cdpId);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCdpInfo",
        "visibility": "public",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_ilk",
                "type": "bytes32"
            }
        ],
        "func": "function getCdpInfo(uint _cdpId, bytes32 _ilk) public view returns (uint, uint) {\n        address urn = manager.urns(_cdpId);\n\n        (uint collateral, uint debt) = vat.urns(_ilk, urn);\n        (,uint rate,,,) = vat.ilks(_ilk);\n\n        return (collateral, rmul(debt, rate));\n    }",
        "comments": [
            "",
            "    /// @notice Gets CDP info (collateral, debt)",
            "    /// @param _cdpId Id of the CDP",
            "    /// @param _ilk Ilk of the CDP",
            "    "
        ],
        "comt": "\n    /// @notice Gets CDP info (collateral, debt)\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    ",
        "@notice": "Gets CDP info (collateral, debt)",
        "@param1": "_cdpId Id of the CDP",
        "@param2": "_ilk Ilk of the CDP",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPrice",
        "visibility": "public",
        "args": [
            {
                "name": "_ilk",
                "type": "bytes32"
            }
        ],
        "func": "function getPrice(bytes32 _ilk) public view returns (uint) {\n        (, uint mat) = spotter.ilks(_ilk);\n        (,,uint spot,,) = vat.ilks(_ilk);\n\n        return rmul(rmul(spot, spotter.par()), mat);\n    }",
        "comments": [
            "",
            "    /// @notice Gets a price of the asset",
            "    /// @param _ilk Ilk of the CDP",
            "    "
        ],
        "comt": "\n    /// @notice Gets a price of the asset\n    /// @param _ilk Ilk of the CDP\n    ",
        "@notice": "Gets a price of the asset",
        "@param1": "_ilk Ilk of the CDP",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getRatio",
        "visibility": "public",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_nextPrice",
                "type": "uint"
            }
        ],
        "func": "function getRatio(uint _cdpId, uint _nextPrice) public view returns (uint) {\n        bytes32 ilk = manager.ilks(_cdpId);\n        uint price = (_nextPrice == 0) ? getPrice(ilk) : _nextPrice;\n\n        (uint collateral, uint debt) = getCdpInfo(_cdpId, ilk);\n\n        if (debt == 0) return 0;\n\n        return rdiv(wmul(collateral, price), debt) / (10 ** 18);\n    }",
        "comments": [
            "",
            "    /// @notice Gets CDP ratio",
            "    /// @param _cdpId Id of the CDP",
            "    /// @param _nextPrice Next price for user",
            "    "
        ],
        "comt": "\n    /// @notice Gets CDP ratio\n    /// @param _cdpId Id of the CDP\n    /// @param _nextPrice Next price for user\n    ",
        "@notice": "Gets CDP ratio",
        "@param1": "_cdpId Id of the CDP",
        "@param2": "_nextPrice Next price for user",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "canCall",
        "visibility": "public",
        "args": [
            {
                "name": "_method",
                "type": "Method"
            },
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_nextPrice",
                "type": "uint"
            }
        ],
        "func": "function canCall(Method _method, uint _cdpId, uint _nextPrice) public view returns(bool, uint) {\n        bool subscribed;\n        CdpHolder memory holder;\n        (subscribed, holder) = subscriptionsContract.getCdpHolder(_cdpId);\n\n        // check if cdp is subscribed\n        if (!subscribed) return (false, 0);\n\n        // check if using next price is allowed\n        if (_nextPrice > 0 && !holder.nextPriceEnabled) return (false, 0);\n\n        // check if boost and boost allowed\n        if (_method == Method.Boost && !holder.boostEnabled) return (false, 0);\n\n        // check if owner is still owner\n        if (getOwner(_cdpId) != holder.owner) return (false, 0);\n\n        uint currRatio = getRatio(_cdpId, _nextPrice);\n\n        if (_method == Method.Repay) {\n            return (currRatio < holder.minRatio, currRatio);\n        } else if (_method == Method.Boost) {\n            return (currRatio > holder.maxRatio, currRatio);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Checks if Boost/Repay could be triggered for the CDP",
            "    /// @dev Called by MCDMonitor to enforce the min/max check",
            "    "
        ],
        "comt": "\n    /// @notice Checks if Boost/Repay could be triggered for the CDP\n    /// @dev Called by MCDMonitor to enforce the min/max check\n    ",
        "@notice": "Checks if Boost/Repay could be triggered for the CDP",
        "@dev": "Called by MCDMonitor to enforce the min/max check",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "ratioGoodAfter",
        "visibility": "public",
        "args": [
            {
                "name": "_method",
                "type": "Method"
            },
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_nextPrice",
                "type": "uint"
            }
        ],
        "func": "function ratioGoodAfter(Method _method, uint _cdpId, uint _nextPrice) public view returns(bool, uint) {\n        CdpHolder memory holder;\n\n        (, holder) = subscriptionsContract.getCdpHolder(_cdpId);\n\n        uint currRatio = getRatio(_cdpId, _nextPrice);\n\n        if (_method == Method.Repay) {\n            return (currRatio < holder.maxRatio, currRatio);\n        } else if (_method == Method.Boost) {\n            return (currRatio > holder.minRatio, currRatio);\n        }\n    }",
        "comments": [
            "",
            "    /// @dev After the Boost/Repay check if the ratio doesn't trigger another call",
            "    "
        ],
        "comt": "\n    /// @dev After the Boost/Repay check if the ratio doesn't trigger another call\n    ",
        "@dev": "After the Boost/Repay check if the ratio doesn't trigger another call",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "calcGasCost",
        "visibility": "public",
        "args": [
            {
                "name": "_gasAmount",
                "type": "uint"
            }
        ],
        "func": "function calcGasCost(uint _gasAmount) public view returns (uint) {\n        uint gasPrice = tx.gasprice <= MAX_GAS_PRICE ? tx.gasprice : MAX_GAS_PRICE;\n\n        return mul(gasPrice, _gasAmount);\n    }",
        "comments": [
            "",
            "    /// @notice Calculates gas cost (in Eth) of tx",
            "    /// @dev Gas price is limited to MAX_GAS_PRICE to prevent attack of draining user CDP",
            "    /// @param _gasAmount Amount of gas used for the tx",
            "    "
        ],
        "comt": "\n    /// @notice Calculates gas cost (in Eth) of tx\n    /// @dev Gas price is limited to MAX_GAS_PRICE to prevent attack of draining user CDP\n    /// @param _gasAmount Amount of gas used for the tx\n    ",
        "@notice": "Calculates gas cost (in Eth) of tx",
        "@dev": "Gas price is limited to MAX_GAS_PRICE to prevent attack of draining user CDP",
        "@param1": "_gasAmount Amount of gas used for the tx",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeBoostGasCost",
        "visibility": "public",
        "args": [
            {
                "name": "_gasCost",
                "type": "uint"
            }
        ],
        "func": "function changeBoostGasCost(uint _gasCost) public onlyOwner {\n        require(_gasCost < 3000000);\n\n        BOOST_GAS_COST = _gasCost;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeRepayGasCost",
        "visibility": "public",
        "args": [
            {
                "name": "_gasCost",
                "type": "uint"
            }
        ],
        "func": "function changeRepayGasCost(uint _gasCost) public onlyOwner {\n        require(_gasCost < 3000000);\n\n        REPAY_GAS_COST = _gasCost;\n    }",
        "comments": [
            "",
            "    /// @notice Allows owner to change gas cost for repay operation, but only up to 3 millions",
            "    /// @param _gasCost New gas cost for repay method",
            "    "
        ],
        "comt": "\n    /// @notice Allows owner to change gas cost for repay operation, but only up to 3 millions\n    /// @param _gasCost New gas cost for repay method\n    ",
        "@notice": "Allows owner to change gas cost for repay operation, but only up to 3 millions",
        "@param1": "_gasCost New gas cost for repay method",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeMaxGasPrice",
        "visibility": "public",
        "args": [
            {
                "name": "_maxGasPrice",
                "type": "uint"
            }
        ],
        "func": "function changeMaxGasPrice(uint _maxGasPrice) public onlyOwner {\n        require(_maxGasPrice < 500000000000);\n\n        MAX_GAS_PRICE = _maxGasPrice;\n    }",
        "comments": [
            "",
            "    /// @notice Allows owner to change max gas price",
            "    /// @param _maxGasPrice New max gas price",
            "    "
        ],
        "comt": "\n    /// @notice Allows owner to change max gas price\n    /// @param _maxGasPrice New max gas price\n    ",
        "@notice": "Allows owner to change max gas price",
        "@param1": "_maxGasPrice New max gas price",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeGasTokenAmount",
        "visibility": "public",
        "args": [
            {
                "name": "_gasAmount",
                "type": "uint"
            },
            {
                "name": "_isRepay",
                "type": "bool"
            }
        ],
        "func": "function changeGasTokenAmount(uint _gasAmount, bool _isRepay) public onlyOwner {\n        if (_isRepay) {\n            REPAY_GAS_TOKEN = _gasAmount;\n        } else {\n            BOOST_GAS_TOKEN = _gasAmount;\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Allows owner to change the amount of gas token burned per function call",
            "    /// @param _gasAmount Amount of gas token",
            "    /// @param _isRepay Flag to know for which function we are setting the gas token amount",
            "    "
        ],
        "comt": "\n    /// @notice Allows owner to change the amount of gas token burned per function call\n    /// @param _gasAmount Amount of gas token\n    /// @param _isRepay Flag to know for which function we are setting the gas token amount\n    ",
        "@notice": "Allows owner to change the amount of gas token burned per function call",
        "@param1": "_gasAmount Amount of gas token",
        "@param2": "_isRepay Flag to know for which function we are setting the gas token amount",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "verifyVaultNextPrice",
        "visibility": "public",
        "args": [
            {
                "name": "_nextPrice",
                "type": "uint"
            },
            {
                "name": "_cdpId",
                "type": "uint"
            }
        ],
        "func": "function verifyVaultNextPrice(uint _nextPrice, uint _cdpId) public view returns(bool) {\n        require(authorized[msg.sender]);\n\n        bytes32 ilk = manager.ilks(_cdpId);\n\n        return verifyNextPrice(_nextPrice, ilk);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "verifyNextPrice",
        "visibility": "public",
        "args": [
            {
                "name": "_nextPrice",
                "type": "uint"
            },
            {
                "name": "_ilk",
                "type": "bytes32"
            }
        ],
        "func": "function verifyNextPrice(uint _nextPrice, bytes32 _ilk) public view returns(bool) {\n        require(authorized[msg.sender]);\n\n        address osmAddress = osmMom.osms(_ilk);\n\n        uint whitelisted = Osm(osmAddress).bud(address(this));\n        // If contracts doesn't have access return true\n        if (whitelisted != 1) return true;\n\n        (bytes32 price, bool has) = Osm(osmAddress).peep();\n\n        return has ? uint(price) == _nextPrice : false;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setAuthorized",
        "visibility": "public",
        "args": [
            {
                "name": "_address",
                "type": "address"
            },
            {
                "name": "_allowed",
                "type": "bool"
            }
        ],
        "func": "function setAuthorized(address _address, bool _allowed) public onlyOwner {\n        authorized[_address] = _allowed;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "subscribe",
        "visibility": "external",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_minRatio",
                "type": "uint128"
            },
            {
                "name": "_maxRatio",
                "type": "uint128"
            },
            {
                "name": "_optimalBoost",
                "type": "uint128"
            },
            {
                "name": "_optimalRepay",
                "type": "uint128"
            },
            {
                "name": "_boostEnabled",
                "type": "bool"
            },
            {
                "name": "_nextPriceEnabled",
                "type": "bool"
            }
        ],
        "func": "function subscribe(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled, bool _nextPriceEnabled) external {}",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unsubscribe",
        "visibility": "external",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            }
        ],
        "func": "function unsubscribe(uint _cdpId) external {}",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "migrate",
        "visibility": "public",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_minRatio",
                "type": "uint128"
            },
            {
                "name": "_maxRatio",
                "type": "uint128"
            },
            {
                "name": "_optimalRatioBoost",
                "type": "uint128"
            },
            {
                "name": "_optimalRatioRepay",
                "type": "uint128"
            },
            {
                "name": "_boostEnabled",
                "type": "bool"
            },
            {
                "name": "_nextPriceEnabled",
                "type": "bool"
            },
            {
                "name": "_subscriptions",
                "type": "address"
            }
        ],
        "func": "function migrate(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalRatioBoost, uint128 _optimalRatioRepay, bool _boostEnabled, bool _nextPriceEnabled, address _subscriptions) public {\n        SubscriptionsInterfaceV2(OLD_SUBSCRIPTION).unsubscribe(_cdpId);\n\n        subscribe(_cdpId, _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled, _nextPriceEnabled, _subscriptions);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "subscribe",
        "visibility": "public",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_minRatio",
                "type": "uint128"
            },
            {
                "name": "_maxRatio",
                "type": "uint128"
            },
            {
                "name": "_optimalRatioBoost",
                "type": "uint128"
            },
            {
                "name": "_optimalRatioRepay",
                "type": "uint128"
            },
            {
                "name": "_boostEnabled",
                "type": "bool"
            },
            {
                "name": "_nextPriceEnabled",
                "type": "bool"
            },
            {
                "name": "_subscriptions",
                "type": "address"
            }
        ],
        "func": "function subscribe(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalRatioBoost, uint128 _optimalRatioRepay, bool _boostEnabled, bool _nextPriceEnabled, address _subscriptions) public {\n\n        address currAuthority = address(DSAuth(address(this)).authority());\n        DSGuard guard = DSGuard(currAuthority);\n\n        if (currAuthority == address(0)) {\n            guard = DSGuardFactory(FACTORY_ADDRESS).newGuard();\n            DSAuth(address(this)).setAuthority(DSAuthority(address(guard)));\n        }\n\n        guard.permit(MONITOR_PROXY_ADDRESS, address(this), bytes4(keccak256(\"execute(address,bytes)\")));\n\n        SubscriptionsInterfaceV2(_subscriptions).subscribe(_cdpId, _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled, _nextPriceEnabled);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "update",
        "visibility": "public",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_minRatio",
                "type": "uint128"
            },
            {
                "name": "_maxRatio",
                "type": "uint128"
            },
            {
                "name": "_optimalRatioBoost",
                "type": "uint128"
            },
            {
                "name": "_optimalRatioRepay",
                "type": "uint128"
            },
            {
                "name": "_boostEnabled",
                "type": "bool"
            },
            {
                "name": "_nextPriceEnabled",
                "type": "bool"
            },
            {
                "name": "_subscriptions",
                "type": "address"
            }
        ],
        "func": "function update(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalRatioBoost, uint128 _optimalRatioRepay, bool _boostEnabled, bool _nextPriceEnabled, address _subscriptions) public {\n        SubscriptionsInterfaceV2(_subscriptions).subscribe(_cdpId, _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled, _nextPriceEnabled);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unsubscribe",
        "visibility": "public",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_subscriptions",
                "type": "address"
            }
        ],
        "func": "function unsubscribe(uint _cdpId, address _subscriptions) public {\n        SubscriptionsInterfaceV2(_subscriptions).unsubscribe(_cdpId);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "subscribe",
        "visibility": "external",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_minRatio",
                "type": "uint128"
            },
            {
                "name": "_maxRatio",
                "type": "uint128"
            },
            {
                "name": "_optimalBoost",
                "type": "uint128"
            },
            {
                "name": "_optimalRepay",
                "type": "uint128"
            },
            {
                "name": "_boostEnabled",
                "type": "bool"
            },
            {
                "name": "_nextPriceEnabled",
                "type": "bool"
            }
        ],
        "func": "function subscribe(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled, bool _nextPriceEnabled) external {\n        require(isOwner(msg.sender, _cdpId), \"Must be called by Cdp owner\");\n\n        // if boost is not enabled, set max ratio to max uint\n        uint128 localMaxRatio = _boostEnabled ? _maxRatio : uint128(-1);\n        require(checkParams(manager.ilks(_cdpId), _minRatio, localMaxRatio), \"Must be correct params\");\n\n        SubPosition storage subInfo = subscribersPos[_cdpId];\n\n        CdpHolder memory subscription = CdpHolder({\n                minRatio: _minRatio,\n                maxRatio: localMaxRatio,\n                optimalRatioBoost: _optimalBoost,\n                optimalRatioRepay: _optimalRepay,\n                owner: msg.sender,\n                cdpId: _cdpId,\n                boostEnabled: _boostEnabled,\n                nextPriceEnabled: _nextPriceEnabled\n            });\n\n        changeIndex++;\n\n        if (subInfo.subscribed) {\n            subscribers[subInfo.arrPos] = subscription;\n\n            emit Updated(msg.sender, _cdpId);\n            emit ParamUpdates(msg.sender, _cdpId, _minRatio, localMaxRatio, _optimalBoost, _optimalRepay, _boostEnabled);\n        } else {\n            subscribers.push(subscription);\n\n            subInfo.arrPos = subscribers.length - 1;\n            subInfo.subscribed = true;\n\n            emit Subscribed(msg.sender, _cdpId);\n        }\n    }",
        "comments": [
            "",
            "    /// @dev Called by the DSProxy contract which owns the CDP",
            "    /// @notice Adds the users CDP in the list of subscriptions so it can be monitored",
            "    /// @param _cdpId Id of the CDP",
            "    /// @param _minRatio Minimum ratio below which repay is triggered",
            "    /// @param _maxRatio Maximum ratio after which boost is triggered",
            "    /// @param _optimalBoost Ratio amount which boost should target",
            "    /// @param _optimalRepay Ratio amount which repay should target",
            "    /// @param _boostEnabled Boolean determing if boost is enabled",
            "    /// @param _nextPriceEnabled Boolean determing if we can use nextPrice for this cdp",
            "    "
        ],
        "comt": "\n    /// @dev Called by the DSProxy contract which owns the CDP\n    /// @notice Adds the users CDP in the list of subscriptions so it can be monitored\n    /// @param _cdpId Id of the CDP\n    /// @param _minRatio Minimum ratio below which repay is triggered\n    /// @param _maxRatio Maximum ratio after which boost is triggered\n    /// @param _optimalBoost Ratio amount which boost should target\n    /// @param _optimalRepay Ratio amount which repay should target\n    /// @param _boostEnabled Boolean determing if boost is enabled\n    /// @param _nextPriceEnabled Boolean determing if we can use nextPrice for this cdp\n    ",
        "@dev": "Called by the DSProxy contract which owns the CDP",
        "@notice": "Adds the users CDP in the list of subscriptions so it can be monitored",
        "@param1": "_cdpId Id of the CDP",
        "@param2": "_minRatio Minimum ratio below which repay is triggered",
        "@param3": "_maxRatio Maximum ratio after which boost is triggered",
        "@param4": "_optimalBoost Ratio amount which boost should target",
        "@param5": "_optimalRepay Ratio amount which repay should target",
        "@param6": "_boostEnabled Boolean determing if boost is enabled",
        "@param7": "_nextPriceEnabled Boolean determing if we can use nextPrice for this cdp",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unsubscribe",
        "visibility": "external",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            }
        ],
        "func": "function unsubscribe(uint _cdpId) external {\n        require(isOwner(msg.sender, _cdpId), \"Must be called by Cdp owner\");\n\n        _unsubscribe(_cdpId);\n    }",
        "comments": [
            "",
            "    /// @notice Called by the users DSProxy",
            "    /// @dev Owner who subscribed cancels his subscription",
            "    "
        ],
        "comt": "\n    /// @notice Called by the users DSProxy\n    /// @dev Owner who subscribed cancels his subscription\n    ",
        "@notice": "Called by the users DSProxy",
        "@dev": "Owner who subscribed cancels his subscription",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getOwner",
        "visibility": "public",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            }
        ],
        "func": "function getOwner(uint _cdpId) public view returns(address) {\n        return manager.owns(_cdpId);\n    }",
        "comments": [
            "",
            "    /// @notice Returns an address that owns the CDP",
            "    /// @param _cdpId Id of the CDP",
            "    "
        ],
        "comt": "\n    /// @notice Returns an address that owns the CDP\n    /// @param _cdpId Id of the CDP\n    ",
        "@notice": "Returns an address that owns the CDP",
        "@param1": "_cdpId Id of the CDP",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getSubscribedInfo",
        "visibility": "public",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            }
        ],
        "func": "function getSubscribedInfo(uint _cdpId) public view returns(bool, uint128, uint128, uint128, uint128, address, uint coll, uint debt) {\n        SubPosition memory subInfo = subscribersPos[_cdpId];\n\n        if (!subInfo.subscribed) return (false, 0, 0, 0, 0, address(0), 0, 0);\n\n        (coll, debt) = saverProxy.getCdpInfo(manager, _cdpId, manager.ilks(_cdpId));\n\n        CdpHolder memory subscriber = subscribers[subInfo.arrPos];\n\n        return (\n            true,\n            subscriber.minRatio,\n            subscriber.maxRatio,\n            subscriber.optimalRatioRepay,\n            subscriber.optimalRatioBoost,\n            subscriber.owner,\n            coll,\n            debt\n        );\n    }",
        "comments": [
            "",
            "    /// @notice Helper method for the front to get all the info about the subscribed CDP",
            "    "
        ],
        "comt": "\n    /// @notice Helper method for the front to get all the info about the subscribed CDP\n    ",
        "@notice": "Helper method for the front to get all the info about the subscribed CDP",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCdpHolder",
        "visibility": "public",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            }
        ],
        "func": "function getCdpHolder(uint _cdpId) public view returns (bool subscribed, CdpHolder memory) {\n        SubPosition memory subInfo = subscribersPos[_cdpId];\n\n        if (!subInfo.subscribed) return (false, CdpHolder(0, 0, 0, 0, address(0), 0, false, false));\n\n        CdpHolder memory subscriber = subscribers[subInfo.arrPos];\n\n        return (true, subscriber);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getIlkInfo",
        "visibility": "public",
        "args": [
            {
                "name": "_ilk",
                "type": "bytes32"
            },
            {
                "name": "_cdpId",
                "type": "uint"
            }
        ],
        "func": "function getIlkInfo(bytes32 _ilk, uint _cdpId) public view returns(bytes32 ilk, uint art, uint rate, uint spot, uint line, uint dust, uint mat, uint par) {\n        // send either ilk or cdpId\n        if (_ilk == bytes32(0)) {\n            _ilk = manager.ilks(_cdpId);\n        }\n\n        ilk = _ilk;\n        (,mat) = spotter.ilks(_ilk);\n        par = spotter.par();\n        (art, rate, spot, line, dust) = vat.ilks(_ilk);\n    }",
        "comments": [
            "",
            "    /// @notice Helper method for the front to get the information about the ilk of a CDP",
            "    "
        ],
        "comt": "\n    /// @notice Helper method for the front to get the information about the ilk of a CDP\n    ",
        "@notice": "Helper method for the front to get the information about the ilk of a CDP",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getSubscribers",
        "visibility": "public",
        "args": [],
        "func": "function getSubscribers() public view returns (CdpHolder[] memory) {\n        return subscribers;\n    }",
        "comments": [
            "",
            "    /// @notice Helper method to return all the subscribed CDPs",
            "    "
        ],
        "comt": "\n    /// @notice Helper method to return all the subscribed CDPs\n    ",
        "@notice": "Helper method to return all the subscribed CDPs",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getSubscribersByPage",
        "visibility": "public",
        "args": [
            {
                "name": "_page",
                "type": "uint"
            },
            {
                "name": "_perPage",
                "type": "uint"
            }
        ],
        "func": "function getSubscribersByPage(uint _page, uint _perPage) public view returns (CdpHolder[] memory) {\n        CdpHolder[] memory holders = new CdpHolder[](_perPage);\n\n        uint start = _page * _perPage;\n        uint end = start + _perPage;\n\n        uint count = 0;\n        for (uint i=start; i<end; i++) {\n            holders[count] = subscribers[i];\n            count++;\n        }\n\n        return holders;\n    }",
        "comments": [
            "",
            "    /// @notice Helper method to return all the subscribed CDPs",
            "    "
        ],
        "comt": "\n    /// @notice Helper method to return all the subscribed CDPs\n    ",
        "@notice": "Helper method to return all the subscribed CDPs",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeMinRatios",
        "visibility": "public",
        "args": [
            {
                "name": "_ilk",
                "type": "bytes32"
            },
            {
                "name": "_newRatio",
                "type": "uint"
            }
        ],
        "func": "function changeMinRatios(bytes32 _ilk, uint _newRatio) public onlyOwner {\n        minLimits[_ilk] = _newRatio;\n    }",
        "comments": [
            "",
            "    ////////////// ADMIN METHODS ///////////////////",
            "",
            "    /// @notice Admin function to change a min. limit for an asset",
            "    "
        ],
        "comt": "\n    ////////////// ADMIN METHODS ///////////////////\n\n    /// @notice Admin function to change a min. limit for an asset\n    ",
        "@notice": "Admin function to change a min. limit for an asset",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unsubscribeByAdmin",
        "visibility": "public",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            }
        ],
        "func": "function unsubscribeByAdmin(uint _cdpId) public onlyOwner {\n        SubPosition storage subInfo = subscribersPos[_cdpId];\n\n        if (subInfo.subscribed) {\n            _unsubscribe(_cdpId);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Admin function to unsubscribe a CDP",
            "    "
        ],
        "comt": "\n    /// @notice Admin function to unsubscribe a CDP\n    ",
        "@notice": "Admin function to unsubscribe a CDP",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repay",
        "visibility": "public",
        "args": [
            {
                "name": "_exchangeData",
                "type": "SaverExchangeCore.ExchangeData memory"
            },
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_gasCost",
                "type": "uint"
            },
            {
                "name": "_joinAddr",
                "type": "address"
            }
        ],
        "func": "function repay(\n        SaverExchangeCore.ExchangeData memory _exchangeData,\n        uint _cdpId,\n        uint _gasCost,\n        address _joinAddr\n    ) public payable {\n\n        address owner = getOwner(manager, _cdpId);\n        bytes32 ilk = manager.ilks(_cdpId);\n\n        drawCollateral(_cdpId, _joinAddr, _exchangeData.srcAmount);\n\n        (, uint daiAmount) = _sell(_exchangeData);\n\n        uint daiAfterFee = sub(daiAmount, getFee(daiAmount, _gasCost, owner));\n\n        paybackDebt(_cdpId, ilk, daiAfterFee, owner);\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n\n        logger.Log(address(this), msg.sender, \"MCDRepay\", abi.encode(_cdpId, owner, _exchangeData.srcAmount, daiAmount));\n\n    }",
        "comments": [
            "",
            "    /// @notice Repay - draws collateral, converts to Dai and repays the debt",
            "    /// @dev Must be called by the DSProxy contract that owns the CDP",
            "    "
        ],
        "comt": "\n    /// @notice Repay - draws collateral, converts to Dai and repays the debt\n    /// @dev Must be called by the DSProxy contract that owns the CDP\n    ",
        "@notice": "Repay - draws collateral, converts to Dai and repays the debt",
        "@dev": "Must be called by the DSProxy contract that owns the CDP",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "boost",
        "visibility": "public",
        "args": [
            {
                "name": "_exchangeData",
                "type": "SaverExchangeCore.ExchangeData memory"
            },
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_gasCost",
                "type": "uint"
            },
            {
                "name": "_joinAddr",
                "type": "address"
            }
        ],
        "func": "function boost(\n        SaverExchangeCore.ExchangeData memory _exchangeData,\n        uint _cdpId,\n        uint _gasCost,\n        address _joinAddr\n    ) public payable {\n        address owner = getOwner(manager, _cdpId);\n        bytes32 ilk = manager.ilks(_cdpId);\n\n        uint daiDrawn = drawDai(_cdpId, ilk, _exchangeData.srcAmount);\n        uint daiAfterFee = sub(daiDrawn, getFee(daiDrawn, _gasCost, owner));\n\n        _exchangeData.srcAmount = daiAfterFee;\n        (, uint swapedColl) = _sell(_exchangeData);\n\n        addCollateral(_cdpId, _joinAddr, swapedColl);\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n\n        logger.Log(address(this), msg.sender, \"MCDBoost\", abi.encode(_cdpId, owner, _exchangeData.srcAmount, swapedColl));\n    }",
        "comments": [
            "",
            "    /// @notice Boost - draws Dai, converts to collateral and adds to CDP",
            "    /// @dev Must be called by the DSProxy contract that owns the CDP",
            "    "
        ],
        "comt": "\n    /// @notice Boost - draws Dai, converts to collateral and adds to CDP\n    /// @dev Must be called by the DSProxy contract that owns the CDP\n    ",
        "@notice": "Boost - draws Dai, converts to collateral and adds to CDP",
        "@dev": "Must be called by the DSProxy contract that owns the CDP",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMaxCollateral",
        "visibility": "public",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_ilk",
                "type": "bytes32"
            },
            {
                "name": "_joinAddr",
                "type": "address"
            }
        ],
        "func": "function getMaxCollateral(uint _cdpId, bytes32 _ilk, address _joinAddr) public view returns (uint) {\n        uint price = getPrice(_ilk);\n\n        (uint collateral, uint debt) = getCdpInfo(manager, _cdpId, _ilk);\n\n        (, uint mat) = Spotter(SPOTTER_ADDRESS).ilks(_ilk);\n\n        uint maxCollateral = sub(sub(collateral, (div(mul(mat, debt), price))), 10);\n\n        uint normalizeMaxCollateral = maxCollateral;\n\n        if (Join(_joinAddr).dec() != 18) {\n            normalizeMaxCollateral = maxCollateral / (10 ** (18 - Join(_joinAddr).dec()));\n        }\n\n        return normalizeMaxCollateral;\n    }",
        "comments": [
            "",
            "    /// @notice Gets the maximum amount of collateral available to draw",
            "    /// @param _cdpId Id of the CDP",
            "    /// @param _ilk Ilk of the CDP",
            "    /// @param _joinAddr Joind address of collateral",
            "    /// @dev Substracts 10 wei to aviod rounding error later on",
            "    "
        ],
        "comt": "\n    /// @notice Gets the maximum amount of collateral available to draw\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    /// @param _joinAddr Joind address of collateral\n    /// @dev Substracts 10 wei to aviod rounding error later on\n    ",
        "@notice": "Gets the maximum amount of collateral available to draw",
        "@param1": "_cdpId Id of the CDP",
        "@param2": "_ilk Ilk of the CDP",
        "@param3": "_joinAddr Joind address of collateral",
        "@dev": "Substracts 10 wei to aviod rounding error later on",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMaxDebt",
        "visibility": "public",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_ilk",
                "type": "bytes32"
            }
        ],
        "func": "function getMaxDebt(uint _cdpId, bytes32 _ilk) public virtual view returns (uint) {\n        uint price = getPrice(_ilk);\n\n        (, uint mat) = spotter.ilks(_ilk);\n        (uint collateral, uint debt) = getCdpInfo(manager, _cdpId, _ilk);\n\n        return sub(sub(div(mul(collateral, price), mat), debt), 10);\n    }",
        "comments": [
            "",
            "    /// @notice Gets the maximum amount of debt available to generate",
            "    /// @param _cdpId Id of the CDP",
            "    /// @param _ilk Ilk of the CDP",
            "    /// @dev Substracts 10 wei to aviod rounding error later on",
            "    "
        ],
        "comt": "\n    /// @notice Gets the maximum amount of debt available to generate\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    /// @dev Substracts 10 wei to aviod rounding error later on\n    ",
        "@notice": "Gets the maximum amount of debt available to generate",
        "@param1": "_cdpId Id of the CDP",
        "@param2": "_ilk Ilk of the CDP",
        "@dev": "Substracts 10 wei to aviod rounding error later on",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPrice",
        "visibility": "public",
        "args": [
            {
                "name": "_ilk",
                "type": "bytes32"
            }
        ],
        "func": "function getPrice(bytes32 _ilk) public view returns (uint) {\n        (, uint mat) = spotter.ilks(_ilk);\n        (,,uint spot,,) = vat.ilks(_ilk);\n\n        return rmul(rmul(spot, spotter.par()), mat);\n    }",
        "comments": [
            "",
            "    /// @notice Gets a price of the asset",
            "    /// @param _ilk Ilk of the CDP",
            "    "
        ],
        "comt": "\n    /// @notice Gets a price of the asset\n    /// @param _ilk Ilk of the CDP\n    ",
        "@notice": "Gets a price of the asset",
        "@param1": "_ilk Ilk of the CDP",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getRatio",
        "visibility": "public",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_ilk",
                "type": "bytes32"
            }
        ],
        "func": "function getRatio(uint _cdpId, bytes32 _ilk) public view returns (uint) {\n        uint price = getPrice( _ilk);\n\n        (uint collateral, uint debt) = getCdpInfo(manager, _cdpId, _ilk);\n\n        if (debt == 0) return 0;\n\n        return rdiv(wmul(collateral, price), debt);\n    }",
        "comments": [
            "",
            "    /// @notice Gets CDP ratio",
            "    /// @param _cdpId Id of the CDP",
            "    /// @param _ilk Ilk of the CDP",
            "    "
        ],
        "comt": "\n    /// @notice Gets CDP ratio\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    ",
        "@notice": "Gets CDP ratio",
        "@param1": "_cdpId Id of the CDP",
        "@param2": "_ilk Ilk of the CDP",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCdpDetailedInfo",
        "visibility": "public",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            }
        ],
        "func": "function getCdpDetailedInfo(uint _cdpId) public view returns (uint collateral, uint debt, uint price, bytes32 ilk) {\n        address urn = manager.urns(_cdpId);\n        ilk = manager.ilks(_cdpId);\n\n        (collateral, debt) = vat.urns(ilk, urn);\n        (,uint rate,,,) = vat.ilks(ilk);\n\n        debt = rmul(debt, rate);\n        price = getPrice(ilk);\n    }",
        "comments": [
            "",
            "    /// @notice Gets CDP info (collateral, debt, price, ilk)",
            "    /// @param _cdpId Id of the CDP",
            "    "
        ],
        "comt": "\n    /// @notice Gets CDP info (collateral, debt, price, ilk)\n    /// @param _cdpId Id of the CDP\n    ",
        "@notice": "Gets CDP info (collateral, debt, price, ilk)",
        "@param1": "_cdpId Id of the CDP",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCdpInfo",
        "visibility": "public",
        "args": [
            {
                "name": "_manager",
                "type": "Manager"
            },
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_ilk",
                "type": "bytes32"
            }
        ],
        "func": "function getCdpInfo(Manager _manager, uint _cdpId, bytes32 _ilk) public view returns (uint, uint) {\n        address vat = _manager.vat();\n        address urn = _manager.urns(_cdpId);\n\n        (uint collateral, uint debt) = Vat(vat).urns(_ilk, urn);\n        (,uint rate,,,) = Vat(vat).ilks(_ilk);\n\n        return (collateral, rmul(debt, rate));\n    }",
        "comments": [
            "",
            "    /// @notice Gets CDP info (collateral, debt)",
            "    /// @param _manager Manager contract",
            "    /// @param _cdpId Id of the CDP",
            "    /// @param _ilk Ilk of the CDP",
            "    "
        ],
        "comt": "\n    /// @notice Gets CDP info (collateral, debt)\n    /// @param _manager Manager contract\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    ",
        "@notice": "Gets CDP info (collateral, debt)",
        "@param1": "_manager Manager contract",
        "@param2": "_cdpId Id of the CDP",
        "@param3": "_ilk Ilk of the CDP",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getOwner",
        "visibility": "public",
        "args": [
            {
                "name": "_manager",
                "type": "Manager"
            },
            {
                "name": "_cdpId",
                "type": "uint"
            }
        ],
        "func": "function getOwner(Manager _manager, uint _cdpId) public view returns (address) {\n        DSProxy proxy = DSProxy(uint160(_manager.owns(_cdpId)));\n\n        return proxy.owner();\n    }",
        "comments": [
            "",
            "    /// @notice Address that owns the DSProxy that owns the CDP",
            "    /// @param _manager Manager contract",
            "    /// @param _cdpId Id of the CDP",
            "    "
        ],
        "comt": "\n    /// @notice Address that owns the DSProxy that owns the CDP\n    /// @param _manager Manager contract\n    /// @param _cdpId Id of the CDP\n    ",
        "@notice": "Address that owns the DSProxy that owns the CDP",
        "@param1": "_manager Manager contract",
        "@param2": "_cdpId Id of the CDP",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "daiBid",
        "visibility": "public",
        "args": [
            {
                "name": "_bidId",
                "type": "uint"
            },
            {
                "name": "_amount",
                "type": "uint"
            },
            {
                "name": "_flipper",
                "type": "address"
            }
        ],
        "func": "function daiBid(uint _bidId, uint _amount, address _flipper) public {\n        uint tendAmount = _amount * (10 ** 27);\n\n        joinDai(_amount);\n\n        (, uint lot, , , , , , ) = Flipper(_flipper).bids(_bidId);\n\n        Vat(VAT_ADDRESS).hope(_flipper);\n\n        Flipper(_flipper).tend(_bidId, lot, tendAmount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "collateralBid",
        "visibility": "public",
        "args": [
            {
                "name": "_bidId",
                "type": "uint"
            },
            {
                "name": "_amount",
                "type": "uint"
            },
            {
                "name": "_flipper",
                "type": "address"
            }
        ],
        "func": "function collateralBid(uint _bidId, uint _amount, address _flipper) public {\n        (uint bid, , , , , , , ) = Flipper(_flipper).bids(_bidId);\n\n        joinDai(bid / (10**27));\n\n        Vat(VAT_ADDRESS).hope(_flipper);\n\n        Flipper(_flipper).dent(_bidId, _amount, bid);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "closeBid",
        "visibility": "public",
        "args": [
            {
                "name": "_bidId",
                "type": "uint"
            },
            {
                "name": "_flipper",
                "type": "address"
            },
            {
                "name": "_joinAddr",
                "type": "address"
            }
        ],
        "func": "function closeBid(uint _bidId, address _flipper, address _joinAddr) public {\n        bytes32 ilk = Join(_joinAddr).ilk();\n\n        Flipper(_flipper).deal(_bidId);\n        uint amount = Vat(VAT_ADDRESS).gem(ilk, address(this));\n\n        Vat(VAT_ADDRESS).hope(_joinAddr);\n        Gem(_joinAddr).exit(msg.sender, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "exitCollateral",
        "visibility": "public",
        "args": [
            {
                "name": "_joinAddr",
                "type": "address"
            }
        ],
        "func": "function exitCollateral(address _joinAddr) public {\n        bytes32 ilk = Join(_joinAddr).ilk();\n\n        uint amount = Vat(VAT_ADDRESS).gem(ilk, address(this));\n\n        Vat(VAT_ADDRESS).hope(_joinAddr);\n        Gem(_joinAddr).exit(msg.sender, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "exitDai",
        "visibility": "public",
        "args": [],
        "func": "function exitDai() public {\n        uint amount = Vat(VAT_ADDRESS).dai(address(this)) / (10**27);\n\n        Vat(VAT_ADDRESS).hope(DAI_JOIN);\n        Gem(DAI_JOIN).exit(msg.sender, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawToken",
        "visibility": "public",
        "args": [
            {
                "name": "_token",
                "type": "address"
            }
        ],
        "func": "function withdrawToken(address _token) public {\n        uint balance = ERC20(_token).balanceOf(address(this));\n        ERC20(_token).transfer(msg.sender, balance);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawEth",
        "visibility": "public",
        "args": [],
        "func": "function withdrawEth() public {\n        uint balance = address(this).balance;\n        msg.sender.transfer(balance);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "executeOperation",
        "visibility": "external",
        "args": [
            {
                "name": "_reserve",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            },
            {
                "name": "_fee",
                "type": "uint256"
            },
            {
                "name": "_params",
                "type": "bytes calldata"
            }
        ],
        "func": "function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n\n        (\n            uint[8] memory numData,\n            address[5] memory addrData,\n            bytes memory callData,\n            address proxy,\n            bool toDai\n        )\n         = abi.decode(_params, (uint256[8],address[5],bytes,address,bool));\n\n        ExchangeData memory exchangeData = ExchangeData({\n            srcAddr: addrData[0],\n            destAddr: addrData[1],\n            srcAmount: numData[4],\n            destAmount: numData[5],\n            minPrice: numData[6],\n            wrapper: addrData[3],\n            exchangeAddr: addrData[2],\n            callData: callData,\n            price0x: numData[7]\n        });\n\n        CloseData memory closeData = CloseData({\n            cdpId: numData[0],\n            collAmount: numData[1],\n            daiAmount: numData[2],\n            minAccepted: numData[3],\n            joinAddr: addrData[4],\n            proxy: proxy,\n            flFee: _fee,\n            toDai: toDai,\n            reserve: _reserve,\n            amount: _amount\n        });\n\n        address user = DSProxy(payable(closeData.proxy)).owner();\n\n        closeCDP(closeData, exchangeData, user);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPrice",
        "visibility": "public",
        "args": [
            {
                "name": "_ilk",
                "type": "bytes32"
            }
        ],
        "func": "function getPrice(bytes32 _ilk) public view returns (uint256) {\n        (, uint256 mat) = spotter.ilks(_ilk);\n        (, , uint256 spot, , ) = vat.ilks(_ilk);\n\n        return rmul(rmul(spot, spotter.par()), mat);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "closeWithLoan",
        "visibility": "public",
        "args": [
            {
                "name": "_exchangeData",
                "type": "SaverExchangeCore.ExchangeData memory"
            },
            {
                "name": "_closeData",
                "type": "CloseData memory"
            },
            {
                "name": "mcdCloseFlashLoan",
                "type": "address payable"
            }
        ],
        "func": "function closeWithLoan(\n        SaverExchangeCore.ExchangeData memory _exchangeData,\n        CloseData memory _closeData,\n        address payable mcdCloseFlashLoan\n    ) public payable {\n        mcdCloseFlashLoan.transfer(msg.value); // 0x fee\n\n        if (_closeData.wholeDebt) {\n            _closeData.daiAmount = getAllDebt(\n                VAT_ADDRESS,\n                manager.urns(_closeData.cdpId),\n                manager.urns(_closeData.cdpId),\n                manager.ilks(_closeData.cdpId)\n            );\n\n            (_closeData.collAmount, )\n                = getCdpInfo(manager, _closeData.cdpId, manager.ilks(_closeData.cdpId));\n        }\n\n        manager.cdpAllow(_closeData.cdpId, mcdCloseFlashLoan, 1);\n\n        (uint[8] memory numData, address[5] memory addrData, bytes memory callData)\n                                            = _packData(_closeData, _exchangeData);\n        bytes memory paramsData = abi.encode(numData, addrData, callData, address(this), _closeData.toDai);\n\n        lendingPool.flashLoan(mcdCloseFlashLoan, DAI_ADDRESS, _closeData.daiAmount, paramsData);\n\n        manager.cdpAllow(_closeData.cdpId, mcdCloseFlashLoan, 0);\n\n        // If sub. to automatic protection unsubscribe\n        unsubscribe(SUBSCRIPTION_ADDRESS_NEW, _closeData.cdpId);\n\n        logger.Log(address(this), msg.sender, \"MCDClose\", abi.encode(_closeData.cdpId, _closeData.collAmount, _closeData.daiAmount, _closeData.toDai));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMaxDebt",
        "visibility": "public",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint256"
            },
            {
                "name": "_ilk",
                "type": "bytes32"
            }
        ],
        "func": "function getMaxDebt(uint256 _cdpId, bytes32 _ilk) public view returns (uint256) {\n        uint256 price = getPrice(_ilk);\n\n        (, uint256 mat) = spotter.ilks(_ilk);\n        (uint256 collateral, uint256 debt) = getCdpInfo(manager, _cdpId, _ilk);\n\n        return sub(wdiv(wmul(collateral, price), mat), debt);\n    }",
        "comments": [
            "",
            "    /// @notice Gets the maximum amount of debt available to generate",
            "    /// @param _cdpId Id of the CDP",
            "    /// @param _ilk Ilk of the CDP",
            "    "
        ],
        "comt": "\n    /// @notice Gets the maximum amount of debt available to generate\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    ",
        "@notice": "Gets the maximum amount of debt available to generate",
        "@param1": "_cdpId Id of the CDP",
        "@param2": "_ilk Ilk of the CDP",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPrice",
        "visibility": "public",
        "args": [
            {
                "name": "_ilk",
                "type": "bytes32"
            }
        ],
        "func": "function getPrice(bytes32 _ilk) public view returns (uint256) {\n        (, uint256 mat) = spotter.ilks(_ilk);\n        (, , uint256 spot, , ) = vat.ilks(_ilk);\n\n        return rmul(rmul(spot, spotter.par()), mat);\n    }",
        "comments": [
            "",
            "    /// @notice Gets a price of the asset",
            "    /// @param _ilk Ilk of the CDP",
            "    "
        ],
        "comt": "\n    /// @notice Gets a price of the asset\n    /// @param _ilk Ilk of the CDP\n    ",
        "@notice": "Gets a price of the asset",
        "@param1": "_ilk Ilk of the CDP",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "executeOperation",
        "visibility": "external",
        "args": [
            {
                "name": "_reserve",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            },
            {
                "name": "_fee",
                "type": "uint256"
            },
            {
                "name": "_params",
                "type": "bytes calldata"
            }
        ],
        "func": "function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n\n        //check the contract has the specified balance\n        require(_amount <= getBalanceInternal(address(this), _reserve),\n            \"Invalid balance for the contract\");\n\n        (\n            uint[6] memory numData,\n            address[5] memory addrData,\n            bytes memory callData,\n            address proxy\n        )\n         = abi.decode(_params, (uint256[6],address[5],bytes,address));\n\n        ExchangeData memory exchangeData = ExchangeData({\n            srcAddr: addrData[0],\n            destAddr: addrData[1],\n            srcAmount: numData[2],\n            destAmount: numData[3],\n            minPrice: numData[4],\n            wrapper: addrData[3],\n            exchangeAddr: addrData[2],\n            callData: callData,\n            price0x: numData[5]\n        });\n\n        openAndLeverage(numData[0], numData[1] + _fee, addrData[4], proxy, exchangeData);\n\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "openAndLeverage",
        "visibility": "public",
        "args": [
            {
                "name": "_collAmount",
                "type": "uint"
            },
            {
                "name": "_daiAmountAndFee",
                "type": "uint"
            },
            {
                "name": "_joinAddr",
                "type": "address"
            },
            {
                "name": "_proxy",
                "type": "address"
            },
            {
                "name": "_exchangeData",
                "type": "ExchangeData memory"
            }
        ],
        "func": "function openAndLeverage(\n        uint _collAmount,\n        uint _daiAmountAndFee,\n        address _joinAddr,\n        address _proxy,\n        ExchangeData memory _exchangeData\n    ) public {\n\n        uint dfsFee = getFee(_exchangeData.srcAmount, DSProxy(payable(_proxy)).owner());\n\n        _exchangeData.srcAmount = (_exchangeData.srcAmount - dfsFee);\n        (, uint256 collSwaped) = _sell(_exchangeData);\n\n        bytes32 ilk = Join(_joinAddr).ilk();\n\n        if (isEthJoinAddr(_joinAddr)) {\n            MCDCreateProxyActions(CREATE_PROXY_ACTIONS).openLockETHAndDraw{value: address(this).balance}(\n                MANAGER_ADDRESS,\n                JUG_ADDRESS,\n                _joinAddr,\n                DAI_JOIN_ADDRESS,\n                ilk,\n                _daiAmountAndFee,\n                _proxy\n            );\n        } else {\n            ERC20(address(Join(_joinAddr).gem())).safeApprove(CREATE_PROXY_ACTIONS, 0);\n            ERC20(address(Join(_joinAddr).gem())).safeApprove(CREATE_PROXY_ACTIONS, uint256(-1));\n\n            MCDCreateProxyActions(CREATE_PROXY_ACTIONS).openLockGemAndDraw(\n                MANAGER_ADDRESS,\n                JUG_ADDRESS,\n                _joinAddr,\n                DAI_JOIN_ADDRESS,\n                ilk,\n                (_collAmount + collSwaped),\n                _daiAmountAndFee,\n                true,\n                _proxy\n            );\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "daiJoin_join",
        "visibility": "public",
        "args": [
            {
                "name": "apt",
                "type": "address"
            },
            {
                "name": "urn",
                "type": "address"
            },
            {
                "name": "wad",
                "type": "uint256"
            }
        ],
        "func": "function daiJoin_join(address apt, address urn, uint256 wad) public {\n        // Gets DAI from the user's wallet\n        DaiJoinLike(apt).dai().transferFrom(msg.sender, address(this), wad);\n        // Approves adapter to take the DAI amount\n        DaiJoinLike(apt).dai().approve(apt, wad);\n        // Joins DAI into the vat\n        DaiJoinLike(apt).join(urn, wad);\n    }",
        "comments": [
            "",
            "    // Public functions",
            "    // solhint-disable-next-line func-name-mixedcase",
            "    "
        ],
        "comt": "\n    // Public functions\n    // solhint-disable-next-line func-name-mixedcase\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "gem",
                "type": "address"
            },
            {
                "name": "dst",
                "type": "address"
            },
            {
                "name": "wad",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address gem, address dst, uint256 wad) public {\n        GemLike(gem).transfer(dst, wad);\n    }",
        "comments": [
            "",
            "    // Public functions",
            "",
            "    "
        ],
        "comt": "\n    // Public functions\n\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "ethJoin_join",
        "visibility": "public",
        "args": [
            {
                "name": "apt",
                "type": "address"
            },
            {
                "name": "urn",
                "type": "address"
            }
        ],
        "func": "function ethJoin_join(address apt, address urn) public payable {\n        // Wraps ETH in WETH\n        GemJoinLike(apt).gem().deposit{value: msg.value}();\n        // Approves adapter to take the WETH amount\n        GemJoinLike(apt).gem().approve(address(apt), msg.value);\n        // Joins WETH collateral into the vat\n        GemJoinLike(apt).join(urn, msg.value);\n    }",
        "comments": [
            "",
            "    // solhint-disable-next-line func-name-mixedcase",
            "    "
        ],
        "comt": "\n    // solhint-disable-next-line func-name-mixedcase\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "gemJoin_join",
        "visibility": "public",
        "args": [
            {
                "name": "apt",
                "type": "address"
            },
            {
                "name": "urn",
                "type": "address"
            },
            {
                "name": "wad",
                "type": "uint256"
            },
            {
                "name": "transferFrom",
                "type": "bool"
            }
        ],
        "func": "function gemJoin_join(address apt, address urn, uint256 wad, bool transferFrom) public {\n        // Only executes for tokens that have approval/transferFrom implementation\n        if (transferFrom) {\n            // Gets token from the user's wallet\n            GemJoinLike(apt).gem().transferFrom(msg.sender, address(this), wad);\n            // Approves adapter to take the token amount\n            GemJoinLike(apt).gem().approve(apt, 0);\n            GemJoinLike(apt).gem().approve(apt, wad);\n        }\n        // Joins token collateral into the vat\n        GemJoinLike(apt).join(urn, wad);\n    }",
        "comments": [
            "",
            "    // solhint-disable-next-line func-name-mixedcase",
            "    "
        ],
        "comt": "\n    // solhint-disable-next-line func-name-mixedcase\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "hope",
        "visibility": "public",
        "args": [
            {
                "name": "obj",
                "type": "address"
            },
            {
                "name": "usr",
                "type": "address"
            }
        ],
        "func": "function hope(address obj, address usr) public {\n        HopeLike(obj).hope(usr);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "nope",
        "visibility": "public",
        "args": [
            {
                "name": "obj",
                "type": "address"
            },
            {
                "name": "usr",
                "type": "address"
            }
        ],
        "func": "function nope(address obj, address usr) public {\n        HopeLike(obj).nope(usr);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "open",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "ilk",
                "type": "bytes32"
            },
            {
                "name": "usr",
                "type": "address"
            }
        ],
        "func": "function open(address manager, bytes32 ilk, address usr) public returns (uint256 cdp) {\n        cdp = ManagerLike(manager).open(ilk, usr);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "give",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint256"
            },
            {
                "name": "usr",
                "type": "address"
            }
        ],
        "func": "function give(address manager, uint256 cdp, address usr) public {\n        ManagerLike(manager).give(cdp, usr);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "move",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint256"
            },
            {
                "name": "dst",
                "type": "address"
            },
            {
                "name": "rad",
                "type": "uint256"
            }
        ],
        "func": "function move(address manager, uint256 cdp, address dst, uint256 rad) public {\n        ManagerLike(manager).move(cdp, dst, rad);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "frob",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint256"
            },
            {
                "name": "dink",
                "type": "int256"
            },
            {
                "name": "dart",
                "type": "int256"
            }
        ],
        "func": "function frob(address manager, uint256 cdp, int256 dink, int256 dart) public {\n        ManagerLike(manager).frob(cdp, dink, dart);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lockETH",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "ethJoin",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint256"
            }
        ],
        "func": "function lockETH(address manager, address ethJoin, uint256 cdp) public payable {\n        // Receives ETH amount, converts it to WETH and joins it into the vat\n        ethJoin_join(ethJoin, address(this));\n        // Locks WETH amount into the CDP\n        VatLike(ManagerLike(manager).vat()).frob(\n            ManagerLike(manager).ilks(cdp),\n            ManagerLike(manager).urns(cdp),\n            address(this),\n            address(this),\n            toInt(msg.value),\n            0\n        );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lockGem",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "gemJoin",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint256"
            },
            {
                "name": "wad",
                "type": "uint256"
            },
            {
                "name": "transferFrom",
                "type": "bool"
            }
        ],
        "func": "function lockGem(address manager, address gemJoin, uint256 cdp, uint256 wad, bool transferFrom)\n        public\n    {\n        // Takes token amount from user's wallet and joins into the vat\n        gemJoin_join(gemJoin, address(this), wad, transferFrom);\n        // Locks token amount into the CDP\n        VatLike(ManagerLike(manager).vat()).frob(\n            ManagerLike(manager).ilks(cdp),\n            ManagerLike(manager).urns(cdp),\n            address(this),\n            address(this),\n            toInt(convertTo18(gemJoin, wad)),\n            0\n        );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "draw",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "jug",
                "type": "address"
            },
            {
                "name": "daiJoin",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint256"
            },
            {
                "name": "wad",
                "type": "uint256"
            }
        ],
        "func": "function draw(address manager, address jug, address daiJoin, uint256 cdp, uint256 wad) public {\n        address urn = ManagerLike(manager).urns(cdp);\n        address vat = ManagerLike(manager).vat();\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        // Generates debt in the CDP\n        frob(manager, cdp, 0, _getDrawDart(vat, jug, urn, ilk, wad));\n        // Moves the DAI amount (balance in the vat in rad) to proxy's address\n        move(manager, cdp, address(this), toRad(wad));\n        // Allows adapter to access to proxy's DAI balance in the vat\n        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\n            VatLike(vat).hope(daiJoin);\n        }\n        // Exits DAI to the user's wallet as a token\n        DaiJoinLike(daiJoin).exit(msg.sender, wad);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lockETHAndDraw",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "jug",
                "type": "address"
            },
            {
                "name": "ethJoin",
                "type": "address"
            },
            {
                "name": "daiJoin",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint256"
            },
            {
                "name": "wadD",
                "type": "uint256"
            }
        ],
        "func": "function lockETHAndDraw(\n        address manager,\n        address jug,\n        address ethJoin,\n        address daiJoin,\n        uint256 cdp,\n        uint256 wadD\n    ) public payable {\n        address urn = ManagerLike(manager).urns(cdp);\n        address vat = ManagerLike(manager).vat();\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        // Receives ETH amount, converts it to WETH and joins it into the vat\n        ethJoin_join(ethJoin, urn);\n        // Locks WETH amount into the CDP and generates debt\n        frob(manager, cdp, toInt(msg.value), _getDrawDart(vat, jug, urn, ilk, wadD));\n        // Moves the DAI amount (balance in the vat in rad) to proxy's address\n        move(manager, cdp, address(this), toRad(wadD));\n        // Allows adapter to access to proxy's DAI balance in the vat\n        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\n            VatLike(vat).hope(daiJoin);\n        }\n        // Exits DAI to the user's wallet as a token\n        DaiJoinLike(daiJoin).exit(msg.sender, wadD);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "openLockETHAndDraw",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "jug",
                "type": "address"
            },
            {
                "name": "ethJoin",
                "type": "address"
            },
            {
                "name": "daiJoin",
                "type": "address"
            },
            {
                "name": "ilk",
                "type": "bytes32"
            },
            {
                "name": "wadD",
                "type": "uint256"
            },
            {
                "name": "owner",
                "type": "address"
            }
        ],
        "func": "function openLockETHAndDraw(\n        address manager,\n        address jug,\n        address ethJoin,\n        address daiJoin,\n        bytes32 ilk,\n        uint256 wadD,\n        address owner\n    ) public payable returns (uint256 cdp) {\n        cdp = open(manager, ilk, address(this));\n        lockETHAndDraw(manager, jug, ethJoin, daiJoin, cdp, wadD);\n        give(manager, cdp, owner);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lockGemAndDraw",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "jug",
                "type": "address"
            },
            {
                "name": "gemJoin",
                "type": "address"
            },
            {
                "name": "daiJoin",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint256"
            },
            {
                "name": "wadC",
                "type": "uint256"
            },
            {
                "name": "wadD",
                "type": "uint256"
            },
            {
                "name": "transferFrom",
                "type": "bool"
            }
        ],
        "func": "function lockGemAndDraw(\n        address manager,\n        address jug,\n        address gemJoin,\n        address daiJoin,\n        uint256 cdp,\n        uint256 wadC,\n        uint256 wadD,\n        bool transferFrom\n    ) public {\n        address urn = ManagerLike(manager).urns(cdp);\n        address vat = ManagerLike(manager).vat();\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        // Takes token amount from user's wallet and joins into the vat\n        gemJoin_join(gemJoin, urn, wadC, transferFrom);\n        // Locks token amount into the CDP and generates debt\n        frob(\n            manager,\n            cdp,\n            toInt(convertTo18(gemJoin, wadC)),\n            _getDrawDart(vat, jug, urn, ilk, wadD)\n        );\n        // Moves the DAI amount (balance in the vat in rad) to proxy's address\n        move(manager, cdp, address(this), toRad(wadD));\n        // Allows adapter to access to proxy's DAI balance in the vat\n        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\n            VatLike(vat).hope(daiJoin);\n        }\n        // Exits DAI to the user's wallet as a token\n        DaiJoinLike(daiJoin).exit(msg.sender, wadD);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "openLockGemAndDraw",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "jug",
                "type": "address"
            },
            {
                "name": "gemJoin",
                "type": "address"
            },
            {
                "name": "daiJoin",
                "type": "address"
            },
            {
                "name": "ilk",
                "type": "bytes32"
            },
            {
                "name": "wadC",
                "type": "uint256"
            },
            {
                "name": "wadD",
                "type": "uint256"
            },
            {
                "name": "transferFrom",
                "type": "bool"
            },
            {
                "name": "owner",
                "type": "address"
            }
        ],
        "func": "function openLockGemAndDraw(\n        address manager,\n        address jug,\n        address gemJoin,\n        address daiJoin,\n        bytes32 ilk,\n        uint256 wadC,\n        uint256 wadD,\n        bool transferFrom,\n        address owner\n    ) public returns (uint256 cdp) {\n        cdp = open(manager, ilk, address(this));\n        lockGemAndDraw(manager, jug, gemJoin, daiJoin, cdp, wadC, wadD, transferFrom);\n        give(manager, cdp, owner);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "openWithLoan",
        "visibility": "public",
        "args": [
            {
                "name": "_exchangeData",
                "type": "SaverExchangeCore.ExchangeData memory"
            },
            {
                "name": "_createData",
                "type": "CreateData memory"
            }
        ],
        "func": "function openWithLoan(\n        SaverExchangeCore.ExchangeData memory _exchangeData,\n        CreateData memory _createData\n    ) public payable {\n\n        MCD_CREATE_FLASH_LOAN.transfer(msg.value); //0x fee\n\n\n        if (!isEthJoinAddr(_createData.joinAddr)) {\n            ERC20(getCollateralAddr(_createData.joinAddr)).safeTransferFrom(msg.sender, address(this), _createData.collAmount);\n            ERC20(getCollateralAddr(_createData.joinAddr)).safeTransfer(MCD_CREATE_FLASH_LOAN, _createData.collAmount);\n        }\n\n        (uint[6] memory numData, address[5] memory addrData, bytes memory callData)\n                                            = _packData(_createData, _exchangeData);\n        bytes memory paramsData = abi.encode(numData, addrData, callData, address(this));\n\n        lendingPool.flashLoan(MCD_CREATE_FLASH_LOAN, DAI_ADDRESS, _createData.daiAmount, paramsData);\n\n        logger.Log(address(this), msg.sender, \"MCDCreate\", abi.encode(manager.last(address(this)), _createData.collAmount, _createData.daiAmount));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "daiJoin_join",
        "visibility": "public",
        "args": [
            {
                "name": "apt",
                "type": "address"
            },
            {
                "name": "urn",
                "type": "address"
            },
            {
                "name": "wad",
                "type": "uint"
            }
        ],
        "func": "function daiJoin_join(address apt, address urn, uint wad) public {\n        // Gets DAI from the user's wallet\n        DaiJoinLike(apt).dai().transferFrom(msg.sender, address(this), wad);\n        // Approves adapter to take the DAI amount\n        DaiJoinLike(apt).dai().approve(apt, wad);\n        // Joins DAI into the vat\n        DaiJoinLike(apt).join(urn, wad);\n    }",
        "comments": [
            "",
            "    // Public functions",
            "",
            "    "
        ],
        "comt": "\n    // Public functions\n\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "gem",
                "type": "address"
            },
            {
                "name": "dst",
                "type": "address"
            },
            {
                "name": "wad",
                "type": "uint"
            }
        ],
        "func": "function transfer(address gem, address dst, uint wad) public {\n        GemLike(gem).transfer(dst, wad);\n    }",
        "comments": [
            "",
            "    // Public functions",
            "",
            "    "
        ],
        "comt": "\n    // Public functions\n\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "ethJoin_join",
        "visibility": "public",
        "args": [
            {
                "name": "apt",
                "type": "address"
            },
            {
                "name": "urn",
                "type": "address"
            }
        ],
        "func": "function ethJoin_join(address apt, address urn) public payable {\n        // Wraps ETH in WETH\n        GemJoinLike(apt).gem().deposit{value: msg.value}();\n        // Approves adapter to take the WETH amount\n        GemJoinLike(apt).gem().approve(address(apt), msg.value);\n        // Joins WETH collateral into the vat\n        GemJoinLike(apt).join(urn, msg.value);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "gemJoin_join",
        "visibility": "public",
        "args": [
            {
                "name": "apt",
                "type": "address"
            },
            {
                "name": "urn",
                "type": "address"
            },
            {
                "name": "wad",
                "type": "uint"
            },
            {
                "name": "transferFrom",
                "type": "bool"
            }
        ],
        "func": "function gemJoin_join(address apt, address urn, uint wad, bool transferFrom) public {\n        // Only executes for tokens that have approval/transferFrom implementation\n        if (transferFrom) {\n            // Gets token from the user's wallet\n            GemJoinLike(apt).gem().transferFrom(msg.sender, address(this), wad);\n            // Approves adapter to take the token amount\n            GemJoinLike(apt).gem().approve(apt, 0);\n            GemJoinLike(apt).gem().approve(apt, wad);\n        }\n        // Joins token collateral into the vat\n        GemJoinLike(apt).join(urn, wad);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "hope",
        "visibility": "public",
        "args": [
            {
                "name": "obj",
                "type": "address"
            },
            {
                "name": "usr",
                "type": "address"
            }
        ],
        "func": "function hope(\n        address obj,\n        address usr\n    ) public {\n        HopeLike(obj).hope(usr);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "nope",
        "visibility": "public",
        "args": [
            {
                "name": "obj",
                "type": "address"
            },
            {
                "name": "usr",
                "type": "address"
            }
        ],
        "func": "function nope(\n        address obj,\n        address usr\n    ) public {\n        HopeLike(obj).nope(usr);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "open",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "ilk",
                "type": "bytes32"
            },
            {
                "name": "usr",
                "type": "address"
            }
        ],
        "func": "function open(\n        address manager,\n        bytes32 ilk,\n        address usr\n    ) public returns (uint cdp) {\n        cdp = ManagerLike(manager).open(ilk, usr);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "give",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint"
            },
            {
                "name": "usr",
                "type": "address"
            }
        ],
        "func": "function give(\n        address manager,\n        uint cdp,\n        address usr\n    ) public {\n        ManagerLike(manager).give(cdp, usr);\n\n        emit CDPAction('give', cdp, 0, 0);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "giveToProxy",
        "visibility": "public",
        "args": [
            {
                "name": "proxyRegistry",
                "type": "address"
            },
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint"
            },
            {
                "name": "dst",
                "type": "address"
            }
        ],
        "func": "function giveToProxy(\n        address proxyRegistry,\n        address manager,\n        uint cdp,\n        address dst\n    ) public {\n        // Gets actual proxy address\n        address proxy = ProxyRegistryLike(proxyRegistry).proxies(dst);\n        // Checks if the proxy address already existed and dst address is still the owner\n        if (proxy == address(0) || ProxyLike(proxy).owner() != dst) {\n            uint csize;\n            assembly {\n                csize := extcodesize(dst)\n            }\n            // We want to avoid creating a proxy for a contract address that might not be able to handle proxies, then losing the CDP\n            require(csize == 0, \"Dst-is-a-contract\");\n            // Creates the proxy for the dst address\n            proxy = ProxyRegistryLike(proxyRegistry).build(dst);\n        }\n        // Transfers CDP to the dst proxy\n        give(manager, cdp, proxy);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cdpAllow",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint"
            },
            {
                "name": "usr",
                "type": "address"
            },
            {
                "name": "ok",
                "type": "uint"
            }
        ],
        "func": "function cdpAllow(\n        address manager,\n        uint cdp,\n        address usr,\n        uint ok\n    ) public {\n        ManagerLike(manager).cdpAllow(cdp, usr, ok);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "urnAllow",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "usr",
                "type": "address"
            },
            {
                "name": "ok",
                "type": "uint"
            }
        ],
        "func": "function urnAllow(\n        address manager,\n        address usr,\n        uint ok\n    ) public {\n        ManagerLike(manager).urnAllow(usr, ok);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "flux",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint"
            },
            {
                "name": "dst",
                "type": "address"
            },
            {
                "name": "wad",
                "type": "uint"
            }
        ],
        "func": "function flux(\n        address manager,\n        uint cdp,\n        address dst,\n        uint wad\n    ) public {\n        ManagerLike(manager).flux(cdp, dst, wad);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "move",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint"
            },
            {
                "name": "dst",
                "type": "address"
            },
            {
                "name": "rad",
                "type": "uint"
            }
        ],
        "func": "function move(\n        address manager,\n        uint cdp,\n        address dst,\n        uint rad\n    ) public {\n        ManagerLike(manager).move(cdp, dst, rad);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "frob",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint"
            },
            {
                "name": "dink",
                "type": "int"
            },
            {
                "name": "dart",
                "type": "int"
            }
        ],
        "func": "function frob(\n        address manager,\n        uint cdp,\n        int dink,\n        int dart\n    ) public {\n        ManagerLike(manager).frob(cdp, dink, dart);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "quit",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint"
            },
            {
                "name": "dst",
                "type": "address"
            }
        ],
        "func": "function quit(\n        address manager,\n        uint cdp,\n        address dst\n    ) public {\n        ManagerLike(manager).quit(cdp, dst);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "enter",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "src",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint"
            }
        ],
        "func": "function enter(\n        address manager,\n        address src,\n        uint cdp\n    ) public {\n        ManagerLike(manager).enter(src, cdp);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "shift",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "cdpSrc",
                "type": "uint"
            },
            {
                "name": "cdpOrg",
                "type": "uint"
            }
        ],
        "func": "function shift(\n        address manager,\n        uint cdpSrc,\n        uint cdpOrg\n    ) public {\n        ManagerLike(manager).shift(cdpSrc, cdpOrg);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "makeGemBag",
        "visibility": "public",
        "args": [
            {
                "name": "gemJoin",
                "type": "address"
            }
        ],
        "func": "function makeGemBag(\n        address gemJoin\n    ) public returns (address bag) {\n        bag = GNTJoinLike(gemJoin).make(address(this));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lockETH",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "ethJoin",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint"
            }
        ],
        "func": "function lockETH(\n        address manager,\n        address ethJoin,\n        uint cdp\n    ) public payable {\n        // Receives ETH amount, converts it to WETH and joins it into the vat\n        ethJoin_join(ethJoin, address(this));\n        // Locks WETH amount into the CDP\n        VatLike(ManagerLike(manager).vat()).frob(\n            ManagerLike(manager).ilks(cdp),\n            ManagerLike(manager).urns(cdp),\n            address(this),\n            address(this),\n            toInt(msg.value),\n            0\n        );\n\n        emit CDPAction('lockETH', cdp, msg.value, 0);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lockGem",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "gemJoin",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint"
            },
            {
                "name": "wad",
                "type": "uint"
            },
            {
                "name": "transferFrom",
                "type": "bool"
            }
        ],
        "func": "function lockGem(\n        address manager,\n        address gemJoin,\n        uint cdp,\n        uint wad,\n        bool transferFrom\n    ) public {\n        // Takes token amount from user's wallet and joins into the vat\n        gemJoin_join(gemJoin, address(this), wad, transferFrom);\n        // Locks token amount into the CDP\n        VatLike(ManagerLike(manager).vat()).frob(\n            ManagerLike(manager).ilks(cdp),\n            ManagerLike(manager).urns(cdp),\n            address(this),\n            address(this),\n            toInt(convertTo18(gemJoin, wad)),\n            0\n        );\n\n        emit CDPAction('lockGem', cdp, wad, 0);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "freeETH",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "ethJoin",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint"
            },
            {
                "name": "wad",
                "type": "uint"
            }
        ],
        "func": "function freeETH(\n        address manager,\n        address ethJoin,\n        uint cdp,\n        uint wad\n    ) public {\n        // Unlocks WETH amount from the CDP\n        frob(manager, cdp, -toInt(wad), 0);\n        // Moves the amount from the CDP urn to proxy's address\n        flux(manager, cdp, address(this), wad);\n        // Exits WETH amount to proxy address as a token\n        GemJoinLike(ethJoin).exit(address(this), wad);\n        // Converts WETH to ETH\n        GemJoinLike(ethJoin).gem().withdraw(wad);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wad);\n\n        emit CDPAction('freeETH', cdp, wad, 0);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "freeGem",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "gemJoin",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint"
            },
            {
                "name": "wad",
                "type": "uint"
            }
        ],
        "func": "function freeGem(\n        address manager,\n        address gemJoin,\n        uint cdp,\n        uint wad\n    ) public {\n        uint wad18 = convertTo18(gemJoin, wad);\n        // Unlocks token amount from the CDP\n        frob(manager, cdp, -toInt(wad18), 0);\n        // Moves the amount from the CDP urn to proxy's address\n        flux(manager, cdp, address(this), wad18);\n        // Exits token amount to the user's wallet as a token\n        GemJoinLike(gemJoin).exit(msg.sender, wad);\n\n        emit CDPAction('freeGem', cdp, wad, 0);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "exitETH",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "ethJoin",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint"
            },
            {
                "name": "wad",
                "type": "uint"
            }
        ],
        "func": "function exitETH(\n        address manager,\n        address ethJoin,\n        uint cdp,\n        uint wad\n    ) public {\n        // Moves the amount from the CDP urn to proxy's address\n        flux(manager, cdp, address(this), wad);\n\n        // Exits WETH amount to proxy address as a token\n        GemJoinLike(ethJoin).exit(address(this), wad);\n        // Converts WETH to ETH\n        GemJoinLike(ethJoin).gem().withdraw(wad);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wad);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "exitGem",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "gemJoin",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint"
            },
            {
                "name": "wad",
                "type": "uint"
            }
        ],
        "func": "function exitGem(\n        address manager,\n        address gemJoin,\n        uint cdp,\n        uint wad\n    ) public {\n        // Moves the amount from the CDP urn to proxy's address\n        flux(manager, cdp, address(this), convertTo18(gemJoin, wad));\n\n        // Exits token amount to the user's wallet as a token\n        GemJoinLike(gemJoin).exit(msg.sender, wad);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "draw",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "jug",
                "type": "address"
            },
            {
                "name": "daiJoin",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint"
            },
            {
                "name": "wad",
                "type": "uint"
            }
        ],
        "func": "function draw(\n        address manager,\n        address jug,\n        address daiJoin,\n        uint cdp,\n        uint wad\n    ) public {\n        address urn = ManagerLike(manager).urns(cdp);\n        address vat = ManagerLike(manager).vat();\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        // Generates debt in the CDP\n        frob(manager, cdp, 0, _getDrawDart(vat, jug, urn, ilk, wad));\n        // Moves the DAI amount (balance in the vat in rad) to proxy's address\n        move(manager, cdp, address(this), toRad(wad));\n        // Allows adapter to access to proxy's DAI balance in the vat\n        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\n            VatLike(vat).hope(daiJoin);\n        }\n        // Exits DAI to the user's wallet as a token\n        DaiJoinLike(daiJoin).exit(msg.sender, wad);\n\n        emit CDPAction('draw', cdp, 0, wad);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wipe",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "daiJoin",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint"
            },
            {
                "name": "wad",
                "type": "uint"
            }
        ],
        "func": "function wipe(\n        address manager,\n        address daiJoin,\n        uint cdp,\n        uint wad\n    ) public {\n        address vat = ManagerLike(manager).vat();\n        address urn = ManagerLike(manager).urns(cdp);\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n\n        address own = ManagerLike(manager).owns(cdp);\n        if (own == address(this) || ManagerLike(manager).cdpCan(own, cdp, address(this)) == 1) {\n            // Joins DAI amount into the vat\n            daiJoin_join(daiJoin, urn, wad);\n            // Paybacks debt to the CDP\n            frob(manager, cdp, 0, _getWipeDart(vat, VatLike(vat).dai(urn), urn, ilk));\n        } else {\n             // Joins DAI amount into the vat\n            daiJoin_join(daiJoin, address(this), wad);\n            // Paybacks debt to the CDP\n            VatLike(vat).frob(\n                ilk,\n                urn,\n                address(this),\n                address(this),\n                0,\n                _getWipeDart(vat, wad * RAY, urn, ilk)\n            );\n        }\n\n        emit CDPAction('wipe', cdp, 0, wad);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wipeAll",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "daiJoin",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint"
            }
        ],
        "func": "function wipeAll(\n        address manager,\n        address daiJoin,\n        uint cdp\n    ) public {\n        address vat = ManagerLike(manager).vat();\n        address urn = ManagerLike(manager).urns(cdp);\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        (, uint art) = VatLike(vat).urns(ilk, urn);\n\n        address own = ManagerLike(manager).owns(cdp);\n        if (own == address(this) || ManagerLike(manager).cdpCan(own, cdp, address(this)) == 1) {\n            // Joins DAI amount into the vat\n            daiJoin_join(daiJoin, urn, _getWipeAllWad(vat, urn, urn, ilk));\n            // Paybacks debt to the CDP\n            frob(manager, cdp, 0, -int(art));\n        } else {\n            // Joins DAI amount into the vat\n            daiJoin_join(daiJoin, address(this), _getWipeAllWad(vat, address(this), urn, ilk));\n            // Paybacks debt to the CDP\n            VatLike(vat).frob(\n                ilk,\n                urn,\n                address(this),\n                address(this),\n                0,\n                -int(art)\n            );\n        }\n\n        emit CDPAction('wipeAll', cdp, 0, art);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lockETHAndDraw",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "jug",
                "type": "address"
            },
            {
                "name": "ethJoin",
                "type": "address"
            },
            {
                "name": "daiJoin",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint"
            },
            {
                "name": "wadD",
                "type": "uint"
            }
        ],
        "func": "function lockETHAndDraw(\n        address manager,\n        address jug,\n        address ethJoin,\n        address daiJoin,\n        uint cdp,\n        uint wadD\n    ) public payable {\n        address urn = ManagerLike(manager).urns(cdp);\n        address vat = ManagerLike(manager).vat();\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        // Receives ETH amount, converts it to WETH and joins it into the vat\n        ethJoin_join(ethJoin, urn);\n        // Locks WETH amount into the CDP and generates debt\n        frob(manager, cdp, toInt(msg.value), _getDrawDart(vat, jug, urn, ilk, wadD));\n        // Moves the DAI amount (balance in the vat in rad) to proxy's address\n        move(manager, cdp, address(this), toRad(wadD));\n        // Allows adapter to access to proxy's DAI balance in the vat\n        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\n            VatLike(vat).hope(daiJoin);\n        }\n        // Exits DAI to the user's wallet as a token\n        DaiJoinLike(daiJoin).exit(msg.sender, wadD);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "openLockETHAndDraw",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "jug",
                "type": "address"
            },
            {
                "name": "ethJoin",
                "type": "address"
            },
            {
                "name": "daiJoin",
                "type": "address"
            },
            {
                "name": "ilk",
                "type": "bytes32"
            },
            {
                "name": "wadD",
                "type": "uint"
            }
        ],
        "func": "function openLockETHAndDraw(\n        address manager,\n        address jug,\n        address ethJoin,\n        address daiJoin,\n        bytes32 ilk,\n        uint wadD\n    ) public payable returns (uint cdp) {\n        cdp = open(manager, ilk, address(this));\n        lockETHAndDraw(manager, jug, ethJoin, daiJoin, cdp, wadD);\n\n        emit CDPAction('openLockETHAndDraw', cdp, msg.value, wadD);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lockGemAndDraw",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "jug",
                "type": "address"
            },
            {
                "name": "gemJoin",
                "type": "address"
            },
            {
                "name": "daiJoin",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint"
            },
            {
                "name": "wadC",
                "type": "uint"
            },
            {
                "name": "wadD",
                "type": "uint"
            },
            {
                "name": "transferFrom",
                "type": "bool"
            }
        ],
        "func": "function lockGemAndDraw(\n        address manager,\n        address jug,\n        address gemJoin,\n        address daiJoin,\n        uint cdp,\n        uint wadC,\n        uint wadD,\n        bool transferFrom\n    ) public {\n        address urn = ManagerLike(manager).urns(cdp);\n        address vat = ManagerLike(manager).vat();\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        // Takes token amount from user's wallet and joins into the vat\n        gemJoin_join(gemJoin, urn, wadC, transferFrom);\n        // Locks token amount into the CDP and generates debt\n        frob(manager, cdp, toInt(convertTo18(gemJoin, wadC)), _getDrawDart(vat, jug, urn, ilk, wadD));\n        // Moves the DAI amount (balance in the vat in rad) to proxy's address\n        move(manager, cdp, address(this), toRad(wadD));\n        // Allows adapter to access to proxy's DAI balance in the vat\n        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\n            VatLike(vat).hope(daiJoin);\n        }\n        // Exits DAI to the user's wallet as a token\n        DaiJoinLike(daiJoin).exit(msg.sender, wadD);\n\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "openLockGemAndDraw",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "jug",
                "type": "address"
            },
            {
                "name": "gemJoin",
                "type": "address"
            },
            {
                "name": "daiJoin",
                "type": "address"
            },
            {
                "name": "ilk",
                "type": "bytes32"
            },
            {
                "name": "wadC",
                "type": "uint"
            },
            {
                "name": "wadD",
                "type": "uint"
            },
            {
                "name": "transferFrom",
                "type": "bool"
            }
        ],
        "func": "function openLockGemAndDraw(\n        address manager,\n        address jug,\n        address gemJoin,\n        address daiJoin,\n        bytes32 ilk,\n        uint wadC,\n        uint wadD,\n        bool transferFrom\n    ) public returns (uint cdp) {\n        cdp = open(manager, ilk, address(this));\n        lockGemAndDraw(manager, jug, gemJoin, daiJoin, cdp, wadC, wadD, transferFrom);\n\n        emit CDPAction('openLockGemAndDraw', cdp, wadC, wadD);\n\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wipeAllAndFreeETH",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "ethJoin",
                "type": "address"
            },
            {
                "name": "daiJoin",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint"
            },
            {
                "name": "wadC",
                "type": "uint"
            }
        ],
        "func": "function wipeAllAndFreeETH(\n        address manager,\n        address ethJoin,\n        address daiJoin,\n        uint cdp,\n        uint wadC\n    ) public {\n        address vat = ManagerLike(manager).vat();\n        address urn = ManagerLike(manager).urns(cdp);\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        (, uint art) = VatLike(vat).urns(ilk, urn);\n\n        // Joins DAI amount into the vat\n        daiJoin_join(daiJoin, urn, _getWipeAllWad(vat, urn, urn, ilk));\n        // Paybacks debt to the CDP and unlocks WETH amount from it\n        frob(\n            manager,\n            cdp,\n            -toInt(wadC),\n            -int(art)\n        );\n        // Moves the amount from the CDP urn to proxy's address\n        flux(manager, cdp, address(this), wadC);\n        // Exits WETH amount to proxy address as a token\n        GemJoinLike(ethJoin).exit(address(this), wadC);\n        // Converts WETH to ETH\n        GemJoinLike(ethJoin).gem().withdraw(wadC);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wadC);\n\n        emit CDPAction('wipeAllAndFreeETH', cdp, wadC, art);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wipeAndFreeGem",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "gemJoin",
                "type": "address"
            },
            {
                "name": "daiJoin",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint"
            },
            {
                "name": "wadC",
                "type": "uint"
            },
            {
                "name": "wadD",
                "type": "uint"
            }
        ],
        "func": "function wipeAndFreeGem(\n        address manager,\n        address gemJoin,\n        address daiJoin,\n        uint cdp,\n        uint wadC,\n        uint wadD\n    ) public {\n        address urn = ManagerLike(manager).urns(cdp);\n        // Joins DAI amount into the vat\n        daiJoin_join(daiJoin, urn, wadD);\n        uint wad18 = convertTo18(gemJoin, wadC);\n        // Paybacks debt to the CDP and unlocks token amount from it\n        frob(\n            manager,\n            cdp,\n            -toInt(wad18),\n            _getWipeDart(ManagerLike(manager).vat(), VatLike(ManagerLike(manager).vat()).dai(urn), urn, ManagerLike(manager).ilks(cdp))\n        );\n        // Moves the amount from the CDP urn to proxy's address\n        flux(manager, cdp, address(this), wad18);\n        // Exits token amount to the user's wallet as a token\n        GemJoinLike(gemJoin).exit(msg.sender, wadC);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wipeAllAndFreeGem",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "gemJoin",
                "type": "address"
            },
            {
                "name": "daiJoin",
                "type": "address"
            },
            {
                "name": "cdp",
                "type": "uint"
            },
            {
                "name": "wadC",
                "type": "uint"
            }
        ],
        "func": "function wipeAllAndFreeGem(\n        address manager,\n        address gemJoin,\n        address daiJoin,\n        uint cdp,\n        uint wadC\n    ) public {\n        address vat = ManagerLike(manager).vat();\n        address urn = ManagerLike(manager).urns(cdp);\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        (, uint art) = VatLike(vat).urns(ilk, urn);\n\n        // Joins DAI amount into the vat\n        daiJoin_join(daiJoin, urn, _getWipeAllWad(vat, urn, urn, ilk));\n        uint wad18 = convertTo18(gemJoin, wadC);\n        // Paybacks debt to the CDP and unlocks token amount from it\n        frob(\n            manager,\n            cdp,\n            -toInt(wad18),\n            -int(art)\n        );\n        // Moves the amount from the CDP urn to proxy's address\n        flux(manager, cdp, address(this), wad18);\n        // Exits token amount to the user's wallet as a token\n        GemJoinLike(gemJoin).exit(msg.sender, wadC);\n\n        emit CDPAction('wipeAllAndFreeGem', cdp, wadC, art);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createProxyAndCDP",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "jug",
                "type": "address"
            },
            {
                "name": "ethJoin",
                "type": "address"
            },
            {
                "name": "daiJoin",
                "type": "address"
            },
            {
                "name": "ilk",
                "type": "bytes32"
            },
            {
                "name": "wadD",
                "type": "uint"
            },
            {
                "name": "registry",
                "type": "address"
            }
        ],
        "func": "function createProxyAndCDP(\n        address manager,\n        address jug,\n        address ethJoin,\n        address daiJoin,\n        bytes32 ilk,\n        uint wadD,\n        address registry\n        ) public payable returns(uint) {\n\n            address proxy = ProxyRegistryInterface(registry).build(msg.sender);\n\n            uint cdp = openLockETHAndDraw(manager,\n                jug,\n                ethJoin,\n                daiJoin,\n                ilk,\n                wadD\n                );\n\n            give(manager, cdp, address(proxy));\n\n            return cdp;\n\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createProxyAndGemCDP",
        "visibility": "public",
        "args": [
            {
                "name": "manager",
                "type": "address"
            },
            {
                "name": "jug",
                "type": "address"
            },
            {
                "name": "gemJoin",
                "type": "address"
            },
            {
                "name": "daiJoin",
                "type": "address"
            },
            {
                "name": "ilk",
                "type": "bytes32"
            },
            {
                "name": "wadC",
                "type": "uint"
            },
            {
                "name": "wadD",
                "type": "uint"
            },
            {
                "name": "transferFrom",
                "type": "bool"
            },
            {
                "name": "registry",
                "type": "address"
            }
        ],
        "func": "function createProxyAndGemCDP(\n        address manager,\n        address jug,\n        address gemJoin,\n        address daiJoin,\n        bytes32 ilk,\n        uint wadC,\n        uint wadD,\n        bool transferFrom,\n        address registry\n        ) public returns(uint) {\n\n\n            address proxy = ProxyRegistryInterface(registry).build(msg.sender);\n\n            uint cdp = openLockGemAndDraw(manager,\n                jug,\n                gemJoin,\n                daiJoin,\n                ilk,\n                wadC,\n                wadD,\n                transferFrom);\n\n            give(manager, cdp, address(proxy));\n\n            return cdp;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "executeOperation",
        "visibility": "external",
        "args": [
            {
                "name": "_reserve",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            },
            {
                "name": "_fee",
                "type": "uint256"
            },
            {
                "name": "_params",
                "type": "bytes calldata"
            }
        ],
        "func": "function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n\n        //check the contract has the specified balance\n        require(_amount <= getBalanceInternal(address(this), _reserve),\n            \"Invalid balance for the contract\");\n\n        (\n            bytes memory exDataBytes,\n            uint cdpId,\n            uint gasCost,\n            address joinAddr,\n            bool isRepay\n        )\n         = abi.decode(_params, (bytes,uint256,uint256,address,bool));\n\n        ExchangeData memory exchangeData = unpackExchangeData(exDataBytes);\n\n        SaverData memory saverData = SaverData({\n            cdpId: cdpId,\n            gasCost: gasCost,\n            loanAmount: _amount,\n            fee: _fee,\n            joinAddr: joinAddr\n        });\n\n        if (isRepay) {\n            repayWithLoan(exchangeData, saverData);\n        } else {\n            boostWithLoan(exchangeData, saverData);\n        }\n\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "boostWithLoan",
        "visibility": "public",
        "args": [
            {
                "name": "_exchangeData",
                "type": "SaverExchangeCore.ExchangeData memory"
            },
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_gasCost",
                "type": "uint"
            },
            {
                "name": "_joinAddr",
                "type": "address"
            }
        ],
        "func": "function boostWithLoan(\n        SaverExchangeCore.ExchangeData memory _exchangeData,\n        uint _cdpId,\n        uint _gasCost,\n        address _joinAddr\n    ) public payable burnGas(25) {\n        uint256 maxDebt = getMaxDebt(_cdpId, manager.ilks(_cdpId));\n\n        uint maxLiq = getAvailableLiquidity(DAI_JOIN_ADDRESS);\n\n        if (maxDebt >= _exchangeData.srcAmount || maxLiq == 0) {\n            if (_exchangeData.srcAmount > maxDebt) {\n                _exchangeData.srcAmount = maxDebt;\n            }\n\n            boost(_exchangeData, _cdpId, _gasCost, _joinAddr);\n            return;\n        }\n\n        uint256 loanAmount = sub(_exchangeData.srcAmount, maxDebt);\n        loanAmount = loanAmount > maxLiq ? maxLiq : loanAmount;\n\n        MCD_SAVER_FLASH_LOAN.transfer(msg.value); // 0x fee\n\n        manager.cdpAllow(_cdpId, MCD_SAVER_FLASH_LOAN, 1);\n\n        bytes memory paramsData = abi.encode(packExchangeData(_exchangeData), _cdpId, _gasCost, _joinAddr, false);\n\n        lendingPool.flashLoan(MCD_SAVER_FLASH_LOAN, DAI_ADDRESS, loanAmount, paramsData);\n\n        manager.cdpAllow(_cdpId, MCD_SAVER_FLASH_LOAN, 0);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repayWithLoan",
        "visibility": "public",
        "args": [
            {
                "name": "_exchangeData",
                "type": "SaverExchangeCore.ExchangeData memory"
            },
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_gasCost",
                "type": "uint"
            },
            {
                "name": "_joinAddr",
                "type": "address"
            }
        ],
        "func": "function repayWithLoan(\n        SaverExchangeCore.ExchangeData memory _exchangeData,\n        uint _cdpId,\n        uint _gasCost,\n        address _joinAddr\n    ) public payable burnGas(25) {\n        uint256 maxColl = getMaxCollateral(_cdpId, manager.ilks(_cdpId), _joinAddr);\n\n\n        uint maxLiq = getAvailableLiquidity(_joinAddr);\n\n        if (maxColl >= _exchangeData.srcAmount || maxLiq == 0) {\n            if (_exchangeData.srcAmount > maxColl) {\n                _exchangeData.srcAmount = maxColl;\n            }\n\n            repay(_exchangeData, _cdpId, _gasCost, _joinAddr);\n            return;\n        }\n\n        uint256 loanAmount = sub(_exchangeData.srcAmount, maxColl);\n        loanAmount = loanAmount > maxLiq ? maxLiq : loanAmount;\n\n        MCD_SAVER_FLASH_LOAN.transfer(msg.value); // 0x fee\n\n        manager.cdpAllow(_cdpId, MCD_SAVER_FLASH_LOAN, 1);\n\n        bytes memory paramsData = abi.encode(packExchangeData(_exchangeData), _cdpId, _gasCost, _joinAddr, true);\n\n        lendingPool.flashLoan(MCD_SAVER_FLASH_LOAN, getAaveCollAddr(_joinAddr), loanAmount, paramsData);\n\n        manager.cdpAllow(_cdpId, MCD_SAVER_FLASH_LOAN, 0);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMaxDebt",
        "visibility": "public",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint256"
            },
            {
                "name": "_ilk",
                "type": "bytes32"
            }
        ],
        "func": "function getMaxDebt(uint256 _cdpId, bytes32 _ilk) public override view returns (uint256) {\n        uint256 price = getPrice(_ilk);\n\n        (, uint256 mat) = spotter.ilks(_ilk);\n        (uint256 collateral, uint256 debt) = getCdpInfo(manager, _cdpId, _ilk);\n\n        return sub(wdiv(wmul(collateral, price), mat), debt);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setCompleted",
        "visibility": "public",
        "args": [
            {
                "name": "completed",
                "type": "uint"
            }
        ],
        "func": "function setCompleted(uint completed) public restricted {\n        last_completed_migration = completed;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "upgrade",
        "visibility": "public",
        "args": [
            {
                "name": "new_address",
                "type": "address"
            }
        ],
        "func": "function upgrade(address new_address) public restricted {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "deposit",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            }
        ],
        "func": "function deposit(address _user, uint _amount) public override {\n        require(msg.sender == _user);\n        // get dai from user\n        require(ERC20(DAI_ADDRESS).transferFrom(_user, address(this), _amount));\n\n        ERC20(DAI_ADDRESS).approve(AAVE_LENDING_POOL_CORE, uint(-1));\n        ILendingPool(AAVE_LENDING_POOL).deposit(DAI_ADDRESS, _amount, 0);\n\n        ERC20(ADAI_ADDRESS).transfer(_user, ERC20(ADAI_ADDRESS).balanceOf(address(this)));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            }
        ],
        "func": "function withdraw(address _user, uint _amount) public override {\n        require(msg.sender == _user);\n        require(ERC20(ADAI_ADDRESS).transferFrom(_user, address(this), _amount));\n\n        IAToken(ADAI_ADDRESS).redeem(_amount);\n\n        // return dai we have to user\n        ERC20(DAI_ADDRESS).transfer(_user, _amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addSavingsProxy",
        "visibility": "public",
        "args": [
            {
                "name": "_savingsProxy",
                "type": "address"
            }
        ],
        "func": "function addSavingsProxy(address _savingsProxy) public auth {\n        savingsProxy = _savingsProxy;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "deposit",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            }
        ],
        "func": "function deposit(address _user, uint _amount) public override {\n        require(msg.sender == _user);\n\n        Account.Info[] memory accounts = new Account.Info[](1);\n        accounts[0] = getAccount(_user, 0);\n\n        Actions.ActionArgs[] memory actions = new Actions.ActionArgs[](1);\n        Types.AssetAmount memory amount = Types.AssetAmount({\n            sign: true,\n            denomination: Types.AssetDenomination.Wei,\n            ref: Types.AssetReference.Delta,\n            value: _amount\n        });\n\n        actions[0] = Actions.ActionArgs({\n            actionType: Actions.ActionType.Deposit,\n            accountId: 0,\n            amount: amount,\n            primaryMarketId: daiMarketId,\n            otherAddress: _user,\n            secondaryMarketId: 0, //not used\n            otherAccountId: 0, //not used\n            data: \"\" //not used\n        });\n\n        soloMargin.operate(accounts, actions);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            }
        ],
        "func": "function withdraw(address _user, uint _amount) public override {\n        require(msg.sender == _user);\n\n        Account.Info[] memory accounts = new Account.Info[](1);\n        accounts[0] = getAccount(_user, 0);\n\n        Actions.ActionArgs[] memory actions = new Actions.ActionArgs[](1);\n        Types.AssetAmount memory amount = Types.AssetAmount({\n            sign: false,\n            denomination: Types.AssetDenomination.Wei,\n            ref: Types.AssetReference.Delta,\n            value: _amount\n        });\n\n        actions[0] = Actions.ActionArgs({\n            actionType: Actions.ActionType.Withdraw,\n            accountId: 0,\n            amount: amount,\n            primaryMarketId: daiMarketId,\n            otherAddress: _user,\n            secondaryMarketId: 0, //not used\n            otherAccountId: 0, //not used\n            data: \"\" //not used\n        });\n\n        soloMargin.operate(accounts, actions);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getWeiBalance",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            },
            {
                "name": "_index",
                "type": "uint"
            }
        ],
        "func": "function getWeiBalance(address _user, uint _index) public view returns(Types.Wei memory) {\n\n        Types.Wei[] memory weiBalances;\n        (,,weiBalances) = soloMargin.getAccountBalances(getAccount(_user, _index));\n\n        return weiBalances[daiMarketId];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getParBalance",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            },
            {
                "name": "_index",
                "type": "uint"
            }
        ],
        "func": "function getParBalance(address _user, uint _index) public view returns(Types.Par memory) {\n        Types.Par[] memory parBalances;\n        (,parBalances,) = soloMargin.getAccountBalances(getAccount(_user, _index));\n\n        return parBalances[daiMarketId];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAccount",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            },
            {
                "name": "_index",
                "type": "uint"
            }
        ],
        "func": "function getAccount(address _user, uint _index) public pure returns(Account.Info memory) {\n        Account.Info memory account = Account.Info({\n            owner: _user,\n            number: _index\n        });\n\n        return account;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addSavingsProxy",
        "visibility": "public",
        "args": [
            {
                "name": "_savingsProxy",
                "type": "address"
            }
        ],
        "func": "function addSavingsProxy(address _savingsProxy) public auth {\n        savingsProxy = _savingsProxy;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "deposit",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            }
        ],
        "func": "function deposit(address _user, uint _amount) public override {\n        require(msg.sender == _user);\n\n        // get dai from user\n        require(ERC20(DAI_ADDRESS).transferFrom(_user, address(this), _amount));\n\n        // approve dai to Fulcrum\n        ERC20(DAI_ADDRESS).approve(NEW_IDAI_ADDRESS, uint(-1));\n\n        // mint iDai\n        ITokenInterface(NEW_IDAI_ADDRESS).mint(_user, _amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "_user",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            }
        ],
        "func": "function withdraw(address _user, uint _amount) public override {\n        require(msg.sender == _user);\n\n        // transfer all users tokens to our contract\n        require(ERC20(NEW_IDAI_ADDRESS).transferFrom(_user, address(this), ITokenInterface(NEW_IDAI_ADDRESS).balanceOf(_user)));\n\n        // approve iDai to that contract\n        ERC20(NEW_IDAI_ADDRESS).approve(NEW_IDAI_ADDRESS, uint(-1));\n        uint tokenPrice = ITokenInterface(NEW_IDAI_ADDRESS).tokenPrice();\n\n        // get dai from iDai contract\n        ITokenInterface(NEW_IDAI_ADDRESS).burn(_user, _amount * decimals / tokenPrice);\n\n        // return all remaining tokens back to user\n        require(ERC20(NEW_IDAI_ADDRESS).transfer(_user, ITokenInterface(NEW_IDAI_ADDRESS).balanceOf(address(this))));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "logDeposit",
        "visibility": "external",
        "args": [
            {
                "name": "_sender",
                "type": "address"
            },
            {
                "name": "_protocol",
                "type": "uint8"
            },
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function logDeposit(address _sender, uint8 _protocol, uint256 _amount) external {\n        emit Deposit(_sender, _protocol, _amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "logWithdraw",
        "visibility": "external",
        "args": [
            {
                "name": "_sender",
                "type": "address"
            },
            {
                "name": "_protocol",
                "type": "uint8"
            },
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function logWithdraw(address _sender, uint8 _protocol, uint256 _amount) external {\n        emit Withdraw(_sender, _protocol, _amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "logSwap",
        "visibility": "external",
        "args": [
            {
                "name": "_sender",
                "type": "address"
            },
            {
                "name": "_protocolFrom",
                "type": "uint8"
            },
            {
                "name": "_protocolTo",
                "type": "uint8"
            },
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function logSwap(address _sender, uint8 _protocolFrom, uint8 _protocolTo, uint256 _amount)\n        external\n    {\n        emit Swap(_sender, _protocolFrom, _protocolTo, _amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "deposit",
        "visibility": "public",
        "args": [
            {
                "name": "_protocol",
                "type": "SavingsProtocol"
            },
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function deposit(SavingsProtocol _protocol, uint256 _amount) public {\n        if (_protocol == SavingsProtocol.Dsr) {\n            dsrDeposit(_amount, true);\n        } else if (_protocol == SavingsProtocol.Compound) {\n            compDeposit(msg.sender, _amount);\n        } else {\n            _deposit(_protocol, _amount, true);\n        }\n\n        SavingsLogger(SAVINGS_LOGGER_ADDRESS).logDeposit(msg.sender, uint8(_protocol), _amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "_protocol",
                "type": "SavingsProtocol"
            },
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function withdraw(SavingsProtocol _protocol, uint256 _amount) public {\n        if (_protocol == SavingsProtocol.Dsr) {\n            dsrWithdraw(_amount, true);\n        } else if (_protocol == SavingsProtocol.Compound) {\n            compWithdraw(msg.sender, _amount);\n        } else {\n            _withdraw(_protocol, _amount, true);\n        }\n\n        SavingsLogger(SAVINGS_LOGGER_ADDRESS).logWithdraw(msg.sender, uint8(_protocol), _amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swap",
        "visibility": "public",
        "args": [
            {
                "name": "_from",
                "type": "SavingsProtocol"
            },
            {
                "name": "_to",
                "type": "SavingsProtocol"
            },
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function swap(SavingsProtocol _from, SavingsProtocol _to, uint256 _amount) public {\n        if (_from == SavingsProtocol.Dsr) {\n            dsrWithdraw(_amount, false);\n        } else if (_from == SavingsProtocol.Compound) {\n            compWithdraw(msg.sender, _amount);\n        } else {\n            _withdraw(_from, _amount, false);\n        }\n\n        // possible to withdraw 1-2 wei less than actual amount due to division precision\n        // so we deposit all amount on DSProxy\n        uint256 amountToDeposit = ERC20(DAI_ADDRESS).balanceOf(address(this));\n\n        if (_to == SavingsProtocol.Dsr) {\n            dsrDeposit(amountToDeposit, false);\n        } else if (_from == SavingsProtocol.Compound) {\n            compDeposit(msg.sender, _amount);\n        } else {\n            _deposit(_to, amountToDeposit, false);\n        }\n\n        SavingsLogger(SAVINGS_LOGGER_ADDRESS).logSwap(\n            msg.sender,\n            uint8(_from),\n            uint8(_to),\n            _amount\n        );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawDai",
        "visibility": "public",
        "args": [],
        "func": "function withdrawDai() public {\n        ERC20(DAI_ADDRESS).transfer(msg.sender, ERC20(DAI_ADDRESS).balanceOf(address(this)));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "claimComp",
        "visibility": "public",
        "args": [],
        "func": "function claimComp() public {\n        ComptrollerInterface(COMP_ADDRESS).claimComp(address(this));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAddress",
        "visibility": "public",
        "args": [
            {
                "name": "_protocol",
                "type": "SavingsProtocol"
            }
        ],
        "func": "function getAddress(SavingsProtocol _protocol) public pure returns (address) {\n\n        if (_protocol == SavingsProtocol.Dydx) {\n            return SAVINGS_DYDX_ADDRESS;\n        }\n\n        if (_protocol == SavingsProtocol.Aave) {\n            return SAVINGS_AAVE_ADDRESS;\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "_protocol",
                "type": "SavingsProtocol"
            },
            {
                "name": "_amount",
                "type": "uint256"
            },
            {
                "name": "_toUser",
                "type": "bool"
            }
        ],
        "func": "function _withdraw(SavingsProtocol _protocol, uint256 _amount, bool _toUser) public {\n        approveWithdraw(_protocol);\n\n        ProtocolInterface(getAddress(_protocol)).withdraw(address(this), _amount);\n\n        endAction(_protocol);\n\n        if (_toUser) {\n            withdrawDai();\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "executeOperation",
        "visibility": "external",
        "args": [
            {
                "name": "_reserve",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            },
            {
                "name": "_fee",
                "type": "uint256"
            },
            {
                "name": "_params",
                "type": "bytes calldata"
            }
        ],
        "func": "function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n        // Format the call data for DSProxy\n        (ParamData memory paramData, ExchangeData memory exchangeData)\n                                 = packFunctionCall(_amount, _fee, _params);\n\n        address protocolAddr1 = shifterRegistry.getAddr(getNameByProtocol(paramData.protocol1));\n        address protocolAddr2 = shifterRegistry.getAddr(getNameByProtocol(paramData.protocol2));\n\n        // Send Flash loan amount to DSProxy\n        sendToProxy(payable(paramData.proxy), _reserve, _amount);\n\n        // Execute the Close/Change debt operation\n        DSProxyInterface(paramData.proxy).execute(protocolAddr1, paramData.proxyData1);\n\n        if (paramData.swapType == 1) { // COLL_SWAP\n            exchangeData.srcAmount -= getFee(getBalance(exchangeData.srcAddr), exchangeData.srcAddr, paramData.proxy);\n            (, uint amount) = _sell(exchangeData);\n\n            sendToProxy(payable(paramData.proxy), exchangeData.destAddr, amount);\n        } else if (paramData.swapType == 2) { // DEBT_SWAP\n            exchangeData.srcAmount -= getFee(exchangeData.srcAmount, exchangeData.srcAddr, paramData.proxy);\n\n            exchangeData.destAmount = (_amount + _fee);\n            _buy(exchangeData);\n\n            // Send extra to DSProxy\n            sendToProxy(payable(paramData.proxy), exchangeData.srcAddr, ERC20(exchangeData.srcAddr).balanceOf(address(this)));\n\n        } else { // NO_SWAP just send tokens to proxy\n            sendToProxy(payable(paramData.proxy), exchangeData.srcAddr, getBalance(exchangeData.srcAddr));\n        }\n\n        // Execute the Open operation\n        DSProxyInterface(paramData.proxy).execute(protocolAddr2, paramData.proxyData2);\n\n        // Repay FL\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "moveLoan",
        "visibility": "public",
        "args": [
            {
                "name": "_exchangeData",
                "type": "SaverExchangeCore.ExchangeData memory"
            },
            {
                "name": "_loanShift",
                "type": "LoanShiftData memory"
            }
        ],
        "func": "function moveLoan(\n        SaverExchangeCore.ExchangeData memory _exchangeData,\n        LoanShiftData memory _loanShift\n    ) public payable burnGas(20) {\n        if (_isSameTypeVaults(_loanShift)) {\n            _forkVault(_loanShift);\n            return;\n        }\n\n        _callCloseAndOpen(_exchangeData, _loanShift);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getLoanAmount",
        "visibility": "public",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_joinAddr",
                "type": "address"
            }
        ],
        "func": "function getLoanAmount(uint _cdpId, address _joinAddr) public returns(uint loanAmount) {\n        return getWholeDebt(_cdpId, _joinAddr);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getWholeDebt",
        "visibility": "public",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_joinAddr",
                "type": "address"
            }
        ],
        "func": "function getWholeDebt(uint _cdpId, address _joinAddr) public returns(uint loanAmount) {\n        return CTokenInterface(_joinAddr).borrowBalanceCurrent(msg.sender);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "close",
        "visibility": "public",
        "args": [
            {
                "name": "_cCollAddr",
                "type": "address"
            },
            {
                "name": "_cBorrowAddr",
                "type": "address"
            },
            {
                "name": "_collAmount",
                "type": "uint"
            },
            {
                "name": "_debtAmount",
                "type": "uint"
            }
        ],
        "func": "function close(\n        address _cCollAddr,\n        address _cBorrowAddr,\n        uint _collAmount,\n        uint _debtAmount\n    ) public {\n        address collAddr = getUnderlyingAddr(_cCollAddr);\n\n        // payback debt\n        paybackDebt(_debtAmount, _cBorrowAddr, getUnderlyingAddr(_cBorrowAddr), tx.origin);\n\n        require(CTokenInterface(_cCollAddr).redeemUnderlying(_collAmount) == 0);\n\n        // Send back money to repay FL\n        if (collAddr == ETH_ADDRESS) {\n            msg.sender.transfer(address(this).balance);\n        } else {\n            ERC20(collAddr).transfer(msg.sender, ERC20(collAddr).balanceOf(address(this)));\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeDebt",
        "visibility": "public",
        "args": [
            {
                "name": "_cBorrowAddrOld",
                "type": "address"
            },
            {
                "name": "_cBorrowAddrNew",
                "type": "address"
            },
            {
                "name": "_debtAmountOld",
                "type": "uint"
            },
            {
                "name": "_debtAmountNew",
                "type": "uint"
            }
        ],
        "func": "function changeDebt(\n        address _cBorrowAddrOld,\n        address _cBorrowAddrNew,\n        uint _debtAmountOld,\n        uint _debtAmountNew\n    ) public {\n\n        address borrowAddrNew = getUnderlyingAddr(_cBorrowAddrNew);\n\n        // payback debt in one token\n        paybackDebt(_debtAmountOld, _cBorrowAddrOld, getUnderlyingAddr(_cBorrowAddrOld), tx.origin);\n\n        // draw debt in another one\n        borrowCompound(_cBorrowAddrNew, _debtAmountNew);\n\n        // Send back money to repay FL\n        if (borrowAddrNew == ETH_ADDRESS) {\n            msg.sender.transfer(address(this).balance);\n        } else {\n            ERC20(borrowAddrNew).transfer(msg.sender, ERC20(borrowAddrNew).balanceOf(address(this)));\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "open",
        "visibility": "public",
        "args": [
            {
                "name": "_cCollAddr",
                "type": "address"
            },
            {
                "name": "_cBorrowAddr",
                "type": "address"
            },
            {
                "name": "_debtAmount",
                "type": "uint"
            }
        ],
        "func": "function open(\n        address _cCollAddr,\n        address _cBorrowAddr,\n        uint _debtAmount\n    ) public {\n\n        address collAddr = getUnderlyingAddr(_cCollAddr);\n        address borrowAddr = getUnderlyingAddr(_cBorrowAddr);\n\n        uint collAmount = 0;\n\n        if (collAddr == ETH_ADDRESS) {\n            collAmount = address(this).balance;\n        } else {\n            collAmount = ERC20(collAddr).balanceOf(address(this));\n        }\n\n        depositCompound(collAddr, _cCollAddr, collAmount);\n\n        // draw debt\n        borrowCompound(_cBorrowAddr, _debtAmount);\n\n        // Send back money to repay FL\n        if (borrowAddr == ETH_ADDRESS) {\n            msg.sender.transfer(address(this).balance);\n        } else {\n            ERC20(borrowAddr).transfer(msg.sender, ERC20(borrowAddr).balanceOf(address(this)));\n        }\n\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repayAll",
        "visibility": "public",
        "args": [
            {
                "name": "_cTokenAddr",
                "type": "address"
            }
        ],
        "func": "function repayAll(address _cTokenAddr) public {\n        address tokenAddr = getUnderlyingAddr(_cTokenAddr);\n        uint amount = ERC20(tokenAddr).balanceOf(address(this));\n\n        if (amount != 0) {\n            paybackDebt(amount, _cTokenAddr, tokenAddr, tx.origin);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "enterMarket",
        "visibility": "public",
        "args": [
            {
                "name": "_cTokenAddr",
                "type": "address"
            }
        ],
        "func": "function enterMarket(address _cTokenAddr) public {\n        address[] memory markets = new address[](1);\n        markets[0] = _cTokenAddr;\n\n        ComptrollerInterface(COMPTROLLER_ADDR).enterMarkets(markets);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getLoanAmount",
        "visibility": "public",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_joinAddr",
                "type": "address"
            }
        ],
        "func": "function getLoanAmount(uint _cdpId, address _joinAddr) public view virtual returns(uint loanAmount) {\n        bytes32 ilk = manager.ilks(_cdpId);\n\n        (, uint rate,,,) = vat.ilks(ilk);\n        (, uint art) = vat.urns(ilk, manager.urns(_cdpId));\n        uint dai = vat.dai(manager.urns(_cdpId));\n\n        uint rad = sub(mul(art, rate), dai);\n        loanAmount = rad / RAY;\n\n        loanAmount = mul(loanAmount, RAY) < rad ? loanAmount + 1 : loanAmount;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "close",
        "visibility": "public",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_joinAddr",
                "type": "address"
            },
            {
                "name": "_loanAmount",
                "type": "uint"
            },
            {
                "name": "_collateral",
                "type": "uint"
            }
        ],
        "func": "function close(\n        uint _cdpId,\n        address _joinAddr,\n        uint _loanAmount,\n        uint _collateral\n    ) public {\n        address owner = getOwner(manager, _cdpId);\n        bytes32 ilk = manager.ilks(_cdpId);\n        (uint maxColl, ) = getCdpInfo(manager, _cdpId, ilk);\n\n        // repay dai debt cdp\n        paybackDebt(_cdpId, ilk, _loanAmount, owner);\n\n        maxColl = _collateral > maxColl ? maxColl : _collateral;\n\n        // withdraw collateral from cdp\n        drawMaxCollateral(_cdpId, _joinAddr, maxColl);\n\n        // send back to msg.sender\n        if (isEthJoinAddr(_joinAddr)) {\n            msg.sender.transfer(address(this).balance);\n        } else {\n            ERC20 collToken = ERC20(getCollateralAddr(_joinAddr));\n            collToken.transfer(msg.sender, collToken.balanceOf(address(this)));\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "open",
        "visibility": "public",
        "args": [
            {
                "name": "_cdpId",
                "type": "uint"
            },
            {
                "name": "_joinAddr",
                "type": "address"
            },
            {
                "name": "_debtAmount",
                "type": "uint"
            }
        ],
        "func": "function open(\n        uint _cdpId,\n        address _joinAddr,\n        uint _debtAmount\n    ) public {\n\n        uint collAmount = 0;\n\n        if (isEthJoinAddr(_joinAddr)) {\n            collAmount = address(this).balance;\n        } else {\n            collAmount = ERC20(address(Join(_joinAddr).gem())).balanceOf(address(this));\n        }\n\n        if (_cdpId == 0) {\n            openAndWithdraw(collAmount, _debtAmount, address(this), _joinAddr);\n        } else {\n            // add collateral\n            addCollateral(_cdpId, _joinAddr, collAmount);\n            // draw debt\n            drawDai(_cdpId, manager.ilks(_cdpId), _debtAmount);\n        }\n\n        // transfer to repay FL\n        ERC20(DAI_ADDRESS).transfer(msg.sender, ERC20(DAI_ADDRESS).balanceOf(address(this)));\n\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "logUint",
        "visibility": "public",
        "args": [
            {
                "name": "_id",
                "type": "string memory"
            },
            {
                "name": "_value",
                "type": "uint"
            }
        ],
        "func": "function logUint(string memory _id, uint _value) public {\n        uintValues[_id] = _value;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "logAddr",
        "visibility": "public",
        "args": [
            {
                "name": "_id",
                "type": "string memory"
            },
            {
                "name": "_value",
                "type": "address"
            }
        ],
        "func": "function logAddr(string memory _id, address _value) public {\n        addrValues[_id] = _value;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "logString",
        "visibility": "public",
        "args": [
            {
                "name": "_id",
                "type": "string memory"
            },
            {
                "name": "_value",
                "type": "string memory"
            }
        ],
        "func": "function logString(string memory _id, string memory _value) public {\n        stringValues[_id] = _value;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "logBytes32",
        "visibility": "public",
        "args": [
            {
                "name": "_id",
                "type": "string memory"
            },
            {
                "name": "_value",
                "type": "bytes32"
            }
        ],
        "func": "function logBytes32(string memory _id, bytes32 _value) public {\n        bytes32Values[_id] = _value;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "callProxy",
        "visibility": "external",
        "args": [
            {
                "name": "_user",
                "type": "address"
            },
            {
                "name": "_proxy",
                "type": "address"
            },
            {
                "name": "_contract",
                "type": "address"
            },
            {
                "name": "_txData",
                "type": "bytes calldata"
            },
            {
                "name": "_nonce",
                "type": "uint256"
            },
            {
                "name": "_v",
                "type": "uint8"
            },
            {
                "name": "_r",
                "type": "bytes32"
            },
            {
                "name": "_s",
                "type": "bytes32"
            }
        ],
        "func": "function callProxy(address _user, address _proxy, address _contract, bytes calldata _txData, uint256 _nonce,\n                    uint8 _v, bytes32 _r, bytes32 _s) external payable onlyAuthorized\n    {\n        bytes32 digest =\n            keccak256(abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH,\n                                     _user,\n                                     _proxy,\n                                     _contract,\n                                     _txData,\n                                     _nonce))\n        ));\n\n        // user must be proxy owner\n        require(DSProxyInterface(_proxy).owner() == _user);\n        require(_user == ecrecover(digest, _v, _r, _s), \"DFSProxy/user-not-valid\");\n        require(!nonces[_user][_nonce], \"DFSProxy/invalid-nonce\");\n        \n        nonces[_user][_nonce] = true;\n\n        DSProxyInterface(_proxy).execute{value: msg.value}(_contract, _txData);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    }
]