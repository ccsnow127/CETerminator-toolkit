[
    {
        "transactions": 9872,
        "function_num": 190
    },
    {
        "name": "genesis",
        "visibility": "public",
        "args": [],
        "func": "function genesis() public payable {\n        // If we run into a very unlikely situation when there are no active\n        // groups on the contract because of slashing and groups terminated\n        // or because beacon has not been used for a very long time and all\n        // groups expired, we first want to make a cleanup.\n        groups.expireOldGroups();\n        require(numberOfGroups() == 0, \"Groups exist\");\n        // Cleanup after potential failed DKG\n        groupSelection.finish();\n        // Set latest added service contract as a group selection starter to receive any DKG fee surplus.\n        groupSelectionStarterContract = ServiceContract(serviceContracts[serviceContracts.length.sub(1)]);\n        startGroupSelection(_genesisGroupSeed, msg.value);\n    }",
        "comments": [
            "",
            "",
            "    /// @notice Triggers group selection if there are no active groups.",
            "    "
        ],
        "comt": "\n\n    /// @notice Triggers group selection if there are no active groups.\n    ",
        "@notice": "Triggers group selection if there are no active groups.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addServiceContract",
        "visibility": "public",
        "args": [
            {
                "name": "serviceContract",
                "type": "address"
            }
        ],
        "func": "function addServiceContract(address serviceContract) public {\n        require(\n            registry.serviceContractUpgraderFor(address(this)) == msg.sender,\n            \"Not authorized\"\n        );\n\n        serviceContracts.push(serviceContract);\n    }",
        "comments": [
            "",
            "    /// @notice Adds service contract",
            "    /// @param serviceContract Address of the service contract.",
            "    "
        ],
        "comt": "\n    /// @notice Adds service contract\n    /// @param serviceContract Address of the service contract.\n    ",
        "@notice": "Adds service contract",
        "@param1": "serviceContract Address of the service contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "refreshGasPrice",
        "visibility": "public",
        "args": [],
        "func": "function refreshGasPrice() public {\n        gasPriceCeiling = gasPriceOracle.gasPrice();\n    }",
        "comments": [
            "",
            "    /// @notice Pulls the most recent gas price from gas price oracle.",
            "    "
        ],
        "comt": "\n    /// @notice Pulls the most recent gas price from gas price oracle.\n    ",
        "@notice": "Pulls the most recent gas price from gas price oracle.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createGroup",
        "visibility": "public",
        "args": [
            {
                "name": "_newEntry",
                "type": "uint256"
            },
            {
                "name": "submitter",
                "type": "address payable"
            }
        ],
        "func": "function createGroup(uint256 _newEntry, address payable submitter) public payable onlyServiceContract {\n        uint256 groupSelectionStartFee = groupSelectionGasEstimate.mul(gasPriceCeiling);\n\n        groupSelectionStarterContract = ServiceContract(msg.sender);\n        startGroupSelection(_newEntry, msg.value.sub(groupSelectionStartFee));\n\n        // reimbursing a submitter that triggered group selection\n        (bool success, ) = stakingContract.beneficiaryOf(submitter).call.value(groupSelectionStartFee)(\"\");\n        require(success, \"Group selection reimbursement failed\");\n    }",
        "comments": [
            "",
            "    /// @notice Triggers the selection process of a new candidate group.",
            "    /// @param _newEntry New random beacon value that stakers will use to",
            "    /// generate their tickets.",
            "    /// @param submitter Operator of this contract.",
            "    "
        ],
        "comt": "\n    /// @notice Triggers the selection process of a new candidate group.\n    /// @param _newEntry New random beacon value that stakers will use to\n    /// generate their tickets.\n    /// @param submitter Operator of this contract.\n    ",
        "@notice": "Triggers the selection process of a new candidate group.",
        "@param1": "_newEntry New random beacon value that stakers will use to /// generate their tickets.",
        "@param2": "submitter Operator of this contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isGroupSelectionPossible",
        "visibility": "public",
        "args": [],
        "func": "function isGroupSelectionPossible() public view returns (bool) {\n        if (!groupSelection.inProgress) {\n            return true;\n        }\n\n        // dkgTimeout is the time after key generation protocol is expected to\n        // be complete plus the expected time to submit the result.\n        uint256 dkgTimeout = groupSelection.ticketSubmissionStartBlock +\n        groupSelection.ticketSubmissionTimeout +\n        dkgResultVerification.timeDKG +\n        groupSize * resultPublicationBlockStep;\n\n        return block.number > dkgTimeout;\n    }",
        "comments": [
            "",
            "    /// @notice Checks if it is possible to fire a new group selection.",
            "    /// Triggering new group selection is only possible when there is no",
            "    /// pending group selection or when the pending group selection timed out.",
            "    "
        ],
        "comt": "\n    /// @notice Checks if it is possible to fire a new group selection.\n    /// Triggering new group selection is only possible when there is no\n    /// pending group selection or when the pending group selection timed out.\n    ",
        "@notice": "Checks if it is possible to fire a new group selection. /// Triggering new group selection is only possible when there is no /// pending group selection or when the pending group selection timed out.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "submitTicket",
        "visibility": "public",
        "args": [
            {
                "name": "ticket",
                "type": "bytes32"
            }
        ],
        "func": "function submitTicket(bytes32 ticket) public {\n        uint256 stakingWeight = stakingContract.eligibleStake(\n            msg.sender, address(this)\n        ).div(groupSelection.minimumStake);\n        groupSelection.submitTicket(ticket, stakingWeight);\n    }",
        "comments": [
            "    ///   has to be unique for all tickets submitted by the given staker for the",
            "    ///   current candidate group selection.",
            "    "
        ],
        "comt": "    ///   has to be unique for all tickets submitted by the given staker for the\n    ///   current candidate group selection.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "ticketSubmissionTimeout",
        "visibility": "public",
        "args": [],
        "func": "function ticketSubmissionTimeout() public view returns (uint256) {\n        return groupSelection.ticketSubmissionTimeout;\n    }",
        "comments": [
            "",
            "    /// @notice Gets the timeout in blocks after which group candidate ticket",
            "    /// submission is finished.",
            "    "
        ],
        "comt": "\n    /// @notice Gets the timeout in blocks after which group candidate ticket\n    /// submission is finished.\n    ",
        "@notice": "Gets the timeout in blocks after which group candidate ticket /// submission is finished.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "submittedTickets",
        "visibility": "public",
        "args": [],
        "func": "function submittedTickets() public view returns (uint64[] memory) {\n        return groupSelection.tickets;\n    }",
        "comments": [
            "",
            "    /// @notice Gets the submitted group candidate tickets so far.",
            "    "
        ],
        "comt": "\n    /// @notice Gets the submitted group candidate tickets so far.\n    ",
        "@notice": "Gets the submitted group candidate tickets so far.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "selectedParticipants",
        "visibility": "public",
        "args": [],
        "func": "function selectedParticipants() public view returns (address[] memory) {\n        return groupSelection.selectedParticipants();\n    }",
        "comments": [
            "",
            "    /// @notice Gets selected participants in ascending order of their tickets.",
            "    "
        ],
        "comt": "\n    /// @notice Gets selected participants in ascending order of their tickets.\n    ",
        "@notice": "Gets selected participants in ascending order of their tickets.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "submitDkgResult",
        "visibility": "public",
        "args": [
            {
                "name": "submitterMemberIndex",
                "type": "uint256"
            },
            {
                "name": "groupPubKey",
                "type": "bytes memory"
            },
            {
                "name": "misbehaved",
                "type": "bytes memory"
            },
            {
                "name": "signatures",
                "type": "bytes memory"
            },
            {
                "name": "signingMembersIndexes",
                "type": "uint[] memory"
            }
        ],
        "func": "function submitDkgResult(\n        uint256 submitterMemberIndex,\n        bytes memory groupPubKey,\n        bytes memory misbehaved,\n        bytes memory signatures,\n        uint[] memory signingMembersIndexes\n    ) public nonReentrant {\n        address[] memory members = selectedParticipants();\n\n        dkgResultVerification.verify(\n            submitterMemberIndex,\n            groupPubKey,\n            misbehaved,\n            signatures,\n            signingMembersIndexes,\n            members,\n            groupSelection.ticketSubmissionStartBlock + groupSelection.ticketSubmissionTimeout\n        );\n\n        groups.setGroupMembers(groupPubKey, members, misbehaved);\n        groups.addGroup(groupPubKey);\n        reimburseDkgSubmitter();\n        emit DkgResultSubmittedEvent(submitterMemberIndex, groupPubKey, misbehaved);\n        groupSelection.finish();\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sign",
        "visibility": "public",
        "args": [
            {
                "name": "requestId",
                "type": "uint256"
            },
            {
                "name": "previousEntry",
                "type": "bytes memory"
            }
        ],
        "func": "function sign(\n        uint256 requestId,\n        bytes memory previousEntry\n    ) public payable onlyServiceContract {\n        uint256 entryVerificationAndProfitFee = groupProfitFee().add(\n            entryVerificationFee()\n        );\n        require(\n            msg.value >= entryVerificationAndProfitFee,\n            \"Insufficient new entry fee\"\n        );\n        uint256 callbackFee = msg.value.sub(entryVerificationAndProfitFee);\n        signRelayEntry(\n            requestId, previousEntry, msg.sender,\n            entryVerificationAndProfitFee, callbackFee\n        );\n    }",
        "comments": [
            "",
            "    /// @notice Creates a request to generate a new relay entry, which will include",
            "    /// a random number (by signing the previous entry's random number).",
            "    /// @param requestId Request Id trackable by service contract",
            "    /// @param previousEntry Previous relay entry",
            "    "
        ],
        "comt": "\n    /// @notice Creates a request to generate a new relay entry, which will include\n    /// a random number (by signing the previous entry's random number).\n    /// @param requestId Request Id trackable by service contract\n    /// @param previousEntry Previous relay entry\n    ",
        "@notice": "Creates a request to generate a new relay entry, which will include /// a random number (by signing the previous entry's random number).",
        "@param1": "requestId Request Id trackable by service contract",
        "@param2": "previousEntry Previous relay entry",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "relayEntry",
        "visibility": "public",
        "args": [
            {
                "name": "_groupSignature",
                "type": "bytes memory"
            }
        ],
        "func": "function relayEntry(bytes memory _groupSignature) public nonReentrant {\n        require(isEntryInProgress(), \"Entry was submitted\");\n        require(!hasEntryTimedOut(), \"Entry timed out\");\n\n        bytes memory groupPubKey = groups.getGroupPublicKey(currentRequestGroupIndex);\n\n        require(\n            BLS.verify(\n                groupPubKey,\n                currentRequestPreviousEntry,\n                _groupSignature\n            ),\n            \"Invalid signature\"\n        );\n\n        emit RelayEntrySubmitted();\n\n        // Spend no more than groupSelectionGasEstimate + 40000 gas max\n        // This will prevent relayEntry failure in case the service contract is compromised\n        currentRequestServiceContract.call.gas(groupSelectionGasEstimate.add(40000))(\n            abi.encodeWithSignature(\n                \"entryCreated(uint256,bytes,address)\",\n                currentRequestId,\n                _groupSignature,\n                msg.sender\n            )\n        );\n\n        if (currentRequestCallbackFee > 0) {\n            executeCallback(uint256(keccak256(_groupSignature)));\n        }\n\n        (uint256 groupMemberReward, uint256 submitterReward, uint256 subsidy) = newEntryRewardsBreakdown();\n        groups.addGroupMemberReward(groupPubKey, groupMemberReward);\n\n        stakingContract.beneficiaryOf(msg.sender).call.value(submitterReward)(\"\");\n\n        if (subsidy > 0) {\n            currentRequestServiceContract.call.gas(35000).value(subsidy)(\n                abi.encodeWithSignature(\"fundRequestSubsidyFeePool()\")\n            );\n        }\n\n        currentRequestStartBlock = 0;\n    }",
        "comments": [
            "",
            "    /// @notice Creates a new relay entry and stores the associated data on the chain.",
            "    /// @param _groupSignature Group BLS signature over the concatenation of the",
            "    /// previous entry and seed.",
            "    "
        ],
        "comt": "\n    /// @notice Creates a new relay entry and stores the associated data on the chain.\n    /// @param _groupSignature Group BLS signature over the concatenation of the\n    /// previous entry and seed.\n    ",
        "@notice": "Creates a new relay entry and stores the associated data on the chain.",
        "@param1": "_groupSignature Group BLS signature over the concatenation of the /// previous entry and seed.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isEntryInProgress",
        "visibility": "public",
        "args": [],
        "func": "function isEntryInProgress() public view returns (bool) {\n        return currentRequestStartBlock != 0;\n    }",
        "comments": [
            "",
            "    /// @notice Returns true if generation of a new relay entry is currently in",
            "    /// progress.",
            "    "
        ],
        "comt": "\n    /// @notice Returns true if generation of a new relay entry is currently in\n    /// progress.\n    ",
        "@notice": "Returns true if generation of a new relay entry is currently in /// progress.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "reportRelayEntryTimeout",
        "visibility": "public",
        "args": [],
        "func": "function reportRelayEntryTimeout() public {\n        require(hasEntryTimedOut(), \"Entry did not time out\");\n        groups.reportRelayEntryTimeout(currentRequestGroupIndex, groupSize);\n        currentRequestStartBlock = 0;\n\n        // We could terminate the last active group. If that's the case,\n        // do not try to execute signing again because there is no group\n        // which can handle it.\n        if (numberOfGroups() > 0) {\n            signRelayEntry(\n                currentRequestId,\n                currentRequestPreviousEntry,\n                currentRequestServiceContract,\n                currentRequestEntryVerificationAndProfitFee,\n                currentRequestCallbackFee\n            );\n        }\n\n        emit RelayEntryTimeoutReported(currentRequestGroupIndex);\n    }",
        "comments": [
            "",
            "    /// @notice Function used to inform about the fact the currently ongoing",
            "    /// new relay entry generation operation timed out. As a result, the group",
            "    /// which was supposed to produce a new relay entry is immediately",
            "    /// terminated and a new group is selected to produce a new relay entry.",
            "    /// All members of the group are punished by seizing minimum stake of",
            "    /// their tokens. The submitter of the transaction is rewarded with a",
            "    /// tattletale reward which is limited to min(1, 20 / group_size) of the",
            "    /// maximum tattletale reward.",
            "    "
        ],
        "comt": "\n    /// @notice Function used to inform about the fact the currently ongoing\n    /// new relay entry generation operation timed out. As a result, the group\n    /// which was supposed to produce a new relay entry is immediately\n    /// terminated and a new group is selected to produce a new relay entry.\n    /// All members of the group are punished by seizing minimum stake of\n    /// their tokens. The submitter of the transaction is rewarded with a\n    /// tattletale reward which is limited to min(1, 20 / group_size) of the\n    /// maximum tattletale reward.\n    ",
        "@notice": "Function used to inform about the fact the currently ongoing /// new relay entry generation operation timed out. As a result, the group /// which was supposed to produce a new relay entry is immediately /// terminated and a new group is selected to produce a new relay entry. /// All members of the group are punished by seizing minimum stake of /// their tokens. The submitter of the transaction is rewarded with a /// tattletale reward which is limited to min(1, 20 / group_size) of the /// maximum tattletale reward.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "groupProfitFee",
        "visibility": "public",
        "args": [],
        "func": "function groupProfitFee() public view returns(uint256) {\n        return groupMemberBaseReward.mul(groupSize);\n    }",
        "comments": [
            "",
            "    /// @notice Gets group profit fee expressed in wei.",
            "    "
        ],
        "comt": "\n    /// @notice Gets group profit fee expressed in wei.\n    ",
        "@notice": "Gets group profit fee expressed in wei.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "hasMinimumStake",
        "visibility": "public",
        "args": [
            {
                "name": "staker",
                "type": "address"
            }
        ],
        "func": "function hasMinimumStake(address staker) public view returns(bool) {\n        return stakingContract.hasMinimumStake(staker, address(this));\n    }",
        "comments": [
            "",
            "    /// @notice Checks if the specified account has enough active stake to become",
            "    /// network operator and that this contract has been authorized for potential",
            "    /// slashing.",
            "    ///",
            "    /// Having the required minimum of active stake makes the operator eligible",
            "    /// to join the network. If the active stake is not currently undelegating,",
            "    /// operator is also eligible for work selection.",
            "    ///",
            "    /// @param staker Staker's address",
            "    /// @return True if has enough active stake to participate in the network,",
            "    /// false otherwise.",
            "    "
        ],
        "comt": "\n    /// @notice Checks if the specified account has enough active stake to become\n    /// network operator and that this contract has been authorized for potential\n    /// slashing.\n    ///\n    /// Having the required minimum of active stake makes the operator eligible\n    /// to join the network. If the active stake is not currently undelegating,\n    /// operator is also eligible for work selection.\n    ///\n    /// @param staker Staker's address\n    /// @return True if has enough active stake to participate in the network,\n    /// false otherwise.\n    ",
        "@notice": "Checks if the specified account has enough active stake to become /// network operator and that this contract has been authorized for potential /// slashing. /// /// Having the required minimum of active stake makes the operator eligible /// to join the network. If the active stake is not currently undelegating, /// operator is also eligible for work selection.",
        "@param1": "staker Staker's address",
        "@return1": "True if has enough active stake to participate in the network, /// false otherwise.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isGroupRegistered",
        "visibility": "public",
        "args": [
            {
                "name": "groupPubKey",
                "type": "bytes memory"
            }
        ],
        "func": "function isGroupRegistered(bytes memory groupPubKey) public view returns(bool) {\n        return groups.isGroupRegistered(groupPubKey);\n    }",
        "comments": [
            "",
            "    /// @notice Checks if group with the given public key is registered.",
            "    "
        ],
        "comt": "\n    /// @notice Checks if group with the given public key is registered.\n    ",
        "@notice": "Checks if group with the given public key is registered.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isStaleGroup",
        "visibility": "public",
        "args": [
            {
                "name": "groupPubKey",
                "type": "bytes memory"
            }
        ],
        "func": "function isStaleGroup(bytes memory groupPubKey) public view returns(bool) {\n        return groups.isStaleGroup(groupPubKey);\n    }",
        "comments": [
            "",
            "    /// @notice Checks if a group with the given public key is a stale group.",
            "    /// Stale group is an expired group which is no longer performing any",
            "    /// operations. It is important to understand that an expired group may",
            "    /// still perform some operations for which it was selected when it was still",
            "    /// active. We consider a group to be stale when it's expired and when its",
            "    /// expiration time and potentially executed operation timeout are both in",
            "    /// the past.",
            "    "
        ],
        "comt": "\n    /// @notice Checks if a group with the given public key is a stale group.\n    /// Stale group is an expired group which is no longer performing any\n    /// operations. It is important to understand that an expired group may\n    /// still perform some operations for which it was selected when it was still\n    /// active. We consider a group to be stale when it's expired and when its\n    /// expiration time and potentially executed operation timeout are both in\n    /// the past.\n    ",
        "@notice": "Checks if a group with the given public key is a stale group. /// Stale group is an expired group which is no longer performing any /// operations. It is important to understand that an expired group may /// still perform some operations for which it was selected when it was still /// active. We consider a group to be stale when it's expired and when its /// expiration time and potentially executed operation timeout are both in /// the past.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "numberOfGroups",
        "visibility": "public",
        "args": [],
        "func": "function numberOfGroups() public view returns(uint256) {\n        return groups.numberOfGroups();\n    }",
        "comments": [
            "",
            "    /// @notice Gets the number of active groups as currently marked in the",
            "    /// contract. This is the state from when the expired groups were last updated",
            "    /// without accounting for recent expirations.",
            "    ///",
            "    /// @dev Even if numberOfGroups() > 0, it is still possible requesting for",
            "    /// a new relay entry will revert with \"no active groups\" failure message.",
            "    /// This function returns the number of active groups as they are currently",
            "    /// marked on-chain. However, during relay request, before group selection,",
            "    /// we run group expiration and it may happen that some groups seen as active",
            "    /// turns out to be expired.",
            "    "
        ],
        "comt": "\n    /// @notice Gets the number of active groups as currently marked in the\n    /// contract. This is the state from when the expired groups were last updated\n    /// without accounting for recent expirations.\n    ///\n    /// @dev Even if numberOfGroups() > 0, it is still possible requesting for\n    /// a new relay entry will revert with \"no active groups\" failure message.\n    /// This function returns the number of active groups as they are currently\n    /// marked on-chain. However, during relay request, before group selection,\n    /// we run group expiration and it may happen that some groups seen as active\n    /// turns out to be expired.\n    ",
        "@notice": "Gets the number of active groups as currently marked in the /// contract. This is the state from when the expired groups were last updated /// without accounting for recent expirations.",
        "@dev": "Even if numberOfGroups() > 0, it is still possible requesting for /// a new relay entry will revert with \"no active groups\" failure message. /// This function returns the number of active groups as they are currently /// marked on-chain. However, during relay request, before group selection, /// we run group expiration and it may happen that some groups seen as active /// turns out to be expired.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getGroupMemberRewards",
        "visibility": "public",
        "args": [
            {
                "name": "groupPubKey",
                "type": "bytes memory"
            }
        ],
        "func": "function getGroupMemberRewards(bytes memory groupPubKey) public view returns (uint256) {\n        return groups.groupMemberRewards[groupPubKey];\n    }",
        "comments": [
            "",
            "    /// @notice Returns accumulated group member rewards for provided group.",
            "    "
        ],
        "comt": "\n    /// @notice Returns accumulated group member rewards for provided group.\n    ",
        "@notice": "Returns accumulated group member rewards for provided group.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "hasWithdrawnRewards",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "groupIndex",
                "type": "uint256"
            }
        ],
        "func": "function hasWithdrawnRewards(address operator, uint256 groupIndex)\n        public view returns (bool) {\n        return groups.hasWithdrawnRewards(operator, groupIndex);\n    }",
        "comments": [
            "",
            "    /// @notice Return whether the given operator has withdrawn their rewards",
            "    /// from the given group.",
            "    "
        ],
        "comt": "\n    /// @notice Return whether the given operator has withdrawn their rewards\n    /// from the given group.\n    ",
        "@notice": "Return whether the given operator has withdrawn their rewards /// from the given group.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawGroupMemberRewards",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "groupIndex",
                "type": "uint256"
            }
        ],
        "func": "function withdrawGroupMemberRewards(address operator, uint256 groupIndex)\n        public nonReentrant {\n        uint256 accumulatedRewards = groups.withdrawFromGroup(operator, groupIndex);\n        (bool success, ) = stakingContract.beneficiaryOf(operator).call.value(accumulatedRewards)(\"\");\n        if (success) {\n            emit GroupMemberRewardsWithdrawn(stakingContract.beneficiaryOf(operator), operator, accumulatedRewards, groupIndex);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Withdraws accumulated group member rewards for operator",
            "    /// using the provided group index.",
            "    /// Once the accumulated reward is withdrawn from the selected group,",
            "    /// the operator is flagged as withdrawn.",
            "    /// Rewards can be withdrawn only from stale group.",
            "    /// @param operator Operator address",
            "    /// @param groupIndex Group index",
            "    "
        ],
        "comt": "\n    /// @notice Withdraws accumulated group member rewards for operator\n    /// using the provided group index.\n    /// Once the accumulated reward is withdrawn from the selected group,\n    /// the operator is flagged as withdrawn.\n    /// Rewards can be withdrawn only from stale group.\n    /// @param operator Operator address\n    /// @param groupIndex Group index\n    ",
        "@notice": "Withdraws accumulated group member rewards for operator /// using the provided group index. /// Once the accumulated reward is withdrawn from the selected group, /// the operator is flagged as withdrawn. /// Rewards can be withdrawn only from stale group.",
        "@param1": "operator Operator address",
        "@param2": "groupIndex Group index",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getFirstActiveGroupIndex",
        "visibility": "public",
        "args": [],
        "func": "function getFirstActiveGroupIndex() public view returns (uint256) {\n        return groups.expiredGroupOffset;\n    }",
        "comments": [
            "",
            "    /// @notice Gets the index of the first active group.",
            "    "
        ],
        "comt": "\n    /// @notice Gets the index of the first active group.\n    ",
        "@notice": "Gets the index of the first active group.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getGroupPublicKey",
        "visibility": "public",
        "args": [
            {
                "name": "groupIndex",
                "type": "uint256"
            }
        ],
        "func": "function getGroupPublicKey(uint256 groupIndex) public view returns (bytes memory) {\n        return groups.getGroupPublicKey(groupIndex);\n    }",
        "comments": [
            "",
            "    /// @notice Gets public key of the group with the given index.",
            "    "
        ],
        "comt": "\n    /// @notice Gets public key of the group with the given index.\n    ",
        "@notice": "Gets public key of the group with the given index.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "entryVerificationFee",
        "visibility": "public",
        "args": [],
        "func": "function entryVerificationFee() public view returns (uint256) {\n        return entryVerificationGasEstimate.mul(gasPriceCeiling);\n    }",
        "comments": [
            "",
            "    /// @notice Returns fee for entry verification in wei. Does not include group",
            "    /// profit fee, DKG contribution or callback fee.",
            "    "
        ],
        "comt": "\n    /// @notice Returns fee for entry verification in wei. Does not include group\n    /// profit fee, DKG contribution or callback fee.\n    ",
        "@notice": "Returns fee for entry verification in wei. Does not include group /// profit fee, DKG contribution or callback fee.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "groupCreationFee",
        "visibility": "public",
        "args": [],
        "func": "function groupCreationFee() public view returns (uint256) {\n        return dkgGasEstimate.add(groupSelectionGasEstimate).mul(gasPriceCeiling);\n    }",
        "comments": [
            "",
            "    /// @notice Returns fee for group creation in wei. Includes the cost of DKG",
            "    /// and the cost of triggering group selection.",
            "    "
        ],
        "comt": "\n    /// @notice Returns fee for group creation in wei. Includes the cost of DKG\n    /// and the cost of triggering group selection.\n    ",
        "@notice": "Returns fee for group creation in wei. Includes the cost of DKG /// and the cost of triggering group selection.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getGroupMembers",
        "visibility": "public",
        "args": [
            {
                "name": "groupPubKey",
                "type": "bytes memory"
            }
        ],
        "func": "function getGroupMembers(bytes memory groupPubKey) public view returns (address[] memory members) {\n        return groups.getGroupMembers(groupPubKey);\n    }",
        "comments": [
            "",
            "    /// @notice Returns members of the given group by group public key.",
            "    "
        ],
        "comt": "\n    /// @notice Returns members of the given group by group public key.\n    ",
        "@notice": "Returns members of the given group by group public key.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getNumberOfCreatedGroups",
        "visibility": "public",
        "args": [],
        "func": "function getNumberOfCreatedGroups() public view returns (uint256) {\n        return groups.groups.length;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getGroupRegistrationTime",
        "visibility": "public",
        "args": [
            {
                "name": "groupIndex",
                "type": "uint256"
            }
        ],
        "func": "function getGroupRegistrationTime(uint256 groupIndex) public view returns (uint256) {\n        return groups.getGroupRegistrationTime(groupIndex);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isGroupTerminated",
        "visibility": "public",
        "args": [
            {
                "name": "groupIndex",
                "type": "uint256"
            }
        ],
        "func": "function isGroupTerminated(uint256 groupIndex) public view returns (bool) {\n        return groups.isGroupTerminated(groupIndex);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "reportUnauthorizedSigning",
        "visibility": "public",
        "args": [
            {
                "name": "groupIndex",
                "type": "uint256"
            },
            {
                "name": "signedMsgSender",
                "type": "bytes memory"
            }
        ],
        "func": "function reportUnauthorizedSigning(\n        uint256 groupIndex,\n        bytes memory signedMsgSender\n    ) public {\n        groups.reportUnauthorizedSigning(\n            groupIndex,\n            signedMsgSender,\n            stakingContract.minimumStake()\n        );\n        emit UnauthorizedSigningReported(groupIndex);\n    }",
        "comments": [
            "",
            "    /// @notice Reports unauthorized signing for the provided group. Must provide",
            "    /// a valid signature of the tattletale address as a message. Successful signature",
            "    /// verification means the private key has been leaked and all group members",
            "    /// should be punished by seizing\u00a0their tokens. The submitter of this proof is",
            "    /// rewarded with 5% of the total seized amount scaled by the reward adjustment",
            "    /// parameter and the rest 95% is burned.",
            "    "
        ],
        "comt": "\n    /// @notice Reports unauthorized signing for the provided group. Must provide\n    /// a valid signature of the tattletale address as a message. Successful signature\n    /// verification means the private key has been leaked and all group members\n    /// should be punished by seizing\u00a0their tokens. The submitter of this proof is\n    /// rewarded with 5% of the total seized amount scaled by the reward adjustment\n    /// parameter and the rest 95% is burned.\n    ",
        "@notice": "Reports unauthorized signing for the provided group. Must provide /// a valid signature of the tattletale address as a message. Successful signature /// verification means the private key has been leaked and all group members /// should be punished by seizing their tokens. The submitter of this proof is /// rewarded with 5% of the total seized amount scaled by the reward adjustment /// parameter and the rest 95% is burned.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "minimumStake",
        "visibility": "public",
        "args": [],
        "func": "function minimumStake() public view returns (uint256) {\n        return MinimumStakeSchedule.current(minimumStakeScheduleStart);\n    }",
        "comments": [
            "",
            "    /// @notice Returns minimum amount of KEEP that allows sMPC cluster client to",
            "    /// participate in the Keep network. Expressed as number with 18-decimal places.",
            "    /// Initial minimum stake is higher than the final and lowered periodically based",
            "    /// on the amount of steps and the length of the minimum stake schedule in seconds.",
            "    "
        ],
        "comt": "\n    /// @notice Returns minimum amount of KEEP that allows sMPC cluster client to\n    /// participate in the Keep network. Expressed as number with 18-decimal places.\n    /// Initial minimum stake is higher than the final and lowered periodically based\n    /// on the amount of steps and the length of the minimum stake schedule in seconds.\n    ",
        "@notice": "Returns minimum amount of KEEP that allows sMPC cluster client to /// participate in the Keep network. Expressed as number with 18-decimal places. /// Initial minimum stake is higher than the final and lowered periodically based /// on the amount of steps and the length of the minimum stake schedule in seconds.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "undelegationPeriod",
        "visibility": "public",
        "args": [],
        "func": "function undelegationPeriod() public view returns(uint256) {\n        return block.timestamp < deployedAt.add(twoMonths) ? twoWeeks : twoMonths;\n    }",
        "comments": [
            "",
            "    /// @notice Returns the current value of the undelegation period.",
            "    /// The staking contract guarantees that an undelegated operator\u2019s stakes",
            "    /// will stay locked for a period of time after undelegation, and thus",
            "    /// available as collateral for any work the operator is engaged in.",
            "    /// The undelegation period is two weeks for the first two months and",
            "    /// two months after that.",
            "    "
        ],
        "comt": "\n    /// @notice Returns the current value of the undelegation period.\n    /// The staking contract guarantees that an undelegated operator\u2019s stakes\n    /// will stay locked for a period of time after undelegation, and thus\n    /// available as collateral for any work the operator is engaged in.\n    /// The undelegation period is two weeks for the first two months and\n    /// two months after that.\n    ",
        "@notice": "Returns the current value of the undelegation period. /// The staking contract guarantees that an undelegated operator\u2019s stakes /// will stay locked for a period of time after undelegation, and thus /// available as collateral for any work the operator is engaged in. /// The undelegation period is two weeks for the first two months and /// two months after that.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "receiveApproval",
        "visibility": "public",
        "args": [
            {
                "name": "_from",
                "type": "address"
            },
            {
                "name": "_value",
                "type": "uint256"
            },
            {
                "name": "_token",
                "type": "address"
            },
            {
                "name": "_extraData",
                "type": "bytes memory"
            }
        ],
        "func": "function receiveApproval(\n        address _from,\n        uint256 _value,\n        address _token,\n        bytes memory _extraData\n    ) public {\n        require(ERC20Burnable(_token) == token, \"Unrecognized token\");\n        require(_extraData.length >= 60, \"Corrupted delegation data\");\n\n        // Transfer tokens to this contract.\n        token.safeTransferFrom(_from, address(this), _value);\n\n        address operator = _extraData.toAddress(20);\n        // See if there is an existing delegation for this operator...\n        if (operators[operator].packedParams.getCreationTimestamp() == 0) {\n            // If there is no existing delegation, delegate tokens using\n            // beneficiary and authorizer passed in _extraData.\n            delegate(_from, _value, operator, _extraData);\n        } else {\n            // If there is an existing delegation, top-up the stake.\n            topUp(_from, _value, operator, _extraData);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Receives approval of token transfer and stakes the approved",
            "    /// amount or adds the approved amount to an existing delegation (a \u201ctop-up\u201d).",
            "    /// In case of a top-up, it is expected that the operator stake is not",
            "    /// undelegated and that the top-up is performed from the same source of",
            "    /// tokens as the initial delegation. That is, if the tokens were delegated",
            "    /// from a grant, top-up has to be performed from the same grant. If the",
            "    /// delegation was done using liquid tokens, only liquid tokens from the",
            "    /// same owner can be used to top-up the stake.",
            "    /// Top-up can not be cancelled so it is important to be careful with the",
            "    /// amount of KEEP added to the stake.",
            "    /// @dev Requires that the provided token contract be the same one linked to",
            "    /// this contract.",
            "    /// @param _from The owner of the tokens who approved them to transfer.",
            "    /// @param _value Approved amount for the transfer and stake.",
            "    /// @param _token Token contract address.",
            "    /// @param _extraData Data for stake delegation. This byte array must have",
            "    /// the following values concatenated:",
            "    /// - Beneficiary address (20 bytes), ignored for a top-up",
            "    /// - Operator address (20 bytes)",
            "    /// - Authorizer address (20 bytes), ignored for a top-up",
            "    /// - Grant ID (32 bytes) - required only when called by TokenStakingEscrow",
            "    "
        ],
        "comt": "\n    /// @notice Receives approval of token transfer and stakes the approved\n    /// amount or adds the approved amount to an existing delegation (a \u201ctop-up\u201d).\n    /// In case of a top-up, it is expected that the operator stake is not\n    /// undelegated and that the top-up is performed from the same source of\n    /// tokens as the initial delegation. That is, if the tokens were delegated\n    /// from a grant, top-up has to be performed from the same grant. If the\n    /// delegation was done using liquid tokens, only liquid tokens from the\n    /// same owner can be used to top-up the stake.\n    /// Top-up can not be cancelled so it is important to be careful with the\n    /// amount of KEEP added to the stake.\n    /// @dev Requires that the provided token contract be the same one linked to\n    /// this contract.\n    /// @param _from The owner of the tokens who approved them to transfer.\n    /// @param _value Approved amount for the transfer and stake.\n    /// @param _token Token contract address.\n    /// @param _extraData Data for stake delegation. This byte array must have\n    /// the following values concatenated:\n    /// - Beneficiary address (20 bytes), ignored for a top-up\n    /// - Operator address (20 bytes)\n    /// - Authorizer address (20 bytes), ignored for a top-up\n    /// - Grant ID (32 bytes) - required only when called by TokenStakingEscrow\n    ",
        "@notice": "Receives approval of token transfer and stakes the approved /// amount or adds the approved amount to an existing delegation (a \u201ctop-up\u201d). /// In case of a top-up, it is expected that the operator stake is not /// undelegated and that the top-up is performed from the same source of /// tokens as the initial delegation. That is, if the tokens were delegated /// from a grant, top-up has to be performed from the same grant. If the /// delegation was done using liquid tokens, only liquid tokens from the /// same owner can be used to top-up the stake. /// Top-up can not be cancelled so it is important to be careful with the /// amount of KEEP added to the stake.",
        "@dev": "Requires that the provided token contract be the same one linked to /// this contract.",
        "@param1": "_from The owner of the tokens who approved them to transfer.",
        "@param2": "_value Approved amount for the transfer and stake.",
        "@param3": "_token Token contract address.",
        "@param4": "_extraData Data for stake delegation. This byte array must have /// the following values concatenated: /// - Beneficiary address (20 bytes), ignored for a top-up /// - Operator address (20 bytes) /// - Authorizer address (20 bytes), ignored for a top-up /// - Grant ID (32 bytes) - required only when called by TokenStakingEscrow",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "commitTopUp",
        "visibility": "public",
        "args": [
            {
                "name": "_operator",
                "type": "address"
            }
        ],
        "func": "function commitTopUp(address _operator) public {\n        operators[_operator].packedParams = topUps.commit(\n            _operator,\n            operators[_operator].packedParams,\n            initializationPeriod\n        );\n    }",
        "comments": [
            "",
            "    /// @notice Commits pending top-up for the provided operator. If the top-up",
            "    /// did not pass the initialization period, the function fails.",
            "    /// @param _operator The operator with a pending top-up that is getting",
            "    /// committed.",
            "    "
        ],
        "comt": "\n    /// @notice Commits pending top-up for the provided operator. If the top-up\n    /// did not pass the initialization period, the function fails.\n    /// @param _operator The operator with a pending top-up that is getting\n    /// committed.\n    ",
        "@notice": "Commits pending top-up for the provided operator. If the top-up /// did not pass the initialization period, the function fails.",
        "@param1": "_operator The operator with a pending top-up that is getting /// committed.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cancelStake",
        "visibility": "public",
        "args": [
            {
                "name": "_operator",
                "type": "address"
            }
        ],
        "func": "function cancelStake(address _operator) public {\n        address owner = operators[_operator].owner;\n        require(\n            msg.sender == owner ||\n            msg.sender == _operator ||\n            grantStaking.canUndelegate(_operator, tokenGrant),\n            \"Not authorized\"\n        );\n        uint256 operatorParams = operators[_operator].packedParams;\n\n        require(\n            !_isInitialized(operatorParams),\n            \"Initialized stake\"\n        );\n\n        uint256 amount = operatorParams.getAmount();\n        operators[_operator].packedParams = operatorParams.setAmount(0);\n\n        transferOrDeposit(owner, _operator, amount);\n    }",
        "comments": [
            "",
            "    /// @notice Cancels stake of tokens within the operator initialization period",
            "    /// without being subjected to the token lockup for the undelegation period.",
            "    /// This can be used to undo mistaken delegation to the wrong operator address.",
            "    /// @param _operator Address of the stake operator.",
            "    "
        ],
        "comt": "\n    /// @notice Cancels stake of tokens within the operator initialization period\n    /// without being subjected to the token lockup for the undelegation period.\n    /// This can be used to undo mistaken delegation to the wrong operator address.\n    /// @param _operator Address of the stake operator.\n    ",
        "@notice": "Cancels stake of tokens within the operator initialization period /// without being subjected to the token lockup for the undelegation period. /// This can be used to undo mistaken delegation to the wrong operator address.",
        "@param1": "_operator Address of the stake operator.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "undelegate",
        "visibility": "public",
        "args": [
            {
                "name": "_operator",
                "type": "address"
            }
        ],
        "func": "function undelegate(address _operator) public {\n        undelegateAt(_operator, block.timestamp);\n    }",
        "comments": [
            "",
            "    /// @notice Undelegates staked tokens. You will be able to recover your stake by calling",
            "    /// `recoverStake()` with operator address once undelegation period is over.",
            "    /// @param _operator Address of the stake operator.",
            "    "
        ],
        "comt": "\n    /// @notice Undelegates staked tokens. You will be able to recover your stake by calling\n    /// `recoverStake()` with operator address once undelegation period is over.\n    /// @param _operator Address of the stake operator.\n    ",
        "@notice": "Undelegates staked tokens. You will be able to recover your stake by calling /// `recoverStake()` with operator address once undelegation period is over.",
        "@param1": "_operator Address of the stake operator.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "undelegateAt",
        "visibility": "public",
        "args": [
            {
                "name": "_operator",
                "type": "address"
            },
            {
                "name": "_undelegationTimestamp",
                "type": "uint256"
            }
        ],
        "func": "function undelegateAt(\n        address _operator,\n        uint256 _undelegationTimestamp\n    ) public {\n        require(\n            msg.sender == _operator ||\n            msg.sender == operators[_operator].owner ||\n            grantStaking.canUndelegate(_operator, tokenGrant),\n            \"Not authorized\"\n        );\n        uint256 oldParams = operators[_operator].packedParams;\n        require(\n            _undelegationTimestamp >= block.timestamp &&\n            _undelegationTimestamp > oldParams.getCreationTimestamp().add(initializationPeriod),\n            \"Invalid timestamp\"\n        );\n        uint256 existingUndelegationTimestamp = oldParams.getUndelegationTimestamp();\n        require(\n            // Undelegation not in progress OR\n            existingUndelegationTimestamp == 0 ||\n            // Undelegating sooner than previously set time OR\n            existingUndelegationTimestamp > _undelegationTimestamp ||\n            // We have already checked above that msg.sender is owner, grantee,\n            // or operator. Only owner and grantee are eligible to postpone the\n            // delegation so it is enough if we exclude operator here.\n            msg.sender != _operator,\n            \"Operator may not postpone\"\n        );\n        operators[_operator].packedParams = oldParams.setUndelegationTimestamp(\n            _undelegationTimestamp\n        );\n        emit Undelegated(_operator, _undelegationTimestamp);\n    }",
        "comments": [
            "",
            "    /// @notice Set an undelegation time for staked tokens.",
            "    /// Undelegation will begin at the specified timestamp.",
            "    /// You will be able to recover your stake by calling",
            "    /// `recoverStake()` with operator address once undelegation period is over.",
            "    /// @param _operator Address of the stake operator.",
            "    /// @param _undelegationTimestamp The timestamp undelegation is to start at.",
            "    "
        ],
        "comt": "\n    /// @notice Set an undelegation time for staked tokens.\n    /// Undelegation will begin at the specified timestamp.\n    /// You will be able to recover your stake by calling\n    /// `recoverStake()` with operator address once undelegation period is over.\n    /// @param _operator Address of the stake operator.\n    /// @param _undelegationTimestamp The timestamp undelegation is to start at.\n    ",
        "@notice": "Set an undelegation time for staked tokens. /// Undelegation will begin at the specified timestamp. /// You will be able to recover your stake by calling /// `recoverStake()` with operator address once undelegation period is over.",
        "@param1": "_operator Address of the stake operator.",
        "@param2": "_undelegationTimestamp The timestamp undelegation is to start at.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "recoverStake",
        "visibility": "public",
        "args": [
            {
                "name": "_operator",
                "type": "address"
            }
        ],
        "func": "function recoverStake(address _operator) public {\n        uint256 operatorParams = operators[_operator].packedParams;\n        require(\n            operatorParams.getUndelegationTimestamp() != 0,\n            \"Not undelegated\"\n        );\n        require(\n            _isUndelegatingFinished(operatorParams),\n            \"Still undelegating\"\n        );\n        require(\n            !isStakeLocked(_operator),\n            \"Locked stake\"\n        );\n\n        uint256 amount = operatorParams.getAmount();\n\n        // If there is a pending top-up, force-commit it before returning tokens.\n        amount = amount.add(topUps.cancel(_operator));\n\n        operators[_operator].packedParams = operatorParams.setAmount(0);\n        transferOrDeposit(operators[_operator].owner, _operator, amount);\n\n        emit RecoveredStake(_operator);\n    }",
        "comments": [
            "",
            "    /// @notice Recovers staked tokens and transfers them back to the owner.",
            "    /// Recovering tokens can only be performed when the operator finished",
            "    /// undelegating.",
            "    /// @param _operator Operator address.",
            "    "
        ],
        "comt": "\n    /// @notice Recovers staked tokens and transfers them back to the owner.\n    /// Recovering tokens can only be performed when the operator finished\n    /// undelegating.\n    /// @param _operator Operator address.\n    ",
        "@notice": "Recovers staked tokens and transfers them back to the owner. /// Recovering tokens can only be performed when the operator finished /// undelegating.",
        "@param1": "_operator Operator address.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getDelegationInfo",
        "visibility": "public",
        "args": [
            {
                "name": "_operator",
                "type": "address"
            }
        ],
        "func": "function getDelegationInfo(address _operator)\n    public view returns (uint256 amount, uint256 createdAt, uint256 undelegatedAt) {\n        return operators[_operator].packedParams.unpack();\n    }",
        "comments": [
            "",
            "    /// @notice Gets stake delegation info for the given operator.",
            "    /// @param _operator Operator address.",
            "    /// @return amount The amount of tokens the given operator delegated.",
            "    /// @return createdAt The time when the stake has been delegated.",
            "    /// @return undelegatedAt The time when undelegation has been requested.",
            "    /// If undelegation has not been requested, 0 is returned.",
            "    "
        ],
        "comt": "\n    /// @notice Gets stake delegation info for the given operator.\n    /// @param _operator Operator address.\n    /// @return amount The amount of tokens the given operator delegated.\n    /// @return createdAt The time when the stake has been delegated.\n    /// @return undelegatedAt The time when undelegation has been requested.\n    /// If undelegation has not been requested, 0 is returned.\n    ",
        "@notice": "Gets stake delegation info for the given operator.",
        "@param1": "_operator Operator address.",
        "@return1": "amount The amount of tokens the given operator delegated.",
        "@return2": "createdAt The time when the stake has been delegated.",
        "@return3": "undelegatedAt The time when undelegation has been requested. /// If undelegation has not been requested, 0 is returned.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lockStake",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "duration",
                "type": "uint256"
            }
        ],
        "func": "function lockStake(\n        address operator,\n        uint256 duration\n    ) public onlyApprovedOperatorContract(msg.sender) {\n        require(\n            isAuthorizedForOperator(operator, msg.sender),\n            \"Not authorized\"\n        );\n\n        uint256 operatorParams = operators[operator].packedParams;\n\n        require(\n            _isInitialized(operatorParams),\n            \"Inactive stake\"\n        );\n        require(\n            !_isUndelegating(operatorParams),\n            \"Undelegating stake\"\n        );\n\n        locks.lockStake(operator, duration);\n    }",
        "comments": [
            "",
            "    /// @notice Locks given operator stake for the specified duration.",
            "    /// Locked stake may not be recovered until the lock expires or is released,",
            "    /// even if the normal undelegation period has passed.",
            "    /// Only previously authorized operator contract can lock the stake.",
            "    /// @param operator Operator address.",
            "    /// @param duration Lock duration in seconds.",
            "    "
        ],
        "comt": "\n    /// @notice Locks given operator stake for the specified duration.\n    /// Locked stake may not be recovered until the lock expires or is released,\n    /// even if the normal undelegation period has passed.\n    /// Only previously authorized operator contract can lock the stake.\n    /// @param operator Operator address.\n    /// @param duration Lock duration in seconds.\n    ",
        "@notice": "Locks given operator stake for the specified duration. /// Locked stake may not be recovered until the lock expires or is released, /// even if the normal undelegation period has passed. /// Only previously authorized operator contract can lock the stake.",
        "@param1": "operator Operator address.",
        "@param2": "duration Lock duration in seconds.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unlockStake",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function unlockStake(\n        address operator\n    ) public {\n        require(\n            isAuthorizedForOperator(operator, msg.sender),\n            \"Not authorized\"\n        );\n        locks.releaseLock(operator);\n    }",
        "comments": [
            "",
            "    /// @notice Removes a lock the caller had previously placed on the operator.",
            "    /// @dev Only for operator contracts.",
            "    /// To remove expired or disabled locks, use `releaseExpiredLocks`.",
            "    /// The authorization check ensures that the caller must have been able",
            "    /// to place a lock on the operator sometime in the past.",
            "    /// We don't need to check for current approval status of the caller",
            "    /// because unlocking stake cannot harm the operator",
            "    /// nor interfere with other operator contracts.",
            "    /// Therefore even disabled operator contracts may freely unlock stake.",
            "    /// @param operator Operator address.",
            "    "
        ],
        "comt": "\n    /// @notice Removes a lock the caller had previously placed on the operator.\n    /// @dev Only for operator contracts.\n    /// To remove expired or disabled locks, use `releaseExpiredLocks`.\n    /// The authorization check ensures that the caller must have been able\n    /// to place a lock on the operator sometime in the past.\n    /// We don't need to check for current approval status of the caller\n    /// because unlocking stake cannot harm the operator\n    /// nor interfere with other operator contracts.\n    /// Therefore even disabled operator contracts may freely unlock stake.\n    /// @param operator Operator address.\n    ",
        "@notice": "Removes a lock the caller had previously placed on the operator.",
        "@dev": "Only for operator contracts. /// To remove expired or disabled locks, use `releaseExpiredLocks`. /// The authorization check ensures that the caller must have been able /// to place a lock on the operator sometime in the past. /// We don't need to check for current approval status of the caller /// because unlocking stake cannot harm the operator /// nor interfere with other operator contracts. /// Therefore even disabled operator contracts may freely unlock stake.",
        "@param1": "operator Operator address.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "releaseExpiredLock",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "operatorContract",
                "type": "address"
            }
        ],
        "func": "function releaseExpiredLock(\n        address operator,\n        address operatorContract\n    ) public {\n        locks.releaseExpiredLock(operator, operatorContract, address(this));\n    }",
        "comments": [
            "",
            "    /// @notice Removes the lock of the specified operator contract",
            "    /// if the lock has expired or the contract has been disabled.",
            "    /// @dev Necessary for removing locks placed by contracts",
            "    /// that have been disabled by the panic button.",
            "    /// Also applicable to prevent inadvertent DoS of `recoverStake`",
            "    /// if too many operator contracts have failed to clean up their locks.",
            "    "
        ],
        "comt": "\n    /// @notice Removes the lock of the specified operator contract\n    /// if the lock has expired or the contract has been disabled.\n    /// @dev Necessary for removing locks placed by contracts\n    /// that have been disabled by the panic button.\n    /// Also applicable to prevent inadvertent DoS of `recoverStake`\n    /// if too many operator contracts have failed to clean up their locks.\n    ",
        "@notice": "Removes the lock of the specified operator contract /// if the lock has expired or the contract has been disabled.",
        "@dev": "Necessary for removing locks placed by contracts /// that have been disabled by the panic button. /// Also applicable to prevent inadvertent DoS of `recoverStake` /// if too many operator contracts have failed to clean up their locks.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isStakeLocked",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function isStakeLocked(address operator) public view returns (bool) {\n        return locks.isStakeLocked(operator, address(this));\n    }",
        "comments": [
            "",
            "    /// @notice Check whether the operator has any active locks",
            "    /// that haven't expired yet",
            "    /// and whose creators aren't disabled by the panic button.",
            "    "
        ],
        "comt": "\n    /// @notice Check whether the operator has any active locks\n    /// that haven't expired yet\n    /// and whose creators aren't disabled by the panic button.\n    ",
        "@notice": "Check whether the operator has any active locks /// that haven't expired yet /// and whose creators aren't disabled by the panic button.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getLocks",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function getLocks(address operator)\n        public\n        view\n        returns (address[] memory creators, uint256[] memory expirations) {\n        return locks.getLocks(operator);\n    }",
        "comments": [
            "",
            "    /// @notice Get the locks placed on the operator.",
            "    /// @return creators The addresses of operator contracts",
            "    /// that have placed a lock on the operator.",
            "    /// @return expirations The expiration times",
            "    /// of the locks placed on the operator.",
            "    "
        ],
        "comt": "\n    /// @notice Get the locks placed on the operator.\n    /// @return creators The addresses of operator contracts\n    /// that have placed a lock on the operator.\n    /// @return expirations The expiration times\n    /// of the locks placed on the operator.\n    ",
        "@notice": "Get the locks placed on the operator.",
        "@return1": "creators The addresses of operator contracts /// that have placed a lock on the operator.",
        "@return2": "expirations The expiration times /// of the locks placed on the operator.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "slash",
        "visibility": "public",
        "args": [
            {
                "name": "amountToSlash",
                "type": "uint256"
            },
            {
                "name": "misbehavedOperators",
                "type": "address[] memory"
            }
        ],
        "func": "function slash(uint256 amountToSlash, address[] memory misbehavedOperators)\n        public\n        onlyApprovedOperatorContract(msg.sender) {\n\n        uint256 totalAmountToBurn;\n        address authoritySource = getAuthoritySource(msg.sender);\n        for (uint i = 0; i < misbehavedOperators.length; i++) {\n            address operator = misbehavedOperators[i];\n            require(authorizations[authoritySource][operator], \"Not authorized\");\n\n            uint256 operatorParams = operators[operator].packedParams;\n            require(\n                _isInitialized(operatorParams),\n                \"Inactive stake\"\n            );\n\n            require(\n                !_isStakeReleased(operator, operatorParams, msg.sender),\n                \"Stake is released\"\n            );\n\n            uint256 currentAmount = operatorParams.getAmount();\n\n            if (currentAmount < amountToSlash) {\n                totalAmountToBurn = totalAmountToBurn.add(currentAmount);\n                operators[operator].packedParams = operatorParams.setAmount(0);\n                emit TokensSlashed(operator, currentAmount);\n            } else {\n                totalAmountToBurn = totalAmountToBurn.add(amountToSlash);\n                operators[operator].packedParams = operatorParams.setAmount(\n                    currentAmount.sub(amountToSlash)\n                );\n                emit TokensSlashed(operator, amountToSlash);\n            }\n        }\n\n        token.burn(totalAmountToBurn);\n    }",
        "comments": [
            "",
            "    /// @notice Slash provided token amount from every member in the misbehaved",
            "    /// operators array and burn 100% of all the tokens.",
            "    /// @param amountToSlash Token amount to slash from every misbehaved operator.",
            "    /// @param misbehavedOperators Array of addresses to seize the tokens from.",
            "    "
        ],
        "comt": "\n    /// @notice Slash provided token amount from every member in the misbehaved\n    /// operators array and burn 100% of all the tokens.\n    /// @param amountToSlash Token amount to slash from every misbehaved operator.\n    /// @param misbehavedOperators Array of addresses to seize the tokens from.\n    ",
        "@notice": "Slash provided token amount from every member in the misbehaved /// operators array and burn 100% of all the tokens.",
        "@param1": "amountToSlash Token amount to slash from every misbehaved operator.",
        "@param2": "misbehavedOperators Array of addresses to seize the tokens from.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "seize",
        "visibility": "public",
        "args": [
            {
                "name": "amountToSeize",
                "type": "uint256"
            },
            {
                "name": "rewardMultiplier",
                "type": "uint256"
            },
            {
                "name": "tattletale",
                "type": "address"
            },
            {
                "name": "misbehavedOperators",
                "type": "address[] memory"
            }
        ],
        "func": "function seize(\n        uint256 amountToSeize,\n        uint256 rewardMultiplier,\n        address tattletale,\n        address[] memory misbehavedOperators\n    ) public onlyApprovedOperatorContract(msg.sender) {\n        uint256 totalAmountToBurn;\n        address authoritySource = getAuthoritySource(msg.sender);\n        for (uint i = 0; i < misbehavedOperators.length; i++) {\n            address operator = misbehavedOperators[i];\n            require(authorizations[authoritySource][operator], \"Not authorized\");\n\n            uint256 operatorParams = operators[operator].packedParams;\n            require(\n                _isInitialized(operatorParams),\n                \"Inactive stake\"\n            );\n\n            require(\n                !_isStakeReleased(operator, operatorParams, msg.sender),\n                \"Stake is released\"\n            );\n\n            uint256 currentAmount = operatorParams.getAmount();\n\n            if (currentAmount < amountToSeize) {\n                totalAmountToBurn = totalAmountToBurn.add(currentAmount);\n                operators[operator].packedParams = operatorParams.setAmount(0);\n                emit TokensSeized(operator, currentAmount);\n            } else {\n                totalAmountToBurn = totalAmountToBurn.add(amountToSeize);\n                operators[operator].packedParams = operatorParams.setAmount(\n                    currentAmount.sub(amountToSeize)\n                );\n                emit TokensSeized(operator, amountToSeize);\n            }\n        }\n\n        uint256 tattletaleReward = (totalAmountToBurn.percent(5)).percent(rewardMultiplier);\n\n        token.safeTransfer(tattletale, tattletaleReward);\n        token.burn(totalAmountToBurn.sub(tattletaleReward));\n    }",
        "comments": [
            "",
            "    /// @notice Seize provided token amount from every member in the misbehaved",
            "    /// operators array. The tattletale is rewarded with 5% of the total seized",
            "    /// amount scaled by the reward adjustment parameter and the rest 95% is burned.",
            "    /// @param amountToSeize Token amount to seize from every misbehaved operator.",
            "    /// @param rewardMultiplier Reward adjustment in percentage. Min 1% and 100% max.",
            "    /// @param tattletale Address to receive the 5% reward.",
            "    /// @param misbehavedOperators Array of addresses to seize the tokens from.",
            "    "
        ],
        "comt": "\n    /// @notice Seize provided token amount from every member in the misbehaved\n    /// operators array. The tattletale is rewarded with 5% of the total seized\n    /// amount scaled by the reward adjustment parameter and the rest 95% is burned.\n    /// @param amountToSeize Token amount to seize from every misbehaved operator.\n    /// @param rewardMultiplier Reward adjustment in percentage. Min 1% and 100% max.\n    /// @param tattletale Address to receive the 5% reward.\n    /// @param misbehavedOperators Array of addresses to seize the tokens from.\n    ",
        "@notice": "Seize provided token amount from every member in the misbehaved /// operators array. The tattletale is rewarded with 5% of the total seized /// amount scaled by the reward adjustment parameter and the rest 95% is burned.",
        "@param1": "amountToSeize Token amount to seize from every misbehaved operator.",
        "@param2": "rewardMultiplier Reward adjustment in percentage. Min 1% and 100% max.",
        "@param3": "tattletale Address to receive the 5% reward.",
        "@param4": "misbehavedOperators Array of addresses to seize the tokens from.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferStakeOwnership",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "newOwner",
                "type": "address"
            }
        ],
        "func": "function transferStakeOwnership(address operator, address newOwner) public {\n        require(msg.sender == operators[operator].owner, \"Not authorized\");\n        operators[operator].owner = newOwner;\n        emit StakeOwnershipTransferred(operator, newOwner);\n    }",
        "comments": [
            "",
            "    /// @notice Allows the current staking relationship owner to transfer the",
            "    /// ownership to someone else.",
            "    /// @param operator Address of the stake operator.",
            "    /// @param newOwner Address of the new staking relationship owner.",
            "    "
        ],
        "comt": "\n    /// @notice Allows the current staking relationship owner to transfer the\n    /// ownership to someone else.\n    /// @param operator Address of the stake operator.\n    /// @param newOwner Address of the new staking relationship owner.\n    ",
        "@notice": "Allows the current staking relationship owner to transfer the /// ownership to someone else.",
        "@param1": "operator Address of the stake operator.",
        "@param2": "newOwner Address of the new staking relationship owner.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "eligibleStake",
        "visibility": "public",
        "args": [
            {
                "name": "_operator",
                "type": "address"
            },
            {
                "name": "_operatorContract",
                "type": "address"
            }
        ],
        "func": "function eligibleStake(\n        address _operator,\n        address _operatorContract\n    ) public view returns (uint256 balance) {\n        uint256 operatorParams = operators[_operator].packedParams;\n        // To be eligible for work selection, the operator must:\n        // - have the operator contract authorized\n        // - have the stake initialized\n        // - must not be undelegating; keep in mind the `undelegatedAt` may be\n        // set to a time in the future, to schedule undelegation in advance.\n        // In this case the operator is still eligible until the timestamp\n        // `undelegatedAt`.\n        if (\n            isAuthorizedForOperator(_operator, _operatorContract) &&\n            _isInitialized(operatorParams) &&\n            !_isUndelegating(operatorParams)\n        ) {\n            balance = operatorParams.getAmount();\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Gets the eligible stake balance of the specified address.",
            "    /// An eligible stake is a stake that passed the initialization period",
            "    /// and is not currently undelegating. Also, the operator had to approve",
            "    /// the specified operator contract.",
            "    ///",
            "    /// Operator with a minimum required amount of eligible stake can join the",
            "    /// network and participate in new work selection.",
            "    ///",
            "    /// @param _operator address of stake operator.",
            "    /// @param _operatorContract address of operator contract.",
            "    /// @return an uint256 representing the eligible stake balance.",
            "    "
        ],
        "comt": "\n    /// @notice Gets the eligible stake balance of the specified address.\n    /// An eligible stake is a stake that passed the initialization period\n    /// and is not currently undelegating. Also, the operator had to approve\n    /// the specified operator contract.\n    ///\n    /// Operator with a minimum required amount of eligible stake can join the\n    /// network and participate in new work selection.\n    ///\n    /// @param _operator address of stake operator.\n    /// @param _operatorContract address of operator contract.\n    /// @return an uint256 representing the eligible stake balance.\n    ",
        "@notice": "Gets the eligible stake balance of the specified address. /// An eligible stake is a stake that passed the initialization period /// and is not currently undelegating. Also, the operator had to approve /// the specified operator contract. /// /// Operator with a minimum required amount of eligible stake can join the /// network and participate in new work selection.",
        "@param1": "_operator address of stake operator.",
        "@param2": "_operatorContract address of operator contract.",
        "@return1": "an uint256 representing the eligible stake balance.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "activeStake",
        "visibility": "public",
        "args": [
            {
                "name": "_operator",
                "type": "address"
            },
            {
                "name": "_operatorContract",
                "type": "address"
            }
        ],
        "func": "function activeStake(\n        address _operator,\n        address _operatorContract\n    ) public view returns (uint256 balance) {\n        uint256 operatorParams = operators[_operator].packedParams;\n        if (\n            isAuthorizedForOperator(_operator, _operatorContract) &&\n            _isInitialized(operatorParams) &&\n            !_isStakeReleased(\n                _operator,\n                operatorParams,\n                _operatorContract\n            )\n        ) {\n            balance = operatorParams.getAmount();\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Gets the active stake balance of the specified address.",
            "    /// An active stake is a stake that passed the initialization period,",
            "    /// and may be in the process of undelegation",
            "    /// but has not been released yet,",
            "    /// either because the undelegation period is not over,",
            "    /// or because the operator contract has an active lock on the operator.",
            "    /// Also, the operator had to approve the specified operator contract.",
            "    ///",
            "    /// The difference between eligible stake is that active stake does not make",
            "    /// the operator eligible for work selection but it may be still finishing",
            "    /// earlier work until the stake is released.",
            "    /// Operator with a minimum required",
            "    /// amount of active stake can join the network but cannot be selected to any",
            "    /// new work.",
            "    ///",
            "    /// @param _operator address of stake operator.",
            "    /// @param _operatorContract address of operator contract.",
            "    /// @return an uint256 representing the eligible stake balance.",
            "    "
        ],
        "comt": "\n    /// @notice Gets the active stake balance of the specified address.\n    /// An active stake is a stake that passed the initialization period,\n    /// and may be in the process of undelegation\n    /// but has not been released yet,\n    /// either because the undelegation period is not over,\n    /// or because the operator contract has an active lock on the operator.\n    /// Also, the operator had to approve the specified operator contract.\n    ///\n    /// The difference between eligible stake is that active stake does not make\n    /// the operator eligible for work selection but it may be still finishing\n    /// earlier work until the stake is released.\n    /// Operator with a minimum required\n    /// amount of active stake can join the network but cannot be selected to any\n    /// new work.\n    ///\n    /// @param _operator address of stake operator.\n    /// @param _operatorContract address of operator contract.\n    /// @return an uint256 representing the eligible stake balance.\n    ",
        "@notice": "Gets the active stake balance of the specified address. /// An active stake is a stake that passed the initialization period, /// and may be in the process of undelegation /// but has not been released yet, /// either because the undelegation period is not over, /// or because the operator contract has an active lock on the operator. /// Also, the operator had to approve the specified operator contract. /// /// The difference between eligible stake is that active stake does not make /// the operator eligible for work selection but it may be still finishing /// earlier work until the stake is released. /// Operator with a minimum required /// amount of active stake can join the network but cannot be selected to any /// new work.",
        "@param1": "_operator address of stake operator.",
        "@param2": "_operatorContract address of operator contract.",
        "@return1": "an uint256 representing the eligible stake balance.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "hasMinimumStake",
        "visibility": "public",
        "args": [
            {
                "name": "staker",
                "type": "address"
            },
            {
                "name": "operatorContract",
                "type": "address"
            }
        ],
        "func": "function hasMinimumStake(\n        address staker,\n        address operatorContract\n    ) public view returns(bool) {\n        return activeStake(staker, operatorContract) >= minimumStake();\n    }",
        "comments": [
            "",
            "    /// @notice Checks if the specified account has enough active stake to become",
            "    /// network operator and that the specified operator contract has been",
            "    /// authorized for potential slashing.",
            "    ///",
            "    /// Having the required minimum of active stake makes the operator eligible",
            "    /// to join the network. If the active stake is not currently undelegating,",
            "    /// operator is also eligible for work selection.",
            "    ///",
            "    /// @param staker Staker's address",
            "    /// @param operatorContract Operator contract's address",
            "    /// @return True if has enough active stake to participate in the network,",
            "    /// false otherwise.",
            "    "
        ],
        "comt": "\n    /// @notice Checks if the specified account has enough active stake to become\n    /// network operator and that the specified operator contract has been\n    /// authorized for potential slashing.\n    ///\n    /// Having the required minimum of active stake makes the operator eligible\n    /// to join the network. If the active stake is not currently undelegating,\n    /// operator is also eligible for work selection.\n    ///\n    /// @param staker Staker's address\n    /// @param operatorContract Operator contract's address\n    /// @return True if has enough active stake to participate in the network,\n    /// false otherwise.\n    ",
        "@notice": "Checks if the specified account has enough active stake to become /// network operator and that the specified operator contract has been /// authorized for potential slashing. /// /// Having the required minimum of active stake makes the operator eligible /// to join the network. If the active stake is not currently undelegating, /// operator is also eligible for work selection.",
        "@param1": "staker Staker's address",
        "@param2": "operatorContract Operator contract's address",
        "@return1": "True if has enough active stake to participate in the network, /// false otherwise.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "authorizeOperatorContract",
        "visibility": "public",
        "args": [
            {
                "name": "_operator",
                "type": "address"
            },
            {
                "name": "_operatorContract",
                "type": "address"
            }
        ],
        "func": "function authorizeOperatorContract(address _operator, address _operatorContract)\n        public\n        onlyApprovedOperatorContract(_operatorContract) {\n        require(\n            authorizerOf(_operator) == msg.sender,\n            \"Not operator authorizer\"\n        );\n        require(\n            getAuthoritySource(_operatorContract) == _operatorContract,\n            \"Delegated authority used\"\n        );\n        authorizations[_operatorContract][_operator] = true;\n    }",
        "comments": [
            "",
            "    /// @notice Authorizes operator contract to access staked token balance of",
            "    /// the provided operator. Can only be executed by stake operator authorizer.",
            "    /// Contracts using delegated authority",
            "    /// cannot be authorized with `authorizeOperatorContract`.",
            "    /// Instead, authorize `getAuthoritySource(_operatorContract)`.",
            "    /// @param _operator address of stake operator.",
            "    /// @param _operatorContract address of operator contract.",
            "    "
        ],
        "comt": "\n    /// @notice Authorizes operator contract to access staked token balance of\n    /// the provided operator. Can only be executed by stake operator authorizer.\n    /// Contracts using delegated authority\n    /// cannot be authorized with `authorizeOperatorContract`.\n    /// Instead, authorize `getAuthoritySource(_operatorContract)`.\n    /// @param _operator address of stake operator.\n    /// @param _operatorContract address of operator contract.\n    ",
        "@notice": "Authorizes operator contract to access staked token balance of /// the provided operator. Can only be executed by stake operator authorizer. /// Contracts using delegated authority /// cannot be authorized with `authorizeOperatorContract`. /// Instead, authorize `getAuthoritySource(_operatorContract)`.",
        "@param1": "_operator address of stake operator.",
        "@param2": "_operatorContract address of operator contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isAuthorizedForOperator",
        "visibility": "public",
        "args": [
            {
                "name": "_operator",
                "type": "address"
            },
            {
                "name": "_operatorContract",
                "type": "address"
            }
        ],
        "func": "function isAuthorizedForOperator(\n        address _operator,\n        address _operatorContract\n    ) public view returns (bool) {\n        return authorizations[getAuthoritySource(_operatorContract)][_operator];\n    }",
        "comments": [
            "",
            "    /// @notice Checks if operator contract has access to the staked token balance of",
            "    /// the provided operator.",
            "    /// @param _operator address of stake operator.",
            "    /// @param _operatorContract address of operator contract.",
            "    "
        ],
        "comt": "\n    /// @notice Checks if operator contract has access to the staked token balance of\n    /// the provided operator.\n    /// @param _operator address of stake operator.\n    /// @param _operatorContract address of operator contract.\n    ",
        "@notice": "Checks if operator contract has access to the staked token balance of /// the provided operator.",
        "@param1": "_operator address of stake operator.",
        "@param2": "_operatorContract address of operator contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "claimDelegatedAuthority",
        "visibility": "public",
        "args": [
            {
                "name": "delegatedAuthoritySource",
                "type": "address"
            }
        ],
        "func": "function claimDelegatedAuthority(\n        address delegatedAuthoritySource\n    ) public onlyApprovedOperatorContract(delegatedAuthoritySource) {\n        require(\n            AuthorityDelegator(delegatedAuthoritySource).__isRecognized(msg.sender),\n            \"Unrecognized claimant\"\n        );\n        delegatedAuthority[msg.sender] = delegatedAuthoritySource;\n    }",
        "comments": [
            "",
            "    /// @notice Grant the sender the same authority as `delegatedAuthoritySource`",
            "    /// @dev If `delegatedAuthoritySource` is an approved operator contract",
            "    /// and recognizes the claimant, this relationship will be recorded in",
            "    /// `delegatedAuthority`. Later, the claimant can slash, seize, place locks etc.",
            "    /// on operators that have authorized the `delegatedAuthoritySource`.",
            "    /// If the `delegatedAuthoritySource` is disabled with the panic button,",
            "    /// any recipients of delegated authority from it will also be disabled.",
            "    "
        ],
        "comt": "\n    /// @notice Grant the sender the same authority as `delegatedAuthoritySource`\n    /// @dev If `delegatedAuthoritySource` is an approved operator contract\n    /// and recognizes the claimant, this relationship will be recorded in\n    /// `delegatedAuthority`. Later, the claimant can slash, seize, place locks etc.\n    /// on operators that have authorized the `delegatedAuthoritySource`.\n    /// If the `delegatedAuthoritySource` is disabled with the panic button,\n    /// any recipients of delegated authority from it will also be disabled.\n    ",
        "@notice": "Grant the sender the same authority as `delegatedAuthoritySource`",
        "@dev": "If `delegatedAuthoritySource` is an approved operator contract /// and recognizes the claimant, this relationship will be recorded in /// `delegatedAuthority`. Later, the claimant can slash, seize, place locks etc. /// on operators that have authorized the `delegatedAuthoritySource`. /// If the `delegatedAuthoritySource` is disabled with the panic button, /// any recipients of delegated authority from it will also be disabled.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isApprovedOperatorContract",
        "visibility": "public",
        "args": [
            {
                "name": "_operatorContract",
                "type": "address"
            }
        ],
        "func": "function isApprovedOperatorContract(address _operatorContract)\n        public\n        view\n        returns (bool)\n    {\n        return\n            registry.isApprovedOperatorContract(\n                getAuthoritySource(_operatorContract)\n            );\n    }",
        "comments": [
            "",
            "    /// @notice Checks if the operator contract is authorized in the registry.",
            "    /// If the contract uses delegated authority it checks authorization of the",
            "    /// source contract.",
            "    /// @param _operatorContract address of operator contract.",
            "    /// @return True if operator contract is approved, false if operator contract",
            "    /// has not been approved or if it was disabled by the panic button.",
            "    "
        ],
        "comt": "\n    /// @notice Checks if the operator contract is authorized in the registry.\n    /// If the contract uses delegated authority it checks authorization of the\n    /// source contract.\n    /// @param _operatorContract address of operator contract.\n    /// @return True if operator contract is approved, false if operator contract\n    /// has not been approved or if it was disabled by the panic button.\n    ",
        "@notice": "Checks if the operator contract is authorized in the registry. /// If the contract uses delegated authority it checks authorization of the /// source contract.",
        "@param1": "_operatorContract address of operator contract.",
        "@return1": "True if operator contract is approved, false if operator contract /// has not been approved or if it was disabled by the panic button.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAuthoritySource",
        "visibility": "public",
        "args": [
            {
                "name": "operatorContract",
                "type": "address"
            }
        ],
        "func": "function getAuthoritySource(\n        address operatorContract\n    ) public view returns (address) {\n        address delegatedAuthoritySource = delegatedAuthority[operatorContract];\n        if (delegatedAuthoritySource == address(0)) {\n            return operatorContract;\n        }\n        return getAuthoritySource(delegatedAuthoritySource);\n    }",
        "comments": [
            "",
            "    /// @notice Get the source of the operator contract's authority.",
            "    /// If the contract uses delegated authority,",
            "    /// returns the original source of the delegated authority.",
            "    /// If the contract doesn't use delegated authority,",
            "    /// returns the contract itself.",
            "    /// Authorize `getAuthoritySource(operatorContract)`",
            "    /// to grant `operatorContract` the authority to penalize an operator.",
            "    "
        ],
        "comt": "\n    /// @notice Get the source of the operator contract's authority.\n    /// If the contract uses delegated authority,\n    /// returns the original source of the delegated authority.\n    /// If the contract doesn't use delegated authority,\n    /// returns the contract itself.\n    /// Authorize `getAuthoritySource(operatorContract)`\n    /// to grant `operatorContract` the authority to penalize an operator.\n    ",
        "@notice": "Get the source of the operator contract's authority. /// If the contract uses delegated authority, /// returns the original source of the delegated authority. /// If the contract doesn't use delegated authority, /// returns the contract itself. /// Authorize `getAuthoritySource(operatorContract)` /// to grant `operatorContract` the authority to penalize an operator.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setGovernance",
        "visibility": "public",
        "args": [
            {
                "name": "_governance",
                "type": "address"
            }
        ],
        "func": "function setGovernance(address _governance) public onlyGovernance {\n        governance = _governance;\n        emit GovernanceUpdated(governance);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setRegistryKeeper",
        "visibility": "public",
        "args": [
            {
                "name": "_registryKeeper",
                "type": "address"
            }
        ],
        "func": "function setRegistryKeeper(address _registryKeeper) public onlyGovernance {\n        registryKeeper = _registryKeeper;\n        emit RegistryKeeperUpdated(registryKeeper);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setDefaultPanicButton",
        "visibility": "public",
        "args": [
            {
                "name": "_panicButton",
                "type": "address"
            }
        ],
        "func": "function setDefaultPanicButton(address _panicButton) public onlyGovernance {\n        defaultPanicButton = _panicButton;\n        emit DefaultPanicButtonUpdated(defaultPanicButton);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setOperatorContractPanicButton",
        "visibility": "public",
        "args": [
            {
                "name": "_operatorContract",
                "type": "address"
            },
            {
                "name": "_panicButton",
                "type": "address"
            }
        ],
        "func": "function setOperatorContractPanicButton(\n        address _operatorContract,\n        address _panicButton\n    ) public onlyForApprovedContract(_operatorContract) onlyGovernance {\n        require(\n            panicButtons[_operatorContract] != address(0),\n            \"Disabled panic button cannot be updated\"\n        );\n        require(\n            _panicButton != address(0),\n            \"Panic button must be non-zero address\"\n        );\n\n        panicButtons[_operatorContract] = _panicButton;\n\n        emit OperatorContractPanicButtonUpdated(\n            _operatorContract,\n            _panicButton\n        );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "disableOperatorContractPanicButton",
        "visibility": "public",
        "args": [
            {
                "name": "_operatorContract",
                "type": "address"
            }
        ],
        "func": "function disableOperatorContractPanicButton(address _operatorContract)\n        public\n        onlyForApprovedContract(_operatorContract)\n        onlyGovernance\n    {\n        require(\n            panicButtons[_operatorContract] != address(0),\n            \"Panic button already disabled\"\n        );\n\n        panicButtons[_operatorContract] = address(0);\n\n        emit OperatorContractPanicButtonDisabled(_operatorContract);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setOperatorContractUpgrader",
        "visibility": "public",
        "args": [
            {
                "name": "_serviceContract",
                "type": "address"
            },
            {
                "name": "_operatorContractUpgrader",
                "type": "address"
            }
        ],
        "func": "function setOperatorContractUpgrader(\n        address _serviceContract,\n        address _operatorContractUpgrader\n    ) public onlyGovernance {\n        operatorContractUpgraders[_serviceContract] = _operatorContractUpgrader;\n        emit OperatorContractUpgraderUpdated(\n            _serviceContract,\n            _operatorContractUpgrader\n        );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setServiceContractUpgrader",
        "visibility": "public",
        "args": [
            {
                "name": "_operatorContract",
                "type": "address"
            },
            {
                "name": "_serviceContractUpgrader",
                "type": "address"
            }
        ],
        "func": "function setServiceContractUpgrader(\n        address _operatorContract,\n        address _serviceContractUpgrader\n    ) public onlyGovernance {\n        serviceContractUpgraders[_operatorContract] = _serviceContractUpgrader;\n        emit ServiceContractUpgraderUpdated(\n            _operatorContract,\n            _serviceContractUpgrader\n        );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approveOperatorContract",
        "visibility": "public",
        "args": [
            {
                "name": "operatorContract",
                "type": "address"
            }
        ],
        "func": "function approveOperatorContract(address operatorContract)\n        public\n        onlyForNewContract(operatorContract)\n        onlyRegistryKeeper\n    {\n        operatorContracts[operatorContract] = ContractStatus.Approved;\n        panicButtons[operatorContract] = defaultPanicButton;\n        emit OperatorContractApproved(operatorContract);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "disableOperatorContract",
        "visibility": "public",
        "args": [
            {
                "name": "operatorContract",
                "type": "address"
            }
        ],
        "func": "function disableOperatorContract(address operatorContract)\n        public\n        onlyForApprovedContract(operatorContract)\n        onlyPanicButton(operatorContract)\n    {\n        operatorContracts[operatorContract] = ContractStatus.Disabled;\n        emit OperatorContractDisabled(operatorContract);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isNewOperatorContract",
        "visibility": "public",
        "args": [
            {
                "name": "operatorContract",
                "type": "address"
            }
        ],
        "func": "function isNewOperatorContract(address operatorContract)\n        public\n        view\n        returns (bool)\n    {\n        return operatorContracts[operatorContract] == ContractStatus.New;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isApprovedOperatorContract",
        "visibility": "public",
        "args": [
            {
                "name": "operatorContract",
                "type": "address"
            }
        ],
        "func": "function isApprovedOperatorContract(address operatorContract)\n        public\n        view\n        returns (bool)\n    {\n        return operatorContracts[operatorContract] == ContractStatus.Approved;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "operatorContractUpgraderFor",
        "visibility": "public",
        "args": [
            {
                "name": "_serviceContract",
                "type": "address"
            }
        ],
        "func": "function operatorContractUpgraderFor(address _serviceContract)\n        public\n        view\n        returns (address)\n    {\n        return operatorContractUpgraders[_serviceContract];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "serviceContractUpgraderFor",
        "visibility": "public",
        "args": [
            {
                "name": "_operatorContract",
                "type": "address"
            }
        ],
        "func": "function serviceContractUpgraderFor(address _operatorContract)\n        public\n        view\n        returns (address)\n    {\n        return serviceContractUpgraders[_operatorContract];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stake",
        "visibility": "public",
        "args": [
            {
                "name": "_amount",
                "type": "uint256"
            },
            {
                "name": "_extraData",
                "type": "bytes memory"
            }
        ],
        "func": "function stake(\n        uint256 _amount,\n        bytes memory _extraData\n    ) public onlyGrant {\n        amount = _amount;\n        operator = _extraData.toAddress(20);\n        tokenSender(address(token)).approveAndCall(\n            address(tokenStaking),\n            _amount,\n            _extraData\n        );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getGrantId",
        "visibility": "public",
        "args": [],
        "func": "function getGrantId() public view onlyGrant returns (uint256) {\n        return grantId;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAmount",
        "visibility": "public",
        "args": [],
        "func": "function getAmount() public view onlyGrant returns (uint256) {\n        return amount;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getStakingContract",
        "visibility": "public",
        "args": [],
        "func": "function getStakingContract() public view onlyGrant returns (address) {\n        return address(tokenStaking);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getDetails",
        "visibility": "public",
        "args": [],
        "func": "function getDetails() public view onlyGrant returns (\n        uint256 _grantId,\n        uint256 _amount,\n        address _tokenStaking\n    ) {\n        return (\n            grantId,\n            amount,\n            address(tokenStaking)\n        );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cancelStake",
        "visibility": "public",
        "args": [],
        "func": "function cancelStake() public onlyGrant returns (uint256) {\n        tokenStaking.cancelStake(operator);\n        return returnTokens();\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "undelegate",
        "visibility": "public",
        "args": [],
        "func": "function undelegate() public onlyGrant {\n        tokenStaking.undelegate(operator);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "recoverStake",
        "visibility": "public",
        "args": [],
        "func": "function recoverStake() public onlyGrant returns (uint256) {\n        tokenStaking.recoverStake(operator);\n        return returnTokens();\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "receiveApproval",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint256"
            },
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "extraData",
                "type": "bytes memory"
            }
        ],
        "func": "function receiveApproval(\n        address from,\n        uint256 value,\n        address token,\n        bytes memory extraData\n    ) public {\n        require(IERC20(token) == keepToken, \"Not a KEEP token\");\n        require(msg.sender == token, \"KEEP token is not the sender\");\n        require(extraData.length == 64, \"Unexpected data length\");\n\n        (address operator, uint256 grantId) = abi.decode(\n            extraData, (address, uint256)\n        );\n        receiveDeposit(from, value, operator, grantId);\n    }",
        "comments": [
            "",
            "    /// @notice receiveApproval accepts deposits from staking contract and",
            "    /// stores them in the escrow by the operator address from which they were",
            "    /// undelegated. Function expects operator address and grant identifier to",
            "    /// be passed as ABI-encoded information in extraData. Grant with the given",
            "    /// identifier has to exist.",
            "    /// @param from Address depositing tokens - it has to be the address of",
            "    /// TokenStaking contract owning TokenStakingEscrow.",
            "    /// @param value The amount of KEEP tokens deposited.",
            "    /// @param token The address of KEEP token contract.",
            "    /// @param extraData ABI-encoded data containing operator address (32 bytes)",
            "    /// and grant ID (32 bytes).",
            "    "
        ],
        "comt": "\n    /// @notice receiveApproval accepts deposits from staking contract and\n    /// stores them in the escrow by the operator address from which they were\n    /// undelegated. Function expects operator address and grant identifier to\n    /// be passed as ABI-encoded information in extraData. Grant with the given\n    /// identifier has to exist.\n    /// @param from Address depositing tokens - it has to be the address of\n    /// TokenStaking contract owning TokenStakingEscrow.\n    /// @param value The amount of KEEP tokens deposited.\n    /// @param token The address of KEEP token contract.\n    /// @param extraData ABI-encoded data containing operator address (32 bytes)\n    /// and grant ID (32 bytes).\n    ",
        "@notice": "receiveApproval accepts deposits from staking contract and /// stores them in the escrow by the operator address from which they were /// undelegated. Function expects operator address and grant identifier to /// be passed as ABI-encoded information in extraData. Grant with the given /// identifier has to exist.",
        "@param1": "from Address depositing tokens - it has to be the address of /// TokenStaking contract owning TokenStakingEscrow.",
        "@param2": "value The amount of KEEP tokens deposited.",
        "@param3": "token The address of KEEP token contract.",
        "@param4": "extraData ABI-encoded data containing operator address (32 bytes) /// and grant ID (32 bytes).",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "redelegate",
        "visibility": "public",
        "args": [
            {
                "name": "previousOperator",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            },
            {
                "name": "extraData",
                "type": "bytes memory"
            }
        ],
        "func": "function redelegate(\n        address previousOperator,\n        uint256 amount,\n        bytes memory extraData\n    ) public {\n        require(extraData.length == 60, \"Corrupted delegation data\");\n\n        Deposit memory deposit = deposits[previousOperator];\n\n        uint256 grantId = deposit.grantId;\n        address newOperator = extraData.toAddress(20);\n        require(isGrantee(msg.sender, grantId), \"Not authorized\");\n        require(getAmountRevoked(grantId) == 0, \"Grant revoked\");\n        require(\n            availableAmount(previousOperator) >= amount,\n            \"Insufficient balance\"\n        );\n        require(\n            !hasDeposit(newOperator),\n            \"Redelegating to previously used operator is not allowed\"\n        );\n\n        deposits[previousOperator].redelegated = deposit.redelegated.add(amount);\n\n        TokenSender(address(keepToken)).approveAndCall(\n            owner(), // TokenStaking contract associated with the escrow\n            amount,\n            abi.encodePacked(extraData, grantId)\n        );\n\n        emit DepositRedelegated(\n            previousOperator,\n            newOperator,\n            grantId,\n            amount\n        );\n    }",
        "comments": [
            "",
            "    /// @notice Redelegates deposit or part of the deposit to another operator.",
            "    /// Uses the same staking contract as the original delegation.",
            "    /// @param previousOperator Address of the operator from the undelegated/canceled",
            "    /// delegation from which tokens were deposited.",
            "    /// @dev Only grantee is allowed to call this function. For managed grant,",
            "    /// caller has to be the managed grantee.",
            "    /// @param amount Amount of tokens to delegate.",
            "    /// @param extraData Data for stake delegation. This byte array must have",
            "    /// the following values concatenated:",
            "    /// - Beneficiary address (20 bytes)",
            "    /// - Operator address (20 bytes)",
            "    /// - Authorizer address (20 bytes)",
            "    "
        ],
        "comt": "\n    /// @notice Redelegates deposit or part of the deposit to another operator.\n    /// Uses the same staking contract as the original delegation.\n    /// @param previousOperator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    /// @dev Only grantee is allowed to call this function. For managed grant,\n    /// caller has to be the managed grantee.\n    /// @param amount Amount of tokens to delegate.\n    /// @param extraData Data for stake delegation. This byte array must have\n    /// the following values concatenated:\n    /// - Beneficiary address (20 bytes)\n    /// - Operator address (20 bytes)\n    /// - Authorizer address (20 bytes)\n    ",
        "@notice": "Redelegates deposit or part of the deposit to another operator. /// Uses the same staking contract as the original delegation.",
        "@param1": "previousOperator Address of the operator from the undelegated/canceled /// delegation from which tokens were deposited.",
        "@dev": "Only grantee is allowed to call this function. For managed grant, /// caller has to be the managed grantee.",
        "@param2": "amount Amount of tokens to delegate.",
        "@param3": "extraData Data for stake delegation. This byte array must have /// the following values concatenated: /// - Beneficiary address (20 bytes) /// - Operator address (20 bytes) /// - Authorizer address (20 bytes)",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "hasDeposit",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function hasDeposit(address operator) public view returns (bool) {\n        return depositedAmount(operator) > 0;\n    }",
        "comments": [
            "",
            "    /// @notice Returns true if there is a deposit for the given operator in",
            "    /// the escrow. Otherwise, returns false.",
            "    /// @param operator Address of the operator from the undelegated/canceled",
            "    /// delegation from which tokens were deposited.",
            "    "
        ],
        "comt": "\n    /// @notice Returns true if there is a deposit for the given operator in\n    /// the escrow. Otherwise, returns false.\n    /// @param operator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    ",
        "@notice": "Returns true if there is a deposit for the given operator in /// the escrow. Otherwise, returns false.",
        "@param1": "operator Address of the operator from the undelegated/canceled /// delegation from which tokens were deposited.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "availableAmount",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function availableAmount(address operator) public view returns (uint256) {\n        Deposit memory deposit = deposits[operator];\n        return deposit.amount.sub(deposit.withdrawn).sub(deposit.redelegated);\n    }",
        "comments": [
            "",
            "    /// @notice Returns the currently available amount deposited in the escrow",
            "    /// that may or may not be currently withdrawable. The available amount",
            "    /// is the amount initially deposited minus the amount withdrawn and",
            "    /// redelegated so far from that deposit.",
            "    /// @param operator Address of the operator from the undelegated/canceled",
            "    /// delegation from which tokens were deposited.",
            "    "
        ],
        "comt": "\n    /// @notice Returns the currently available amount deposited in the escrow\n    /// that may or may not be currently withdrawable. The available amount\n    /// is the amount initially deposited minus the amount withdrawn and\n    /// redelegated so far from that deposit.\n    /// @param operator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    ",
        "@notice": "Returns the currently available amount deposited in the escrow /// that may or may not be currently withdrawable. The available amount /// is the amount initially deposited minus the amount withdrawn and /// redelegated so far from that deposit.",
        "@param1": "operator Address of the operator from the undelegated/canceled /// delegation from which tokens were deposited.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "depositedAmount",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function depositedAmount(address operator) public view returns (uint256) {\n        return deposits[operator].amount;\n    }",
        "comments": [
            "",
            "    /// @notice Returns the total amount deposited in the escrow after",
            "    /// undelegating it from the provided operator.",
            "    /// @param operator Address of the operator from the undelegated/canceled",
            "    /// delegation from which tokens were deposited.",
            "    "
        ],
        "comt": "\n    /// @notice Returns the total amount deposited in the escrow after\n    /// undelegating it from the provided operator.\n    /// @param operator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    ",
        "@notice": "Returns the total amount deposited in the escrow after /// undelegating it from the provided operator.",
        "@param1": "operator Address of the operator from the undelegated/canceled /// delegation from which tokens were deposited.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "depositGrantId",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function depositGrantId(address operator) public view returns (uint256) {\n        return deposits[operator].grantId;\n    }",
        "comments": [
            "",
            "    /// @notice Returns grant ID for the amount deposited in the escrow after",
            "    /// undelegating it from the provided operator.",
            "    /// @param operator Address of the operator from the undelegated/canceled",
            "    /// delegation from which tokens were deposited.",
            "    "
        ],
        "comt": "\n    /// @notice Returns grant ID for the amount deposited in the escrow after\n    /// undelegating it from the provided operator.\n    /// @param operator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    ",
        "@notice": "Returns grant ID for the amount deposited in the escrow after /// undelegating it from the provided operator.",
        "@param1": "operator Address of the operator from the undelegated/canceled /// delegation from which tokens were deposited.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "depositWithdrawnAmount",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function depositWithdrawnAmount(address operator) public view returns (uint256) {\n        return deposits[operator].withdrawn;\n    }",
        "comments": [
            "",
            "    /// @notice Returns the amount withdrawn so far from the value deposited",
            "    /// in the escrow contract after undelegating it from the provided operator.",
            "    /// @param operator Address of the operator from the undelegated/canceled",
            "    /// delegation from which tokens were deposited.",
            "    "
        ],
        "comt": "\n    /// @notice Returns the amount withdrawn so far from the value deposited\n    /// in the escrow contract after undelegating it from the provided operator.\n    /// @param operator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    ",
        "@notice": "Returns the amount withdrawn so far from the value deposited /// in the escrow contract after undelegating it from the provided operator.",
        "@param1": "operator Address of the operator from the undelegated/canceled /// delegation from which tokens were deposited.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "depositRedelegatedAmount",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function depositRedelegatedAmount(address operator) public view returns (uint256) {\n        return deposits[operator].redelegated;\n    }",
        "comments": [
            "",
            "    /// @notice Returns the total amount redelegated so far from the value",
            "    /// deposited in the escrow contract after undelegating it from the provided",
            "    /// operator.",
            "    /// @param operator Address of the operator from the undelegated/canceled",
            "    /// delegation from which tokens were deposited.",
            "    "
        ],
        "comt": "\n    /// @notice Returns the total amount redelegated so far from the value\n    /// deposited in the escrow contract after undelegating it from the provided\n    /// operator.\n    /// @param operator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    ",
        "@notice": "Returns the total amount redelegated so far from the value /// deposited in the escrow contract after undelegating it from the provided /// operator.",
        "@param1": "operator Address of the operator from the undelegated/canceled /// delegation from which tokens were deposited.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawable",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function withdrawable(address operator) public view returns (uint256) {\n        Deposit memory deposit = deposits[operator];\n\n        // Staked tokens can be only withdrawn by grantee for non-revoked grant\n        // assuming that grant has not fully unlocked before it's been\n        // revoked.\n        //\n        // It is not possible for the escrow to determine the number of tokens\n        // it should return to the grantee of a revoked grant given different\n        // possible staking contracts and staking policies.\n        //\n        // If the entire grant unlocked before it's been reverted, escrow\n        // lets to withdraw the entire deposited amount.\n        if (getAmountRevoked(deposit.grantId) == 0) {\n            (\n                uint256 duration,\n                uint256 start,\n                uint256 cliff\n            ) = getUnlockingSchedule(deposit.grantId);\n\n            uint256 unlocked = now.getUnlockedAmount(\n                deposit.amount,\n                duration,\n                start,\n                cliff\n            );\n\n            if (deposit.withdrawn.add(deposit.redelegated) < unlocked) {\n                return unlocked.sub(deposit.withdrawn).sub(deposit.redelegated);\n            }\n        }\n\n        return 0;\n    }",
        "comments": [
            "",
            "    /// @notice Returns the currently withdrawable amount that was previously",
            "    /// deposited in the escrow after undelegating it from the provided operator.",
            "    /// Tokens are unlocked based on their grant unlocking schedule.",
            "    /// Function returns 0 for non-existing deposits and revoked grants if they",
            "    /// have been revoked before they fully unlocked.",
            "    /// @param operator Address of the operator from the undelegated/canceled",
            "    /// delegation from which tokens were deposited.",
            "    "
        ],
        "comt": "\n    /// @notice Returns the currently withdrawable amount that was previously\n    /// deposited in the escrow after undelegating it from the provided operator.\n    /// Tokens are unlocked based on their grant unlocking schedule.\n    /// Function returns 0 for non-existing deposits and revoked grants if they\n    /// have been revoked before they fully unlocked.\n    /// @param operator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    ",
        "@notice": "Returns the currently withdrawable amount that was previously /// deposited in the escrow after undelegating it from the provided operator. /// Tokens are unlocked based on their grant unlocking schedule. /// Function returns 0 for non-existing deposits and revoked grants if they /// have been revoked before they fully unlocked.",
        "@param1": "operator Address of the operator from the undelegated/canceled /// delegation from which tokens were deposited.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function withdraw(address operator) public {\n        Deposit memory deposit = deposits[operator];\n        address grantee = getGrantee(deposit.grantId);\n\n        // Make sure this function is not called for a managed grant.\n        // If called for a managed grant, tokens could be locked there.\n        // Better be safe than sorry.\n        (bool success, ) = address(this).call(\n            abi.encodeWithSignature(\"getManagedGrantee(address)\", grantee)\n        );\n        require(!success, \"Can not be called for managed grant\");\n\n        require(\n            msg.sender == grantee || msg.sender == operator,\n            \"Only grantee or operator can withdraw\"\n        );\n\n        withdraw(deposit, operator, grantee);\n    }",
        "comments": [
            "",
            "    /// @notice Withdraws currently unlocked tokens deposited in the escrow",
            "    /// after undelegating them from the provided operator. Only grantee or",
            "    /// operator can call this function. Important: this function can not be",
            "    /// called for a `ManagedGrant` grantee. This may lead to locking tokens.",
            "    /// For `ManagedGrant`, please use `withdrawToManagedGrantee` instead.",
            "    /// @param operator Address of the operator from the undelegated/canceled",
            "    /// delegation from which tokens were deposited.",
            "    "
        ],
        "comt": "\n    /// @notice Withdraws currently unlocked tokens deposited in the escrow\n    /// after undelegating them from the provided operator. Only grantee or\n    /// operator can call this function. Important: this function can not be\n    /// called for a `ManagedGrant` grantee. This may lead to locking tokens.\n    /// For `ManagedGrant`, please use `withdrawToManagedGrantee` instead.\n    /// @param operator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    ",
        "@notice": "Withdraws currently unlocked tokens deposited in the escrow /// after undelegating them from the provided operator. Only grantee or /// operator can call this function. Important: this function can not be /// called for a `ManagedGrant` grantee. This may lead to locking tokens. /// For `ManagedGrant`, please use `withdrawToManagedGrantee` instead.",
        "@param1": "operator Address of the operator from the undelegated/canceled /// delegation from which tokens were deposited.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawToManagedGrantee",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function withdrawToManagedGrantee(address operator) public {\n        Deposit memory deposit = deposits[operator];\n        address managedGrant = getGrantee(deposit.grantId);\n        address grantee = getManagedGrantee(managedGrant);\n\n        require(\n            msg.sender == grantee || msg.sender == operator,\n            \"Only grantee or operator can withdraw\"\n        );\n\n        withdraw(deposit, operator, grantee);\n    }",
        "comments": [
            "",
            "    /// @notice Withdraws currently unlocked tokens deposited in the escrow",
            "    /// after undelegating them from the provided operator. Only grantee or",
            "    /// operator can call this function. This function works only for",
            "    /// `ManagedGrant` grantees. For a standard grant, please use `withdraw`",
            "    /// instead.",
            "    /// @param operator Address of the operator from the undelegated/canceled",
            "    /// delegation from which tokens were deposited.",
            "    "
        ],
        "comt": "\n    /// @notice Withdraws currently unlocked tokens deposited in the escrow\n    /// after undelegating them from the provided operator. Only grantee or\n    /// operator can call this function. This function works only for\n    /// `ManagedGrant` grantees. For a standard grant, please use `withdraw`\n    /// instead.\n    /// @param operator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    ",
        "@notice": "Withdraws currently unlocked tokens deposited in the escrow /// after undelegating them from the provided operator. Only grantee or /// operator can call this function. This function works only for /// `ManagedGrant` grantees. For a standard grant, please use `withdraw` /// instead.",
        "@param1": "operator Address of the operator from the undelegated/canceled /// delegation from which tokens were deposited.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "migrate",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "receivingEscrow",
                "type": "address"
            }
        ],
        "func": "function migrate(\n        address operator,\n        address receivingEscrow\n    ) public {\n        Deposit memory deposit = deposits[operator];\n        require(isGrantee(msg.sender, deposit.grantId), \"Not authorized\");\n\n        address grantManager = getGrantManager(deposit.grantId);\n        require(\n            authorizedEscrows[grantManager][receivingEscrow],\n            \"Escrow not authorized\"\n        );\n\n        uint256 amountLeft = availableAmount(operator);\n        deposits[operator].withdrawn = deposit.withdrawn.add(amountLeft);\n        TokenSender(address(keepToken)).approveAndCall(\n            receivingEscrow,\n            amountLeft,\n            abi.encode(operator, deposit.grantId)\n        );\n    }",
        "comments": [
            "",
            "    /// @notice Migrates all available tokens to another authorized escrow.",
            "    /// Can be requested only by grantee.",
            "    /// @param operator Address of the operator from the undelegated/canceled",
            "    /// delegation from which tokens were deposited.",
            "    /// @param receivingEscrow Escrow to which tokens should be migrated.",
            "    /// @dev The receiving escrow needs to accept deposits from this escrow, at",
            "    /// least for the period of migration.",
            "    "
        ],
        "comt": "\n    /// @notice Migrates all available tokens to another authorized escrow.\n    /// Can be requested only by grantee.\n    /// @param operator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    /// @param receivingEscrow Escrow to which tokens should be migrated.\n    /// @dev The receiving escrow needs to accept deposits from this escrow, at\n    /// least for the period of migration.\n    ",
        "@notice": "Migrates all available tokens to another authorized escrow. /// Can be requested only by grantee.",
        "@param1": "operator Address of the operator from the undelegated/canceled /// delegation from which tokens were deposited.",
        "@param2": "receivingEscrow Escrow to which tokens should be migrated.",
        "@dev": "The receiving escrow needs to accept deposits from this escrow, at /// least for the period of migration.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawRevoked",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function withdrawRevoked(address operator) public {\n        Deposit memory deposit = deposits[operator];\n\n        require(\n            getAmountRevoked(deposit.grantId) > 0,\n            \"No revoked tokens to withdraw\"\n        );\n\n        address grantManager = getGrantManager(deposit.grantId);\n        withdrawRevoked(deposit, operator, grantManager);\n    }",
        "comments": [
            "",
            "    /// @notice Withdraws the entire amount that is still deposited in the",
            "    /// escrow in case the grant has been revoked. Anyone can call this function",
            "    /// and the entire amount is transferred back to the grant manager.",
            "    /// @param operator Address of the operator from the undelegated/canceled",
            "    /// delegation from which tokens were deposited.",
            "    "
        ],
        "comt": "\n    /// @notice Withdraws the entire amount that is still deposited in the\n    /// escrow in case the grant has been revoked. Anyone can call this function\n    /// and the entire amount is transferred back to the grant manager.\n    /// @param operator Address of the operator from the undelegated/canceled\n    /// delegation from which tokens were deposited.\n    ",
        "@notice": "Withdraws the entire amount that is still deposited in the /// escrow in case the grant has been revoked. Anyone can call this function /// and the entire amount is transferred back to the grant manager.",
        "@param1": "operator Address of the operator from the undelegated/canceled /// delegation from which tokens were deposited.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "authorizeEscrow",
        "visibility": "public",
        "args": [
            {
                "name": "anotherEscrow",
                "type": "address"
            }
        ],
        "func": "function authorizeEscrow(address anotherEscrow) public {\n        require(\n            anotherEscrow != address(0x0),\n            \"Escrow address can't be zero\"\n        );\n        authorizedEscrows[msg.sender][anotherEscrow] = true;\n        emit EscrowAuthorized(msg.sender, anotherEscrow);\n    }",
        "comments": [
            "",
            "    /// @notice Used by grant manager to authorize another escrows for",
            "    // funds migration.",
            "    "
        ],
        "comt": "\n    /// @notice Used by grant manager to authorize another escrows for\n    // funds migration.\n    ",
        "@notice": "Used by grant manager to authorize another escrows for // funds migration.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getManagedGrantee",
        "visibility": "public",
        "args": [
            {
                "name": "managedGrant",
                "type": "address"
            }
        ],
        "func": "function getManagedGrantee(\n        address managedGrant\n    ) public view returns(address) {\n        ManagedGrant grant = ManagedGrant(managedGrant);\n        return grant.grantee();\n    }",
        "comments": [
            "",
            "    /// @notice Resolves the final grantee of ManagedGrant contract. If the",
            "    /// provided address is not a ManagedGrant contract, function reverts.",
            "    /// @param managedGrant Address of the managed grant contract.",
            "    "
        ],
        "comt": "\n    /// @notice Resolves the final grantee of ManagedGrant contract. If the\n    /// provided address is not a ManagedGrant contract, function reverts.\n    /// @param managedGrant Address of the managed grant contract.\n    ",
        "@notice": "Resolves the final grantee of ManagedGrant contract. If the /// provided address is not a ManagedGrant contract, function reverts.",
        "@param1": "managedGrant Address of the managed grant contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approveAndCall",
        "visibility": "public",
        "args": [
            {
                "name": "_spender",
                "type": "address"
            },
            {
                "name": "_value",
                "type": "uint256"
            },
            {
                "name": "_extraData",
                "type": "bytes memory"
            }
        ],
        "func": "function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\n            return true;\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Set allowance for other address and notify.",
            "    /// Allows `_spender` to spend no more than `_value` tokens",
            "    /// on your behalf and then ping the contract about it.",
            "    /// @param _spender The address authorized to spend.",
            "    /// @param _value The max amount they can spend.",
            "    /// @param _extraData Extra information to send to the approved contract.",
            "    "
        ],
        "comt": "\n    /// @notice Set allowance for other address and notify.\n    /// Allows `_spender` to spend no more than `_value` tokens\n    /// on your behalf and then ping the contract about it.\n    /// @param _spender The address authorized to spend.\n    /// @param _value The max amount they can spend.\n    /// @param _extraData Extra information to send to the approved contract.\n    ",
        "@notice": "Set allowance for other address and notify. /// Allows `_spender` to spend no more than `_value` tokens /// on your behalf and then ping the contract about it.",
        "@param1": "_spender The address authorized to spend.",
        "@param2": "_value The max amount they can spend.",
        "@param3": "_extraData Extra information to send to the approved contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "requestGranteeReassignment",
        "visibility": "public",
        "args": [
            {
                "name": "_newGrantee",
                "type": "address"
            }
        ],
        "func": "function requestGranteeReassignment(address _newGrantee)\n        public\n        onlyGrantee\n        noRequestedReassignment\n    {\n        _setRequestedNewGrantee(_newGrantee);\n        emit GranteeReassignmentRequested(_newGrantee);\n    }",
        "comments": [
            "",
            "    /// @notice Request a reassignment of the grantee address.",
            "    /// Can only be called by the grantee.",
            "    /// @param _newGrantee The requested new grantee.",
            "    "
        ],
        "comt": "\n    /// @notice Request a reassignment of the grantee address.\n    /// Can only be called by the grantee.\n    /// @param _newGrantee The requested new grantee.\n    ",
        "@notice": "Request a reassignment of the grantee address. /// Can only be called by the grantee.",
        "@param1": "_newGrantee The requested new grantee.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cancelReassignmentRequest",
        "visibility": "public",
        "args": [],
        "func": "function cancelReassignmentRequest()\n        public\n        onlyGrantee\n        withRequestedReassignment\n    {\n        address cancelledGrantee = requestedNewGrantee;\n        requestedNewGrantee = address(0);\n        emit GranteeReassignmentCancelled(cancelledGrantee);\n    }",
        "comments": [
            "",
            "    /// @notice Cancel a pending grantee reassignment request.",
            "    /// Can only be called by the grantee.",
            "    "
        ],
        "comt": "\n    /// @notice Cancel a pending grantee reassignment request.\n    /// Can only be called by the grantee.\n    ",
        "@notice": "Cancel a pending grantee reassignment request. /// Can only be called by the grantee.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeReassignmentRequest",
        "visibility": "public",
        "args": [
            {
                "name": "_newGrantee",
                "type": "address"
            }
        ],
        "func": "function changeReassignmentRequest(address _newGrantee)\n        public\n        onlyGrantee\n        withRequestedReassignment\n    {\n        address previouslyRequestedGrantee = requestedNewGrantee;\n        require(\n            previouslyRequestedGrantee != _newGrantee,\n            \"Unchanged reassignment request\"\n        );\n        _setRequestedNewGrantee(_newGrantee);\n        emit GranteeReassignmentChanged(previouslyRequestedGrantee, _newGrantee);\n    }",
        "comments": [
            "",
            "    /// @notice Change a pending reassignment request to a different grantee.",
            "    /// Can only be called by the grantee.",
            "    /// @param _newGrantee The address of the new requested grantee.",
            "    "
        ],
        "comt": "\n    /// @notice Change a pending reassignment request to a different grantee.\n    /// Can only be called by the grantee.\n    /// @param _newGrantee The address of the new requested grantee.\n    ",
        "@notice": "Change a pending reassignment request to a different grantee. /// Can only be called by the grantee.",
        "@param1": "_newGrantee The address of the new requested grantee.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "confirmGranteeReassignment",
        "visibility": "public",
        "args": [
            {
                "name": "_newGrantee",
                "type": "address"
            }
        ],
        "func": "function confirmGranteeReassignment(address _newGrantee)\n        public\n        onlyManager\n        withRequestedReassignment\n    {\n        address oldGrantee = grantee;\n        require(\n            requestedNewGrantee == _newGrantee,\n            \"Reassignment address mismatch\"\n        );\n        grantee = requestedNewGrantee;\n        requestedNewGrantee = address(0);\n        emit GranteeReassignmentConfirmed(oldGrantee, _newGrantee);\n    }",
        "comments": [
            "",
            "    /// @notice Confirm a grantee reassignment request and set the new grantee as the grantee.",
            "    /// Can only be called by the grant manager.",
            "    /// @param _newGrantee The address of the new grantee.",
            "    /// Must match the currently requested new grantee.",
            "    "
        ],
        "comt": "\n    /// @notice Confirm a grantee reassignment request and set the new grantee as the grantee.\n    /// Can only be called by the grant manager.\n    /// @param _newGrantee The address of the new grantee.\n    /// Must match the currently requested new grantee.\n    ",
        "@notice": "Confirm a grantee reassignment request and set the new grantee as the grantee. /// Can only be called by the grant manager.",
        "@param1": "_newGrantee The address of the new grantee. /// Must match the currently requested new grantee.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [],
        "func": "function withdraw() public onlyGrantee {\n        require(\n            requestedNewGrantee == address(0),\n            \"Can not withdraw with pending reassignment\"\n        );\n        tokenGrant.withdraw(grantId);\n        uint256 amount = token.balanceOf(address(this));\n        token.safeTransfer(grantee, amount);\n        emit TokensWithdrawn(grantee, amount);\n    }",
        "comments": [
            "",
            "    /// @notice Withdraw all unlocked tokens from the grant.",
            "    "
        ],
        "comt": "\n    /// @notice Withdraw all unlocked tokens from the grant.\n    ",
        "@notice": "Withdraw all unlocked tokens from the grant.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stake",
        "visibility": "public",
        "args": [
            {
                "name": "_stakingContract",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            },
            {
                "name": "_extraData",
                "type": "bytes memory"
            }
        ],
        "func": "function stake(\n        address _stakingContract,\n        uint256 _amount,\n        bytes memory _extraData\n    ) public onlyGrantee {\n        tokenGrant.stake(grantId, _stakingContract, _amount, _extraData);\n    }",
        "comments": [
            "",
            "    /// @notice Stake tokens from the grant.",
            "    /// @param _stakingContract The contract to stake the tokens on.",
            "    /// @param _amount The amount of tokens to stake.",
            "    /// @param _extraData Data for the stake delegation.",
            "    /// This byte array must have the following values concatenated:",
            "    /// beneficiary address (20 bytes)",
            "    /// operator address (20 bytes)",
            "    /// authorizer address (20 bytes)",
            "    "
        ],
        "comt": "\n    /// @notice Stake tokens from the grant.\n    /// @param _stakingContract The contract to stake the tokens on.\n    /// @param _amount The amount of tokens to stake.\n    /// @param _extraData Data for the stake delegation.\n    /// This byte array must have the following values concatenated:\n    /// beneficiary address (20 bytes)\n    /// operator address (20 bytes)\n    /// authorizer address (20 bytes)\n    ",
        "@notice": "Stake tokens from the grant.",
        "@param1": "_stakingContract The contract to stake the tokens on.",
        "@param2": "_amount The amount of tokens to stake.",
        "@param3": "_extraData Data for the stake delegation. /// This byte array must have the following values concatenated: /// beneficiary address (20 bytes) /// operator address (20 bytes) /// authorizer address (20 bytes)",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cancelStake",
        "visibility": "public",
        "args": [
            {
                "name": "_operator",
                "type": "address"
            }
        ],
        "func": "function cancelStake(address _operator) public onlyGranteeOr(_operator) {\n        tokenGrant.cancelStake(_operator);\n    }",
        "comments": [
            "",
            "    /// @notice Cancel delegating tokens to the given operator.",
            "    "
        ],
        "comt": "\n    /// @notice Cancel delegating tokens to the given operator.\n    ",
        "@notice": "Cancel delegating tokens to the given operator.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "undelegate",
        "visibility": "public",
        "args": [
            {
                "name": "_operator",
                "type": "address"
            }
        ],
        "func": "function undelegate(address _operator) public onlyGranteeOr(_operator) {\n        tokenGrant.undelegate(_operator);\n    }",
        "comments": [
            "",
            "    /// @notice Begin undelegating tokens from the given operator.",
            "    "
        ],
        "comt": "\n    /// @notice Begin undelegating tokens from the given operator.\n    ",
        "@notice": "Begin undelegating tokens from the given operator.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "recoverStake",
        "visibility": "public",
        "args": [
            {
                "name": "_operator",
                "type": "address"
            }
        ],
        "func": "function recoverStake(address _operator) public {\n        tokenGrant.recoverStake(_operator);\n    }",
        "comments": [
            "",
            "    /// @notice Recover tokens previously staked and delegated to the operator.",
            "    "
        ],
        "comt": "\n    /// @notice Recover tokens previously staked and delegated to the operator.\n    ",
        "@notice": "Recover tokens previously staked and delegated to the operator.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "beginGasPriceUpdate",
        "visibility": "public",
        "args": [
            {
                "name": "_newGasPrice",
                "type": "uint256"
            }
        ],
        "func": "function beginGasPriceUpdate(uint256 _newGasPrice) public onlyOwner {\n        newGasPrice = _newGasPrice;\n        gasPriceChangeInitiated = block.timestamp;\n    }",
        "comments": [
            "",
            "    /// @notice Initialize the gas price update. Change is finalized after",
            "    /// the governance delay elapses.",
            "    /// @param _newGasPrice New gas price in wei.",
            "    "
        ],
        "comt": "\n    /// @notice Initialize the gas price update. Change is finalized after\n    /// the governance delay elapses.\n    /// @param _newGasPrice New gas price in wei.\n    ",
        "@notice": "Initialize the gas price update. Change is finalized after /// the governance delay elapses.",
        "@param1": "_newGasPrice New gas price in wei.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "finalizeGasPriceUpdate",
        "visibility": "public",
        "args": [],
        "func": "function finalizeGasPriceUpdate() public onlyAfterGovernanceDelay {\n        gasPrice = newGasPrice;\n\n        newGasPrice = 0;\n        gasPriceChangeInitiated = 0;\n\n        emit GasPriceUpdated(gasPrice);\n        \n        for (uint256 i = 0; i < consumerContracts.length; i++) {\n            GasPriceOracleConsumer(consumerContracts[i]).refreshGasPrice();\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Finalizes the gas price update. Finalization may happen only",
            "    /// after the governance delay elapses.",
            "    "
        ],
        "comt": "\n    /// @notice Finalizes the gas price update. Finalization may happen only\n    /// after the governance delay elapses.\n    ",
        "@notice": "Finalizes the gas price update. Finalization may happen only /// after the governance delay elapses.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addConsumerContract",
        "visibility": "public",
        "args": [
            {
                "name": "consumerContract",
                "type": "address"
            }
        ],
        "func": "function addConsumerContract(address consumerContract) public onlyOwner {\n        consumerContracts.push(consumerContract);\n    }",
        "comments": [
            "",
            "    /// @notice Adds a new consumer contract to the oracle. Consumer contract is",
            "    /// expected to implement GasPriceOracleConsumer interface and receives",
            "    /// a notifcation every time gas price update is finalized.",
            "    /// @param consumerContract The new consumer contract to add to the oracle.",
            "    "
        ],
        "comt": "\n    /// @notice Adds a new consumer contract to the oracle. Consumer contract is\n    /// expected to implement GasPriceOracleConsumer interface and receives\n    /// a notifcation every time gas price update is finalized.\n    /// @param consumerContract The new consumer contract to add to the oracle.\n    ",
        "@notice": "Adds a new consumer contract to the oracle. Consumer contract is /// expected to implement GasPriceOracleConsumer interface and receives /// a notifcation every time gas price update is finalized.",
        "@param1": "consumerContract The new consumer contract to add to the oracle.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeConsumerContract",
        "visibility": "public",
        "args": [
            {
                "name": "index",
                "type": "uint256"
            }
        ],
        "func": "function removeConsumerContract(uint256 index) public onlyOwner {\n        require(index < consumerContracts.length, \"Invalid index\");\n        consumerContracts[index] = consumerContracts[consumerContracts.length - 1];\n        consumerContracts.length--;\n    }",
        "comments": [
            "",
            "    /// @notice Removes consumer contract from the oracle by its index.",
            "    /// @param index Index of the consumer contract to be removed.",
            "    "
        ],
        "comt": "\n    /// @notice Removes consumer contract from the oracle by its index.\n    /// @param index Index of the consumer contract to be removed.\n    ",
        "@notice": "Removes consumer contract from the oracle by its index.",
        "@param1": "index Index of the consumer contract to be removed.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getConsumerContracts",
        "visibility": "public",
        "args": [],
        "func": "function getConsumerContracts() public view returns (address[] memory) {\n        return consumerContracts;\n    }",
        "comments": [
            "",
            "    /// @notice Returns all consumer contracts currently registered in the",
            "    /// oracle.",
            "    "
        ],
        "comt": "\n    /// @notice Returns all consumer contracts currently registered in the\n    /// oracle.\n    ",
        "@notice": "Returns all consumer contracts currently registered in the /// oracle.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function burn(uint256 amount) public {\n        _burn(_msgSender(), amount);\n    }",
        "comments": [
            "/**",
            "     * @dev Destroys `amount` tokens from the caller.",
            "     *",
            "     * See {ERC20-_burn}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n",
        "@dev": "Destroys `amount` tokens from the caller. * * See {ERC20-_burn}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burnFrom",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function burnFrom(address account, uint256 amount) public {\n        _burnFrom(account, amount);\n    }",
        "comments": [
            "/**",
            "     * @dev See {ERC20-_burnFrom}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {ERC20-_burnFrom}.\n     */\n",
        "@dev": "See {ERC20-_burnFrom}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-totalSupply}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-totalSupply}.\n     */\n",
        "@dev": "See {IERC20-totalSupply}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-balanceOf}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-balanceOf}.\n     */\n",
        "@dev": "See {IERC20-balanceOf}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-transfer}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `recipient` cannot be the zero address.",
            "     * - the caller must have a balance of at least `amount`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n",
        "@dev": "See {IERC20-transfer}. * * Requirements: * * - `recipient` cannot be the zero address. * - the caller must have a balance of at least `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allowance",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            }
        ],
        "func": "function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-allowance}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-allowance}.\n     */\n",
        "@dev": "See {IERC20-allowance}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-approve}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n",
        "@dev": "See {IERC20-approve}. * * Requirements: * * - `spender` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-transferFrom}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance. This is not",
            "     * required by the EIP. See the note at the beginning of {ERC20};",
            "     *",
            "     * Requirements:",
            "     * - `sender` and `recipient` cannot be the zero address.",
            "     * - `sender` must have a balance of at least `amount`.",
            "     * - the caller must have allowance for `sender`'s tokens of at least",
            "     * `amount`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n",
        "@dev": "See {IERC20-transferFrom}. * * Emits an {Approval} event indicating the updated allowance. This is not * required by the EIP. See the note at the beginning of {ERC20}; * * Requirements: * - `sender` and `recipient` cannot be the zero address. * - `sender` must have a balance of at least `amount`. * - the caller must have allowance for `sender`'s tokens of at least * `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "increaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "addedValue",
                "type": "uint256"
            }
        ],
        "func": "function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Atomically increases the allowance granted to `spender` by the caller.",
            "     *",
            "     * This is an alternative to {approve} that can be used as a mitigation for",
            "     * problems described in {IERC20-approve}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n",
        "@dev": "Atomically increases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decreaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "subtractedValue",
                "type": "uint256"
            }
        ],
        "func": "function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Atomically decreases the allowance granted to `spender` by the caller.",
            "     *",
            "     * This is an alternative to {approve} that can be used as a mitigation for",
            "     * problems described in {IERC20-approve}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     * - `spender` must have allowance for the caller of at least",
            "     * `subtractedValue`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n",
        "@dev": "Atomically decreases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address. * - `spender` must have allowance for the caller of at least * `subtractedValue`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "name",
        "visibility": "public",
        "args": [],
        "func": "function name() public view returns (string memory) {\n        return _name;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the name of the token.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the name of the token.\n     */\n",
        "@dev": "Returns the name of the token.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "symbol",
        "visibility": "public",
        "args": [],
        "func": "function symbol() public view returns (string memory) {\n        return _symbol;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the symbol of the token, usually a shorter version of the",
            "     * name.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n",
        "@dev": "Returns the symbol of the token, usually a shorter version of the * name.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decimals",
        "visibility": "public",
        "args": [],
        "func": "function decimals() public view returns (uint8) {\n        return _decimals;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the number of decimals used to get its user representation.",
            "     * For example, if `decimals` equals `2`, a balance of `505` tokens should",
            "     * be displayed to a user as `5,05` (`505 / 10 ** 2`).",
            "     *",
            "     * Tokens usually opt for a value of 18, imitating the relationship between",
            "     * Ether and Wei.",
            "     *",
            "     * NOTE: This information is only used for _display_ purposes: it in",
            "     * no way affects any of the arithmetic of the contract, including",
            "     * {IERC20-balanceOf} and {IERC20-transfer}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n",
        "@dev": "Returns the number of decimals used to get its user representation. * For example, if `decimals` equals `2`, a balance of `505` tokens should * be displayed to a user as `5,05` (`505 / 10 ** 2`). * * Tokens usually opt for a value of 18, imitating the relationship between * Ether and Wei. * * NOTE: This information is only used for _display_ purposes: it in * no way affects any of the arithmetic of the contract, including * {IERC20-balanceOf} and {IERC20-transfer}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "_address",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address _address) public view returns (uint256 balance) {\n        return operators[_address].packedParams.getAmount();\n    }",
        "comments": [
            "",
            "    /// @notice Gets the stake balance of the specified address.",
            "    /// @param _address The address to query the balance of.",
            "    /// @return An uint256 representing the amount staked by the passed address.",
            "    "
        ],
        "comt": "\n    /// @notice Gets the stake balance of the specified address.\n    /// @param _address The address to query the balance of.\n    /// @return An uint256 representing the amount staked by the passed address.\n    ",
        "@notice": "Gets the stake balance of the specified address.",
        "@param1": "_address The address to query the balance of.",
        "@return1": "An uint256 representing the amount staked by the passed address.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "ownerOf",
        "visibility": "public",
        "args": [
            {
                "name": "_operator",
                "type": "address"
            }
        ],
        "func": "function ownerOf(address _operator) public view returns (address) {\n        return operators[_operator].owner;\n    }",
        "comments": [
            "",
            "    /// @notice Gets the stake owner for the specified operator address.",
            "    /// @return Stake owner address.",
            "    "
        ],
        "comt": "\n    /// @notice Gets the stake owner for the specified operator address.\n    /// @return Stake owner address.\n    ",
        "@notice": "Gets the stake owner for the specified operator address.",
        "@return1": "Stake owner address.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "beneficiaryOf",
        "visibility": "public",
        "args": [
            {
                "name": "_operator",
                "type": "address"
            }
        ],
        "func": "function beneficiaryOf(address _operator) public view returns (address payable) {\n        return operators[_operator].beneficiary;\n    }",
        "comments": [
            "",
            "    /// @notice Gets the beneficiary for the specified operator address.",
            "    /// @return Beneficiary address.",
            "    "
        ],
        "comt": "\n    /// @notice Gets the beneficiary for the specified operator address.\n    /// @return Beneficiary address.\n    ",
        "@notice": "Gets the beneficiary for the specified operator address.",
        "@return1": "Beneficiary address.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "authorizerOf",
        "visibility": "public",
        "args": [
            {
                "name": "_operator",
                "type": "address"
            }
        ],
        "func": "function authorizerOf(address _operator) public view returns (address) {\n        return operators[_operator].authorizer;\n    }",
        "comments": [
            "",
            "    /// @notice Gets the authorizer for the specified operator address.",
            "    /// @return Authorizer address.",
            "    "
        ],
        "comt": "\n    /// @notice Gets the authorizer for the specified operator address.\n    /// @return Authorizer address.\n    ",
        "@notice": "Gets the authorizer for the specified operator address.",
        "@return1": "Authorizer address.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "start",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "_seed",
                "type": "uint256"
            }
        ],
        "func": "function start(Storage storage self, uint256 _seed) public {\n        // We execute the minimum required cleanup here needed in case the\n        // previous group selection failed and did not clean up properly in\n        // finish function.\n        cleanupTickets(self);\n        self.inProgress = true;\n        self.seed = _seed;\n        self.ticketSubmissionStartBlock = block.number;\n    }",
        "comments": [
            "",
            "    /// @notice Starts group selection protocol.",
            "    /// @param _seed pseudorandom seed value used as an input for the group",
            "    /// selection. All submitted tickets needs to have the seed mixed-in into the",
            "    /// value.",
            "    "
        ],
        "comt": "\n    /// @notice Starts group selection protocol.\n    /// @param _seed pseudorandom seed value used as an input for the group\n    /// selection. All submitted tickets needs to have the seed mixed-in into the\n    /// value.\n    ",
        "@notice": "Starts group selection protocol.",
        "@param1": "_seed pseudorandom seed value used as an input for the group /// selection. All submitted tickets needs to have the seed mixed-in into the /// value.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "finish",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            }
        ],
        "func": "function finish(Storage storage self) public {\n        cleanupCandidates(self);\n        cleanupTickets(self);\n        self.inProgress = false;\n    }",
        "comments": [
            "",
            "    /// @notice Finishes group selection protocol clearing up all the submitted",
            "    /// tickets. This function may be expensive if not executed as a part of",
            "    /// another transaction consuming a lot of gas and as a result, getting",
            "    /// gas refund for clearing up the storage.",
            "    "
        ],
        "comt": "\n    /// @notice Finishes group selection protocol clearing up all the submitted\n    /// tickets. This function may be expensive if not executed as a part of\n    /// another transaction consuming a lot of gas and as a result, getting\n    /// gas refund for clearing up the storage.\n    ",
        "@notice": "Finishes group selection protocol clearing up all the submitted /// tickets. This function may be expensive if not executed as a part of /// another transaction consuming a lot of gas and as a result, getting /// gas refund for clearing up the storage.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "submitTicket",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "ticket",
                "type": "bytes32"
            },
            {
                "name": "stakingWeight",
                "type": "uint256"
            }
        ],
        "func": "function submitTicket(\n        Storage storage self,\n        bytes32 ticket,\n        uint256 stakingWeight\n    ) public {\n        uint64 ticketValue;\n        uint160 stakerValue;\n        uint32 virtualStakerIndex;\n\n        bytes memory ticketBytes = abi.encodePacked(ticket);\n        /* solium-disable-next-line */\n        assembly {\n            // ticket value is 8 bytes long\n            ticketValue := mload(add(ticketBytes, 8))\n            // staker value is 20 bytes long\n            stakerValue := mload(add(ticketBytes, 28))\n            // virtual staker index is 4 bytes long\n            virtualStakerIndex := mload(add(ticketBytes, 32))\n        }\n\n        submitTicket(\n            self,\n            ticketValue,\n            uint256(stakerValue),\n            uint256(virtualStakerIndex),\n            stakingWeight\n        );\n    }",
        "comments": [
            "    ///   has to be unique for all tickets submitted by the given staker for the",
            "    ///   current candidate group selection.",
            "    /// @param stakingWeight Ratio of the minimum stake to the candidate's",
            "    /// stake.",
            "    "
        ],
        "comt": "    ///   has to be unique for all tickets submitted by the given staker for the\n    ///   current candidate group selection.\n    /// @param stakingWeight Ratio of the minimum stake to the candidate's\n    /// stake.\n    ",
        "@param1": "stakingWeight Ratio of the minimum stake to the candidate's /// stake.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "submitTicket",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "ticketValue",
                "type": "uint64"
            },
            {
                "name": "stakerValue",
                "type": "uint256"
            },
            {
                "name": "virtualStakerIndex",
                "type": "uint256"
            },
            {
                "name": "stakingWeight",
                "type": "uint256"
            }
        ],
        "func": "function submitTicket(\n        Storage storage self,\n        uint64 ticketValue,\n        uint256 stakerValue,\n        uint256 virtualStakerIndex,\n        uint256 stakingWeight\n    ) public {\n        if (block.number > self.ticketSubmissionStartBlock.add(self.ticketSubmissionTimeout)) {\n            revert(\"Ticket submission is over\");\n        }\n\n        if (self.candidate[ticketValue] != address(0)) {\n            revert(\"Duplicate ticket\");\n        }\n\n        if (isTicketValid(\n            ticketValue,\n            stakerValue,\n            virtualStakerIndex,\n            stakingWeight,\n            self.seed\n        )) {\n            addTicket(self, ticketValue);\n        } else {\n            revert(\"Invalid ticket\");\n        }\n    }",
        "comments": [
            "    /// has to be unique for all tickets submitted by the given staker for the",
            "    /// current candidate group selection.",
            "    /// @param stakingWeight Ratio of the minimum stake to the candidate's",
            "    /// stake.",
            "    "
        ],
        "comt": "    /// has to be unique for all tickets submitted by the given staker for the\n    /// current candidate group selection.\n    /// @param stakingWeight Ratio of the minimum stake to the candidate's\n    /// stake.\n    ",
        "@param1": "stakingWeight Ratio of the minimum stake to the candidate's /// stake.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "selectedParticipants",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            }
        ],
        "func": "function selectedParticipants(Storage storage self) public view returns (address[] memory) {\n        require(\n            block.number >= self.ticketSubmissionStartBlock.add(self.ticketSubmissionTimeout),\n            \"Ticket submission in progress\"\n        );\n\n        require(self.tickets.length >= self.groupSize, \"Not enough tickets submitted\");\n\n        uint256[] memory previousTicketIndex = readPreviousTicketIndices(self);\n        address[] memory selected = new address[](self.groupSize);\n        uint256 ticketIndex = self.tail;\n        selected[self.tickets.length - 1] = self.candidate[self.tickets[ticketIndex]];\n        for (uint256 i = self.tickets.length - 1; i > 0; i--) {\n            ticketIndex = previousTicketIndex[ticketIndex];\n            selected[i-1] = self.candidate[self.tickets[ticketIndex]];\n        }\n\n        return selected;\n    }",
        "comments": [
            "",
            "    /// @notice Gets selected participants in ascending order of their tickets.",
            "    "
        ],
        "comt": "\n    /// @notice Gets selected participants in ascending order of their tickets.\n    ",
        "@notice": "Gets selected participants in ascending order of their tickets.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addGroup",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "groupPubKey",
                "type": "bytes memory"
            }
        ],
        "func": "function addGroup(\n        Storage storage self,\n        bytes memory groupPubKey\n    ) public {\n        self.groupIndices[groupPubKey] = (self.groups.length ^ GROUP_INDEX_FLAG);\n        self.groups.push(Group(groupPubKey, block.number, false, uint248(block.timestamp)));\n    }",
        "comments": [
            "",
            "    /// @notice Adds a new group.",
            "    "
        ],
        "comt": "\n    /// @notice Adds a new group.\n    ",
        "@notice": "Adds a new group.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setGroupMembers",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "groupPubKey",
                "type": "bytes memory"
            },
            {
                "name": "members",
                "type": "address[] memory"
            },
            {
                "name": "misbehaved",
                "type": "bytes memory"
            }
        ],
        "func": "function setGroupMembers(\n        Storage storage self,\n        bytes memory groupPubKey,\n        address[] memory members,\n        bytes memory misbehaved\n    ) public {\n        self.groupMembers[groupPubKey] = members;\n\n        // Iterate misbehaved array backwards, replace misbehaved\n        // member with the last element and reduce array length\n        uint256 i = misbehaved.length;\n        while (i > 0) {\n             // group member indexes start from 1, so we need to -1 on misbehaved\n            uint256 memberArrayPosition = misbehaved.toUint8(i - 1) - 1;\n            self.groupMembers[groupPubKey][memberArrayPosition] = self.groupMembers[groupPubKey][self.groupMembers[groupPubKey].length - 1];\n            self.groupMembers[groupPubKey].length--;\n            i--;\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "terminateGroup",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "groupIndex",
                "type": "uint256"
            }
        ],
        "func": "function terminateGroup(\n        Storage storage self,\n        uint256 groupIndex\n    ) public {\n        require(\n            !isGroupTerminated(self, groupIndex),\n            \"Group has been already terminated\"\n        );\n        self.groups[groupIndex].terminated = true;\n        self.activeTerminatedGroups.length++;\n\n        // Sorting activeTerminatedGroups in ascending order so a non-terminated\n        // group is properly selected.\n        uint256 i;\n        for (\n            i = self.activeTerminatedGroups.length - 1;\n            i > 0 && self.activeTerminatedGroups[i - 1] > groupIndex;\n            i--\n        ) {\n            self.activeTerminatedGroups[i] = self.activeTerminatedGroups[i - 1];\n        }\n        self.activeTerminatedGroups[i] = groupIndex;\n    }",
        "comments": [
            "",
            "    /// @notice Terminates group with the provided index. Reverts if the group",
            "    /// is already terminated.",
            "    "
        ],
        "comt": "\n    /// @notice Terminates group with the provided index. Reverts if the group\n    /// is already terminated.\n    ",
        "@notice": "Terminates group with the provided index. Reverts if the group /// is already terminated.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isStaleGroup",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "groupPubKey",
                "type": "bytes memory"
            }
        ],
        "func": "function isStaleGroup(\n        Storage storage self,\n        bytes memory groupPubKey\n    ) public view returns(bool) {\n        uint256 flaggedIndex = self.groupIndices[groupPubKey];\n        require(flaggedIndex != 0, \"Group does not exist\");\n        uint256 index = flaggedIndex ^ GROUP_INDEX_FLAG;\n        bool isExpired = self.expiredGroupOffset > index;\n        bool isStale = groupStaleTime(self, self.groups[index]) < block.number;\n        return isExpired && isStale;\n    }",
        "comments": [
            "",
            "    /// @notice Checks if a group with the given public key is a stale group.",
            "    /// Stale group is an expired group which is no longer performing any",
            "    /// operations. It is important to understand that an expired group may",
            "    /// still perform some operations for which it was selected when it was still",
            "    /// active. We consider a group to be stale when it's expired and when its",
            "    /// expiration time and potentially executed operation timeout are both in",
            "    /// the past.",
            "    "
        ],
        "comt": "\n    /// @notice Checks if a group with the given public key is a stale group.\n    /// Stale group is an expired group which is no longer performing any\n    /// operations. It is important to understand that an expired group may\n    /// still perform some operations for which it was selected when it was still\n    /// active. We consider a group to be stale when it's expired and when its\n    /// expiration time and potentially executed operation timeout are both in\n    /// the past.\n    ",
        "@notice": "Checks if a group with the given public key is a stale group. /// Stale group is an expired group which is no longer performing any /// operations. It is important to understand that an expired group may /// still perform some operations for which it was selected when it was still /// active. We consider a group to be stale when it's expired and when its /// expiration time and potentially executed operation timeout are both in /// the past.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "isStaleGroup",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "groupIndex",
                "type": "uint256"
            }
        ],
        "func": "function isStaleGroup(\n        Storage storage self,\n        uint256 groupIndex\n    ) public view returns(bool) {\n        return groupStaleTime(self, self.groups[groupIndex]) < block.number;\n    }",
        "comments": [
            "",
            "    /// @notice Checks if a group with the given index is a stale group.",
            "    /// Stale group is an expired group which is no longer performing any",
            "    /// operations. It is important to understand that an expired group may",
            "    /// still perform some operations for which it was selected when it was still",
            "    /// active. We consider a group to be stale when it's expired and when its",
            "    /// expiration time and potentially executed operation timeout are both in",
            "    /// the past.",
            "    "
        ],
        "comt": "\n    /// @notice Checks if a group with the given index is a stale group.\n    /// Stale group is an expired group which is no longer performing any\n    /// operations. It is important to understand that an expired group may\n    /// still perform some operations for which it was selected when it was still\n    /// active. We consider a group to be stale when it's expired and when its\n    /// expiration time and potentially executed operation timeout are both in\n    /// the past.\n    ",
        "@notice": "Checks if a group with the given index is a stale group. /// Stale group is an expired group which is no longer performing any /// operations. It is important to understand that an expired group may /// still perform some operations for which it was selected when it was still /// active. We consider a group to be stale when it's expired and when its /// expiration time and potentially executed operation timeout are both in /// the past.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "expireOldGroups",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            }
        ],
        "func": "function expireOldGroups(Storage storage self) public {\n        // Move expiredGroupOffset as long as there are some groups that should\n        // be marked as expired. It is possible that expired group offset will\n        // move out of the groups array by one position. It means that all groups\n        // are expired (it points to the first active group) and that place in\n        // groups array - currently empty - will be possibly filled later by\n        // a new group.\n        while(\n            self.expiredGroupOffset < self.groups.length &&\n            groupActiveTimeOf(self, self.groups[self.expiredGroupOffset]) < block.number\n        ) {\n            self.expiredGroupOffset++;\n        }\n\n        // Go through all activeTerminatedGroups and if some of the terminated\n        // groups are expired, remove them from activeTerminatedGroups collection.\n        // This is needed because we evaluate the shift of selected group index\n        // based on how many non-expired groups has been terminated.\n        for (uint i = 0; i < self.activeTerminatedGroups.length; i++) {\n            if (self.expiredGroupOffset > self.activeTerminatedGroups[i]) {\n                self.activeTerminatedGroups[i] = self.activeTerminatedGroups[self.activeTerminatedGroups.length - 1];\n                self.activeTerminatedGroups.length--;\n            }\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Goes through groups starting from the oldest one that is still",
            "    /// active and checks if it hasn't expired. If so, updates the information",
            "    /// about expired groups so that all expired groups are marked as such.",
            "    "
        ],
        "comt": "\n    /// @notice Goes through groups starting from the oldest one that is still\n    /// active and checks if it hasn't expired. If so, updates the information\n    /// about expired groups so that all expired groups are marked as such.\n    ",
        "@notice": "Goes through groups starting from the oldest one that is still /// active and checks if it hasn't expired. If so, updates the information /// about expired groups so that all expired groups are marked as such.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "selectGroup",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "seed",
                "type": "uint256"
            }
        ],
        "func": "function selectGroup(\n        Storage storage self,\n        uint256 seed\n    ) public returns(uint256) {\n        expireOldGroups(self);\n\n        require(numberOfGroups(self) > 0, \"No active groups\");\n\n        uint256 selectedGroup = seed % numberOfGroups(self);\n        return shiftByTerminatedGroups(self, shiftByExpiredGroups(self, selectedGroup));\n    }",
        "comments": [
            "",
            "    /// @notice Returns an index of a randomly selected active group. Terminated",
            "    /// and expired groups are not considered as active.",
            "    /// Before new group is selected, information about expired groups",
            "    /// is updated. At least one active group needs to be present for this",
            "    /// function to succeed.",
            "    /// @param seed Random number used as a group selection seed.",
            "    "
        ],
        "comt": "\n    /// @notice Returns an index of a randomly selected active group. Terminated\n    /// and expired groups are not considered as active.\n    /// Before new group is selected, information about expired groups\n    /// is updated. At least one active group needs to be present for this\n    /// function to succeed.\n    /// @param seed Random number used as a group selection seed.\n    ",
        "@notice": "Returns an index of a randomly selected active group. Terminated /// and expired groups are not considered as active. /// Before new group is selected, information about expired groups /// is updated. At least one active group needs to be present for this /// function to succeed.",
        "@param1": "seed Random number used as a group selection seed.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawFromGroup",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "groupIndex",
                "type": "uint256"
            }
        ],
        "func": "function withdrawFromGroup(\n        Storage storage self,\n        address operator,\n        uint256 groupIndex\n    ) public returns (uint256 rewards) {\n        bool isExpired = self.expiredGroupOffset > groupIndex;\n        bool isStale = isStaleGroup(self, groupIndex);\n        require(isExpired && isStale, \"Group must be expired and stale\");\n        bytes memory groupPublicKey = getGroupPublicKey(self, groupIndex);\n        require(\n            !(self.withdrawn[groupPublicKey][operator]),\n            \"Rewards already withdrawn\"\n        );\n        self.withdrawn[groupPublicKey][operator] = true;\n        for (uint i = 0; i < self.groupMembers[groupPublicKey].length; i++) {\n            if (operator == self.groupMembers[groupPublicKey][i]) {\n                rewards = rewards.add(self.groupMemberRewards[groupPublicKey]);\n            }\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Withdraws accumulated group member rewards for operator",
            "    /// using the provided group index.",
            "    /// Once the accumulated reward is withdrawn from the selected group,",
            "    /// the operator is flagged as withdrawn.",
            "    /// Rewards can be withdrawn only from stale group.",
            "    /// @param operator Operator address.",
            "    /// @param groupIndex Group index.",
            "    "
        ],
        "comt": "\n    /// @notice Withdraws accumulated group member rewards for operator\n    /// using the provided group index.\n    /// Once the accumulated reward is withdrawn from the selected group,\n    /// the operator is flagged as withdrawn.\n    /// Rewards can be withdrawn only from stale group.\n    /// @param operator Operator address.\n    /// @param groupIndex Group index.\n    ",
        "@notice": "Withdraws accumulated group member rewards for operator /// using the provided group index. /// Once the accumulated reward is withdrawn from the selected group, /// the operator is flagged as withdrawn. /// Rewards can be withdrawn only from stale group.",
        "@param1": "operator Operator address.",
        "@param2": "groupIndex Group index.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getGroupMembers",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "groupPubKey",
                "type": "bytes memory"
            }
        ],
        "func": "function getGroupMembers(\n        Storage storage self,\n        bytes memory groupPubKey\n    ) public view returns (address[] memory members) {\n        return self.groupMembers[groupPubKey];\n    }",
        "comments": [
            "",
            "    /// @notice Returns members of the given group by group public key.",
            "    /// @param groupPubKey Group public key.",
            "    "
        ],
        "comt": "\n    /// @notice Returns members of the given group by group public key.\n    /// @param groupPubKey Group public key.\n    ",
        "@notice": "Returns members of the given group by group public key.",
        "@param1": "groupPubKey Group public key.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getGroupMembers",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "groupIndex",
                "type": "uint256"
            }
        ],
        "func": "function getGroupMembers(\n        Storage storage self,\n        uint256 groupIndex\n    ) public view returns (address[] memory members) {\n        bytes memory groupPubKey = self.groups[groupIndex].groupPubKey;\n        return self.groupMembers[groupPubKey];\n    }",
        "comments": [
            "",
            "    /// @notice Returns addresses of all the members in the provided group.",
            "    "
        ],
        "comt": "\n    /// @notice Returns addresses of all the members in the provided group.\n    ",
        "@notice": "Returns addresses of all the members in the provided group.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getGroupRegistrationTime",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "groupIndex",
                "type": "uint256"
            }
        ],
        "func": "function getGroupRegistrationTime(\n        Storage storage self,\n        uint256 groupIndex\n    ) public view returns (uint256) {\n        return uint256(self.groups[groupIndex].registrationTime);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "reportUnauthorizedSigning",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "groupIndex",
                "type": "uint256"
            },
            {
                "name": "signedMsgSender",
                "type": "bytes memory"
            },
            {
                "name": "minimumStake",
                "type": "uint256"
            }
        ],
        "func": "function reportUnauthorizedSigning(\n        Storage storage self,\n        uint256 groupIndex,\n        bytes memory signedMsgSender,\n        uint256 minimumStake\n    ) public {\n        require(!isStaleGroup(self, groupIndex), \"Group can not be stale\");\n        bytes memory groupPubKey = getGroupPublicKey(self, groupIndex);\n\n        require(\n            BLS.verifyBytes(\n                groupPubKey,\n                abi.encodePacked(msg.sender),\n                signedMsgSender\n            ),\n            \"Invalid signature\"\n        );\n\n        terminateGroup(self, groupIndex);\n        self.stakingContract.seize(minimumStake, 100, msg.sender, self.groupMembers[groupPubKey]);\n    }",
        "comments": [
            "",
            "    /// @notice Reports unauthorized signing for the provided group. Must provide",
            "    /// a valid signature of the group address as a message. Successful signature",
            "    /// verification means the private key has been leaked and all group members",
            "    /// should be punished by seizing\u00a0their tokens. The submitter of this proof is",
            "    /// rewarded with 5% of the total seized amount scaled by the reward adjustment",
            "    /// parameter and the rest 95% is burned. Group has to be active or expired.",
            "    /// Unauthorized signing cannot be reported for stale or terminated group.",
            "    /// In case of reporting unauthorized signing for stale group,",
            "    /// terminated group, or when the signature is inavlid, function reverts.",
            "    "
        ],
        "comt": "\n    /// @notice Reports unauthorized signing for the provided group. Must provide\n    /// a valid signature of the group address as a message. Successful signature\n    /// verification means the private key has been leaked and all group members\n    /// should be punished by seizing\u00a0their tokens. The submitter of this proof is\n    /// rewarded with 5% of the total seized amount scaled by the reward adjustment\n    /// parameter and the rest 95% is burned. Group has to be active or expired.\n    /// Unauthorized signing cannot be reported for stale or terminated group.\n    /// In case of reporting unauthorized signing for stale group,\n    /// terminated group, or when the signature is inavlid, function reverts.\n    ",
        "@notice": "Reports unauthorized signing for the provided group. Must provide /// a valid signature of the group address as a message. Successful signature /// verification means the private key has been leaked and all group members /// should be punished by seizing their tokens. The submitter of this proof is /// rewarded with 5% of the total seized amount scaled by the reward adjustment /// parameter and the rest 95% is burned. Group has to be active or expired. /// Unauthorized signing cannot be reported for stale or terminated group. /// In case of reporting unauthorized signing for stale group, /// terminated group, or when the signature is inavlid, function reverts.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "reportRelayEntryTimeout",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "groupIndex",
                "type": "uint256"
            },
            {
                "name": "groupSize",
                "type": "uint256"
            }
        ],
        "func": "function reportRelayEntryTimeout(\n        Storage storage self,\n        uint256 groupIndex,\n        uint256 groupSize\n    ) public {\n        uint256 punishment = relayEntryTimeoutPunishment(self);\n        terminateGroup(self, groupIndex);\n        // Reward is limited to\u00a0min(1, 20 / group_size) of the maximum tattletale reward, see the Yellow Paper for more details.\n        uint256 rewardAdjustment = uint256(20 * 100).div(groupSize); // Reward adjustment in percentage\n        rewardAdjustment = rewardAdjustment > 100 ? 100:rewardAdjustment; // Reward adjustment can be 100% max\n        self.stakingContract.seize(punishment, rewardAdjustment, msg.sender, getGroupMembers(self, groupIndex));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "relayEntryTimeoutPunishment",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            }
        ],
        "func": "function relayEntryTimeoutPunishment(\n        Storage storage self\n    ) public view returns (uint256) {\n        uint256 minimumStake = self.stakingContract.minimumStake();\n\n        uint256 stakingContractDeployedAt = self.stakingContract.deployedAt();\n        /* solium-disable-next-line security/no-block-members */\n        if (now < stakingContractDeployedAt + THREE_MONTHS) {\n            return minimumStake.percent(1);\n        /* solium-disable-next-line security/no-block-members */\n        } else if (now < stakingContractDeployedAt + SIX_MONTHS) {\n            return minimumStake.percent(50);\n        } else {\n            return minimumStake;\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Evaluates relay entry timeout punishment using the following",
            "    /// rules:",
            "    /// - 1% of the minimum stake for the first 3 months,",
            "    /// - 50% of the minimum stake between the first 3 and 6 months,",
            "    /// - 100% of the minimum stake after the first 6 months.",
            "    "
        ],
        "comt": "\n    /// @notice Evaluates relay entry timeout punishment using the following\n    /// rules:\n    /// - 1% of the minimum stake for the first 3 months,\n    /// - 50% of the minimum stake between the first 3 and 6 months,\n    /// - 100% of the minimum stake after the first 6 months.\n    ",
        "@notice": "Evaluates relay entry timeout punishment using the following /// rules: /// - 1% of the minimum stake for the first 3 months, /// - 50% of the minimum stake between the first 3 and 6 months, /// - 100% of the minimum stake after the first 6 months.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "hasWithdrawnRewards",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "groupIndex",
                "type": "uint256"
            }
        ],
        "func": "function hasWithdrawnRewards(\n        Storage storage self,\n        address operator,\n        uint256 groupIndex\n    ) public view returns (bool) {\n        return self.withdrawn[getGroupPublicKey(self, groupIndex)][operator];\n    }",
        "comments": [
            "",
            "    /// @notice Return whether the given operator",
            "    /// has withdrawn their rewards from the given group.",
            "    "
        ],
        "comt": "\n    /// @notice Return whether the given operator\n    /// has withdrawn their rewards from the given group.\n    ",
        "@notice": "Return whether the given operator /// has withdrawn their rewards from the given group.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "verify",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "submitterMemberIndex",
                "type": "uint256"
            },
            {
                "name": "groupPubKey",
                "type": "bytes memory"
            },
            {
                "name": "misbehaved",
                "type": "bytes memory"
            },
            {
                "name": "signatures",
                "type": "bytes memory"
            },
            {
                "name": "signingMemberIndices",
                "type": "uint256[] memory"
            },
            {
                "name": "members",
                "type": "address[] memory"
            },
            {
                "name": "groupSelectionEndBlock",
                "type": "uint256"
            }
        ],
        "func": "function verify(\n        Storage storage self,\n        uint256 submitterMemberIndex,\n        bytes memory groupPubKey,\n        bytes memory misbehaved,\n        bytes memory signatures,\n        uint256[] memory signingMemberIndices,\n        address[] memory members,\n        uint256 groupSelectionEndBlock\n    ) public view {\n        require(submitterMemberIndex > 0, \"Invalid submitter index\");\n        require(\n            members[submitterMemberIndex - 1] == msg.sender,\n            \"Unexpected submitter index\"\n        );\n\n        uint T_init = groupSelectionEndBlock + self.timeDKG;\n        require(\n            block.number >= (T_init + (submitterMemberIndex-1) * self.resultPublicationBlockStep),\n            \"Submitter not eligible\"\n        );\n\n        require(groupPubKey.length == 128, \"Malformed group public key\");\n\n        require(\n            misbehaved.length <= self.groupSize - self.signatureThreshold,\n            \"Malformed misbehaved bytes\"\n        );\n\n        uint256 signaturesCount = signatures.length / 65;\n        require(signatures.length >= 65, \"Too short signatures array\");\n        require(signatures.length % 65 == 0, \"Malformed signatures array\");\n        require(signaturesCount == signingMemberIndices.length, \"Unexpected signatures count\");\n        require(signaturesCount >= self.signatureThreshold, \"Too few signatures\");\n        require(signaturesCount <= self.groupSize, \"Too many signatures\");\n\n        bytes32 resultHash = keccak256(abi.encodePacked(groupPubKey, misbehaved));\n\n        bytes memory current; // Current signature to be checked.\n\n        bool[] memory usedMemberIndices = new bool[](self.groupSize);\n\n        for(uint i = 0; i < signaturesCount; i++){\n            uint256 memberIndex = signingMemberIndices[i];\n            require(memberIndex > 0, \"Invalid index\");\n            require(memberIndex <= members.length, \"Index out of range\");\n\n            require(!usedMemberIndices[memberIndex - 1], \"Duplicate member index\");\n            usedMemberIndices[memberIndex - 1] = true;\n\n            current = signatures.slice(65*i, 65);\n            address recoveredAddress = resultHash.toEthSignedMessageHash().recover(current);\n            require(members[memberIndex - 1] == recoveredAddress, \"Invalid signature\");\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "reimburseCallback",
        "visibility": "public",
        "args": [
            {
                "name": "stakingContract",
                "type": "TokenStaking"
            },
            {
                "name": "gasPriceCeiling",
                "type": "uint256"
            },
            {
                "name": "gasLimit",
                "type": "uint256"
            },
            {
                "name": "gasSpent",
                "type": "uint256"
            },
            {
                "name": "callbackFee",
                "type": "uint256"
            },
            {
                "name": "callbackSurplusRecipientData",
                "type": "bytes memory"
            }
        ],
        "func": "function reimburseCallback(\n        TokenStaking stakingContract,\n        uint256 gasPriceCeiling,\n        uint256 gasLimit,\n        uint256 gasSpent,\n        uint256 callbackFee,\n        bytes memory callbackSurplusRecipientData\n    ) public {\n        uint256 gasPrice = gasPriceCeiling;\n        // We need to check if tx.gasprice is non-zero as a workaround to a bug\n        // in go-ethereum:\n        // https://github.com/ethereum/go-ethereum/pull/20189\n        if (tx.gasprice > 0 && tx.gasprice < gasPriceCeiling) {\n            gasPrice = tx.gasprice;\n        }\n\n        // Obtain the actual callback gas expenditure and refund the surplus.\n        //\n        // In case of heavily underpriced transactions, EVM may wrap the call\n        // with additional opcodes. In this case gasSpent > gasLimit.\n        // The worst scenario cost is included in entry verification fee.\n        // If this happens we return just the gasLimit here.\n        uint256 actualCallbackGas = gasSpent < gasLimit ? gasSpent : gasLimit;\n        uint256 actualCallbackFee = actualCallbackGas.mul(gasPrice);\n\n        // Get the beneficiary.\n        address payable beneficiary = stakingContract.beneficiaryOf(msg.sender);\n\n        // If we spent less on the callback than the customer transferred for the\n        // callback execution, we need to reimburse the difference.\n        if (actualCallbackFee < callbackFee) {\n            uint256 callbackSurplus = callbackFee.sub(actualCallbackFee);\n            // Reimburse submitter with his actual callback cost.\n            beneficiary.call.value(actualCallbackFee)(\"\");\n\n            // Return callback surplus to the requestor.\n            // Expecting 32 bytes data containing 20 byte address\n            if (callbackSurplusRecipientData.length == 32) {\n                address surplusRecipient = callbackSurplusRecipientData.toAddress(12);\n                surplusRecipient.call.gas(8000).value(callbackSurplus)(\"\");\n            }\n        } else {\n            // Reimburse submitter with the callback payment sent by the requestor.\n            beneficiary.call.value(callbackFee)(\"\");\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Reimburses callback execution cost and surplus based on actual gas",
            "    /// usage to the submitter's beneficiary address and if necessary to the",
            "    /// callback requestor (surplus recipient).",
            "    /// @param stakingContract Staking contract to get the address of the beneficiary",
            "    /// @param gasPriceCeiling Gas price ceiling in wei",
            "    /// @param gasLimit Gas limit set for the callback",
            "    /// @param gasSpent Gas spent by the submitter on the callback",
            "    /// @param callbackFee Fee paid for the callback by the requestor",
            "    /// @param callbackSurplusRecipientData Data containing surplus recipient address",
            "    "
        ],
        "comt": "\n    /// @notice Reimburses callback execution cost and surplus based on actual gas\n    /// usage to the submitter's beneficiary address and if necessary to the\n    /// callback requestor (surplus recipient).\n    /// @param stakingContract Staking contract to get the address of the beneficiary\n    /// @param gasPriceCeiling Gas price ceiling in wei\n    /// @param gasLimit Gas limit set for the callback\n    /// @param gasSpent Gas spent by the submitter on the callback\n    /// @param callbackFee Fee paid for the callback by the requestor\n    /// @param callbackSurplusRecipientData Data containing surplus recipient address\n    ",
        "@notice": "Reimburses callback execution cost and surplus based on actual gas /// usage to the submitter's beneficiary address and if necessary to the /// callback requestor (surplus recipient).",
        "@param1": "stakingContract Staking contract to get the address of the beneficiary",
        "@param2": "gasPriceCeiling Gas price ceiling in wei",
        "@param3": "gasLimit Gas limit set for the callback",
        "@param4": "gasSpent Gas spent by the submitter on the callback",
        "@param5": "callbackFee Fee paid for the callback by the requestor",
        "@param6": "callbackSurplusRecipientData Data containing surplus recipient address",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "calculate",
        "visibility": "public",
        "args": [
            {
                "name": "currentRequestStartBlock",
                "type": "uint256"
            },
            {
                "name": "relayEntryTimeout",
                "type": "uint256"
            }
        ],
        "func": "function calculate(\n        uint256 currentRequestStartBlock,\n        uint256 relayEntryTimeout\n    ) public view returns(uint256 delayFactor) {\n        uint256 decimals = 1e16; // Adding 16 decimals to perform float division.\n\n        // T_deadline is the earliest block when no submissions are accepted\n        // and an entry timed out. The last block the entry can be published in is\n        //     currentRequestStartBlock + relayEntryTimeout\n        // and submission are no longer accepted from block\n        //     currentRequestStartBlock + relayEntryTimeout + 1.\n        uint256 deadlineBlock = currentRequestStartBlock.add(relayEntryTimeout).add(1);\n\n        // T_begin is the earliest block the result can be published in.\n        // Relay entry can be generated instantly after relay request is\n        // registered on-chain so a new entry can be published at the next\n        // block the earliest.\n        uint256 submissionStartBlock = currentRequestStartBlock.add(1);\n\n        // Use submissionStartBlock block as entryReceivedBlock if entry submitted earlier than expected.\n        uint256 entryReceivedBlock = block.number <= submissionStartBlock ? submissionStartBlock:block.number;\n\n        // T_remaining = T_deadline - T_received\n        uint256 remainingBlocks = deadlineBlock.sub(entryReceivedBlock);\n\n        // T_deadline - T_begin\n        uint256 submissionWindow = deadlineBlock.sub(submissionStartBlock);\n\n        // delay factor = [ T_remaining / (T_deadline - T_begin)]^2\n        //\n        // Since we add 16 decimal places to perform float division, we do:\n        // delay factor = [ T_temaining * decimals / (T_deadline - T_begin)]^2 / decimals =\n        //    = [T_remaining / (T_deadline - T_begin) ]^2 * decimals\n        delayFactor = ((remainingBlocks.mul(decimals).div(submissionWindow))**2).div(decimals);\n    }",
        "comments": [
            "",
            "    /// @notice Gets delay factor for rewards calculation.",
            "    /// @return Integer representing floating-point number with 16 decimals places.",
            "    "
        ],
        "comt": "\n    /// @notice Gets delay factor for rewards calculation.\n    /// @return Integer representing floating-point number with 16 decimals places.\n    ",
        "@notice": "Gets delay factor for rewards calculation.",
        "@return1": "Integer representing floating-point number with 16 decimals places.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "tryCapturingDelegationData",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "tokenGrant",
                "type": "TokenGrant"
            },
            {
                "name": "escrow",
                "type": "address"
            },
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "extraData",
                "type": "bytes memory"
            }
        ],
        "func": "function tryCapturingDelegationData(\n        Storage storage self,\n        TokenGrant tokenGrant,\n        address escrow,\n        address from,\n        address operator,\n        bytes memory extraData\n    ) public returns (bool, uint256) {\n        if (from == escrow) {\n            require(extraData.length == 92, \"Corrupted delegation data from escrow\");\n            uint256 grantId = extraData.toUint(60);\n            setGrantForOperator(self, operator, grantId);\n            return (true, grantId);\n        } else {\n            return tryCapturingGrantId(self, tokenGrant, operator);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Tries to capture delegation data if the pending delegation has",
            "    /// been created from a grant. There are only two possibilities and they",
            "    /// need to be handled differently: delegation comes from the TokenGrant",
            "    /// contract or delegation comes from TokenStakingEscrow. In those two cases",
            "    /// grant ID has to be captured in a different way.",
            "    /// @dev In case of a delegation from the escrow, it is expected that grant",
            "    /// ID is passed in extraData bytes array. When the delegation comes from",
            "    /// the TokenGrant contract, delegation data are obtained directly from that",
            "    /// contract using `tryCapturingGrantId` function.",
            "    /// @param tokenGrant KEEP token grant contract reference.",
            "    /// @param escrow TokenStakingEscrow contract address.",
            "    /// @param from The owner of the tokens who approved them to transfer.",
            "    /// @param operator The operator tokens are delegated to.",
            "    /// @param extraData Data for stake delegation, as passed to",
            "    /// `receiveApproval` of `TokenStaking`.",
            "    "
        ],
        "comt": "\n    /// @notice Tries to capture delegation data if the pending delegation has\n    /// been created from a grant. There are only two possibilities and they\n    /// need to be handled differently: delegation comes from the TokenGrant\n    /// contract or delegation comes from TokenStakingEscrow. In those two cases\n    /// grant ID has to be captured in a different way.\n    /// @dev In case of a delegation from the escrow, it is expected that grant\n    /// ID is passed in extraData bytes array. When the delegation comes from\n    /// the TokenGrant contract, delegation data are obtained directly from that\n    /// contract using `tryCapturingGrantId` function.\n    /// @param tokenGrant KEEP token grant contract reference.\n    /// @param escrow TokenStakingEscrow contract address.\n    /// @param from The owner of the tokens who approved them to transfer.\n    /// @param operator The operator tokens are delegated to.\n    /// @param extraData Data for stake delegation, as passed to\n    /// `receiveApproval` of `TokenStaking`.\n    ",
        "@notice": "Tries to capture delegation data if the pending delegation has /// been created from a grant. There are only two possibilities and they /// need to be handled differently: delegation comes from the TokenGrant /// contract or delegation comes from TokenStakingEscrow. In those two cases /// grant ID has to be captured in a different way.",
        "@dev": "In case of a delegation from the escrow, it is expected that grant /// ID is passed in extraData bytes array. When the delegation comes from /// the TokenGrant contract, delegation data are obtained directly from that /// contract using `tryCapturingGrantId` function.",
        "@param1": "tokenGrant KEEP token grant contract reference.",
        "@param2": "escrow TokenStakingEscrow contract address.",
        "@param3": "from The owner of the tokens who approved them to transfer.",
        "@param4": "operator The operator tokens are delegated to.",
        "@param5": "extraData Data for stake delegation, as passed to /// `receiveApproval` of `TokenStaking`.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "hasGrantDelegated",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function hasGrantDelegated(\n        Storage storage self,\n        address operator\n    ) public view returns (bool) {\n        return self._operatorToGrant[operator] != 0;\n    }",
        "comments": [
            "",
            "    /// @notice Returns true if the given operator operates on stake delegated",
            "    /// from a grant. false is returned otherwise.",
            "    /// @param operator The operator to which tokens from a grant are",
            "    /// potentially delegated to.",
            "    "
        ],
        "comt": "\n    /// @notice Returns true if the given operator operates on stake delegated\n    /// from a grant. false is returned otherwise.\n    /// @param operator The operator to which tokens from a grant are\n    /// potentially delegated to.\n    ",
        "@notice": "Returns true if the given operator operates on stake delegated /// from a grant. false is returned otherwise.",
        "@param1": "operator The operator to which tokens from a grant are /// potentially delegated to.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setGrantForOperator",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "grantId",
                "type": "uint256"
            }
        ],
        "func": "function setGrantForOperator(\n        Storage storage self,\n        address operator,\n        uint256 grantId\n    ) public {\n        self._operatorToGrant[operator] = grantId ^ GRANT_ID_FLAG;\n    }",
        "comments": [
            "",
            "    /// @notice Associates operator with the provided grant ID. It means that",
            "    /// the given operator delegates on stake from the grant with this ID.",
            "    /// @param operator The operator tokens are delegate to.",
            "    /// @param grantId Identifier of a grant from which the tokens are delegated",
            "    /// to.",
            "    "
        ],
        "comt": "\n    /// @notice Associates operator with the provided grant ID. It means that\n    /// the given operator delegates on stake from the grant with this ID.\n    /// @param operator The operator tokens are delegate to.\n    /// @param grantId Identifier of a grant from which the tokens are delegated\n    /// to.\n    ",
        "@notice": "Associates operator with the provided grant ID. It means that /// the given operator delegates on stake from the grant with this ID.",
        "@param1": "operator The operator tokens are delegate to.",
        "@param2": "grantId Identifier of a grant from which the tokens are delegated /// to.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getGrantForOperator",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function getGrantForOperator(\n        Storage storage self,\n        address operator\n    ) public view returns (uint256) {\n        uint256 grantId = self._operatorToGrant[operator];\n        require (grantId != 0, \"No grant for the operator\");\n        return grantId ^ GRANT_ID_FLAG;\n    }",
        "comments": [
            "",
            "    /// @notice Returns grant ID for the provided operator. If the operator",
            "    /// does not operate on stake delegated from a grant, function reverts.",
            "    /// @dev To avoid reverting in case the grant ID for the operator does not",
            "    /// exist, consider calling hasGrantDelegated before.",
            "    /// @param operator The operator tokens are delegate to.",
            "    "
        ],
        "comt": "\n    /// @notice Returns grant ID for the provided operator. If the operator\n    /// does not operate on stake delegated from a grant, function reverts.\n    /// @dev To avoid reverting in case the grant ID for the operator does not\n    /// exist, consider calling hasGrantDelegated before.\n    /// @param operator The operator tokens are delegate to.\n    ",
        "@notice": "Returns grant ID for the provided operator. If the operator /// does not operate on stake delegated from a grant, function reverts.",
        "@dev": "To avoid reverting in case the grant ID for the operator does not /// exist, consider calling hasGrantDelegated before.",
        "@param1": "operator The operator tokens are delegate to.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "canUndelegate",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "tokenGrant",
                "type": "TokenGrant"
            }
        ],
        "func": "function canUndelegate(\n        Storage storage self,\n        address operator,\n        TokenGrant tokenGrant\n    ) public returns (bool) {\n        // First of all, we need to see if the operator has grant delegated.\n        // If not, we don't need to bother about checking grantee or\n        // managed grantee and we just return false.\n        if (!hasGrantDelegated(self, operator)) {\n            return false;\n        }\n\n        uint256 grantId = getGrantForOperator(self, operator);\n        (,,,,uint256 revokedAt, address grantee) = tokenGrant.getGrant(grantId);\n\n        // Is msg.sender grantee of a standard grant?\n        if (msg.sender == grantee) {\n            return true;\n        }\n\n        // If not, we need to dig deeper and see if we are dealing with\n        // a grantee from a managed grant.\n        if ((msg.sender).isManagedGranteeForGrant(grantId, tokenGrant)) {\n            return true;\n        }\n\n        // There is only one possibility left - grant has been revoked and\n        // grant manager wants to take back delegated tokens.\n        if (revokedAt == 0) {\n            return false;\n        }\n        (address grantManager,,,,) = tokenGrant.getGrantUnlockingSchedule(grantId);\n        return msg.sender == grantManager;\n    }",
        "comments": [
            "",
            "    /// @notice Returns true if msg.sender is grantee eligible to trigger stake",
            "    /// undelegation for this operator. Function checks both standard grantee",
            "    /// and managed grantee case.",
            "    /// @param operator The operator tokens are delegated to.",
            "    /// @param tokenGrant KEEP token grant contract reference.",
            "    "
        ],
        "comt": "\n    /// @notice Returns true if msg.sender is grantee eligible to trigger stake\n    /// undelegation for this operator. Function checks both standard grantee\n    /// and managed grantee case.\n    /// @param operator The operator tokens are delegated to.\n    /// @param tokenGrant KEEP token grant contract reference.\n    ",
        "@notice": "Returns true if msg.sender is grantee eligible to trigger stake /// undelegation for this operator. Function checks both standard grantee /// and managed grantee case.",
        "@param1": "operator The operator tokens are delegated to.",
        "@param2": "tokenGrant KEEP token grant contract reference.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "authorizeStakingContract",
        "visibility": "public",
        "args": [
            {
                "name": "_stakingContract",
                "type": "address"
            }
        ],
        "func": "function authorizeStakingContract(address _stakingContract) public {\n        require(\n            _stakingContract != address(0x0),\n            \"Staking contract address can't be zero\"\n        );\n        stakingContracts[msg.sender][_stakingContract] = true;\n        emit StakingContractAuthorized(msg.sender, _stakingContract);\n    }",
        "comments": [
            "",
            "    /// @notice Used by grant manager to authorize staking contract with the given",
            "    /// address.",
            "    "
        ],
        "comt": "\n    /// @notice Used by grant manager to authorize staking contract with the given\n    /// address.\n    ",
        "@notice": "Used by grant manager to authorize staking contract with the given /// address.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "_owner",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }",
        "comments": [
            "",
            "    /// @notice Gets the amount of granted tokens to the specified address.",
            "    /// @param _owner The address to query the grants balance of.",
            "    /// @return An uint256 representing the grants balance owned by the passed address.",
            "    "
        ],
        "comt": "\n    /// @notice Gets the amount of granted tokens to the specified address.\n    /// @param _owner The address to query the grants balance of.\n    /// @return An uint256 representing the grants balance owned by the passed address.\n    ",
        "@notice": "Gets the amount of granted tokens to the specified address.",
        "@param1": "_owner The address to query the grants balance of.",
        "@return1": "An uint256 representing the grants balance owned by the passed address.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stakeBalanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "_address",
                "type": "address"
            }
        ],
        "func": "function stakeBalanceOf(address _address) public view returns (uint256 balance) {\n        for (uint i = 0; i < grantIndices[_address].length; i++) {\n            uint256 id = grantIndices[_address][i];\n            balance += grants[id].staked;\n        }\n        return balance;\n    }",
        "comments": [
            "",
            "    /// @notice Gets the stake balance of the specified address.",
            "    /// @param _address The address to query the balance of.",
            "    /// @return An uint256 representing the amount staked by the passed address.",
            "    "
        ],
        "comt": "\n    /// @notice Gets the stake balance of the specified address.\n    /// @param _address The address to query the balance of.\n    /// @return An uint256 representing the amount staked by the passed address.\n    ",
        "@notice": "Gets the stake balance of the specified address.",
        "@param1": "_address The address to query the balance of.",
        "@return1": "An uint256 representing the amount staked by the passed address.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getGrant",
        "visibility": "public",
        "args": [
            {
                "name": "_id",
                "type": "uint256"
            }
        ],
        "func": "function getGrant(uint256 _id) public view returns (\n        uint256 amount,\n        uint256 withdrawn,\n        uint256 staked,\n        uint256 revokedAmount,\n        uint256 revokedAt,\n        address grantee\n    ) {\n        return (\n            grants[_id].amount,\n            grants[_id].withdrawn,\n            grants[_id].staked,\n            grants[_id].revokedAmount,\n            grants[_id].revokedAt,\n            grants[_id].grantee\n        );\n    }",
        "comments": [
            "",
            "    /// @notice Gets grant by ID. Returns only basic grant data.",
            "    /// If you need unlocking schedule for the grant you must call `getGrantUnlockingSchedule()`",
            "    /// This is to avoid Ethereum `Stack too deep` issue described here:",
            "    /// https://forum.ethereum.org/discussion/2400/error-stack-too-deep-try-removing-local-variables",
            "    /// @param _id ID of the token grant.",
            "    /// @return amount The amount of tokens the grant provides.",
            "    /// @return withdrawn The amount of tokens that have already been withdrawn",
            "    ///                   from the grant.",
            "    /// @return staked The amount of tokens that have been staked from the grant.",
            "    /// @return revoked A boolean indicating whether the grant has been revoked,",
            "    ///                 which is to say that it is no longer unlocking.",
            "    /// @return grantee The grantee of grant.",
            "    "
        ],
        "comt": "\n    /// @notice Gets grant by ID. Returns only basic grant data.\n    /// If you need unlocking schedule for the grant you must call `getGrantUnlockingSchedule()`\n    /// This is to avoid Ethereum `Stack too deep` issue described here:\n    /// https://forum.ethereum.org/discussion/2400/error-stack-too-deep-try-removing-local-variables\n    /// @param _id ID of the token grant.\n    /// @return amount The amount of tokens the grant provides.\n    /// @return withdrawn The amount of tokens that have already been withdrawn\n    ///                   from the grant.\n    /// @return staked The amount of tokens that have been staked from the grant.\n    /// @return revoked A boolean indicating whether the grant has been revoked,\n    ///                 which is to say that it is no longer unlocking.\n    /// @return grantee The grantee of grant.\n    ",
        "@notice": "Gets grant by ID. Returns only basic grant data. /// If you need unlocking schedule for the grant you must call `getGrantUnlockingSchedule()` /// This is to avoid Ethereum `Stack too deep` issue described here: /// https://forum.ethereum.org/discussion/2400/error-stack-too-deep-try-removing-local-variables",
        "@param1": "_id ID of the token grant.",
        "@return1": "amount The amount of tokens the grant provides.",
        "@return2": "withdrawn The amount of tokens that have already been withdrawn /// from the grant.",
        "@return3": "staked The amount of tokens that have been staked from the grant.",
        "@return4": "revoked A boolean indicating whether the grant has been revoked, /// which is to say that it is no longer unlocking.",
        "@return5": "grantee The grantee of grant.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getGrantUnlockingSchedule",
        "visibility": "public",
        "args": [
            {
                "name": "_id",
                "type": "uint256"
            }
        ],
        "func": "function getGrantUnlockingSchedule(\n        uint256 _id\n    ) public view returns (\n        address grantManager,\n        uint256 duration,\n        uint256 start,\n        uint256 cliff,\n        address policy\n    ) {\n        return (\n            grants[_id].grantManager,\n            grants[_id].duration,\n            grants[_id].start,\n            grants[_id].cliff,\n            address(grants[_id].stakingPolicy)\n        );\n    }",
        "comments": [
            "",
            "    /// @notice Gets grant unlocking schedule by grant ID.",
            "    /// @param _id ID of the token grant.",
            "    /// @return grantManager The address designated as the manager of the grant,",
            "    ///                      which is the only address that can revoke this grant.",
            "    /// @return duration The duration, in seconds, during which the tokens will",
            "    ///                  unlocking linearly.",
            "    /// @return start The start time, as a timestamp comparing to `now`.",
            "    /// @return cliff The timestamp, before which none of the tokens in the grant",
            "    ///               will be unlocked, and after which a linear amount based on",
            "    ///               the time elapsed since the start will be unlocked.",
            "    /// @return policy The address of the grant's staking policy.",
            "    "
        ],
        "comt": "\n    /// @notice Gets grant unlocking schedule by grant ID.\n    /// @param _id ID of the token grant.\n    /// @return grantManager The address designated as the manager of the grant,\n    ///                      which is the only address that can revoke this grant.\n    /// @return duration The duration, in seconds, during which the tokens will\n    ///                  unlocking linearly.\n    /// @return start The start time, as a timestamp comparing to `now`.\n    /// @return cliff The timestamp, before which none of the tokens in the grant\n    ///               will be unlocked, and after which a linear amount based on\n    ///               the time elapsed since the start will be unlocked.\n    /// @return policy The address of the grant's staking policy.\n    ",
        "@notice": "Gets grant unlocking schedule by grant ID.",
        "@param1": "_id ID of the token grant.",
        "@return1": "grantManager The address designated as the manager of the grant, /// which is the only address that can revoke this grant.",
        "@return2": "duration The duration, in seconds, during which the tokens will /// unlocking linearly.",
        "@return3": "start The start time, as a timestamp comparing to `now`.",
        "@return4": "cliff The timestamp, before which none of the tokens in the grant /// will be unlocked, and after which a linear amount based on /// the time elapsed since the start will be unlocked.",
        "@return5": "policy The address of the grant's staking policy.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getGrants",
        "visibility": "public",
        "args": [
            {
                "name": "_granteeOrGrantManager",
                "type": "address"
            }
        ],
        "func": "function getGrants(address _granteeOrGrantManager) public view returns (uint256[] memory) {\n        return grantIndices[_granteeOrGrantManager];\n    }",
        "comments": [
            "",
            "    /// @notice Gets grant ids of the specified address.",
            "    /// @param _granteeOrGrantManager The address to query.",
            "    /// @return An uint256 array of grant IDs.",
            "    "
        ],
        "comt": "\n    /// @notice Gets grant ids of the specified address.\n    /// @param _granteeOrGrantManager The address to query.\n    /// @return An uint256 array of grant IDs.\n    ",
        "@notice": "Gets grant ids of the specified address.",
        "@param1": "_granteeOrGrantManager The address to query.",
        "@return1": "An uint256 array of grant IDs.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getGranteeOperators",
        "visibility": "public",
        "args": [
            {
                "name": "grantee",
                "type": "address"
            }
        ],
        "func": "function getGranteeOperators(address grantee) public view returns (address[] memory) {\n        return granteesToOperators[grantee];\n    }",
        "comments": [
            "",
            "    /// @notice Gets operator addresses of the specified grantee address.",
            "    /// @param grantee The grantee address.",
            "    /// @return An array of all operators for a given grantee.",
            "    "
        ],
        "comt": "\n    /// @notice Gets operator addresses of the specified grantee address.\n    /// @param grantee The grantee address.\n    /// @return An array of all operators for a given grantee.\n    ",
        "@notice": "Gets operator addresses of the specified grantee address.",
        "@param1": "grantee The grantee address.",
        "@return1": "An array of all operators for a given grantee.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getGrantStakeDetails",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function getGrantStakeDetails(address operator) public view returns (uint256 grantId, uint256 amount, address stakingContract) {\n        return grantStakes[operator].getDetails();\n    }",
        "comments": [
            "",
            "    /// @notice Gets grant stake details of the given operator.",
            "    /// @param operator The operator address.",
            "    /// @return grantId ID of the token grant.",
            "    /// @return amount The amount of tokens the given operator delegated.",
            "    /// @return stakingContract The address of staking contract.",
            "    "
        ],
        "comt": "\n    /// @notice Gets grant stake details of the given operator.\n    /// @param operator The operator address.\n    /// @return grantId ID of the token grant.\n    /// @return amount The amount of tokens the given operator delegated.\n    /// @return stakingContract The address of staking contract.\n    ",
        "@notice": "Gets grant stake details of the given operator.",
        "@param1": "operator The operator address.",
        "@return1": "grantId ID of the token grant.",
        "@return2": "amount The amount of tokens the given operator delegated.",
        "@return3": "stakingContract The address of staking contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "receiveApproval",
        "visibility": "public",
        "args": [
            {
                "name": "_from",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            },
            {
                "name": "_token",
                "type": "address"
            },
            {
                "name": "_extraData",
                "type": "bytes memory"
            }
        ],
        "func": "function receiveApproval(address _from, uint256 _amount, address _token, bytes memory _extraData) public {\n        require(ERC20Burnable(_token) == token, \"Token contract must be the same one linked to this contract.\");\n        require(_amount <= token.balanceOf(_from), \"Sender must have enough amount.\");\n        (address _grantManager,\n         address _grantee,\n         uint256 _duration,\n         uint256 _start,\n         uint256 _cliffDuration,\n         bool _revocable,\n         address _stakingPolicy) = abi.decode(\n             _extraData,\n             (address, address, uint256, uint256, uint256, bool, address)\n        );\n\n        require(_grantee != address(0), \"Grantee address can't be zero.\");\n        require(\n            _cliffDuration <= _duration,\n            \"Unlocking cliff duration must be less or equal total unlocking duration.\"\n        );\n\n        require(_stakingPolicy != address(0), \"Staking policy can't be zero.\");\n\n        uint256 id = numGrants++;\n        grants[id] = Grant(\n            _grantManager,\n            _grantee,\n            0, 0, 0,\n            _revocable,\n            _amount,\n            _duration,\n            _start,\n            _start.add(_cliffDuration),\n            0, 0,\n            GrantStakingPolicy(_stakingPolicy)\n        );\n\n        // Maintain a record to make it easier to query grants by grant manager.\n        grantIndices[_from].push(id);\n\n        // Maintain a record to make it easier to query grants by grantee.\n        grantIndices[_grantee].push(id);\n\n        token.safeTransferFrom(_from, address(this), _amount);\n\n        // Maintain a record of the unlocked amount\n        balances[_grantee] = balances[_grantee].add(_amount);\n        emit TokenGrantCreated(id);\n    }",
        "comments": [
            "    ///               no tokens will be unlocked until the time `start + cliff`.",
            "    /// revocable (bool) Whether the token grant is revocable or not (1 or 0).",
            "    /// stakingPolicy (address) Address of the staking policy for the grant.",
            "    "
        ],
        "comt": "    ///               no tokens will be unlocked until the time `start + cliff`.\n    /// revocable (bool) Whether the token grant is revocable or not (1 or 0).\n    /// stakingPolicy (address) Address of the staking policy for the grant.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "_id",
                "type": "uint256"
            }
        ],
        "func": "function withdraw(uint256 _id) public {\n        uint256 amount = withdrawable(_id);\n        require(amount > 0, \"Grant available to withdraw amount should be greater than zero.\");\n\n        // Update withdrawn amount.\n        grants[_id].withdrawn = grants[_id].withdrawn.add(amount);\n\n        // Update grantee grants balance.\n        balances[grants[_id].grantee] = balances[grants[_id].grantee].sub(amount);\n\n        // Transfer tokens from this contract balance to the grantee token balance.\n        token.safeTransfer(grants[_id].grantee, amount);\n\n        emit TokenGrantWithdrawn(_id, amount);\n    }",
        "comments": [
            "",
            "    /// @notice Withdraws Token grant amount to grantee.",
            "    /// @dev Transfers unlocked tokens of the token grant to grantee.",
            "    /// @param _id Grant ID.",
            "    "
        ],
        "comt": "\n    /// @notice Withdraws Token grant amount to grantee.\n    /// @dev Transfers unlocked tokens of the token grant to grantee.\n    /// @param _id Grant ID.\n    ",
        "@notice": "Withdraws Token grant amount to grantee.",
        "@dev": "Transfers unlocked tokens of the token grant to grantee.",
        "@param1": "_id Grant ID.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unlockedAmount",
        "visibility": "public",
        "args": [
            {
                "name": "_id",
                "type": "uint256"
            }
        ],
        "func": "function unlockedAmount(uint256 _id) public view returns (uint256) {\n        Grant storage grant = grants[_id];\n        return (grant.revokedAt != 0)\n            // Grant revoked -> return what is remaining\n            ? grant.amount.sub(grant.revokedAmount)\n            // Not revoked -> calculate the unlocked amount normally\n            : now.getUnlockedAmount(\n                grant.amount,\n                grant.duration,\n                grant.start,\n                grant.cliff\n            );\n    }",
        "comments": [
            "",
            "    /// @notice Calculates and returns unlocked grant amount.",
            "    /// @dev Calculates token grant amount that has already unlocked,",
            "    /// including any tokens that have already been withdrawn by the grantee as well",
            "    /// as any tokens that are available to withdraw but have not yet been withdrawn.",
            "    /// @param _id Grant ID.",
            "    "
        ],
        "comt": "\n    /// @notice Calculates and returns unlocked grant amount.\n    /// @dev Calculates token grant amount that has already unlocked,\n    /// including any tokens that have already been withdrawn by the grantee as well\n    /// as any tokens that are available to withdraw but have not yet been withdrawn.\n    /// @param _id Grant ID.\n    ",
        "@notice": "Calculates and returns unlocked grant amount.",
        "@dev": "Calculates token grant amount that has already unlocked, /// including any tokens that have already been withdrawn by the grantee as well /// as any tokens that are available to withdraw but have not yet been withdrawn.",
        "@param1": "_id Grant ID.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawable",
        "visibility": "public",
        "args": [
            {
                "name": "_id",
                "type": "uint256"
            }
        ],
        "func": "function withdrawable(uint256 _id) public view returns (uint256) {\n        uint256 unlocked = unlockedAmount(_id);\n        uint256 withdrawn = grants[_id].withdrawn;\n        uint256 staked = grants[_id].staked;\n\n        if (withdrawn.add(staked) >= unlocked) {\n            return 0;\n        } else {\n            return unlocked.sub(withdrawn).sub(staked);\n        }\n    }",
        "comments": [
            "",
            "    /// @notice Calculates withdrawable granted amount.",
            "    /// @dev Calculates the amount that has already unlocked but hasn't been withdrawn yet.",
            "    /// @param _id Grant ID.",
            "    "
        ],
        "comt": "\n    /// @notice Calculates withdrawable granted amount.\n    /// @dev Calculates the amount that has already unlocked but hasn't been withdrawn yet.\n    /// @param _id Grant ID.\n    ",
        "@notice": "Calculates withdrawable granted amount.",
        "@dev": "Calculates the amount that has already unlocked but hasn't been withdrawn yet.",
        "@param1": "_id Grant ID.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "revoke",
        "visibility": "public",
        "args": [
            {
                "name": "_id",
                "type": "uint256"
            }
        ],
        "func": "function revoke(uint256 _id) public {\n        require(grants[_id].grantManager == msg.sender, \"Only grant manager can revoke.\");\n        require(grants[_id].revocable, \"Grant must be revocable in the first place.\");\n        require(grants[_id].revokedAt == 0, \"Grant must not be already revoked.\");\n\n        uint256 unlockedAmount = unlockedAmount(_id);\n        uint256 revokedAmount = grants[_id].amount.sub(unlockedAmount);\n        grants[_id].revokedAt = now;\n        grants[_id].revokedAmount = revokedAmount;\n\n        // Update grantee's grants balance.\n        balances[grants[_id].grantee] = balances[grants[_id].grantee].sub(revokedAmount);\n        emit TokenGrantRevoked(_id);\n    }",
        "comments": [
            "",
            "    /// @notice Allows the grant manager to revoke the grant.",
            "    /// @dev Granted tokens that are already unlocked (releasable amount)",
            "    /// remain in the grant so grantee can still withdraw them",
            "    /// the rest are revoked and withdrawable by token grant manager.",
            "    /// @param _id Grant ID.",
            "    "
        ],
        "comt": "\n    /// @notice Allows the grant manager to revoke the grant.\n    /// @dev Granted tokens that are already unlocked (releasable amount)\n    /// remain in the grant so grantee can still withdraw them\n    /// the rest are revoked and withdrawable by token grant manager.\n    /// @param _id Grant ID.\n    ",
        "@notice": "Allows the grant manager to revoke the grant.",
        "@dev": "Granted tokens that are already unlocked (releasable amount) /// remain in the grant so grantee can still withdraw them /// the rest are revoked and withdrawable by token grant manager.",
        "@param1": "_id Grant ID.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawRevoked",
        "visibility": "public",
        "args": [
            {
                "name": "_id",
                "type": "uint256"
            }
        ],
        "func": "function withdrawRevoked(uint256 _id) public {\n        Grant storage grant = grants[_id];\n        require(\n            grant.grantManager == msg.sender,\n            \"Only grant manager can withdraw revoked tokens.\"\n        );\n        uint256 revoked = grant.revokedAmount;\n        uint256 revokedWithdrawn = grant.revokedWithdrawn;\n        require(revokedWithdrawn < revoked, \"All revoked tokens withdrawn.\");\n\n        uint256 revokedRemaining = revoked.sub(revokedWithdrawn);\n\n        uint256 totalAmount = grant.amount;\n        uint256 staked = grant.staked;\n        uint256 granteeWithdrawn = grant.withdrawn;\n        uint256 remainingPresentInGrant =\n            totalAmount.sub(staked).sub(revokedWithdrawn).sub(granteeWithdrawn);\n\n        require(remainingPresentInGrant > 0, \"No revoked tokens withdrawable.\");\n\n        uint256 amountToWithdraw = remainingPresentInGrant < revokedRemaining\n            ? remainingPresentInGrant\n            : revokedRemaining;\n        token.safeTransfer(msg.sender, amountToWithdraw);\n        grant.revokedWithdrawn += amountToWithdraw;\n    }",
        "comments": [
            "",
            "    /// @notice Allows the grant manager to withdraw revoked tokens.",
            "    /// @dev Will withdraw as many of the revoked tokens as possible",
            "    /// without pushing the grant contract into a token deficit.",
            "    /// If the grantee has staked more tokens than the unlocked amount,",
            "    /// those tokens will remain in the grant until undelegated and returned,",
            "    /// after which they can be withdrawn by calling `withdrawRevoked` again.",
            "    /// @param _id Grant ID.",
            "    "
        ],
        "comt": "\n    /// @notice Allows the grant manager to withdraw revoked tokens.\n    /// @dev Will withdraw as many of the revoked tokens as possible\n    /// without pushing the grant contract into a token deficit.\n    /// If the grantee has staked more tokens than the unlocked amount,\n    /// those tokens will remain in the grant until undelegated and returned,\n    /// after which they can be withdrawn by calling `withdrawRevoked` again.\n    /// @param _id Grant ID.\n    ",
        "@notice": "Allows the grant manager to withdraw revoked tokens.",
        "@dev": "Will withdraw as many of the revoked tokens as possible /// without pushing the grant contract into a token deficit. /// If the grantee has staked more tokens than the unlocked amount, /// those tokens will remain in the grant until undelegated and returned, /// after which they can be withdrawn by calling `withdrawRevoked` again.",
        "@param1": "_id Grant ID.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stake",
        "visibility": "public",
        "args": [
            {
                "name": "_id",
                "type": "uint256"
            },
            {
                "name": "_stakingContract",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            },
            {
                "name": "_extraData",
                "type": "bytes memory"
            }
        ],
        "func": "function stake(uint256 _id, address _stakingContract, uint256 _amount, bytes memory _extraData) public {\n        require(grants[_id].grantee == msg.sender, \"Only grantee of the grant can stake it.\");\n        require(grants[_id].revokedAt == 0, \"Revoked grant can not be staked\");\n        require(\n            stakingContracts[grants[_id].grantManager][_stakingContract],\n            \"Provided staking contract is not authorized.\"\n        );\n\n        // Expecting 60 bytes _extraData for stake delegation.\n        require(_extraData.length == 60, \"Stake delegation data must be provided.\");\n        address operator = _extraData.toAddress(20);\n\n        // Calculate available amount. Amount of unlocked tokens minus what user already withdrawn and staked.\n        require(_amount <= availableToStake(_id), \"Must have available granted amount to stake.\");\n\n        // Keep staking record.\n        TokenGrantStake grantStake = new TokenGrantStake(\n            address(token),\n            _id,\n            _stakingContract\n        );\n        grantStakes[operator] = grantStake;\n        granteesToOperators[grants[_id].grantee].push(operator);\n        grants[_id].staked += _amount;\n\n        token.transfer(address(grantStake), _amount);\n\n        // Staking contract expects 40 bytes _extraData for stake delegation.\n        // 20 bytes beneficiary's address + 20 bytes operator's address.\n        grantStake.stake(_amount, _extraData);\n        emit TokenGrantStaked(_id, _amount, operator);\n    }",
        "comments": [
            "",
            "    /// @notice Stake token grant.",
            "    /// @dev Stakable token grant amount is determined",
            "    /// by the grant's staking policy.",
            "    /// @param _id Grant Id.",
            "    /// @param _stakingContract Address of the staking contract.",
            "    /// @param _amount Amount to stake.",
            "    /// @param _extraData Data for stake delegation. This byte array must have",
            "    /// the following values concatenated:",
            "    /// - Beneficiary address (20 bytes)",
            "    /// - Operator address (20 bytes)",
            "    /// - Authorizer address (20 bytes)",
            "    "
        ],
        "comt": "\n    /// @notice Stake token grant.\n    /// @dev Stakable token grant amount is determined\n    /// by the grant's staking policy.\n    /// @param _id Grant Id.\n    /// @param _stakingContract Address of the staking contract.\n    /// @param _amount Amount to stake.\n    /// @param _extraData Data for stake delegation. This byte array must have\n    /// the following values concatenated:\n    /// - Beneficiary address (20 bytes)\n    /// - Operator address (20 bytes)\n    /// - Authorizer address (20 bytes)\n    ",
        "@notice": "Stake token grant.",
        "@dev": "Stakable token grant amount is determined /// by the grant's staking policy.",
        "@param1": "_id Grant Id.",
        "@param2": "_stakingContract Address of the staking contract.",
        "@param3": "_amount Amount to stake.",
        "@param4": "_extraData Data for stake delegation. This byte array must have /// the following values concatenated: /// - Beneficiary address (20 bytes) /// - Operator address (20 bytes) /// - Authorizer address (20 bytes)",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "availableToStake",
        "visibility": "public",
        "args": [
            {
                "name": "_grantId",
                "type": "uint256"
            }
        ],
        "func": "function availableToStake(uint256 _grantId) public view returns (uint256) {\n        Grant storage grant = grants[_grantId];\n        // Revoked grants cannot be staked.\n        // If the grant isn't revoked, the number of revoked tokens is 0.\n        if (grant.revokedAt != 0) { return 0; }\n        uint256 amount = grant.amount;\n        uint256 withdrawn = grant.withdrawn;\n        uint256 remaining = amount.sub(withdrawn);\n        uint256 stakeable = grant.stakingPolicy.getStakeableAmount(\n            now,\n            amount,\n            grant.duration,\n            grant.start,\n            grant.cliff,\n            withdrawn\n        );\n        // Clamp the stakeable amount to what is left in the grant\n        // in the case of a malfunctioning staking policy.\n        if (stakeable > remaining) {\n            stakeable = remaining;\n        }\n\n        return stakeable.sub(grant.staked);\n    }",
        "comments": [
            "",
            "    ///  @notice Returns the amount of tokens available for staking from the grant.",
            "    /// The stakeable amount is determined by the staking policy of the grant.",
            "    /// If the grantee has withdrawn some tokens",
            "    /// or the policy returns an erroneously high value,",
            "    /// the stakeable amount is limited to the number of tokens remaining.",
            "    /// @param _grantId Identifier of the grant",
            "    "
        ],
        "comt": "\n    ///  @notice Returns the amount of tokens available for staking from the grant.\n    /// The stakeable amount is determined by the staking policy of the grant.\n    /// If the grantee has withdrawn some tokens\n    /// or the policy returns an erroneously high value,\n    /// the stakeable amount is limited to the number of tokens remaining.\n    /// @param _grantId Identifier of the grant\n    ",
        "@notice": "Returns the amount of tokens available for staking from the grant. /// The stakeable amount is determined by the staking policy of the grant. /// If the grantee has withdrawn some tokens /// or the policy returns an erroneously high value, /// the stakeable amount is limited to the number of tokens remaining.",
        "@param1": "_grantId Identifier of the grant",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "cancelStake",
        "visibility": "public",
        "args": [
            {
                "name": "_operator",
                "type": "address"
            }
        ],
        "func": "function cancelStake(address _operator) public {\n        TokenGrantStake grantStake = grantStakes[_operator];\n        uint256 grantId = grantStake.getGrantId();\n        require(\n            msg.sender == _operator || msg.sender == grants[grantId].grantee,\n            \"Only operator or grantee can cancel the delegation.\"\n        );\n\n        uint256 returned = grantStake.cancelStake();\n        grants[grantId].staked = grants[grantId].staked.sub(returned);\n    }",
        "comments": [
            "",
            "    /// @notice Cancels delegation within the operator initialization period",
            "    /// without being subjected to the stake lockup for the undelegation period.",
            "    /// This can be used to undo mistaken delegation to the wrong operator address.",
            "    /// @param _operator Address of the stake operator.",
            "    "
        ],
        "comt": "\n    /// @notice Cancels delegation within the operator initialization period\n    /// without being subjected to the stake lockup for the undelegation period.\n    /// This can be used to undo mistaken delegation to the wrong operator address.\n    /// @param _operator Address of the stake operator.\n    ",
        "@notice": "Cancels delegation within the operator initialization period /// without being subjected to the stake lockup for the undelegation period. /// This can be used to undo mistaken delegation to the wrong operator address.",
        "@param1": "_operator Address of the stake operator.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "undelegate",
        "visibility": "public",
        "args": [
            {
                "name": "_operator",
                "type": "address"
            }
        ],
        "func": "function undelegate(address _operator) public {\n        TokenGrantStake grantStake = grantStakes[_operator];\n        uint256 grantId = grantStake.getGrantId();\n        require(\n            msg.sender == _operator || msg.sender == grants[grantId].grantee,\n            \"Only operator or grantee can undelegate.\"\n        );\n\n        grantStake.undelegate();\n    }",
        "comments": [
            "",
            "    /// @notice Undelegate the token grant.",
            "    /// @param _operator Operator of the stake.",
            "    "
        ],
        "comt": "\n    /// @notice Undelegate the token grant.\n    /// @param _operator Operator of the stake.\n    ",
        "@notice": "Undelegate the token grant.",
        "@param1": "_operator Operator of the stake.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cancelRevokedStake",
        "visibility": "public",
        "args": [
            {
                "name": "_operator",
                "type": "address"
            }
        ],
        "func": "function cancelRevokedStake(address _operator) public {\n        TokenGrantStake grantStake = grantStakes[_operator];\n        uint256 grantId = grantStake.getGrantId();\n        require(\n            grants[grantId].revokedAt != 0,\n            \"Grant must be revoked\"\n        );\n        require(\n            msg.sender == grants[grantId].grantManager,\n            \"Only grant manager can force cancellation of revoked grant stake.\"\n        );\n\n        uint256 returned = grantStake.cancelStake();\n        grants[grantId].staked = grants[grantId].staked.sub(returned);\n    }",
        "comments": [
            "",
            "    /// @notice Force cancellation of a revoked grant's stake.",
            "    /// Can be used by the grant manager",
            "    /// to immediately withdraw tokens back into the grant,",
            "    /// from an operator still within the initialization period.",
            "    /// These tokens can then be withdrawn",
            "    /// if some revoked tokens haven't been withdrawn yet.",
            "    "
        ],
        "comt": "\n    /// @notice Force cancellation of a revoked grant's stake.\n    /// Can be used by the grant manager\n    /// to immediately withdraw tokens back into the grant,\n    /// from an operator still within the initialization period.\n    /// These tokens can then be withdrawn\n    /// if some revoked tokens haven't been withdrawn yet.\n    ",
        "@notice": "Force cancellation of a revoked grant's stake. /// Can be used by the grant manager /// to immediately withdraw tokens back into the grant, /// from an operator still within the initialization period. /// These tokens can then be withdrawn /// if some revoked tokens haven't been withdrawn yet.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "undelegateRevoked",
        "visibility": "public",
        "args": [
            {
                "name": "_operator",
                "type": "address"
            }
        ],
        "func": "function undelegateRevoked(address _operator) public {\n        TokenGrantStake grantStake = grantStakes[_operator];\n        uint256 grantId = grantStake.getGrantId();\n        require(\n            grants[grantId].revokedAt != 0,\n            \"Grant must be revoked\"\n        );\n        require(\n            msg.sender == grants[grantId].grantManager,\n            \"Only grant manager can force undelegation of revoked grant stake\"\n        );\n\n        grantStake.undelegate();\n    }",
        "comments": [
            "",
            "    /// @notice Force undelegation of a revoked grant's stake.",
            "    /// @dev Can be called by the grant manager once the grant is revoked.",
            "    /// Has to be done this way, instead of undelegating all operators when the",
            "    /// grant is revoked, because the latter method is vulnerable to DoS via",
            "    /// out-of-gas.",
            "    "
        ],
        "comt": "\n    /// @notice Force undelegation of a revoked grant's stake.\n    /// @dev Can be called by the grant manager once the grant is revoked.\n    /// Has to be done this way, instead of undelegating all operators when the\n    /// grant is revoked, because the latter method is vulnerable to DoS via\n    /// out-of-gas.\n    ",
        "@notice": "Force undelegation of a revoked grant's stake.",
        "@dev": "Can be called by the grant manager once the grant is revoked. /// Has to be done this way, instead of undelegating all operators when the /// grant is revoked, because the latter method is vulnerable to DoS via /// out-of-gas.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "recoverStake",
        "visibility": "public",
        "args": [
            {
                "name": "_operator",
                "type": "address"
            }
        ],
        "func": "function recoverStake(address _operator) public {\n        TokenGrantStake grantStake = grantStakes[_operator];\n        uint256 returned = grantStake.recoverStake();\n        uint256 grantId = grantStake.getGrantId();\n        grants[grantId].staked = grants[grantId].staked.sub(returned);\n\n        delete grantStakes[_operator];\n    }",
        "comments": [
            "",
            "    /// @notice Recover stake of the token grant.",
            "    /// Recovers the tokens correctly",
            "    /// even if they were earlier recovered directly in the staking contract.",
            "    /// @param _operator Operator of the stake.",
            "    "
        ],
        "comt": "\n    /// @notice Recover stake of the token grant.\n    /// Recovers the tokens correctly\n    /// even if they were earlier recovered directly in the staking contract.\n    /// @param _operator Operator of the stake.\n    ",
        "@notice": "Recover stake of the token grant. /// Recovers the tokens correctly /// even if they were earlier recovered directly in the staking contract.",
        "@param1": "_operator Operator of the stake.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sign",
        "visibility": "public",
        "args": [
            {
                "name": "message",
                "type": "bytes memory"
            },
            {
                "name": "secretKey",
                "type": "uint256"
            }
        ],
        "func": "function sign(bytes memory message, uint256 secretKey) public view returns(bytes memory) {\n        AltBn128.G1Point memory p_1 = AltBn128.g1HashToPoint(message);\n        AltBn128.G1Point memory p_2 = AltBn128.scalarMultiply(p_1, secretKey);\n\n        return AltBn128.g1Marshal(p_2);\n    }",
        "comments": [
            "/**",
            "     * @dev Creates a signature over message using the provided secret key.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Creates a signature over message using the provided secret key.\n     */\n",
        "@dev": "Creates a signature over message using the provided secret key.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "verify",
        "visibility": "public",
        "args": [
            {
                "name": "publicKey",
                "type": "bytes memory"
            },
            {
                "name": "message",
                "type": "bytes memory"
            },
            {
                "name": "signature",
                "type": "bytes memory"
            }
        ],
        "func": "function verify(\n        bytes memory publicKey,\n        bytes memory message,\n        bytes memory signature\n    ) public view returns (bool) {\n\n        AltBn128.G1Point memory _signature = AltBn128.g1Unmarshal(signature);\n\n        return AltBn128.pairing(\n            AltBn128.G1Point(_signature.x, AltBn128.getP() - _signature.y),\n            AltBn128.g2(),\n            AltBn128.g1Unmarshal(message),\n            AltBn128.g2Unmarshal(publicKey)\n        );\n    }",
        "comments": [
            "/**",
            "     * @dev Verify performs the pairing operation to check if the signature",
            "     * is correct for the provided message and the corresponding public key.",
            "     * Public key must be a valid point on G2 curve in an uncompressed format.",
            "     * Message must be a valid point on G1 curve in an uncompressed format.",
            "     * Signature must be a valid point on G1 curve in an uncompressed format.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Verify performs the pairing operation to check if the signature\n     * is correct for the provided message and the corresponding public key.\n     * Public key must be a valid point on G2 curve in an uncompressed format.\n     * Message must be a valid point on G1 curve in an uncompressed format.\n     * Signature must be a valid point on G1 curve in an uncompressed format.\n     */\n",
        "@dev": "Verify performs the pairing operation to check if the signature * is correct for the provided message and the corresponding public key. * Public key must be a valid point on G2 curve in an uncompressed format. * Message must be a valid point on G1 curve in an uncompressed format. * Signature must be a valid point on G1 curve in an uncompressed format.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "verifyBytes",
        "visibility": "public",
        "args": [
            {
                "name": "publicKey",
                "type": "bytes memory"
            },
            {
                "name": "message",
                "type": "bytes memory"
            },
            {
                "name": "signature",
                "type": "bytes memory"
            }
        ],
        "func": "function verifyBytes(\n        bytes memory publicKey,\n        bytes memory message,\n        bytes memory signature\n    ) public view returns (bool) {\n        AltBn128.G1Point memory point = AltBn128.g1HashToPoint(message);\n        bytes memory messageAsPoint = AltBn128.g1Marshal(point);\n\n        return verify(publicKey, messageAsPoint, signature);\n    }",
        "comments": [
            "/**",
            "     * @dev VerifyBytes wraps the functionality of BLS.verify, but hashes a message",
            "     * to a point on G1 and marshal to bytes first to allow raw bytes verificaion.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev VerifyBytes wraps the functionality of BLS.verify, but hashes a message\n     * to a point on G1 and marshal to bytes first to allow raw bytes verificaion.\n     */\n",
        "@dev": "VerifyBytes wraps the functionality of BLS.verify, but hashes a message * to a point on G1 and marshal to bytes first to allow raw bytes verificaion.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lockStake",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "duration",
                "type": "uint256"
            }
        ],
        "func": "function lockStake(\n        Storage storage self,\n        address operator,\n        uint256 duration\n    ) public {\n        require(duration <= maximumLockDuration, \"Lock duration too long\");\n        self.operatorLocks[operator].setLock(\n            msg.sender,\n            uint96(block.timestamp.add(duration))\n        );\n        emit StakeLocked(operator, msg.sender, block.timestamp.add(duration));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "releaseLock",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function releaseLock(\n        Storage storage self,\n        address operator\n    ) public {\n        self.operatorLocks[operator].releaseLock(msg.sender);\n        emit LockReleased(operator, msg.sender);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "releaseExpiredLock",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "operatorContract",
                "type": "address"
            },
            {
                "name": "authorityVerifier",
                "type": "address"
            }
        ],
        "func": "function releaseExpiredLock(\n        Storage storage self,\n        address operator,\n        address operatorContract,\n        address authorityVerifier\n    ) public {\n        LockUtils.LockSet storage locks = self.operatorLocks[operator];\n\n        require(\n            locks.contains(operatorContract),\n            \"No matching lock present\"\n        );\n\n        bool expired = block.timestamp >= locks.getLockTime(operatorContract);\n        bool disabled = !AuthorityVerifier(authorityVerifier)\n            .isApprovedOperatorContract(operatorContract);\n\n        require(\n            expired || disabled,\n            \"Lock still active and valid\"\n        );\n\n        locks.releaseLock(operatorContract);\n\n        emit ExpiredLockReleased(operator, operatorContract);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isStakeLocked",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "authorityVerifier",
                "type": "address"
            }
        ],
        "func": "function isStakeLocked(\n        Storage storage self,\n        address operator,\n        address authorityVerifier\n    ) public view returns (bool) {\n        LockUtils.Lock[] storage _locks = self.operatorLocks[operator].locks;\n        LockUtils.Lock memory lock;\n        for (uint i = 0; i < _locks.length; i++) {\n            lock = _locks[i];\n            if (block.timestamp < lock.expiresAt) {\n                if (\n                    AuthorityVerifier(authorityVerifier)\n                        .isApprovedOperatorContract(lock.creator)\n                ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }",
        "comments": [
            "",
            "    /// @dev AuthorityVerifier is a trusted implementation and not a third-party,",
            "    /// external contract. AuthorityVerifier never reverts on the check and",
            "    /// has a reasonable gas consumption.",
            "    "
        ],
        "comt": "\n    /// @dev AuthorityVerifier is a trusted implementation and not a third-party,\n    /// external contract. AuthorityVerifier never reverts on the check and\n    /// has a reasonable gas consumption.\n    ",
        "@dev": "AuthorityVerifier is a trusted implementation and not a third-party, /// external contract. AuthorityVerifier never reverts on the check and /// has a reasonable gas consumption.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isStakeReleased",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "operatorContract",
                "type": "address"
            }
        ],
        "func": "function isStakeReleased(\n        Storage storage self,\n        address operator,\n        address operatorContract\n    ) public view returns (bool) {\n        LockUtils.LockSet storage locks = self.operatorLocks[operator];\n        // `getLockTime` returns 0 if the lock doesn't exist,\n        // thus we don't need to check for its presence separately.\n        return block.timestamp >= locks.getLockTime(operatorContract);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getLocks",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function getLocks(\n        Storage storage self,\n        address operator\n    ) public view returns (address[] memory creators, uint256[] memory expirations) {\n        uint256 lockCount = self.operatorLocks[operator].locks.length;\n        creators = new address[](lockCount);\n        expirations = new uint256[](lockCount);\n        LockUtils.Lock memory lock;\n        for (uint i = 0; i < lockCount; i++) {\n            lock = self.operatorLocks[operator].locks[i];\n            creators[i] = lock.creator;\n            expirations[i] = lock.expiresAt;\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "instantComplete",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "value",
                "type": "uint256"
            },
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "operatorParams",
                "type": "uint256"
            },
            {
                "name": "escrow",
                "type": "TokenStakingEscrow"
            }
        ],
        "func": "function instantComplete(\n        Storage storage self,\n        uint256 value,\n        address operator,\n        uint256 operatorParams,\n        TokenStakingEscrow escrow\n    ) public returns (uint256 newParams) {\n        // Stake is not yet initialized so we don't need to check if the\n        // operator is not undelegating - initializing and undelegating at the\n        // same time is not possible. We do however, need to check whether the\n        // operator has not canceled its previous stake for that operator,\n        // depositing the stake it in the escrow. We do not want to allow\n        // resurrecting operators with cancelled stake by top-ups.\n        require(\n            !escrow.hasDeposit(operator),\n            \"Stake for the operator already deposited in the escrow\"\n        );\n        require(value > 0, \"Top-up value must be greater than zero\");\n\n        uint256 newAmount = operatorParams.getAmount().add(value);\n        newParams = operatorParams.setAmountAndCreationTimestamp(\n            newAmount,\n            block.timestamp\n        );\n\n        emit TopUpCompleted(operator, newAmount);\n    }",
        "comments": [
            "",
            "    /// @notice Performs top-up in one step when stake is not yet initialized by",
            "    /// adding the top-up amount to the stake and resetting stake initialization",
            "    /// time counter.",
            "    /// @dev This function should be called only for not yet initialized stake.",
            "    /// @param value Top-up value, the number of tokens added to the stake.",
            "    /// @param operator Operator The operator with existing delegation to which",
            "    /// the tokens should be added to.",
            "    /// @param operatorParams Parameters of that operator, as stored in the",
            "    /// staking contract.",
            "    /// @param escrow Reference to TokenStakingEscrow contract.",
            "    /// @return New value of parameters. It should be updated for the operator",
            "    /// in the staking contract.",
            "    "
        ],
        "comt": "\n    /// @notice Performs top-up in one step when stake is not yet initialized by\n    /// adding the top-up amount to the stake and resetting stake initialization\n    /// time counter.\n    /// @dev This function should be called only for not yet initialized stake.\n    /// @param value Top-up value, the number of tokens added to the stake.\n    /// @param operator Operator The operator with existing delegation to which\n    /// the tokens should be added to.\n    /// @param operatorParams Parameters of that operator, as stored in the\n    /// staking contract.\n    /// @param escrow Reference to TokenStakingEscrow contract.\n    /// @return New value of parameters. It should be updated for the operator\n    /// in the staking contract.\n    ",
        "@notice": "Performs top-up in one step when stake is not yet initialized by /// adding the top-up amount to the stake and resetting stake initialization /// time counter.",
        "@dev": "This function should be called only for not yet initialized stake.",
        "@param1": "value Top-up value, the number of tokens added to the stake.",
        "@param2": "operator Operator The operator with existing delegation to which /// the tokens should be added to.",
        "@param3": "operatorParams Parameters of that operator, as stored in the /// staking contract.",
        "@param4": "escrow Reference to TokenStakingEscrow contract.",
        "@return1": "New value of parameters. It should be updated for the operator /// in the staking contract.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "initiate",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "value",
                "type": "uint256"
            },
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "operatorParams",
                "type": "uint256"
            },
            {
                "name": "escrow",
                "type": "TokenStakingEscrow"
            }
        ],
        "func": "function initiate(\n        Storage storage self,\n        uint256 value,\n        address operator,\n        uint256 operatorParams,\n        TokenStakingEscrow escrow\n    ) public {\n        // Stake is initialized, the operator is still active so we need\n        // to check if it's not undelegating.\n        require(!isUndelegating(operatorParams), \"Stake undelegated\");\n        // We also need to check if the stake for the operator is not already\n        // in the escrow because it's been previously cancelled.\n        require(\n            !escrow.hasDeposit(operator),\n            \"Stake for the operator already deposited in the escrow\"\n        );\n        require(value > 0, \"Top-up value must be greater than zero\");\n\n        TopUp memory awaiting = self.topUps[operator];\n        self.topUps[operator] = TopUp(awaiting.amount.add(value), now);\n        emit TopUpInitiated(operator, value);\n    }",
        "comments": [
            "",
            "    /// @notice Initiates top-up of the given value for tokens delegated to",
            "    /// the provided operator. If there is an existing top-up still",
            "    /// initializing, top-up values are summed up and initialization period",
            "    /// is set to the current block timestamp.",
            "    /// @dev This function should be called only for active operators with",
            "    /// initialized stake.",
            "    /// @param value Top-up value, the number of tokens added to the stake.",
            "    /// @param operator Operator The operator with existing delegation to which",
            "    /// the tokens should be added to.",
            "    /// @param operatorParams Parameters of that operator, as stored in the",
            "    /// staking contract.",
            "    /// @param escrow Reference to TokenStakingEscrow contract.",
            "    "
        ],
        "comt": "\n    /// @notice Initiates top-up of the given value for tokens delegated to\n    /// the provided operator. If there is an existing top-up still\n    /// initializing, top-up values are summed up and initialization period\n    /// is set to the current block timestamp.\n    /// @dev This function should be called only for active operators with\n    /// initialized stake.\n    /// @param value Top-up value, the number of tokens added to the stake.\n    /// @param operator Operator The operator with existing delegation to which\n    /// the tokens should be added to.\n    /// @param operatorParams Parameters of that operator, as stored in the\n    /// staking contract.\n    /// @param escrow Reference to TokenStakingEscrow contract.\n    ",
        "@notice": "Initiates top-up of the given value for tokens delegated to /// the provided operator. If there is an existing top-up still /// initializing, top-up values are summed up and initialization period /// is set to the current block timestamp.",
        "@dev": "This function should be called only for active operators with /// initialized stake.",
        "@param1": "value Top-up value, the number of tokens added to the stake.",
        "@param2": "operator Operator The operator with existing delegation to which /// the tokens should be added to.",
        "@param3": "operatorParams Parameters of that operator, as stored in the /// staking contract.",
        "@param4": "escrow Reference to TokenStakingEscrow contract.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "commit",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "operatorParams",
                "type": "uint256"
            },
            {
                "name": "initializationPeriod",
                "type": "uint256"
            }
        ],
        "func": "function commit(\n        Storage storage self,\n        address operator,\n        uint256 operatorParams,\n        uint256 initializationPeriod\n    ) public returns (uint256 newParams) {\n        TopUp memory topUp = self.topUps[operator];\n        require(topUp.amount > 0, \"No top up to commit\");\n        require(\n            now > topUp.createdAt.add(initializationPeriod),\n            \"Stake is initializing\"\n        );\n\n        uint256 newAmount = operatorParams.getAmount().add(topUp.amount);\n        newParams = operatorParams.setAmount(newAmount);\n\n        delete self.topUps[operator];\n        emit TopUpCompleted(operator, newAmount);\n    }",
        "comments": [
            "",
            "    /// @notice Commits the top-up if it passed the initialization period.",
            "    /// Tokens are added to the stake once the top-up is committed.",
            "    /// @param operator Operator The operator with a pending stake top-up.",
            "    /// @param initializationPeriod Stake initialization period.",
            "    "
        ],
        "comt": "\n    /// @notice Commits the top-up if it passed the initialization period.\n    /// Tokens are added to the stake once the top-up is committed.\n    /// @param operator Operator The operator with a pending stake top-up.\n    /// @param initializationPeriod Stake initialization period.\n    ",
        "@notice": "Commits the top-up if it passed the initialization period. /// Tokens are added to the stake once the top-up is committed.",
        "@param1": "operator Operator The operator with a pending stake top-up.",
        "@param2": "initializationPeriod Stake initialization period.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cancel",
        "visibility": "public",
        "args": [
            {
                "name": "self",
                "type": "Storage storage"
            },
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function cancel(\n        Storage storage self,\n        address operator\n    ) public returns (uint256) {\n        TopUp memory topUp = self.topUps[operator];\n        if (topUp.amount == 0) {\n            return 0;\n        }\n\n        delete self.topUps[operator];\n        return topUp.amount;\n    }",
        "comments": [
            "",
            "    /// @notice Cancels pending, initiating top-up. If there is no initiating",
            "    /// top-up for the operator, function does nothing. This function should be",
            "    /// used when the stake is recovered to return tokens from a pending,",
            "    /// initiating top-up.",
            "    /// @param operator Operator The operator from which the stake is recovered.",
            "    "
        ],
        "comt": "\n    /// @notice Cancels pending, initiating top-up. If there is no initiating\n    /// top-up for the operator, function does nothing. This function should be\n    /// used when the stake is recovered to return tokens from a pending,\n    /// initiating top-up.\n    /// @param operator Operator The operator from which the stake is recovered.\n    ",
        "@notice": "Cancels pending, initiating top-up. If there is no initiating /// top-up for the operator, function does nothing. This function should be /// used when the stake is recovered to return tokens from a pending, /// initiating top-up.",
        "@param1": "operator Operator The operator from which the stake is recovered.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "owner",
        "visibility": "public",
        "args": [],
        "func": "function owner() public view returns (address) {\n        return _owner;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the address of the current owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the address of the current owner.\n     */\n",
        "@dev": "Returns the address of the current owner.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isOwner",
        "visibility": "public",
        "args": [],
        "func": "function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns true if the caller is the current owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns true if the caller is the current owner.\n     */\n",
        "@dev": "Returns true if the caller is the current owner.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "renounceOwnership",
        "visibility": "public",
        "args": [],
        "func": "function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }",
        "comments": [
            "/**",
            "     * @dev Leaves the contract without owner. It will not be possible to call",
            "     * `onlyOwner` functions anymore. Can only be called by the current owner.",
            "     *",
            "     * NOTE: Renouncing ownership will leave the contract without an owner,",
            "     * thereby removing any functionality that is only available to the owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n",
        "@dev": "Leaves the contract without owner. It will not be possible to call * `onlyOwner` functions anymore. Can only be called by the current owner. * * NOTE: Renouncing ownership will leave the contract without an owner, * thereby removing any functionality that is only available to the owner.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferOwnership",
        "visibility": "public",
        "args": [
            {
                "name": "newOwner",
                "type": "address"
            }
        ],
        "func": "function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }",
        "comments": [
            "/**",
            "     * @dev Transfers ownership of the contract to a new account (`newOwner`).",
            "     * Can only be called by the current owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n",
        "@dev": "Transfers ownership of the contract to a new account (`newOwner`). * Can only be called by the current owner.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    }
]