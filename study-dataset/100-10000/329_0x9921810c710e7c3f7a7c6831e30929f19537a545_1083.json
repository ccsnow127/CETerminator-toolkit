[
    {
        "transactions": 1083,
        "function_num": 329
    },
    {
        "name": "foo",
        "visibility": "public",
        "args": [],
        "func": "function foo() public {\n *     require(hasRole(MY_ROLE, _msgSender()));\n *     ...\n * }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "hasRole",
        "visibility": "public",
        "args": [
            {
                "name": "role",
                "type": "bytes32"
            },
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }",
        "comments": [
            "/**",
            "     * @dev Returns `true` if `account` has been granted `role`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n",
        "@dev": "Returns `true` if `account` has been granted `role`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getRoleMemberCount",
        "visibility": "public",
        "args": [
            {
                "name": "role",
                "type": "bytes32"
            }
        ],
        "func": "function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the number of accounts that have `role`. Can be used",
            "     * together with {getRoleMember} to enumerate all bearers of a role.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n",
        "@dev": "Returns the number of accounts that have `role`. Can be used * together with {getRoleMember} to enumerate all bearers of a role.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getRoleMember",
        "visibility": "public",
        "args": [
            {
                "name": "role",
                "type": "bytes32"
            },
            {
                "name": "index",
                "type": "uint256"
            }
        ],
        "func": "function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }",
        "comments": [
            "/**",
            "     * @dev Returns one of the accounts that have `role`. `index` must be a",
            "     * value between 0 and {getRoleMemberCount}, non-inclusive.",
            "     *",
            "     * Role bearers are not sorted in any particular way, and their ordering may",
            "     * change at any point.",
            "     *",
            "     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure",
            "     * you perform all queries on the same block. See the following",
            "     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]",
            "     * for more information.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n",
        "@dev": "Returns one of the accounts that have `role`. `index` must be a * value between 0 and {getRoleMemberCount}, non-inclusive. * * Role bearers are not sorted in any particular way, and their ordering may * change at any point. * * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure * you perform all queries on the same block. See the following * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] * for more information.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getRoleAdmin",
        "visibility": "public",
        "args": [
            {
                "name": "role",
                "type": "bytes32"
            }
        ],
        "func": "function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the admin role that controls `role`. See {grantRole} and",
            "     * {revokeRole}.",
            "     *",
            "     * To change a role's admin, use {_setRoleAdmin}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n",
        "@dev": "Returns the admin role that controls `role`. See {grantRole} and * {revokeRole}. * * To change a role's admin, use {_setRoleAdmin}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "grantRole",
        "visibility": "public",
        "args": [
            {
                "name": "role",
                "type": "bytes32"
            },
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }",
        "comments": [
            "/**",
            "     * @dev Grants `role` to `account`.",
            "     *",
            "     * If `account` had not been already granted `role`, emits a {RoleGranted}",
            "     * event.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - the caller must have ``role``'s admin role.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n",
        "@dev": "Grants `role` to `account`. * * If `account` had not been already granted `role`, emits a {RoleGranted} * event. * * Requirements: * * - the caller must have ``role``'s admin role.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "revokeRole",
        "visibility": "public",
        "args": [
            {
                "name": "role",
                "type": "bytes32"
            },
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }",
        "comments": [
            "/**",
            "     * @dev Revokes `role` from `account`.",
            "     *",
            "     * If `account` had been granted `role`, emits a {RoleRevoked} event.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - the caller must have ``role``'s admin role.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n",
        "@dev": "Revokes `role` from `account`. * * If `account` had been granted `role`, emits a {RoleRevoked} event. * * Requirements: * * - the caller must have ``role``'s admin role.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "renounceRole",
        "visibility": "public",
        "args": [
            {
                "name": "role",
                "type": "bytes32"
            },
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }",
        "comments": [
            "/**",
            "     * @dev Revokes `role` from the calling account.",
            "     *",
            "     * Roles are often managed via {grantRole} and {revokeRole}: this function's",
            "     * purpose is to provide a mechanism for accounts to lose their privileges",
            "     * if they are compromised (such as when a trusted device is misplaced).",
            "     *",
            "     * If the calling account had been granted `role`, emits a {RoleRevoked}",
            "     * event.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - the caller must be `account`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n",
        "@dev": "Revokes `role` from the calling account. * * Roles are often managed via {grantRole} and {revokeRole}: this function's * purpose is to provide a mechanism for accounts to lose their privileges * if they are compromised (such as when a trusted device is misplaced). * * If the calling account had been granted `role`, emits a {RoleRevoked} * event. * * Requirements: * * - the caller must be `account`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addToWhitelist",
        "visibility": "external",
        "args": [
            {
                "name": "newElement",
                "type": "address"
            }
        ],
        "func": "function addToWhitelist(address newElement) external onlyOwner {\n        // Ignore if address is already included\n        if (whitelist[newElement] == Status.In) {\n            return;\n        }\n\n        // Only append new addresses to the array, never a duplicate\n        if (whitelist[newElement] == Status.None) {\n            whitelistIndices.push(newElement);\n        }\n\n        whitelist[newElement] = Status.In;\n\n        emit AddedToWhitelist(newElement);\n    }",
        "comments": [
            "/**",
            "     * @notice Adds an address to the whitelist.",
            "     * @param newElement the new address to add.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Adds an address to the whitelist.\n     * @param newElement the new address to add.\n     */\n",
        "@notice": "Adds an address to the whitelist.",
        "@param1": "newElement the new address to add.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeFromWhitelist",
        "visibility": "external",
        "args": [
            {
                "name": "elementToRemove",
                "type": "address"
            }
        ],
        "func": "function removeFromWhitelist(address elementToRemove) external onlyOwner {\n        if (whitelist[elementToRemove] != Status.Out) {\n            whitelist[elementToRemove] = Status.Out;\n            emit RemovedFromWhitelist(elementToRemove);\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Removes an address from the whitelist.",
            "     * @param elementToRemove the existing address to remove.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Removes an address from the whitelist.\n     * @param elementToRemove the existing address to remove.\n     */\n",
        "@notice": "Removes an address from the whitelist.",
        "@param1": "elementToRemove the existing address to remove.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isOnWhitelist",
        "visibility": "external",
        "args": [
            {
                "name": "elementToCheck",
                "type": "address"
            }
        ],
        "func": "function isOnWhitelist(address elementToCheck) external view returns (bool) {\n        return whitelist[elementToCheck] == Status.In;\n    }",
        "comments": [
            "/**",
            "     * @notice Checks whether an address is on the whitelist.",
            "     * @param elementToCheck the address to check.",
            "     * @return True if `elementToCheck` is on the whitelist, or False.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Checks whether an address is on the whitelist.\n     * @param elementToCheck the address to check.\n     * @return True if `elementToCheck` is on the whitelist, or False.\n     */\n",
        "@notice": "Checks whether an address is on the whitelist.",
        "@param1": "elementToCheck the address to check.",
        "@return1": "True if `elementToCheck` is on the whitelist, or False.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getWhitelist",
        "visibility": "external",
        "args": [],
        "func": "function getWhitelist() external view returns (address[] memory activeWhitelist) {\n        // Determine size of whitelist first\n        uint256 activeCount = 0;\n        for (uint256 i = 0; i < whitelistIndices.length; i++) {\n            if (whitelist[whitelistIndices[i]] == Status.In) {\n                activeCount++;\n            }\n        }\n\n        // Populate whitelist\n        activeWhitelist = new address[](activeCount);\n        activeCount = 0;\n        for (uint256 i = 0; i < whitelistIndices.length; i++) {\n            address addr = whitelistIndices[i];\n            if (whitelist[addr] == Status.In) {\n                activeWhitelist[activeCount] = addr;\n                activeCount++;\n            }\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Gets all addresses that are currently included in the whitelist.",
            "     * @dev Note: This method skips over, but still iterates through addresses. It is possible for this call to run out",
            "     * of gas if a large number of addresses have been removed. To reduce the likelihood of this unlikely scenario, we",
            "     * can modify the implementation so that when addresses are removed, the last addresses in the array is moved to",
            "     * the empty index.",
            "     * @return activeWhitelist the list of addresses on the whitelist.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets all addresses that are currently included in the whitelist.\n     * @dev Note: This method skips over, but still iterates through addresses. It is possible for this call to run out\n     * of gas if a large number of addresses have been removed. To reduce the likelihood of this unlikely scenario, we\n     * can modify the implementation so that when addresses are removed, the last addresses in the array is moved to\n     * the empty index.\n     * @return activeWhitelist the list of addresses on the whitelist.\n     */\n",
        "@notice": "Gets all addresses that are currently included in the whitelist.",
        "@dev": "Note: This method skips over, but still iterates through addresses. It is possible for this call to run out * of gas if a large number of addresses have been removed. To reduce the likelihood of this unlikely scenario, we * can modify the implementation so that when addresses are removed, the last addresses in the array is moved to * the empty index.",
        "@return1": "activeWhitelist the list of addresses on the whitelist.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "payee",
                "type": "address payable"
            }
        ],
        "func": "function withdraw(address payable payee) public virtual override {\n        require(withdrawalAllowed(payee), \"ConditionalEscrow: payee is not allowed to withdraw\");\n        super.withdraw(payee);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "commitVote",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            },
            {
                "name": "hash",
                "type": "bytes32"
            }
        ],
        "func": "function commitVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes32 hash\n    ) external onlyRoleHolder(uint256(Roles.Voter)) {\n        _getVotingAddress().commitVote(identifier, time, hash);\n    }",
        "comments": [
            "/**",
            "     * @notice Forwards a commit to Voting.",
            "     * @param identifier uniquely identifies the feed for this vote. EG BTC/USD price pair.",
            "     * @param time specifies the unix timestamp of the price being voted on.",
            "     * @param hash the keccak256 hash of the price you want to vote for and a random integer salt value.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Forwards a commit to Voting.\n     * @param identifier uniquely identifies the feed for this vote. EG BTC/USD price pair.\n     * @param time specifies the unix timestamp of the price being voted on.\n     * @param hash the keccak256 hash of the price you want to vote for and a random integer salt value.\n     */\n",
        "@notice": "Forwards a commit to Voting.",
        "@param1": "identifier uniquely identifies the feed for this vote. EG BTC/USD price pair.",
        "@param2": "time specifies the unix timestamp of the price being voted on.",
        "@param3": "hash the keccak256 hash of the price you want to vote for and a random integer salt value.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "batchCommit",
        "visibility": "external",
        "args": [
            {
                "name": "commits",
                "type": "VotingInterface.Commitment[] calldata"
            }
        ],
        "func": "function batchCommit(VotingInterface.Commitment[] calldata commits) external onlyRoleHolder(uint256(Roles.Voter)) {\n        _getVotingAddress().batchCommit(commits);\n    }",
        "comments": [
            "/**",
            "     * @notice Forwards a batch commit to Voting.",
            "     * @param commits struct to encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Forwards a batch commit to Voting.\n     * @param commits struct to encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.\n     */\n",
        "@notice": "Forwards a batch commit to Voting.",
        "@param1": "commits struct to encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "revealVote",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            },
            {
                "name": "price",
                "type": "int256"
            },
            {
                "name": "salt",
                "type": "int256"
            }
        ],
        "func": "function revealVote(\n        bytes32 identifier,\n        uint256 time,\n        int256 price,\n        int256 salt\n    ) external onlyRoleHolder(uint256(Roles.Voter)) {\n        _getVotingAddress().revealVote(identifier, time, price, salt);\n    }",
        "comments": [
            "/**",
            "     * @notice Forwards a reveal to Voting.",
            "     * @param identifier voted on in the commit phase. EG BTC/USD price pair.",
            "     * @param time specifies the unix timestamp of the price being voted on.",
            "     * @param price used along with the `salt` to produce the `hash` during the commit phase.",
            "     * @param salt used along with the `price` to produce the `hash` during the commit phase.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Forwards a reveal to Voting.\n     * @param identifier voted on in the commit phase. EG BTC/USD price pair.\n     * @param time specifies the unix timestamp of the price being voted on.\n     * @param price used along with the `salt` to produce the `hash` during the commit phase.\n     * @param salt used along with the `price` to produce the `hash` during the commit phase.\n     */\n",
        "@notice": "Forwards a reveal to Voting.",
        "@param1": "identifier voted on in the commit phase. EG BTC/USD price pair.",
        "@param2": "time specifies the unix timestamp of the price being voted on.",
        "@param3": "price used along with the `salt` to produce the `hash` during the commit phase.",
        "@param4": "salt used along with the `price` to produce the `hash` during the commit phase.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "batchReveal",
        "visibility": "external",
        "args": [
            {
                "name": "reveals",
                "type": "VotingInterface.Reveal[] calldata"
            }
        ],
        "func": "function batchReveal(VotingInterface.Reveal[] calldata reveals) external onlyRoleHolder(uint256(Roles.Voter)) {\n        _getVotingAddress().batchReveal(reveals);\n    }",
        "comments": [
            "/**",
            "     * @notice Forwards a batch reveal to Voting.",
            "     * @param reveals is an array of the Reveal struct which contains an identifier, time, price and salt.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Forwards a batch reveal to Voting.\n     * @param reveals is an array of the Reveal struct which contains an identifier, time, price and salt.\n     */\n",
        "@notice": "Forwards a batch reveal to Voting.",
        "@param1": "reveals is an array of the Reveal struct which contains an identifier, time, price and salt.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "retrieveRewards",
        "visibility": "public",
        "args": [
            {
                "name": "roundId",
                "type": "uint256"
            },
            {
                "name": "toRetrieve",
                "type": "VotingInterface.PendingRequest[] memory"
            }
        ],
        "func": "function retrieveRewards(uint256 roundId, VotingInterface.PendingRequest[] memory toRetrieve)\n        public\n        onlyRoleHolder(uint256(Roles.Voter))\n        returns (FixedPoint.Unsigned memory)\n    {\n        return _getVotingAddress().retrieveRewards(address(this), roundId, toRetrieve);\n    }",
        "comments": [
            "/**",
            "     * @notice Forwards a reward retrieval to Voting.",
            "     * @dev Rewards are added to the tokens already held by this contract.",
            "     * @param roundId defines the round from which voting rewards will be retrieved from.",
            "     * @param toRetrieve an array of PendingRequests which rewards are retrieved from.",
            "     * @return amount of rewards that the user should receive.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Forwards a reward retrieval to Voting.\n     * @dev Rewards are added to the tokens already held by this contract.\n     * @param roundId defines the round from which voting rewards will be retrieved from.\n     * @param toRetrieve an array of PendingRequests which rewards are retrieved from.\n     * @return amount of rewards that the user should receive.\n     */\n",
        "@notice": "Forwards a reward retrieval to Voting.",
        "@dev": "Rewards are added to the tokens already held by this contract.",
        "@param1": "roundId defines the round from which voting rewards will be retrieved from.",
        "@param2": "toRetrieve an array of PendingRequests which rewards are retrieved from.",
        "@return1": "amount of rewards that the user should receive.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "newDesignatedVoting",
        "visibility": "external",
        "args": [
            {
                "name": "ownerAddress",
                "type": "address"
            }
        ],
        "func": "function newDesignatedVoting(address ownerAddress) external returns (DesignatedVoting) {\n        require(address(designatedVotingContracts[msg.sender]) == address(0), \"Duplicate hot key not permitted\");\n\n        DesignatedVoting designatedVoting = new DesignatedVoting(finder, ownerAddress, msg.sender);\n        designatedVotingContracts[msg.sender] = designatedVoting;\n        return designatedVoting;\n    }",
        "comments": [
            "/**",
            "     * @notice Deploys a new `DesignatedVoting` contract.",
            "     * @param ownerAddress defines who will own the deployed instance of the designatedVoting contract.",
            "     * @return designatedVoting a new DesignatedVoting contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Deploys a new `DesignatedVoting` contract.\n     * @param ownerAddress defines who will own the deployed instance of the designatedVoting contract.\n     * @return designatedVoting a new DesignatedVoting contract.\n     */\n",
        "@notice": "Deploys a new `DesignatedVoting` contract.",
        "@param1": "ownerAddress defines who will own the deployed instance of the designatedVoting contract.",
        "@return1": "designatedVoting a new DesignatedVoting contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setDesignatedVoting",
        "visibility": "external",
        "args": [
            {
                "name": "designatedVotingAddress",
                "type": "address"
            }
        ],
        "func": "function setDesignatedVoting(address designatedVotingAddress) external {\n        require(address(designatedVotingContracts[msg.sender]) == address(0), \"Duplicate hot key not permitted\");\n        designatedVotingContracts[msg.sender] = DesignatedVoting(designatedVotingAddress);\n    }",
        "comments": [
            "/**",
            "     * @notice Associates a `DesignatedVoting` instance with `msg.sender`.",
            "     * @param designatedVotingAddress address to designate voting to.",
            "     * @dev This is generally only used if the owner of a `DesignatedVoting` contract changes their `voter`",
            "     * address and wants that reflected here.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Associates a `DesignatedVoting` instance with `msg.sender`.\n     * @param designatedVotingAddress address to designate voting to.\n     * @dev This is generally only used if the owner of a `DesignatedVoting` contract changes their `voter`\n     * address and wants that reflected here.\n     */\n",
        "@notice": "Associates a `DesignatedVoting` instance with `msg.sender`.",
        "@param1": "designatedVotingAddress address to designate voting to.",
        "@dev": "This is generally only used if the owner of a `DesignatedVoting` contract changes their `voter` * address and wants that reflected here.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "supportsInterface",
        "visibility": "public",
        "args": [
            {
                "name": "interfaceId",
                "type": "bytes4"
            }
        ],
        "func": "function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC165-supportsInterface}.",
            "     *",
            "     * Time complexity O(1), guaranteed to always use less than 30 000 gas.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n",
        "@dev": "See {IERC165-supportsInterface}. * * Time complexity O(1), guaranteed to always use less than 30 000 gas.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "canImplementInterfaceForAddress",
        "visibility": "public",
        "args": [
            {
                "name": "interfaceHash",
                "type": "bytes32"
            },
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) public view override returns (bytes32) {\n        return _supportedInterfaces[interfaceHash][account] ? _ERC1820_ACCEPT_MAGIC : bytes32(0x00);\n    }",
        "comments": [
            "/**",
            "     * See {IERC1820Implementer-canImplementInterfaceForAddress}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * See {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "name",
        "visibility": "public",
        "args": [],
        "func": "function name() public view returns (string memory) {\n        return _name;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the name of the token.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the name of the token.\n     */\n",
        "@dev": "Returns the name of the token.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "symbol",
        "visibility": "public",
        "args": [],
        "func": "function symbol() public view returns (string memory) {\n        return _symbol;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the symbol of the token, usually a shorter version of the",
            "     * name.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n",
        "@dev": "Returns the symbol of the token, usually a shorter version of the * name.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decimals",
        "visibility": "public",
        "args": [],
        "func": "function decimals() public view returns (uint8) {\n        return _decimals;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the number of decimals used to get its user representation.",
            "     * For example, if `decimals` equals `2`, a balance of `505` tokens should",
            "     * be displayed to a user as `5,05` (`505 / 10 ** 2`).",
            "     *",
            "     * Tokens usually opt for a value of 18, imitating the relationship between",
            "     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is",
            "     * called.",
            "     *",
            "     * NOTE: This information is only used for _display_ purposes: it in",
            "     * no way affects any of the arithmetic of the contract, including",
            "     * {IERC20-balanceOf} and {IERC20-transfer}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n",
        "@dev": "Returns the number of decimals used to get its user representation. * For example, if `decimals` equals `2`, a balance of `505` tokens should * be displayed to a user as `5,05` (`505 / 10 ** 2`). * * Tokens usually opt for a value of 18, imitating the relationship between * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is * called. * * NOTE: This information is only used for _display_ purposes: it in * no way affects any of the arithmetic of the contract, including * {IERC20-balanceOf} and {IERC20-transfer}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-totalSupply}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-totalSupply}.\n     */\n",
        "@dev": "See {IERC20-totalSupply}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-balanceOf}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-balanceOf}.\n     */\n",
        "@dev": "See {IERC20-balanceOf}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-transfer}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `recipient` cannot be the zero address.",
            "     * - the caller must have a balance of at least `amount`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n",
        "@dev": "See {IERC20-transfer}. * * Requirements: * * - `recipient` cannot be the zero address. * - the caller must have a balance of at least `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allowance",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            }
        ],
        "func": "function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-allowance}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-allowance}.\n     */\n",
        "@dev": "See {IERC20-allowance}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-approve}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n",
        "@dev": "See {IERC20-approve}. * * Requirements: * * - `spender` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-transferFrom}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance. This is not",
            "     * required by the EIP. See the note at the beginning of {ERC20};",
            "     *",
            "     * Requirements:",
            "     * - `sender` and `recipient` cannot be the zero address.",
            "     * - `sender` must have a balance of at least `amount`.",
            "     * - the caller must have allowance for ``sender``'s tokens of at least",
            "     * `amount`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n",
        "@dev": "See {IERC20-transferFrom}. * * Emits an {Approval} event indicating the updated allowance. This is not * required by the EIP. See the note at the beginning of {ERC20}; * * Requirements: * - `sender` and `recipient` cannot be the zero address. * - `sender` must have a balance of at least `amount`. * - the caller must have allowance for ``sender``'s tokens of at least * `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "increaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "addedValue",
                "type": "uint256"
            }
        ],
        "func": "function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Atomically increases the allowance granted to `spender` by the caller.",
            "     *",
            "     * This is an alternative to {approve} that can be used as a mitigation for",
            "     * problems described in {IERC20-approve}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n",
        "@dev": "Atomically increases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decreaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "subtractedValue",
                "type": "uint256"
            }
        ],
        "func": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Atomically decreases the allowance granted to `spender` by the caller.",
            "     *",
            "     * This is an alternative to {approve} that can be used as a mitigation for",
            "     * problems described in {IERC20-approve}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     * - `spender` must have allowance for the caller of at least",
            "     * `subtractedValue`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n",
        "@dev": "Atomically decreases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address. * - `spender` must have allowance for the caller of at least * `subtractedValue`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }",
        "comments": [
            "/**",
            "     * @dev Destroys `amount` tokens from the caller.",
            "     *",
            "     * See {ERC20-_burn}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n",
        "@dev": "Destroys `amount` tokens from the caller. * * See {ERC20-_burn}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burnFrom",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }",
        "comments": [
            "/**",
            "     * @dev Destroys `amount` tokens from `account`, deducting from the caller's",
            "     * allowance.",
            "     *",
            "     * See {ERC20-_burn} and {ERC20-allowance}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - the caller must have allowance for ``accounts``'s tokens of at least",
            "     * `amount`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n",
        "@dev": "Destroys `amount` tokens from `account`, deducting from the caller's * allowance. * * See {ERC20-_burn} and {ERC20-allowance}. * * Requirements: * * - the caller must have allowance for ``accounts``'s tokens of at least * `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cap",
        "visibility": "public",
        "args": [],
        "func": "function cap() public view returns (uint256) {\n        return _cap;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the cap on the token's total supply.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the cap on the token's total supply.\n     */\n",
        "@dev": "Returns the cap on the token's total supply.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "public",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function mint(address to, uint256 amount) public {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }",
        "comments": [
            "/**",
            "     * @dev Creates `amount` new tokens for `to`.",
            "     *",
            "     * See {ERC20-_mint}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - the caller must have the `MINTER_ROLE`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n",
        "@dev": "Creates `amount` new tokens for `to`. * * See {ERC20-_mint}. * * Requirements: * * - the caller must have the `MINTER_ROLE`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "pause",
        "visibility": "public",
        "args": [],
        "func": "function pause() public {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }",
        "comments": [
            "/**",
            "     * @dev Pauses all token transfers.",
            "     *",
            "     * See {ERC20Pausable} and {Pausable-_pause}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - the caller must have the `PAUSER_ROLE`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n",
        "@dev": "Pauses all token transfers. * * See {ERC20Pausable} and {Pausable-_pause}. * * Requirements: * * - the caller must have the `PAUSER_ROLE`.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unpause",
        "visibility": "public",
        "args": [],
        "func": "function unpause() public {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }",
        "comments": [
            "/**",
            "     * @dev Unpauses all token transfers.",
            "     *",
            "     * See {ERC20Pausable} and {Pausable-_unpause}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - the caller must have the `PAUSER_ROLE`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n",
        "@dev": "Unpauses all token transfers. * * See {ERC20Pausable} and {Pausable-_unpause}. * * Requirements: * * - the caller must have the `PAUSER_ROLE`.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOfAt",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            },
            {
                "name": "snapshotId",
                "type": "uint256"
            }
        ],
        "func": "function balanceOfAt(address account, uint256 snapshotId) public view returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\n\n        return snapshotted ? value : balanceOf(account);\n    }",
        "comments": [
            "/**",
            "     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\n     */\n",
        "@dev": "Retrieves the balance of `account` at the time `snapshotId` was created.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupplyAt",
        "visibility": "public",
        "args": [
            {
                "name": "snapshotId",
                "type": "uint256"
            }
        ],
        "func": "function totalSupplyAt(uint256 snapshotId) public view returns(uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\n\n        return snapshotted ? value : totalSupply();\n    }",
        "comments": [
            "/**",
            "     * @dev Retrieves the total supply at the time `snapshotId` was created.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\n     */\n",
        "@dev": "Retrieves the total supply at the time `snapshotId` was created.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address owner) public view override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n\n        return _holderTokens[owner].length();\n    }",
        "comments": [
            "/**",
            "     * @dev Gets the balance of the specified address.",
            "     * @param owner address to query the balance of",
            "     * @return uint256 representing the amount owned by the passed address",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Gets the balance of the specified address.\n     * @param owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     */\n",
        "@dev": "Gets the balance of the specified address.",
        "@param1": "owner address to query the balance of",
        "@return1": "uint256 representing the amount owned by the passed address",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "ownerOf",
        "visibility": "public",
        "args": [
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function ownerOf(uint256 tokenId) public view override returns (address) {\n        return _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\n    }",
        "comments": [
            "/**",
            "     * @dev Gets the owner of the specified token ID.",
            "     * @param tokenId uint256 ID of the token to query the owner of",
            "     * @return address currently marked as the owner of the given token ID",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Gets the owner of the specified token ID.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n",
        "@dev": "Gets the owner of the specified token ID.",
        "@param1": "tokenId uint256 ID of the token to query the owner of",
        "@return1": "address currently marked as the owner of the given token ID",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "name",
        "visibility": "public",
        "args": [],
        "func": "function name() public view override returns (string memory) {\n        return _name;\n    }",
        "comments": [
            "/**",
            "     * @dev Gets the token name.",
            "     * @return string representing the token name",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Gets the token name.\n     * @return string representing the token name\n     */\n",
        "@dev": "Gets the token name.",
        "@return1": "string representing the token name",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "symbol",
        "visibility": "public",
        "args": [],
        "func": "function symbol() public view override returns (string memory) {\n        return _symbol;\n    }",
        "comments": [
            "/**",
            "     * @dev Gets the token symbol.",
            "     * @return string representing the token symbol",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Gets the token symbol.\n     * @return string representing the token symbol\n     */\n",
        "@dev": "Gets the token symbol.",
        "@return1": "string representing the token symbol",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "tokenURI",
        "visibility": "public",
        "args": [
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n\n        // If there is no base URI, return the token URI.\n        if (bytes(_baseURI).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(_baseURI, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(_baseURI, tokenId.toString()));\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the URI for a given token ID. May return an empty string.",
            "     *",
            "     * If a base URI is set (via {_setBaseURI}), it is added as a prefix to the",
            "     * token's own URI (via {_setTokenURI}).",
            "     *",
            "     * If there is a base URI but no token URI, the token's ID will be used as",
            "     * its URI when appending it to the base URI. This pattern for autogenerated",
            "     * token URIs can lead to large gas savings.",
            "     *",
            "     * .Examples",
            "     * |===",
            "     * |`_setBaseURI()` |`_setTokenURI()` |`tokenURI()`",
            "     * | \"\"",
            "     * | \"\"",
            "     * | \"\"",
            "     * | \"\"",
            "     * | \"token.uri/123\"",
            "     * | \"token.uri/123\"",
            "     * | \"token.uri/\"",
            "     * | \"123\"",
            "     * | \"token.uri/123\"",
            "     * | \"token.uri/\"",
            "     * | \"\"",
            "     * | \"token.uri/<tokenId>\"",
            "     * |===",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `tokenId` must exist.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the URI for a given token ID. May return an empty string.\n     *\n     * If a base URI is set (via {_setBaseURI}), it is added as a prefix to the\n     * token's own URI (via {_setTokenURI}).\n     *\n     * If there is a base URI but no token URI, the token's ID will be used as\n     * its URI when appending it to the base URI. This pattern for autogenerated\n     * token URIs can lead to large gas savings.\n     *\n     * .Examples\n     * |===\n     * |`_setBaseURI()` |`_setTokenURI()` |`tokenURI()`\n     * | \"\"\n     * | \"\"\n     * | \"\"\n     * | \"\"\n     * | \"token.uri/123\"\n     * | \"token.uri/123\"\n     * | \"token.uri/\"\n     * | \"123\"\n     * | \"token.uri/123\"\n     * | \"token.uri/\"\n     * | \"\"\n     * | \"token.uri/<tokenId>\"\n     * |===\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n",
        "@dev": "Returns the URI for a given token ID. May return an empty string. * * If a base URI is set (via {_setBaseURI}), it is added as a prefix to the * token's own URI (via {_setTokenURI}). * * If there is a base URI but no token URI, the token's ID will be used as * its URI when appending it to the base URI. This pattern for autogenerated * token URIs can lead to large gas savings. * * .Examples * |=== * |`_setBaseURI()` |`_setTokenURI()` |`tokenURI()` * | \"\" * | \"\" * | \"\" * | \"\" * | \"token.uri/123\" * | \"token.uri/123\" * | \"token.uri/\" * | \"123\" * | \"token.uri/123\" * | \"token.uri/\" * | \"\" * | \"token.uri/<tokenId>\" * |=== * * Requirements: * * - `tokenId` must exist.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "baseURI",
        "visibility": "public",
        "args": [],
        "func": "function baseURI() public view returns (string memory) {\n        return _baseURI;\n    }",
        "comments": [
            "/**",
            "    * @dev Returns the base URI set via {_setBaseURI}. This will be",
            "    * automatically added as a prefix in {tokenURI} to each token's URI, or",
            "    * to the token ID if no specific URI is set for that token ID.",
            "    */",
            ""
        ],
        "comt": "/**\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\n    * to the token ID if no specific URI is set for that token ID.\n    */\n",
        "@dev": "Returns the base URI set via {_setBaseURI}. This will be * automatically added as a prefix in {tokenURI} to each token's URI, or * to the token ID if no specific URI is set for that token ID.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "tokenOfOwnerByIndex",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "index",
                "type": "uint256"
            }
        ],
        "func": "function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\n        return _holderTokens[owner].at(index);\n    }",
        "comments": [
            "/**",
            "     * @dev Gets the token ID at a given index of the tokens list of the requested owner.",
            "     * @param owner address owning the tokens list to be accessed",
            "     * @param index uint256 representing the index to be accessed of the requested tokens list",
            "     * @return uint256 token ID at the given index of the tokens list owned by the requested address",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner.\n     * @param owner address owning the tokens list to be accessed\n     * @param index uint256 representing the index to be accessed of the requested tokens list\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\n     */\n",
        "@dev": "Gets the token ID at a given index of the tokens list of the requested owner.",
        "@param1": "owner address owning the tokens list to be accessed",
        "@param2": "index uint256 representing the index to be accessed of the requested tokens list",
        "@return1": "uint256 token ID at the given index of the tokens list owned by the requested address",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view override returns (uint256) {\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n        return _tokenOwners.length();\n    }",
        "comments": [
            "/**",
            "     * @dev Gets the total amount of tokens stored by the contract.",
            "     * @return uint256 representing the total amount of tokens",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Gets the total amount of tokens stored by the contract.\n     * @return uint256 representing the total amount of tokens\n     */\n",
        "@dev": "Gets the total amount of tokens stored by the contract.",
        "@return1": "uint256 representing the total amount of tokens",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "tokenByIndex",
        "visibility": "public",
        "args": [
            {
                "name": "index",
                "type": "uint256"
            }
        ],
        "func": "function tokenByIndex(uint256 index) public view override returns (uint256) {\n        (uint256 tokenId, ) = _tokenOwners.at(index);\n        return tokenId;\n    }",
        "comments": [
            "/**",
            "     * @dev Gets the token ID at a given index of all the tokens in this contract",
            "     * Reverts if the index is greater or equal to the total number of tokens.",
            "     * @param index uint256 representing the index to be accessed of the tokens list",
            "     * @return uint256 token ID at the given index of the tokens list",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Gets the token ID at a given index of all the tokens in this contract\n     * Reverts if the index is greater or equal to the total number of tokens.\n     * @param index uint256 representing the index to be accessed of the tokens list\n     * @return uint256 token ID at the given index of the tokens list\n     */\n",
        "@dev": "Gets the token ID at a given index of all the tokens in this contract * Reverts if the index is greater or equal to the total number of tokens.",
        "@param1": "index uint256 representing the index to be accessed of the tokens list",
        "@return1": "uint256 token ID at the given index of the tokens list",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }",
        "comments": [
            "/**",
            "     * @dev Approves another address to transfer the given token ID",
            "     * The zero address indicates there is no approved address.",
            "     * There can only be one approved address per token at a given time.",
            "     * Can only be called by the token owner or an approved operator.",
            "     * @param to address to be approved for the given token ID",
            "     * @param tokenId uint256 ID of the token to be approved",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Approves another address to transfer the given token ID\n     * The zero address indicates there is no approved address.\n     * There can only be one approved address per token at a given time.\n     * Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n",
        "@dev": "Approves another address to transfer the given token ID * The zero address indicates there is no approved address. * There can only be one approved address per token at a given time. * Can only be called by the token owner or an approved operator.",
        "@param1": "to address to be approved for the given token ID",
        "@param2": "tokenId uint256 ID of the token to be approved",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getApproved",
        "visibility": "public",
        "args": [
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function getApproved(uint256 tokenId) public view override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }",
        "comments": [
            "/**",
            "     * @dev Gets the approved address for a token ID, or zero if no address set",
            "     * Reverts if the token ID does not exist.",
            "     * @param tokenId uint256 ID of the token to query the approval of",
            "     * @return address currently approved for the given token ID",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for the given token ID\n     */\n",
        "@dev": "Gets the approved address for a token ID, or zero if no address set * Reverts if the token ID does not exist.",
        "@param1": "tokenId uint256 ID of the token to query the approval of",
        "@return1": "address currently approved for the given token ID",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setApprovalForAll",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "approved",
                "type": "bool"
            }
        ],
        "func": "function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }",
        "comments": [
            "/**",
            "     * @dev Sets or unsets the approval of a given operator",
            "     * An operator is allowed to transfer all tokens of the sender on their behalf.",
            "     * @param operator operator address to set the approval",
            "     * @param approved representing the status of the approval to be set",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\n     * @param operator operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n",
        "@dev": "Sets or unsets the approval of a given operator * An operator is allowed to transfer all tokens of the sender on their behalf.",
        "@param1": "operator operator address to set the approval",
        "@param2": "approved representing the status of the approval to be set",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isApprovedForAll",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function isApprovedForAll(address owner, address operator) public view override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }",
        "comments": [
            "/**",
            "     * @dev Tells whether an operator is approved by a given owner.",
            "     * @param owner owner address which you want to query the approval of",
            "     * @param operator operator address which you want to query the approval of",
            "     * @return bool whether the given operator is approved by the given owner",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Tells whether an operator is approved by a given owner.\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n",
        "@dev": "Tells whether an operator is approved by a given owner.",
        "@param1": "owner owner address which you want to query the approval of",
        "@param2": "operator operator address which you want to query the approval of",
        "@return1": "bool whether the given operator is approved by the given owner",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }",
        "comments": [
            "/**",
            "     * @dev Transfers the ownership of a given token ID to another address.",
            "     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.",
            "     * Requires the msg.sender to be the owner, approved, or operator.",
            "     * @param from current owner of the token",
            "     * @param to address to receive the ownership of the given token ID",
            "     * @param tokenId uint256 ID of the token to be transferred",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Transfers the ownership of a given token ID to another address.\n     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     * Requires the msg.sender to be the owner, approved, or operator.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n",
        "@dev": "Transfers the ownership of a given token ID to another address. * Usage of this method is discouraged, use {safeTransferFrom} whenever possible. * Requires the msg.sender to be the owner, approved, or operator.",
        "@param1": "from current owner of the token",
        "@param2": "to address to receive the ownership of the given token ID",
        "@param3": "tokenId uint256 ID of the token to be transferred",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "safeTransferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }",
        "comments": [
            "/**",
            "     * @dev Safely transfers the ownership of a given token ID to another address",
            "     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},",
            "     * which is called upon a safe transfer, and return the magic value",
            "     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,",
            "     * the transfer is reverted.",
            "     * Requires the msg.sender to be the owner, approved, or operator",
            "     * @param from current owner of the token",
            "     * @param to address to receive the ownership of the given token ID",
            "     * @param tokenId uint256 ID of the token to be transferred",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n",
        "@dev": "Safely transfers the ownership of a given token ID to another address * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received}, * which is called upon a safe transfer, and return the magic value * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise, * the transfer is reverted. * Requires the msg.sender to be the owner, approved, or operator",
        "@param1": "from current owner of the token",
        "@param2": "to address to receive the ownership of the given token ID",
        "@param3": "tokenId uint256 ID of the token to be transferred",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "safeTransferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "name": "_data",
                "type": "bytes memory"
            }
        ],
        "func": "function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }",
        "comments": [
            "/**",
            "     * @dev Safely transfers the ownership of a given token ID to another address",
            "     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},",
            "     * which is called upon a safe transfer, and return the magic value",
            "     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,",
            "     * the transfer is reverted.",
            "     * Requires the _msgSender() to be the owner, approved, or operator",
            "     * @param from current owner of the token",
            "     * @param to address to receive the ownership of the given token ID",
            "     * @param tokenId uint256 ID of the token to be transferred",
            "     * @param _data bytes data to send along with a safe transfer check",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the _msgSender() to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n",
        "@dev": "Safely transfers the ownership of a given token ID to another address * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received}, * which is called upon a safe transfer, and return the magic value * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise, * the transfer is reverted. * Requires the _msgSender() to be the owner, approved, or operator",
        "@param1": "from current owner of the token",
        "@param2": "to address to receive the ownership of the given token ID",
        "@param3": "tokenId uint256 ID of the token to be transferred",
        "@param4": "_data bytes data to send along with a safe transfer check",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "public",
        "args": [
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }",
        "comments": [
            "/**",
            "     * @dev Burns a specific ERC721 token.",
            "     * @param tokenId uint256 id of the ERC721 token to be burned.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Burns a specific ERC721 token.\n     * @param tokenId uint256 id of the ERC721 token to be burned.\n     */\n",
        "@dev": "Burns a specific ERC721 token.",
        "@param1": "tokenId uint256 id of the ERC721 token to be burned.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "onERC721Received",
        "visibility": "public",
        "args": [
            {
                "name": "address",
                "type": "address"
            },
            {
                "name": "address",
                "type": "address"
            },
            {
                "name": "uint256",
                "type": "uint256"
            },
            {
                "name": "memory",
                "type": "bytes"
            }
        ],
        "func": "function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "public",
        "args": [
            {
                "name": "to",
                "type": "address"
            }
        ],
        "func": "function mint(address to) public {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have minter role to mint\");\n\n        // We can just use balanceOf to create the new tokenId because tokens\n        // can be burned (destroyed), so we need a separate counter.\n        _mint(to, _tokenIdTracker.current());\n        _tokenIdTracker.increment();\n    }",
        "comments": [
            "/**",
            "     * @dev Creates a new token for `to`. Its token ID will be automatically",
            "     * assigned (and available on the emitted {Transfer} event), and the token",
            "     * URI autogenerated based on the base URI passed at construction.",
            "     *",
            "     * See {ERC721-_mint}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - the caller must have the `MINTER_ROLE`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Creates a new token for `to`. Its token ID will be automatically\n     * assigned (and available on the emitted {Transfer} event), and the token\n     * URI autogenerated based on the base URI passed at construction.\n     *\n     * See {ERC721-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n",
        "@dev": "Creates a new token for `to`. Its token ID will be automatically * assigned (and available on the emitted {Transfer} event), and the token * URI autogenerated based on the base URI passed at construction. * * See {ERC721-_mint}. * * Requirements: * * - the caller must have the `MINTER_ROLE`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "pause",
        "visibility": "public",
        "args": [],
        "func": "function pause() public {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to pause\");\n        _pause();\n    }",
        "comments": [
            "/**",
            "     * @dev Pauses all token transfers.",
            "     *",
            "     * See {ERC721Pausable} and {Pausable-_pause}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - the caller must have the `PAUSER_ROLE`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC721Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n",
        "@dev": "Pauses all token transfers. * * See {ERC721Pausable} and {Pausable-_pause}. * * Requirements: * * - the caller must have the `PAUSER_ROLE`.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unpause",
        "visibility": "public",
        "args": [],
        "func": "function unpause() public {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to unpause\");\n        _unpause();\n    }",
        "comments": [
            "/**",
            "     * @dev Unpauses all token transfers.",
            "     *",
            "     * See {ERC721Pausable} and {Pausable-_unpause}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - the caller must have the `PAUSER_ROLE`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC721Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n",
        "@dev": "Unpauses all token transfers. * * See {ERC721Pausable} and {Pausable-_unpause}. * * Requirements: * * - the caller must have the `PAUSER_ROLE`.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "name",
        "visibility": "public",
        "args": [],
        "func": "function name() public view override returns (string memory) {\n        return _name;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC777-name}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC777-name}.\n     */\n",
        "@dev": "See {IERC777-name}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "symbol",
        "visibility": "public",
        "args": [],
        "func": "function symbol() public view override returns (string memory) {\n        return _symbol;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC777-symbol}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC777-symbol}.\n     */\n",
        "@dev": "See {IERC777-symbol}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decimals",
        "visibility": "public",
        "args": [],
        "func": "function decimals() public pure returns (uint8) {\n        return 18;\n    }",
        "comments": [
            "/**",
            "     * @dev See {ERC20-decimals}.",
            "     *",
            "     * Always returns 18, as per the",
            "     * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {ERC20-decimals}.\n     *\n     * Always returns 18, as per the\n     * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\n     */\n",
        "@dev": "See {ERC20-decimals}. * * Always returns 18, as per the * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "granularity",
        "visibility": "public",
        "args": [],
        "func": "function granularity() public view override returns (uint256) {\n        return 1;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC777-granularity}.",
            "     *",
            "     * This implementation always returns `1`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC777-granularity}.\n     *\n     * This implementation always returns `1`.\n     */\n",
        "@dev": "See {IERC777-granularity}. * * This implementation always returns `1`.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view override(IERC20, IERC777) returns (uint256) {\n        return _totalSupply;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC777-totalSupply}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC777-totalSupply}.\n     */\n",
        "@dev": "See {IERC777-totalSupply}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "tokenHolder",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address tokenHolder) public view override(IERC20, IERC777) returns (uint256) {\n        return _balances[tokenHolder];\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the amount of tokens owned by an account (`tokenHolder`).",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the amount of tokens owned by an account (`tokenHolder`).\n     */\n",
        "@dev": "Returns the amount of tokens owned by an account (`tokenHolder`).",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "send",
        "visibility": "public",
        "args": [
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            },
            {
                "name": "data",
                "type": "bytes memory"
            }
        ],
        "func": "function send(address recipient, uint256 amount, bytes memory data) public override  {\n        _send(_msgSender(), recipient, amount, data, \"\", true);\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC777-send}.",
            "     *",
            "     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC777-send}.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n",
        "@dev": "See {IERC777-send}. * * Also emits a {IERC20-Transfer} event for ERC20 compatibility.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address recipient, uint256 amount) public override returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n\n        address from = _msgSender();\n\n        _callTokensToSend(from, from, recipient, amount, \"\", \"\");\n\n        _move(from, from, recipient, amount, \"\", \"\");\n\n        _callTokensReceived(from, from, recipient, amount, \"\", \"\", false);\n\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-transfer}.",
            "     *",
            "     * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}",
            "     * interface if it is a contract.",
            "     *",
            "     * Also emits a {Sent} event.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-transfer}.\n     *\n     * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\n     * interface if it is a contract.\n     *\n     * Also emits a {Sent} event.\n     */\n",
        "@dev": "See {IERC20-transfer}. * * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient} * interface if it is a contract. * * Also emits a {Sent} event.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            },
            {
                "name": "data",
                "type": "bytes memory"
            }
        ],
        "func": "function burn(uint256 amount, bytes memory data) public override  {\n        _burn(_msgSender(), amount, data, \"\");\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC777-burn}.",
            "     *",
            "     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC777-burn}.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n",
        "@dev": "See {IERC777-burn}. * * Also emits a {IERC20-Transfer} event for ERC20 compatibility.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isOperatorFor",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "tokenHolder",
                "type": "address"
            }
        ],
        "func": "function isOperatorFor(\n        address operator,\n        address tokenHolder\n    ) public view override returns (bool) {\n        return operator == tokenHolder ||\n            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||\n            _operators[tokenHolder][operator];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC777-isOperatorFor}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC777-isOperatorFor}.\n     */\n",
        "@dev": "See {IERC777-isOperatorFor}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "authorizeOperator",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function authorizeOperator(address operator) public override  {\n        require(_msgSender() != operator, \"ERC777: authorizing self as operator\");\n\n        if (_defaultOperators[operator]) {\n            delete _revokedDefaultOperators[_msgSender()][operator];\n        } else {\n            _operators[_msgSender()][operator] = true;\n        }\n\n        emit AuthorizedOperator(operator, _msgSender());\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC777-authorizeOperator}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC777-authorizeOperator}.\n     */\n",
        "@dev": "See {IERC777-authorizeOperator}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "revokeOperator",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function revokeOperator(address operator) public override  {\n        require(operator != _msgSender(), \"ERC777: revoking self as operator\");\n\n        if (_defaultOperators[operator]) {\n            _revokedDefaultOperators[_msgSender()][operator] = true;\n        } else {\n            delete _operators[_msgSender()][operator];\n        }\n\n        emit RevokedOperator(operator, _msgSender());\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC777-revokeOperator}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC777-revokeOperator}.\n     */\n",
        "@dev": "See {IERC777-revokeOperator}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "defaultOperators",
        "visibility": "public",
        "args": [],
        "func": "function defaultOperators() public view override returns (address[] memory) {\n        return _defaultOperatorsArray;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC777-defaultOperators}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC777-defaultOperators}.\n     */\n",
        "@dev": "See {IERC777-defaultOperators}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "operatorSend",
        "visibility": "public",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            },
            {
                "name": "data",
                "type": "bytes memory"
            },
            {
                "name": "operatorData",
                "type": "bytes memory"
            }
        ],
        "func": "function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    )\n    public override\n    {\n        require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");\n        _send(sender, recipient, amount, data, operatorData, true);\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC777-operatorSend}.",
            "     *",
            "     * Emits {Sent} and {IERC20-Transfer} events.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC777-operatorSend}.\n     *\n     * Emits {Sent} and {IERC20-Transfer} events.\n     */\n",
        "@dev": "See {IERC777-operatorSend}. * * Emits {Sent} and {IERC20-Transfer} events.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "operatorBurn",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            },
            {
                "name": "data",
                "type": "bytes memory"
            },
            {
                "name": "operatorData",
                "type": "bytes memory"
            }
        ],
        "func": "function operatorBurn(address account, uint256 amount, bytes memory data, bytes memory operatorData) public override {\n        require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");\n        _burn(account, amount, data, operatorData);\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC777-operatorBurn}.",
            "     *",
            "     * Emits {Burned} and {IERC20-Transfer} events.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC777-operatorBurn}.\n     *\n     * Emits {Burned} and {IERC20-Transfer} events.\n     */\n",
        "@dev": "See {IERC777-operatorBurn}. * * Emits {Burned} and {IERC20-Transfer} events.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allowance",
        "visibility": "public",
        "args": [
            {
                "name": "holder",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            }
        ],
        "func": "function allowance(address holder, address spender) public view override returns (uint256) {\n        return _allowances[holder][spender];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-allowance}.",
            "     *",
            "     * Note that operator and allowance concepts are orthogonal: operators may",
            "     * not have allowance, and accounts with allowance may not be operators",
            "     * themselves.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-allowance}.\n     *\n     * Note that operator and allowance concepts are orthogonal: operators may\n     * not have allowance, and accounts with allowance may not be operators\n     * themselves.\n     */\n",
        "@dev": "See {IERC20-allowance}. * * Note that operator and allowance concepts are orthogonal: operators may * not have allowance, and accounts with allowance may not be operators * themselves.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint256"
            }
        ],
        "func": "function approve(address spender, uint256 value) public override returns (bool) {\n        address holder = _msgSender();\n        _approve(holder, spender, value);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-approve}.",
            "     *",
            "     * Note that accounts cannot have allowance issued by their operators.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-approve}.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n",
        "@dev": "See {IERC20-approve}. * * Note that accounts cannot have allowance issued by their operators.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "holder",
                "type": "address"
            },
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(address holder, address recipient, uint256 amount) public override returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n        require(holder != address(0), \"ERC777: transfer from the zero address\");\n\n        address spender = _msgSender();\n\n        _callTokensToSend(spender, holder, recipient, amount, \"\", \"\");\n\n        _move(spender, holder, recipient, amount, \"\", \"\");\n        _approve(holder, spender, _allowances[holder][spender].sub(amount, \"ERC777: transfer amount exceeds allowance\"));\n\n        _callTokensReceived(spender, holder, recipient, amount, \"\", \"\", false);\n\n        return true;\n    }",
        "comments": [
            "/**",
            "    * @dev See {IERC20-transferFrom}.",
            "    *",
            "    * Note that operator and allowance concepts are orthogonal: operators cannot",
            "    * call `transferFrom` (unless they have allowance), and accounts with",
            "    * allowance cannot call `operatorSend` (unless they are operators).",
            "    *",
            "    * Emits {Sent}, {IERC20-Transfer} and {IERC20-Approval} events.",
            "    */",
            ""
        ],
        "comt": "/**\n    * @dev See {IERC20-transferFrom}.\n    *\n    * Note that operator and allowance concepts are orthogonal: operators cannot\n    * call `transferFrom` (unless they have allowance), and accounts with\n    * allowance cannot call `operatorSend` (unless they are operators).\n    *\n    * Emits {Sent}, {IERC20-Transfer} and {IERC20-Approval} events.\n    */\n",
        "@dev": "See {IERC20-transferFrom}. * * Note that operator and allowance concepts are orthogonal: operators cannot * call `transferFrom` (unless they have allowance), and accounts with * allowance cannot call `operatorSend` (unless they are operators). * * Emits {Sent}, {IERC20-Transfer} and {IERC20-Approval} events.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "depositsOf",
        "visibility": "public",
        "args": [
            {
                "name": "payee",
                "type": "address"
            }
        ],
        "func": "function depositsOf(address payee) public view returns (uint256) {\n        return _deposits[payee];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "deposit",
        "visibility": "public",
        "args": [
            {
                "name": "payee",
                "type": "address"
            }
        ],
        "func": "function deposit(address payee) public virtual payable onlyOwner {\n        uint256 amount = msg.value;\n        _deposits[payee] = _deposits[payee].add(amount);\n\n        emit Deposited(payee, amount);\n    }",
        "comments": [
            "/**",
            "     * @dev Stores the sent amount as credit to be withdrawn.",
            "     * @param payee The destination address of the funds.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Stores the sent amount as credit to be withdrawn.\n     * @param payee The destination address of the funds.\n     */\n",
        "@dev": "Stores the sent amount as credit to be withdrawn.",
        "@param1": "payee The destination address of the funds.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "payee",
                "type": "address payable"
            }
        ],
        "func": "function withdraw(address payable payee) public virtual onlyOwner {\n        uint256 payment = _deposits[payee];\n\n        _deposits[payee] = 0;\n\n        payee.sendValue(payment);\n\n        emit Withdrawn(payee, payment);\n    }",
        "comments": [
            "/**",
            "     * @dev Withdraw accumulated balance for a payee, forwarding all gas to the",
            "     * recipient.",
            "     *",
            "     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.",
            "     * Make sure you trust the recipient, or are either following the",
            "     * checks-effects-interactions pattern or using {ReentrancyGuard}.",
            "     *",
            "     * @param payee The address whose funds will be withdrawn and transferred to.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Withdraw accumulated balance for a payee, forwarding all gas to the\n     * recipient.\n     *\n     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.\n     * Make sure you trust the recipient, or are either following the\n     * checks-effects-interactions pattern or using {ReentrancyGuard}.\n     *\n     * @param payee The address whose funds will be withdrawn and transferred to.\n     */\n",
        "@dev": "Withdraw accumulated balance for a payee, forwarding all gas to the * recipient. * * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities. * Make sure you trust the recipient, or are either following the * checks-effects-interactions pattern or using {ReentrancyGuard}.",
        "@param1": "payee The address whose funds will be withdrawn and transferred to.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "external",
        "args": [
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint256"
            }
        ],
        "func": "function mint(address recipient, uint256 value)\n        external\n        override\n        onlyRoleHolder(uint256(Roles.Minter))\n        returns (bool)\n    {\n        _mint(recipient, value);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Mints `value` tokens to `recipient`, returning true on success.",
            "     * @param recipient address to mint to.",
            "     * @param value amount of tokens to mint.",
            "     * @return True if the mint succeeded, or False.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Mints `value` tokens to `recipient`, returning true on success.\n     * @param recipient address to mint to.\n     * @param value amount of tokens to mint.\n     * @return True if the mint succeeded, or False.\n     */\n",
        "@dev": "Mints `value` tokens to `recipient`, returning true on success.",
        "@param1": "recipient address to mint to.",
        "@param2": "value amount of tokens to mint.",
        "@return1": "True if the mint succeeded, or False.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "external",
        "args": [
            {
                "name": "value",
                "type": "uint256"
            }
        ],
        "func": "function burn(uint256 value) external override onlyRoleHolder(uint256(Roles.Burner)) {\n        _burn(msg.sender, value);\n    }",
        "comments": [
            "/**",
            "     * @dev Burns `value` tokens owned by `msg.sender`.",
            "     * @param value amount of tokens to burn.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Burns `value` tokens owned by `msg.sender`.\n     * @param value amount of tokens to burn.\n     */\n",
        "@dev": "Burns `value` tokens owned by `msg.sender`.",
        "@param1": "value amount of tokens to burn.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createExpiringMultiParty",
        "visibility": "public",
        "args": [
            {
                "name": "params",
                "type": "Params memory"
            }
        ],
        "func": "function createExpiringMultiParty(Params memory params) public returns (address) {\n        ExpiringMultiParty derivative = new ExpiringMultiParty(_convertParams(params));\n\n        address[] memory parties = new address[](1);\n        parties[0] = msg.sender;\n\n        _registerContract(parties, address(derivative));\n\n        emit CreatedExpiringMultiParty(address(derivative), msg.sender);\n\n        return address(derivative);\n    }",
        "comments": [
            "/**",
            "     * @notice Creates an instance of expiring multi party and registers it within the registry.",
            "     * @dev caller is automatically registered as the first (and only) party member.",
            "     * @param params is a `ConstructorParams` object from ExpiringMultiParty.",
            "     * @return address of the deployed ExpiringMultiParty contract",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Creates an instance of expiring multi party and registers it within the registry.\n     * @dev caller is automatically registered as the first (and only) party member.\n     * @param params is a `ConstructorParams` object from ExpiringMultiParty.\n     * @return address of the deployed ExpiringMultiParty contract\n     */\n",
        "@notice": "Creates an instance of expiring multi party and registers it within the registry.",
        "@dev": "caller is automatically registered as the first (and only) party member.",
        "@param1": "params is a `ConstructorParams` object from ExpiringMultiParty.",
        "@return1": "address of the deployed ExpiringMultiParty contract",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "payFees",
        "visibility": "public",
        "args": [],
        "func": "function payFees() public returns (FixedPoint.Unsigned memory totalPaid) {\n        StoreInterface store = _getStore();\n        uint256 time = getCurrentTime();\n        FixedPoint.Unsigned memory _pfc = pfc();\n\n        // Exit early if there is no pfc (thus, no fees to be paid).\n        if (_pfc.isEqual(0)) {\n            return totalPaid;\n        }\n\n        (FixedPoint.Unsigned memory regularFee, FixedPoint.Unsigned memory latePenalty) = store.computeRegularFee(\n            lastPaymentTime,\n            time,\n            _pfc\n        );\n        lastPaymentTime = time;\n\n        if (regularFee.isGreaterThan(0)) {\n            collateralCurrency.safeIncreaseAllowance(address(store), regularFee.rawValue);\n            store.payOracleFeesErc20(address(collateralCurrency), regularFee);\n        }\n\n        if (latePenalty.isGreaterThan(0)) {\n            collateralCurrency.safeTransfer(msg.sender, latePenalty.rawValue);\n        }\n\n        emit RegularFeesPaid(regularFee.rawValue, latePenalty.rawValue);\n\n        totalPaid = regularFee.add(latePenalty);\n        FixedPoint.Unsigned memory effectiveFee = totalPaid.divCeil(_pfc);\n        cumulativeFeeMultiplier = cumulativeFeeMultiplier.mul(FixedPoint.fromUnscaledUint(1).sub(effectiveFee));\n    }",
        "comments": [
            "/**",
            "     * @notice Pays UMA DVM regular fees to the Store contract.",
            "     * @dev These must be paid periodically for the life of the contract. If the contract has not paid its",
            "     * regular fee in a week or mre then a late penalty is applied which is sent to the caller.",
            "     * @return totalPaid The amount of collateral that the contract paid (sum of the amount paid to the Store and the caller).",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Pays UMA DVM regular fees to the Store contract.\n     * @dev These must be paid periodically for the life of the contract. If the contract has not paid its\n     * regular fee in a week or mre then a late penalty is applied which is sent to the caller.\n     * @return totalPaid The amount of collateral that the contract paid (sum of the amount paid to the Store and the caller).\n     */\n",
        "@notice": "Pays UMA DVM regular fees to the Store contract.",
        "@dev": "These must be paid periodically for the life of the contract. If the contract has not paid its * regular fee in a week or mre then a late penalty is applied which is sent to the caller.",
        "@return1": "totalPaid The amount of collateral that the contract paid (sum of the amount paid to the Store and the caller).",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "callEmergencyShutdown",
        "visibility": "external",
        "args": [
            {
                "name": "financialContract",
                "type": "address"
            }
        ],
        "func": "function callEmergencyShutdown(address financialContract) external onlyOwner {\n        AdministrateeInterface administratee = AdministrateeInterface(financialContract);\n        administratee.emergencyShutdown();\n    }",
        "comments": [
            "/**",
            "     * @notice Calls emergency shutdown on the provided financial contract.",
            "     * @param financialContract address of the FinancialContract to be shut down.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Calls emergency shutdown on the provided financial contract.\n     * @param financialContract address of the FinancialContract to be shut down.\n     */\n",
        "@notice": "Calls emergency shutdown on the provided financial contract.",
        "@param1": "financialContract address of the FinancialContract to be shut down.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "callRemargin",
        "visibility": "external",
        "args": [
            {
                "name": "financialContract",
                "type": "address"
            }
        ],
        "func": "function callRemargin(address financialContract) external onlyOwner {\n        AdministrateeInterface administratee = AdministrateeInterface(financialContract);\n        administratee.remargin();\n    }",
        "comments": [
            "/**",
            "     * @notice Calls remargin on the provided financial contract.",
            "     * @param financialContract address of the FinancialContract to be remargined.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Calls remargin on the provided financial contract.\n     * @param financialContract address of the FinancialContract to be remargined.\n     */\n",
        "@notice": "Calls remargin on the provided financial contract.",
        "@param1": "financialContract address of the FinancialContract to be remargined.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeImplementationAddress",
        "visibility": "external",
        "args": [
            {
                "name": "interfaceName",
                "type": "bytes32"
            },
            {
                "name": "implementationAddress",
                "type": "address"
            }
        ],
        "func": "function changeImplementationAddress(bytes32 interfaceName, address implementationAddress)\n        external\n        override\n        onlyOwner\n    {\n        interfacesImplemented[interfaceName] = implementationAddress;\n\n        emit InterfaceImplementationChanged(interfaceName, implementationAddress);\n    }",
        "comments": [
            "/**",
            "     * @notice Updates the address of the contract that implements `interfaceName`.",
            "     * @param interfaceName bytes32 of the interface name that is either changed or registered.",
            "     * @param implementationAddress address of the implementation contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Updates the address of the contract that implements `interfaceName`.\n     * @param interfaceName bytes32 of the interface name that is either changed or registered.\n     * @param implementationAddress address of the implementation contract.\n     */\n",
        "@notice": "Updates the address of the contract that implements `interfaceName`.",
        "@param1": "interfaceName bytes32 of the interface name that is either changed or registered.",
        "@param2": "implementationAddress address of the implementation contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getImplementationAddress",
        "visibility": "external",
        "args": [
            {
                "name": "interfaceName",
                "type": "bytes32"
            }
        ],
        "func": "function getImplementationAddress(bytes32 interfaceName) external override view returns (address) {\n        address implementationAddress = interfacesImplemented[interfaceName];\n        require(implementationAddress != address(0x0), \"Implementation not found\");\n        return implementationAddress;\n    }",
        "comments": [
            "/**",
            "     * @notice Gets the address of the contract that implements the given `interfaceName`.",
            "     * @param interfaceName queried interface.",
            "     * @return implementationAddress address of the defined interface.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets the address of the contract that implements the given `interfaceName`.\n     * @param interfaceName queried interface.\n     * @return implementationAddress address of the defined interface.\n     */\n",
        "@notice": "Gets the address of the contract that implements the given `interfaceName`.",
        "@param1": "interfaceName queried interface.",
        "@return1": "implementationAddress address of the defined interface.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapFromUnscaledUint",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            }
        ],
        "func": "function wrapFromUnscaledUint(uint256 a) external pure returns (uint256) {\n        return FixedPoint.fromUnscaledUint(a).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapIsEqual",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapIsEqual(uint256 a, uint256 b) external pure returns (bool) {\n        return FixedPoint.Unsigned(a).isEqual(FixedPoint.Unsigned(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsEqual",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedIsEqual(uint256 a, uint256 b) external pure returns (bool) {\n        return FixedPoint.Unsigned(a).isEqual(b);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapIsGreaterThan",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapIsGreaterThan(uint256 a, uint256 b) external pure returns (bool) {\n        return FixedPoint.Unsigned(a).isGreaterThan(FixedPoint.Unsigned(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapIsGreaterThanOrEqual",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapIsGreaterThanOrEqual(uint256 a, uint256 b) external pure returns (bool) {\n        return FixedPoint.Unsigned(a).isGreaterThanOrEqual(FixedPoint.Unsigned(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsGreaterThan",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedIsGreaterThan(uint256 a, uint256 b) external pure returns (bool) {\n        return FixedPoint.Unsigned(a).isGreaterThan(b);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsGreaterThanOrEqual",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedIsGreaterThanOrEqual(uint256 a, uint256 b) external pure returns (bool) {\n        return FixedPoint.Unsigned(a).isGreaterThanOrEqual(b);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsGreaterThanOpposite",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedIsGreaterThanOpposite(uint256 a, uint256 b) external pure returns (bool) {\n        return a.isGreaterThan(FixedPoint.Unsigned(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsGreaterThanOrEqualOpposite",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedIsGreaterThanOrEqualOpposite(uint256 a, uint256 b) external pure returns (bool) {\n        return a.isGreaterThanOrEqual(FixedPoint.Unsigned(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapIsLessThan",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapIsLessThan(uint256 a, uint256 b) external pure returns (bool) {\n        return FixedPoint.Unsigned(a).isLessThan(FixedPoint.Unsigned(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapIsLessThanOrEqual",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapIsLessThanOrEqual(uint256 a, uint256 b) external pure returns (bool) {\n        return FixedPoint.Unsigned(a).isLessThanOrEqual(FixedPoint.Unsigned(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsLessThan",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedIsLessThan(uint256 a, uint256 b) external pure returns (bool) {\n        return FixedPoint.Unsigned(a).isLessThan(b);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsLessThanOrEqual",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedIsLessThanOrEqual(uint256 a, uint256 b) external pure returns (bool) {\n        return FixedPoint.Unsigned(a).isLessThanOrEqual(b);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsLessThanOpposite",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedIsLessThanOpposite(uint256 a, uint256 b) external pure returns (bool) {\n        return a.isLessThan(FixedPoint.Unsigned(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedIsLessThanOrEqualOpposite",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedIsLessThanOrEqualOpposite(uint256 a, uint256 b) external pure returns (bool) {\n        return a.isLessThanOrEqual(FixedPoint.Unsigned(b));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMin",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMin(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).min(FixedPoint.Unsigned(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMax",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMax(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).max(FixedPoint.Unsigned(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapAdd",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapAdd(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).add(FixedPoint.Unsigned(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedAdd",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedAdd(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).add(b).rawValue;\n    }",
        "comments": [
            "",
            "    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.",
            "    "
        ],
        "comt": "\n    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapSub",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapSub(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).sub(FixedPoint.Unsigned(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedSub",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedSub(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).sub(b).rawValue;\n    }",
        "comments": [
            "",
            "    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.",
            "    "
        ],
        "comt": "\n    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedSubOpposite",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedSubOpposite(uint256 a, uint256 b) external pure returns (uint256) {\n        return a.sub(FixedPoint.Unsigned(b)).rawValue;\n    }",
        "comments": [
            "",
            "    // The second uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.",
            "    "
        ],
        "comt": "\n    // The second uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMul",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMul(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).mul(FixedPoint.Unsigned(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMulCeil",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMulCeil(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).mulCeil(FixedPoint.Unsigned(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedMul",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedMul(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).mul(b).rawValue;\n    }",
        "comments": [
            "",
            "    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.",
            "    "
        ],
        "comt": "\n    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedMulCeil",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedMulCeil(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).mulCeil(b).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapDiv",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapDiv(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).div(FixedPoint.Unsigned(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapDivCeil",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapDivCeil(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).divCeil(FixedPoint.Unsigned(b)).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedDiv",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedDiv(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).div(b).rawValue;\n    }",
        "comments": [
            "",
            "    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.",
            "    "
        ],
        "comt": "\n    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedDivCeil",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedDivCeil(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).divCeil(b).rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapMixedDivOpposite",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapMixedDivOpposite(uint256 a, uint256 b) external pure returns (uint256) {\n        return a.div(FixedPoint.Unsigned(b)).rawValue;\n    }",
        "comments": [
            "",
            "    // The second uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.",
            "    "
        ],
        "comt": "\n    // The second uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapPow",
        "visibility": "external",
        "args": [
            {
                "name": "a",
                "type": "uint256"
            },
            {
                "name": "b",
                "type": "uint256"
            }
        ],
        "func": "function wrapPow(uint256 a, uint256 b) external pure returns (uint256) {\n        return FixedPoint.Unsigned(a).pow(b).rawValue;\n    }",
        "comments": [
            "",
            "    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.",
            "    "
        ],
        "comt": "\n    // The first uint256 is interpreted with a scaling factor and is converted to an `Unsigned` directly.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "propose",
        "visibility": "public",
        "args": [
            {
                "name": "transactions",
                "type": "Transaction[] memory"
            }
        ],
        "func": "function propose(Transaction[] memory transactions) public onlyRoleHolder(uint256(Roles.Proposer)) {\n        uint256 id = proposals.length;\n        uint256 time = getCurrentTime();\n\n        // Note: doing all of this array manipulation manually is necessary because directly setting an array of\n        // structs in storage to an an array of structs in memory is currently not implemented in solidity :/.\n\n        // Add a zero-initialized element to the proposals array.\n        proposals.push();\n\n        // Initialize the new proposal.\n        Proposal storage proposal = proposals[id];\n        proposal.requestTime = time;\n\n        // Initialize the transaction array.\n        for (uint256 i = 0; i < transactions.length; i++) {\n            require(transactions[i].to != address(0), \"The `to` address cannot be 0x0\");\n            // If the transaction has any data with it the recipient must be a contract, not an EOA.\n            if (transactions[i].data.length > 0) {\n                require(transactions[i].to.isContract(), \"EOA can't accept tx with data\");\n            }\n            proposal.transactions.push(transactions[i]);\n        }\n\n        bytes32 identifier = _constructIdentifier(id);\n\n        // Request a vote on this proposal in the DVM.\n        OracleInterface oracle = _getOracle();\n        IdentifierWhitelistInterface supportedIdentifiers = _getIdentifierWhitelist();\n        supportedIdentifiers.addSupportedIdentifier(identifier);\n\n        oracle.requestPrice(identifier, time);\n        supportedIdentifiers.removeSupportedIdentifier(identifier);\n\n        emit NewProposal(id, transactions);\n    }",
        "comments": [
            "/**",
            "     * @notice Proposes a new governance action. Can only be called by the holder of the Proposer role.",
            "     * @param transactions list of transactions that are being proposed.",
            "     * @dev You can create the data portion of each transaction by doing the following:",
            "     * ```",
            "     * const truffleContractInstance = await TruffleContract.deployed()",
            "     * const data = truffleContractInstance.methods.methodToCall(arg1, arg2).encodeABI()",
            "     * ```",
            "     * Note: this method must be public because of a solidity limitation that",
            "     * disallows structs arrays to be passed to external functions.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Proposes a new governance action. Can only be called by the holder of the Proposer role.\n     * @param transactions list of transactions that are being proposed.\n     * @dev You can create the data portion of each transaction by doing the following:\n     * ```\n     * const truffleContractInstance = await TruffleContract.deployed()\n     * const data = truffleContractInstance.methods.methodToCall(arg1, arg2).encodeABI()\n     * ```\n     * Note: this method must be public because of a solidity limitation that\n     * disallows structs arrays to be passed to external functions.\n     */\n",
        "@notice": "Proposes a new governance action. Can only be called by the holder of the Proposer role.",
        "@param1": "transactions list of transactions that are being proposed.",
        "@dev": "You can create the data portion of each transaction by doing the following: * ``` * const truffleContractInstance = await TruffleContract.deployed() * const data = truffleContractInstance.methods.methodToCall(arg1, arg2).encodeABI() * ``` * Note: this method must be public because of a solidity limitation that * disallows structs arrays to be passed to external functions.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "executeProposal",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint256"
            },
            {
                "name": "transactionIndex",
                "type": "uint256"
            }
        ],
        "func": "function executeProposal(uint256 id, uint256 transactionIndex) external payable {\n        Proposal storage proposal = proposals[id];\n        int256 price = _getOracle().getPrice(_constructIdentifier(id), proposal.requestTime);\n\n        Transaction memory transaction = proposal.transactions[transactionIndex];\n\n        require(\n            transactionIndex == 0 || proposal.transactions[transactionIndex.sub(1)].to == address(0),\n            \"Previous tx not yet executed\"\n        );\n        require(transaction.to != address(0), \"Tx already executed\");\n        require(price != 0, \"Proposal was rejected\");\n        require(msg.value == transaction.value, \"Must send exact amount of ETH\");\n\n        // Delete the transaction before execution to avoid any potential re-entrancy issues.\n        delete proposal.transactions[transactionIndex];\n\n        require(_executeCall(transaction.to, transaction.value, transaction.data), \"Tx execution failed\");\n\n        emit ProposalExecuted(id, transactionIndex);\n    }",
        "comments": [
            "/**",
            "     * @notice Executes a proposed governance action that has been approved by voters.",
            "     * @dev This can be called by any address. Caller is expected to send enough ETH to execute payable transactions.",
            "     * @param id unique id for the executed proposal.",
            "     * @param transactionIndex unique transaction index for the executed proposal.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Executes a proposed governance action that has been approved by voters.\n     * @dev This can be called by any address. Caller is expected to send enough ETH to execute payable transactions.\n     * @param id unique id for the executed proposal.\n     * @param transactionIndex unique transaction index for the executed proposal.\n     */\n",
        "@notice": "Executes a proposed governance action that has been approved by voters.",
        "@dev": "This can be called by any address. Caller is expected to send enough ETH to execute payable transactions.",
        "@param1": "id unique id for the executed proposal.",
        "@param2": "transactionIndex unique transaction index for the executed proposal.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "numProposals",
        "visibility": "external",
        "args": [],
        "func": "function numProposals() external view returns (uint256) {\n        return proposals.length;\n    }",
        "comments": [
            "/**",
            "     * @notice Gets the total number of proposals (includes executed and non-executed).",
            "     * @return uint256 representing the current number of proposals.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets the total number of proposals (includes executed and non-executed).\n     * @return uint256 representing the current number of proposals.\n     */\n",
        "@notice": "Gets the total number of proposals (includes executed and non-executed).",
        "@return1": "uint256 representing the current number of proposals.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getProposal",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function getProposal(uint256 id) external view returns (Proposal memory) {\n        return proposals[id];\n    }",
        "comments": [
            "/**",
            "     * @notice Gets the proposal data for a particular id.",
            "     * @dev after a proposal is executed, its data will be zeroed out, except for the request time.",
            "     * @param id uniquely identify the identity of the proposal.",
            "     * @return proposal struct containing transactions[] and requestTime.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets the proposal data for a particular id.\n     * @dev after a proposal is executed, its data will be zeroed out, except for the request time.\n     * @param id uniquely identify the identity of the proposal.\n     * @return proposal struct containing transactions[] and requestTime.\n     */\n",
        "@notice": "Gets the proposal data for a particular id.",
        "@dev": "after a proposal is executed, its data will be zeroed out, except for the request time.",
        "@param1": "id uniquely identify the identity of the proposal.",
        "@return1": "proposal struct containing transactions[] and requestTime.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addPrefix",
        "visibility": "external",
        "args": [
            {
                "name": "input",
                "type": "bytes32"
            },
            {
                "name": "prefix",
                "type": "bytes32"
            },
            {
                "name": "prefixLength",
                "type": "uint256"
            }
        ],
        "func": "function addPrefix(\n        bytes32 input,\n        bytes32 prefix,\n        uint256 prefixLength\n    ) external pure returns (bytes32) {\n        return _addPrefix(input, prefix, prefixLength);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "uintToUtf8",
        "visibility": "external",
        "args": [
            {
                "name": "v",
                "type": "uint256"
            }
        ],
        "func": "function uintToUtf8(uint256 v) external pure returns (bytes32 ret) {\n        return _uintToUtf8(v);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "constructIdentifier",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function constructIdentifier(uint256 id) external pure returns (bytes32 identifier) {\n        return _constructIdentifier(id);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getHubAddr",
        "visibility": "public",
        "args": [],
        "func": "function getHubAddr() public view override returns (address) {\n        return _relayHub;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the address of the {IRelayHub} contract for this recipient.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the address of the {IRelayHub} contract for this recipient.\n     */\n",
        "@dev": "Returns the address of the {IRelayHub} contract for this recipient.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "relayHubVersion",
        "visibility": "public",
        "args": [],
        "func": "function relayHubVersion() public view returns (string memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return \"1.0.0\";\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "preRelayedCall",
        "visibility": "public",
        "args": [
            {
                "name": "context",
                "type": "bytes memory"
            }
        ],
        "func": "function preRelayedCall(bytes memory context) public virtual override returns (bytes32) {\n        require(msg.sender == getHubAddr(), \"GSNRecipient: caller is not RelayHub\");\n        return _preRelayedCall(context);\n    }",
        "comments": [
            "",
            "    // Base implementations for pre and post relayedCall: only RelayHub can invoke them, and data is forwarded to the",
            "    // internal hook.",
            "",
            "    /**",
            "     * @dev See `IRelayRecipient.preRelayedCall`.",
            "     *",
            "     * This function should not be overriden directly, use `_preRelayedCall` instead.",
            "     *",
            "     * * Requirements:",
            "     *",
            "     * - the caller must be the `RelayHub` contract.",
            "     */",
            "    "
        ],
        "comt": "\n    // Base implementations for pre and post relayedCall: only RelayHub can invoke them, and data is forwarded to the\n    // internal hook.\n\n    /**\n     * @dev See `IRelayRecipient.preRelayedCall`.\n     *\n     * This function should not be overriden directly, use `_preRelayedCall` instead.\n     *\n     * * Requirements:\n     *\n     * - the caller must be the `RelayHub` contract.\n     */\n    ",
        "@dev": "See `IRelayRecipient.preRelayedCall`. * * This function should not be overriden directly, use `_preRelayedCall` instead. * * * Requirements: * * - the caller must be the `RelayHub` contract.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "postRelayedCall",
        "visibility": "public",
        "args": [
            {
                "name": "context",
                "type": "bytes memory"
            },
            {
                "name": "success",
                "type": "bool"
            },
            {
                "name": "actualCharge",
                "type": "uint256"
            },
            {
                "name": "preRetVal",
                "type": "bytes32"
            }
        ],
        "func": "function postRelayedCall(bytes memory context, bool success, uint256 actualCharge, bytes32 preRetVal) public virtual override {\n        require(msg.sender == getHubAddr(), \"GSNRecipient: caller is not RelayHub\");\n        _postRelayedCall(context, success, actualCharge, preRetVal);\n    }",
        "comments": [
            "/**",
            "     * @dev See `IRelayRecipient.postRelayedCall`.",
            "     *",
            "     * This function should not be overriden directly, use `_postRelayedCall` instead.",
            "     *",
            "     * * Requirements:",
            "     *",
            "     * - the caller must be the `RelayHub` contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See `IRelayRecipient.postRelayedCall`.\n     *\n     * This function should not be overriden directly, use `_postRelayedCall` instead.\n     *\n     * * Requirements:\n     *\n     * - the caller must be the `RelayHub` contract.\n     */\n",
        "@dev": "See `IRelayRecipient.postRelayedCall`. * * This function should not be overriden directly, use `_postRelayedCall` instead. * * * Requirements: * * - the caller must be the `RelayHub` contract.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "token",
        "visibility": "public",
        "args": [],
        "func": "function token() public view returns (IERC20) {\n        return IERC20(_token);\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the gas payment token.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the gas payment token.\n     */\n",
        "@dev": "Returns the gas payment token.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "acceptRelayedCall",
        "visibility": "public",
        "args": [
            {
                "name": "address",
                "type": "address"
            },
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "memory",
                "type": "bytes"
            },
            {
                "name": "transactionFee",
                "type": "uint256"
            },
            {
                "name": "gasPrice",
                "type": "uint256"
            },
            {
                "name": "uint256",
                "type": "uint256"
            },
            {
                "name": "uint256",
                "type": "uint256"
            },
            {
                "name": "memory",
                "type": "bytes"
            },
            {
                "name": "maxPossibleCharge",
                "type": "uint256"
            }
        ],
        "func": "function acceptRelayedCall(\n        address,\n        address from,\n        bytes memory,\n        uint256 transactionFee,\n        uint256 gasPrice,\n        uint256,\n        uint256,\n        bytes memory,\n        uint256 maxPossibleCharge\n    )\n        public\n        view\n        virtual\n        override\n        returns (uint256, bytes memory)\n    {\n        if (_token.balanceOf(from) < maxPossibleCharge) {\n            return _rejectRelayedCall(uint256(GSNRecipientERC20FeeErrorCodes.INSUFFICIENT_BALANCE));\n        }\n\n        return _approveRelayedCall(abi.encode(from, maxPossibleCharge, transactionFee, gasPrice));\n    }",
        "comments": [
            "/**",
            "     * @dev Ensures that only users with enough gas payment token balance can have transactions relayed through the GSN.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Ensures that only users with enough gas payment token balance can have transactions relayed through the GSN.\n     */\n",
        "@dev": "Ensures that only users with enough gas payment token balance can have transactions relayed through the GSN.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function mint(address account, uint256 amount) public onlyOwner {\n        _mint(account, amount);\n    }",
        "comments": [
            "",
            "    // The owner (GSNRecipientERC20Fee) can mint tokens",
            "    "
        ],
        "comt": "\n    // The owner (GSNRecipientERC20Fee) can mint tokens\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allowance",
        "visibility": "public",
        "args": [
            {
                "name": "tokenOwner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            }
        ],
        "func": "function allowance(address tokenOwner, address spender) public view override returns (uint256) {\n        if (spender == owner()) {\n            return _UINT256_MAX;\n        } else {\n            return super.allowance(tokenOwner, spender);\n        }\n    }",
        "comments": [
            "",
            "    // The owner has 'infinite' allowance for all token holders",
            "    "
        ],
        "comt": "\n    // The owner has 'infinite' allowance for all token holders\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        if (recipient == owner()) {\n            _transfer(sender, recipient, amount);\n            return true;\n        } else {\n            return super.transferFrom(sender, recipient, amount);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "acceptRelayedCall",
        "visibility": "public",
        "args": [
            {
                "name": "relay",
                "type": "address"
            },
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "encodedFunction",
                "type": "bytes memory"
            },
            {
                "name": "transactionFee",
                "type": "uint256"
            },
            {
                "name": "gasPrice",
                "type": "uint256"
            },
            {
                "name": "gasLimit",
                "type": "uint256"
            },
            {
                "name": "nonce",
                "type": "uint256"
            },
            {
                "name": "approvalData",
                "type": "bytes memory"
            },
            {
                "name": "uint256",
                "type": "uint256"
            }
        ],
        "func": "function acceptRelayedCall(\n        address relay,\n        address from,\n        bytes memory encodedFunction,\n        uint256 transactionFee,\n        uint256 gasPrice,\n        uint256 gasLimit,\n        uint256 nonce,\n        bytes memory approvalData,\n        uint256\n    )\n        public\n        view\n        virtual\n        override\n        returns (uint256, bytes memory)\n    {\n        bytes memory blob = abi.encodePacked(\n            relay,\n            from,\n            encodedFunction,\n            transactionFee,\n            gasPrice,\n            gasLimit,\n            nonce, // Prevents replays on RelayHub\n            getHubAddr(), // Prevents replays in multiple RelayHubs\n            address(this) // Prevents replays in multiple recipients\n        );\n        if (keccak256(blob).toEthSignedMessageHash().recover(approvalData) == _trustedSigner) {\n            return _approveRelayedCall();\n        } else {\n            return _rejectRelayedCall(uint256(GSNRecipientSignatureErrorCodes.INVALID_SIGNER));\n        }\n    }",
        "comments": [
            "/**",
            "     * @dev Ensures that only transactions with a trusted signature can be relayed through the GSN.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Ensures that only transactions with a trusted signature can be relayed through the GSN.\n     */\n",
        "@dev": "Ensures that only transactions with a trusted signature can be relayed through the GSN.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addSupportedIdentifier",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            }
        ],
        "func": "function addSupportedIdentifier(bytes32 identifier) external override onlyOwner {\n        if (!supportedIdentifiers[identifier]) {\n            supportedIdentifiers[identifier] = true;\n            emit SupportedIdentifierAdded(identifier);\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Adds the provided identifier as a supported identifier.",
            "     * @dev Price requests using this identifier will succeed after this call.",
            "     * @param identifier unique UTF-8 representation for the feed being added. Eg: BTC/USD.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Adds the provided identifier as a supported identifier.\n     * @dev Price requests using this identifier will succeed after this call.\n     * @param identifier unique UTF-8 representation for the feed being added. Eg: BTC/USD.\n     */\n",
        "@notice": "Adds the provided identifier as a supported identifier.",
        "@dev": "Price requests using this identifier will succeed after this call.",
        "@param1": "identifier unique UTF-8 representation for the feed being added. Eg: BTC/USD.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeSupportedIdentifier",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            }
        ],
        "func": "function removeSupportedIdentifier(bytes32 identifier) external override onlyOwner {\n        if (supportedIdentifiers[identifier]) {\n            supportedIdentifiers[identifier] = false;\n            emit SupportedIdentifierRemoved(identifier);\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Removes the identifier from the whitelist.",
            "     * @dev Price requests using this identifier will no longer succeed after this call.",
            "     * @param identifier unique UTF-8 representation for the feed being removed. Eg: BTC/USD.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Removes the identifier from the whitelist.\n     * @dev Price requests using this identifier will no longer succeed after this call.\n     * @param identifier unique UTF-8 representation for the feed being removed. Eg: BTC/USD.\n     */\n",
        "@notice": "Removes the identifier from the whitelist.",
        "@dev": "Price requests using this identifier will no longer succeed after this call.",
        "@param1": "identifier unique UTF-8 representation for the feed being removed. Eg: BTC/USD.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isIdentifierSupported",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            }
        ],
        "func": "function isIdentifierSupported(bytes32 identifier) external override view returns (bool) {\n        return supportedIdentifiers[identifier];\n    }",
        "comments": [
            "/**",
            "     * @notice Checks whether an identifier is on the whitelist.",
            "     * @param identifier unique UTF-8 representation for the feed being queried. Eg: BTC/USD.",
            "     * @return bool if the identifier is supported (or not).",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Checks whether an identifier is on the whitelist.\n     * @param identifier unique UTF-8 representation for the feed being queried. Eg: BTC/USD.\n     * @return bool if the identifier is supported (or not).\n     */\n",
        "@notice": "Checks whether an identifier is on the whitelist.",
        "@param1": "identifier unique UTF-8 representation for the feed being queried. Eg: BTC/USD.",
        "@return1": "bool if the identifier is supported (or not).",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "computeReturn",
        "visibility": "external",
        "args": [
            {
                "name": "oldPrice",
                "type": "int256"
            },
            {
                "name": "newPrice",
                "type": "int256"
            }
        ],
        "func": "function computeReturn(int256 oldPrice, int256 newPrice) external override view returns (int256 assetReturn) {\n        if (oldPrice == 0) {\n            // To avoid a divide-by-zero, just return 0 instead of hitting an exception.\n            return 0;\n        }\n\n        // Compute the underlying asset return: +1% would be 1.01 (* 1 ether).\n        int256 underlyingAssetReturn = newPrice.mul(FP_SCALING_FACTOR).div(oldPrice);\n\n        // Compute the RoR of the underlying asset and multiply by leverageMultiplier to get the modified return.\n        assetReturn = underlyingAssetReturn.sub(FP_SCALING_FACTOR).mul(leverageMultiplier);\n\n        // If oldPrice is < 0, we need to flip the sign to keep returns positively correlated with\n        // leverageMultiplier * price diffs.\n        if (oldPrice < 0) {\n            assetReturn = assetReturn.mul(-1);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "leverage",
        "visibility": "external",
        "args": [],
        "func": "function leverage() external override view returns (int256 _leverage) {\n        return leverageMultiplier;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createLiquidation",
        "visibility": "external",
        "args": [
            {
                "name": "sponsor",
                "type": "address"
            },
            {
                "name": "collateralPerToken",
                "type": "FixedPoint.Unsigned calldata"
            },
            {
                "name": "maxTokensToLiquidate",
                "type": "FixedPoint.Unsigned calldata"
            }
        ],
        "func": "function createLiquidation(\n        address sponsor,\n        FixedPoint.Unsigned calldata collateralPerToken,\n        FixedPoint.Unsigned calldata maxTokensToLiquidate\n    )\n        external\n        fees()\n        onlyPreExpiration()\n        returns (\n            uint256 liquidationId,\n            FixedPoint.Unsigned memory tokensLiquidated,\n            FixedPoint.Unsigned memory finalFeeBond\n        )\n    {\n        // Retrieve Position data for sponsor\n        PositionData storage positionToLiquidate = _getPositionData(sponsor);\n\n        tokensLiquidated = FixedPoint.min(maxTokensToLiquidate, positionToLiquidate.tokensOutstanding);\n        // TODO: Limit liquidations from being too small or very close to 100% without being exactly 100%.\n        FixedPoint.Unsigned memory ratio = tokensLiquidated.div(positionToLiquidate.tokensOutstanding);\n\n        // Starting values for the Position being liquidated.\n        // If withdrawal request amount is > position's collateral, then set this to 0, otherwise set it to (startCollateral - withdrawal request amount).\n        FixedPoint.Unsigned memory startCollateral = _getCollateral(positionToLiquidate.rawCollateral);\n        FixedPoint.Unsigned memory startCollateralNetOfWithdrawal = FixedPoint.fromUnscaledUint(0);\n        if (positionToLiquidate.withdrawalRequestAmount.isLessThanOrEqual(startCollateral)) {\n            startCollateralNetOfWithdrawal = startCollateral.sub(positionToLiquidate.withdrawalRequestAmount);\n        }\n\n        // Scoping to get rid of a stack too deep error.\n        {\n            FixedPoint.Unsigned memory startTokens = positionToLiquidate.tokensOutstanding;\n\n            // Check the max price constraint to ensure that the Position's collateralization ratio hasn't increased beyond\n            // what the liquidator was willing to liquidate at.\n            // collateralPerToken >= startCollateralNetOfWithdrawal / startTokens.\n            require(collateralPerToken.mul(startTokens).isGreaterThanOrEqual(startCollateralNetOfWithdrawal));\n        }\n\n        // The actual amount of collateral that gets moved to the liquidation.\n        FixedPoint.Unsigned memory lockedCollateral = startCollateral.mul(ratio);\n        // For purposes of disputes, it's actually this liquidatedCollateral value that's used. This value is net of\n        // withdrawal requests.\n        FixedPoint.Unsigned memory liquidatedCollateral = startCollateralNetOfWithdrawal.mul(ratio);\n        // Part of the withdrawal request is also removed. Ideally:\n        // liquidatedCollateral + withdrawalAmountToRemove = lockedCollateral.\n        FixedPoint.Unsigned memory withdrawalAmountToRemove = positionToLiquidate.withdrawalRequestAmount.mul(ratio);\n\n        // Compute final fee at time of liquidation.\n        finalFeeBond = _computeFinalFees();\n\n        // Construct liquidation object.\n        // Note: all dispute-related values are just zeroed out until a dispute occurs.\n        // liquidationId is the index of the new LiquidationData that we will push into the array,\n        // which is equal to the current length of the array pre-push.\n        liquidationId = liquidations[sponsor].length;\n        liquidations[sponsor].push(\n            LiquidationData({\n                sponsor: sponsor,\n                liquidator: msg.sender,\n                state: Status.PreDispute,\n                liquidationTime: getCurrentTime(),\n                tokensOutstanding: tokensLiquidated,\n                lockedCollateral: lockedCollateral,\n                liquidatedCollateral: liquidatedCollateral,\n                rawUnitCollateral: _convertCollateral(FixedPoint.fromUnscaledUint(1)),\n                disputer: address(0),\n                settlementPrice: FixedPoint.fromUnscaledUint(0),\n                finalFee: finalFeeBond\n            })\n        );\n\n        // Adjust the sponsor's remaining position.\n        _reduceSponsorPosition(sponsor, tokensLiquidated, lockedCollateral, withdrawalAmountToRemove);\n\n        // Add to the global liquidation collateral count.\n        _addCollateral(rawLiquidationCollateral, lockedCollateral.add(finalFeeBond));\n\n        // Destroy tokens\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), tokensLiquidated.rawValue);\n        tokenCurrency.burn(tokensLiquidated.rawValue);\n\n        // Pull final fee from liquidator.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), finalFeeBond.rawValue);\n\n        emit LiquidationCreated(\n            sponsor,\n            msg.sender,\n            liquidationId,\n            tokensLiquidated.rawValue,\n            lockedCollateral.rawValue,\n            liquidatedCollateral.rawValue\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Liquidates the sponsor's position if the caller has enough",
            "     * synthetic tokens to retire the position's outstanding tokens.",
            "     * @dev This method generates an ID that will uniquely identify liquidation for the sponsor.",
            "     * @param sponsor address to liquidate.",
            "     * @param collateralPerToken abort the liquidation if the position's collateral per token exceeds this value.",
            "     * @param maxTokensToLiquidate max number of tokes to liquidate.",
            "     * @return liquidationId of the newly created liquidation.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Liquidates the sponsor's position if the caller has enough\n     * synthetic tokens to retire the position's outstanding tokens.\n     * @dev This method generates an ID that will uniquely identify liquidation for the sponsor.\n     * @param sponsor address to liquidate.\n     * @param collateralPerToken abort the liquidation if the position's collateral per token exceeds this value.\n     * @param maxTokensToLiquidate max number of tokes to liquidate.\n     * @return liquidationId of the newly created liquidation.\n     */\n",
        "@notice": "Liquidates the sponsor's position if the caller has enough * synthetic tokens to retire the position's outstanding tokens.",
        "@dev": "This method generates an ID that will uniquely identify liquidation for the sponsor.",
        "@param1": "sponsor address to liquidate.",
        "@param2": "collateralPerToken abort the liquidation if the position's collateral per token exceeds this value.",
        "@param3": "maxTokensToLiquidate max number of tokes to liquidate.",
        "@return1": "liquidationId of the newly created liquidation.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "dispute",
        "visibility": "external",
        "args": [
            {
                "name": "liquidationId",
                "type": "uint256"
            },
            {
                "name": "sponsor",
                "type": "address"
            }
        ],
        "func": "function dispute(uint256 liquidationId, address sponsor)\n        external\n        disputable(liquidationId, sponsor)\n        fees()\n        returns (FixedPoint.Unsigned memory totalPaid)\n    {\n        LiquidationData storage disputedLiquidation = _getLiquidationData(sponsor, liquidationId);\n\n        // Multiply by the unit collateral so the dispute bond is a percentage of the locked collateral after fees.\n        FixedPoint.Unsigned memory disputeBondAmount = disputedLiquidation.lockedCollateral.mul(disputeBondPct).mul(\n            _getCollateral(disputedLiquidation.rawUnitCollateral)\n        );\n        _addCollateral(rawLiquidationCollateral, disputeBondAmount);\n\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), disputeBondAmount.rawValue);\n\n        // Request a price from DVM,\n        // Liquidation is pending dispute until DVM returns a price\n        disputedLiquidation.state = Status.PendingDispute;\n        disputedLiquidation.disputer = msg.sender;\n\n        // Enqueue a request with the DVM.\n        _requestOraclePrice(disputedLiquidation.liquidationTime);\n\n        // Pay a final fee.\n        _payFinalFees(msg.sender, disputedLiquidation.finalFee);\n\n        emit LiquidationDisputed(\n            sponsor,\n            disputedLiquidation.liquidator,\n            msg.sender,\n            liquidationId,\n            disputeBondAmount.rawValue\n        );\n\n        return disputeBondAmount.add(disputedLiquidation.finalFee);\n    }",
        "comments": [
            "/**",
            "     * @notice Disputes a liquidation, if the caller has enough collateral to post a dispute bond",
            "     * and pay a fixed final fee charged on each price request.",
            "     * @dev Can only dispute a liquidation before the liquidation expires and if there are no other pending disputes.",
            "     * @param liquidationId of the disputed liquidation.",
            "     * @param sponsor the address of the sponsor who's liquidation is being disputed.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Disputes a liquidation, if the caller has enough collateral to post a dispute bond\n     * and pay a fixed final fee charged on each price request.\n     * @dev Can only dispute a liquidation before the liquidation expires and if there are no other pending disputes.\n     * @param liquidationId of the disputed liquidation.\n     * @param sponsor the address of the sponsor who's liquidation is being disputed.\n     */\n",
        "@notice": "Disputes a liquidation, if the caller has enough collateral to post a dispute bond * and pay a fixed final fee charged on each price request.",
        "@dev": "Can only dispute a liquidation before the liquidation expires and if there are no other pending disputes.",
        "@param1": "liquidationId of the disputed liquidation.",
        "@param2": "sponsor the address of the sponsor who's liquidation is being disputed.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawLiquidation",
        "visibility": "public",
        "args": [
            {
                "name": "liquidationId",
                "type": "uint256"
            },
            {
                "name": "sponsor",
                "type": "address"
            }
        ],
        "func": "function withdrawLiquidation(uint256 liquidationId, address sponsor)\n        public\n        withdrawable(liquidationId, sponsor)\n        fees()\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\n        require(\n            (msg.sender == liquidation.disputer) ||\n                (msg.sender == liquidation.liquidator) ||\n                (msg.sender == liquidation.sponsor)\n        );\n\n        // Settles the liquidation if necessary.\n        // Note: this will fail if the price has not resolved yet.\n        _settle(liquidationId, sponsor);\n\n        // Calculate rewards as a function of the TRV. Note: all payouts are scaled by the unit collateral value so\n        // all payouts are charged the fees pro rata.\n        FixedPoint.Unsigned memory feeAttenuation = _getCollateral(liquidation.rawUnitCollateral);\n        FixedPoint.Unsigned memory tokenRedemptionValue = liquidation\n            .tokensOutstanding\n            .mul(liquidation.settlementPrice)\n            .mul(feeAttenuation);\n        FixedPoint.Unsigned memory collateral = liquidation.lockedCollateral.mul(feeAttenuation);\n        FixedPoint.Unsigned memory disputerDisputeReward = disputerDisputeRewardPct.mul(tokenRedemptionValue);\n        FixedPoint.Unsigned memory sponsorDisputeReward = sponsorDisputeRewardPct.mul(tokenRedemptionValue);\n        FixedPoint.Unsigned memory disputeBondAmount = collateral.mul(disputeBondPct);\n        FixedPoint.Unsigned memory finalFee = liquidation.finalFee.mul(feeAttenuation);\n\n        // There are three main outcome states: either the dispute succeeded, failed or was not updated.\n        // Based on the state, different parties of a liquidation can withdraw different amounts.\n        // Once a caller has been paid their address deleted from the struct.\n        // This prevents them from being paid multiple from times the same liquidation.\n        FixedPoint.Unsigned memory withdrawalAmount;\n        if (liquidation.state == Status.DisputeSucceeded) {\n            // If the dispute is successful then all three users can withdraw from the contract.\n            if (msg.sender == liquidation.disputer) {\n                // Pay DISPUTER: disputer reward + dispute bond + returned final fee\n                FixedPoint.Unsigned memory payToDisputer = disputerDisputeReward.add(disputeBondAmount).add(finalFee);\n                withdrawalAmount = withdrawalAmount.add(payToDisputer);\n                delete liquidation.disputer;\n            }\n\n            if (msg.sender == liquidation.sponsor) {\n                // Pay SPONSOR: remaining collateral (collateral - TRV) + sponsor reward\n                FixedPoint.Unsigned memory remainingCollateral = collateral.sub(tokenRedemptionValue);\n                FixedPoint.Unsigned memory payToSponsor = sponsorDisputeReward.add(remainingCollateral);\n                withdrawalAmount = withdrawalAmount.add(payToSponsor);\n                delete liquidation.sponsor;\n            }\n\n            if (msg.sender == liquidation.liquidator) {\n                // Pay LIQUIDATOR: TRV - dispute reward - sponsor reward\n                // If TRV > Collateral, then subtract rewards from collateral\n                // NOTE: This should never be below zero since we prevent (sponsorDisputePct+disputerDisputePct) >= 0 in\n                // the constructor when these params are set\n                FixedPoint.Unsigned memory payToLiquidator = tokenRedemptionValue.sub(sponsorDisputeReward).sub(\n                    disputerDisputeReward\n                );\n                withdrawalAmount = withdrawalAmount.add(payToLiquidator);\n                delete liquidation.liquidator;\n            }\n\n            // Free up space once all collateral is withdrawn\n            if (\n                liquidation.disputer == address(0) &&\n                liquidation.sponsor == address(0) &&\n                liquidation.liquidator == address(0)\n            ) {\n                delete liquidations[sponsor][liquidationId];\n            }\n            // In the case of a failed dispute only the liquidator can withdraw.\n        } else if (liquidation.state == Status.DisputeFailed && msg.sender == liquidation.liquidator) {\n            // Pay LIQUIDATOR: collateral + dispute bond + returned final fee\n            withdrawalAmount = collateral.add(disputeBondAmount).add(finalFee);\n            delete liquidations[sponsor][liquidationId];\n            // If the state is pre-dispute but time has passed liveness then the dispute failed and the liquidator can withdraw\n        } else if (liquidation.state == Status.PreDispute && msg.sender == liquidation.liquidator) {\n            // Pay LIQUIDATOR: collateral + returned final fee\n            withdrawalAmount = collateral.add(finalFee);\n            delete liquidations[sponsor][liquidationId];\n        }\n\n        require(withdrawalAmount.isGreaterThan(0));\n        amountWithdrawn = _removeCollateral(rawLiquidationCollateral, withdrawalAmount);\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n\n        emit LiquidationWithdrawn(msg.sender, amountWithdrawn.rawValue, liquidation.state);\n    }",
        "comments": [
            "/**",
            "     * @notice After a dispute has settled or after a non-disputed liquidation has expired,",
            "     * the sponsor, liquidator, and/or disputer can call this method to receive payments.",
            "     * @dev If the dispute SUCCEEDED: the sponsor, liquidator, and disputer are eligible for payment",
            "     * If the dispute FAILED: only the liquidator can receive payment",
            "     * Once all collateral is withdrawn, delete the liquidation data.",
            "     * @param liquidationId uniquely identifies the sponsor's liquidation.",
            "     * @param sponsor address of the sponsor associated with the liquidation.",
            "     * @return amountWithdrawn the total amount of underlying returned from the liquidation.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice After a dispute has settled or after a non-disputed liquidation has expired,\n     * the sponsor, liquidator, and/or disputer can call this method to receive payments.\n     * @dev If the dispute SUCCEEDED: the sponsor, liquidator, and disputer are eligible for payment\n     * If the dispute FAILED: only the liquidator can receive payment\n     * Once all collateral is withdrawn, delete the liquidation data.\n     * @param liquidationId uniquely identifies the sponsor's liquidation.\n     * @param sponsor address of the sponsor associated with the liquidation.\n     * @return amountWithdrawn the total amount of underlying returned from the liquidation.\n     */\n",
        "@notice": "After a dispute has settled or after a non-disputed liquidation has expired, * the sponsor, liquidator, and/or disputer can call this method to receive payments.",
        "@dev": "If the dispute SUCCEEDED: the sponsor, liquidator, and disputer are eligible for payment * If the dispute FAILED: only the liquidator can receive payment * Once all collateral is withdrawn, delete the liquidation data.",
        "@param1": "liquidationId uniquely identifies the sponsor's liquidation.",
        "@param2": "sponsor address of the sponsor associated with the liquidation.",
        "@return1": "amountWithdrawn the total amount of underlying returned from the liquidation.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "pfc",
        "visibility": "public",
        "args": [],
        "func": "function pfc() public override view returns (FixedPoint.Unsigned memory) {\n        return super.pfc().add(_getCollateral(rawLiquidationCollateral));\n    }",
        "comments": [
            "/**",
            "     * @dev This overrides pfc() so the Liquidatable contract can report its profit from corruption.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev This overrides pfc() so the Liquidatable contract can report its profit from corruption.\n     */\n",
        "@dev": "This overrides pfc() so the Liquidatable contract can report its profit from corruption.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getLiquidations",
        "visibility": "external",
        "args": [
            {
                "name": "sponsor",
                "type": "address"
            }
        ],
        "func": "function getLiquidations(address sponsor) external view returns (LiquidationData[] memory) {\n        return liquidations[sponsor];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "pushLatestPrice",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "publishTime",
                "type": "uint256"
            },
            {
                "name": "newPrice",
                "type": "int256"
            }
        ],
        "func": "function pushLatestPrice(\n        bytes32 identifier,\n        uint256 publishTime,\n        int256 newPrice\n    ) external onlyRoleHolder(uint256(Roles.Writer)) {\n        require(publishTime <= getCurrentTime().add(BLOCK_TIMESTAMP_TOLERANCE));\n        require(publishTime > prices[identifier].timestamp);\n        prices[identifier] = PriceTick(publishTime, newPrice);\n        emit PriceUpdated(identifier, publishTime, newPrice);\n    }",
        "comments": [
            "/**",
            "     * @notice Adds a new price to the series for a given identifier.",
            "     * @dev The pushed publishTime must be later than the last time pushed so far.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Adds a new price to the series for a given identifier.\n     * @dev The pushed publishTime must be later than the last time pushed so far.\n     */\n",
        "@notice": "Adds a new price to the series for a given identifier.",
        "@dev": "The pushed publishTime must be later than the last time pushed so far.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isIdentifierSupported",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            }
        ],
        "func": "function isIdentifierSupported(bytes32 identifier) external override view returns (bool isSupported) {\n        isSupported = _isIdentifierSupported(identifier);\n    }",
        "comments": [
            "/**",
            "     * @notice Whether this feed has ever published any prices for this identifier.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Whether this feed has ever published any prices for this identifier.\n     */\n",
        "@notice": "Whether this feed has ever published any prices for this identifier.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "latestPrice",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            }
        ],
        "func": "function latestPrice(bytes32 identifier) external override view returns (uint256 publishTime, int256 price) {\n        require(_isIdentifierSupported(identifier));\n        publishTime = prices[identifier].timestamp;\n        price = prices[identifier].price;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setCompleted",
        "visibility": "public",
        "args": [
            {
                "name": "completed",
                "type": "uint256"
            }
        ],
        "func": "function setCompleted(uint256 completed) public restricted {\n        last_completed_migration = completed;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "upgrade",
        "visibility": "public",
        "args": [
            {
                "name": "new_address",
                "type": "address"
            }
        ],
        "func": "function upgrade(address new_address) public restricted {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "remargin",
        "visibility": "external",
        "args": [],
        "func": "function remargin() external override {\n        timesRemargined++;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "emergencyShutdown",
        "visibility": "external",
        "args": [],
        "func": "function emergencyShutdown() external override {\n        timesEmergencyShutdown++;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "requestPrice",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            }
        ],
        "func": "function requestPrice(bytes32 identifier, uint256 time) external override {\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\n        Price storage lookup = verifiedPrices[identifier][time];\n        if (!lookup.isAvailable && !queryIndices[identifier][time].isValid) {\n            // New query, enqueue it for review.\n            queryIndices[identifier][time] = QueryIndex(true, requestedPrices.length);\n            requestedPrices.push(QueryPoint(identifier, time));\n        }\n    }",
        "comments": [
            "",
            "    // Enqueues a request (if a request isn't already present) for the given (identifier, time) pair.",
            "",
            "    "
        ],
        "comt": "\n    // Enqueues a request (if a request isn't already present) for the given (identifier, time) pair.\n\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "pushPrice",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            },
            {
                "name": "price",
                "type": "int256"
            }
        ],
        "func": "function pushPrice(\n        bytes32 identifier,\n        uint256 time,\n        int256 price\n    ) external {\n        verifiedPrices[identifier][time] = Price(true, price, getCurrentTime());\n\n        QueryIndex storage queryIndex = queryIndices[identifier][time];\n        require(queryIndex.isValid, \"Can't push prices that haven't been requested\");\n        // Delete from the array. Instead of shifting the queries over, replace the contents of `indexToReplace` with\n        // the contents of the last index (unless it is the last index).\n        uint256 indexToReplace = queryIndex.index;\n        delete queryIndices[identifier][time];\n        uint256 lastIndex = requestedPrices.length - 1;\n        if (lastIndex != indexToReplace) {\n            QueryPoint storage queryToCopy = requestedPrices[lastIndex];\n            queryIndices[queryToCopy.identifier][queryToCopy.time].index = indexToReplace;\n            requestedPrices[indexToReplace] = queryToCopy;\n        }\n    }",
        "comments": [
            "",
            "    // Pushes the verified price for a requested query.",
            "    "
        ],
        "comt": "\n    // Pushes the verified price for a requested query.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "hasPrice",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            }
        ],
        "func": "function hasPrice(bytes32 identifier, uint256 time) external override view returns (bool) {\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\n        Price storage lookup = verifiedPrices[identifier][time];\n        return lookup.isAvailable;\n    }",
        "comments": [
            "",
            "    // Checks whether a price has been resolved.",
            "    "
        ],
        "comt": "\n    // Checks whether a price has been resolved.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPrice",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            }
        ],
        "func": "function getPrice(bytes32 identifier, uint256 time) external override view returns (int256) {\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\n        Price storage lookup = verifiedPrices[identifier][time];\n        require(lookup.isAvailable);\n        return lookup.price;\n    }",
        "comments": [
            "",
            "    // Gets a price that has already been resolved.",
            "    "
        ],
        "comt": "\n    // Gets a price that has already been resolved.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPendingQueries",
        "visibility": "external",
        "args": [],
        "func": "function getPendingQueries() external view returns (QueryPoint[] memory) {\n        return requestedPrices;\n    }",
        "comments": [
            "",
            "    // Gets the queries that still need verified prices.",
            "    "
        ],
        "comt": "\n    // Gets the queries that still need verified prices.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "holdsRole",
        "visibility": "public",
        "args": [
            {
                "name": "roleId",
                "type": "uint256"
            },
            {
                "name": "memberToCheck",
                "type": "address"
            }
        ],
        "func": "function holdsRole(uint256 roleId, address memberToCheck) public view returns (bool) {\n        Role storage role = roles[roleId];\n        if (role.roleType == RoleType.Exclusive) {\n            return role.exclusiveRoleMembership.isMember(memberToCheck);\n        } else if (role.roleType == RoleType.Shared) {\n            return role.sharedRoleMembership.isMember(memberToCheck);\n        }\n        revert(\"Invalid roleId\");\n    }",
        "comments": [
            "/**",
            "     * @notice Whether `memberToCheck` is a member of roleId.",
            "     * @dev Reverts if roleId does not correspond to an initialized role.",
            "     * @param roleId the Role to check.",
            "     * @param memberToCheck the address to check.",
            "     * @return True if `memberToCheck` is a member of `roleId`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Whether `memberToCheck` is a member of roleId.\n     * @dev Reverts if roleId does not correspond to an initialized role.\n     * @param roleId the Role to check.\n     * @param memberToCheck the address to check.\n     * @return True if `memberToCheck` is a member of `roleId`.\n     */\n",
        "@notice": "Whether `memberToCheck` is a member of roleId.",
        "@dev": "Reverts if roleId does not correspond to an initialized role.",
        "@param1": "roleId the Role to check.",
        "@param2": "memberToCheck the address to check.",
        "@return1": "True if `memberToCheck` is a member of `roleId`.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "resetMember",
        "visibility": "public",
        "args": [
            {
                "name": "roleId",
                "type": "uint256"
            },
            {
                "name": "newMember",
                "type": "address"
            }
        ],
        "func": "function resetMember(uint256 roleId, address newMember) public onlyExclusive(roleId) onlyRoleManager(roleId) {\n        roles[roleId].exclusiveRoleMembership.resetMember(newMember);\n        emit ResetExclusiveMember(roleId, newMember, msg.sender);\n    }",
        "comments": [
            "/**",
            "     * @notice Changes the exclusive role holder of `roleId` to `newMember`.",
            "     * @dev Reverts if the caller is not a member of the managing role for `roleId` or if `roleId` is not an",
            "     * initialized, ExclusiveRole.",
            "     * @param roleId the ExclusiveRole membership to modify.",
            "     * @param newMember the new ExclusiveRole member.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Changes the exclusive role holder of `roleId` to `newMember`.\n     * @dev Reverts if the caller is not a member of the managing role for `roleId` or if `roleId` is not an\n     * initialized, ExclusiveRole.\n     * @param roleId the ExclusiveRole membership to modify.\n     * @param newMember the new ExclusiveRole member.\n     */\n",
        "@notice": "Changes the exclusive role holder of `roleId` to `newMember`.",
        "@dev": "Reverts if the caller is not a member of the managing role for `roleId` or if `roleId` is not an * initialized, ExclusiveRole.",
        "@param1": "roleId the ExclusiveRole membership to modify.",
        "@param2": "newMember the new ExclusiveRole member.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMember",
        "visibility": "public",
        "args": [
            {
                "name": "roleId",
                "type": "uint256"
            }
        ],
        "func": "function getMember(uint256 roleId) public view onlyExclusive(roleId) returns (address) {\n        return roles[roleId].exclusiveRoleMembership.getMember();\n    }",
        "comments": [
            "/**",
            "     * @notice Gets the current holder of the exclusive role, `roleId`.",
            "     * @dev Reverts if `roleId` does not represent an initialized, exclusive role.",
            "     * @param roleId the ExclusiveRole membership to check.",
            "     * @return the address of the current ExclusiveRole member.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets the current holder of the exclusive role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, exclusive role.\n     * @param roleId the ExclusiveRole membership to check.\n     * @return the address of the current ExclusiveRole member.\n     */\n",
        "@notice": "Gets the current holder of the exclusive role, `roleId`.",
        "@dev": "Reverts if `roleId` does not represent an initialized, exclusive role.",
        "@param1": "roleId the ExclusiveRole membership to check.",
        "@return1": "the address of the current ExclusiveRole member.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addMember",
        "visibility": "public",
        "args": [
            {
                "name": "roleId",
                "type": "uint256"
            },
            {
                "name": "newMember",
                "type": "address"
            }
        ],
        "func": "function addMember(uint256 roleId, address newMember) public onlyShared(roleId) onlyRoleManager(roleId) {\n        roles[roleId].sharedRoleMembership.addMember(newMember);\n        emit AddedSharedMember(roleId, newMember, msg.sender);\n    }",
        "comments": [
            "/**",
            "     * @notice Adds `newMember` to the shared role, `roleId`.",
            "     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the",
            "     * managing role for `roleId`.",
            "     * @param roleId the SharedRole membership to modify.",
            "     * @param newMember the new SharedRole member.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Adds `newMember` to the shared role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\n     * managing role for `roleId`.\n     * @param roleId the SharedRole membership to modify.\n     * @param newMember the new SharedRole member.\n     */\n",
        "@notice": "Adds `newMember` to the shared role, `roleId`.",
        "@dev": "Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the * managing role for `roleId`.",
        "@param1": "roleId the SharedRole membership to modify.",
        "@param2": "newMember the new SharedRole member.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeMember",
        "visibility": "public",
        "args": [
            {
                "name": "roleId",
                "type": "uint256"
            },
            {
                "name": "memberToRemove",
                "type": "address"
            }
        ],
        "func": "function removeMember(uint256 roleId, address memberToRemove) public onlyShared(roleId) onlyRoleManager(roleId) {\n        roles[roleId].sharedRoleMembership.removeMember(memberToRemove);\n        emit RemovedSharedMember(roleId, memberToRemove, msg.sender);\n    }",
        "comments": [
            "/**",
            "     * @notice Removes `memberToRemove` from the shared role, `roleId`.",
            "     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the",
            "     * managing role for `roleId`.",
            "     * @param roleId the SharedRole membership to modify.",
            "     * @param memberToRemove the current SharedRole member to remove.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Removes `memberToRemove` from the shared role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\n     * managing role for `roleId`.\n     * @param roleId the SharedRole membership to modify.\n     * @param memberToRemove the current SharedRole member to remove.\n     */\n",
        "@notice": "Removes `memberToRemove` from the shared role, `roleId`.",
        "@dev": "Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the * managing role for `roleId`.",
        "@param1": "roleId the SharedRole membership to modify.",
        "@param2": "memberToRemove the current SharedRole member to remove.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "renounceMembership",
        "visibility": "public",
        "args": [
            {
                "name": "roleId",
                "type": "uint256"
            }
        ],
        "func": "function renounceMembership(uint256 roleId) public onlyShared(roleId) onlyRoleHolder(roleId) {\n        roles[roleId].sharedRoleMembership.removeMember(msg.sender);\n        emit RemovedSharedMember(roleId, msg.sender, msg.sender);\n    }",
        "comments": [
            "/**",
            "     * @notice Removes caller from the role, `roleId`.",
            "     * @dev Reverts if the caller is not a member of the role for `roleId` or if `roleId` is not an",
            "     * initialized, SharedRole.",
            "     * @param roleId the SharedRole membership to modify.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Removes caller from the role, `roleId`.\n     * @dev Reverts if the caller is not a member of the role for `roleId` or if `roleId` is not an\n     * initialized, SharedRole.\n     * @param roleId the SharedRole membership to modify.\n     */\n",
        "@notice": "Removes caller from the role, `roleId`.",
        "@dev": "Reverts if the caller is not a member of the role for `roleId` or if `roleId` is not an * initialized, SharedRole.",
        "@param1": "roleId the SharedRole membership to modify.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createSharedRole",
        "visibility": "external",
        "args": [
            {
                "name": "roleId",
                "type": "uint256"
            },
            {
                "name": "managingRoleId",
                "type": "uint256"
            },
            {
                "name": "initialMembers",
                "type": "address[] calldata"
            }
        ],
        "func": "function createSharedRole(\n        uint256 roleId,\n        uint256 managingRoleId,\n        address[] calldata initialMembers\n    ) external {\n        _createSharedRole(roleId, managingRoleId, initialMembers);\n    }",
        "comments": [
            "",
            "",
            "// The purpose of this contract is to make the MultiRole creation methods externally callable for testing purposes.",
            "contract MultiRoleTest is MultiRole {",
            "    "
        ],
        "comt": "\n\n// The purpose of this contract is to make the MultiRole creation methods externally callable for testing purposes.\ncontract MultiRoleTest is MultiRole {\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createExclusiveRole",
        "visibility": "external",
        "args": [
            {
                "name": "roleId",
                "type": "uint256"
            },
            {
                "name": "managingRoleId",
                "type": "uint256"
            },
            {
                "name": "initialMember",
                "type": "address"
            }
        ],
        "func": "function createExclusiveRole(\n        uint256 roleId,\n        uint256 managingRoleId,\n        address initialMember\n    ) external {\n        _createExclusiveRole(roleId, managingRoleId, initialMember);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "revertIfNotHoldingRole",
        "visibility": "external",
        "args": [
            {
                "name": "roleId",
                "type": "uint256"
            }
        ],
        "func": "function revertIfNotHoldingRole(uint256 roleId) external view onlyRoleHolder(roleId) {}",
        "comments": [
            "",
            "    // solhint-disable-next-line no-empty-blocks",
            "    "
        ],
        "comt": "\n    // solhint-disable-next-line no-empty-blocks\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "owner",
        "visibility": "public",
        "args": [],
        "func": "function owner() public view returns (address) {\n        return _owner;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the address of the current owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the address of the current owner.\n     */\n",
        "@dev": "Returns the address of the current owner.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "renounceOwnership",
        "visibility": "public",
        "args": [],
        "func": "function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }",
        "comments": [
            "/**",
            "     * @dev Leaves the contract without owner. It will not be possible to call",
            "     * `onlyOwner` functions anymore. Can only be called by the current owner.",
            "     *",
            "     * NOTE: Renouncing ownership will leave the contract without an owner,",
            "     * thereby removing any functionality that is only available to the owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n",
        "@dev": "Leaves the contract without owner. It will not be possible to call * `onlyOwner` functions anymore. Can only be called by the current owner. * * NOTE: Renouncing ownership will leave the contract without an owner, * thereby removing any functionality that is only available to the owner.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferOwnership",
        "visibility": "public",
        "args": [
            {
                "name": "newOwner",
                "type": "address"
            }
        ],
        "func": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }",
        "comments": [
            "/**",
            "     * @dev Transfers ownership of the contract to a new account (`newOwner`).",
            "     * Can only be called by the current owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n",
        "@dev": "Transfers ownership of the contract to a new account (`newOwner`). * Can only be called by the current owner.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "paused",
        "visibility": "public",
        "args": [],
        "func": "function paused() public view returns (bool) {\n        return _paused;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns true if the contract is paused, and false otherwise.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n",
        "@dev": "Returns true if the contract is paused, and false otherwise.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalShares",
        "visibility": "public",
        "args": [],
        "func": "function totalShares() public view returns (uint256) {\n        return _totalShares;\n    }",
        "comments": [
            "/**",
            "     * @dev Getter for the total shares held by payees.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Getter for the total shares held by payees.\n     */\n",
        "@dev": "Getter for the total shares held by payees.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalReleased",
        "visibility": "public",
        "args": [],
        "func": "function totalReleased() public view returns (uint256) {\n        return _totalReleased;\n    }",
        "comments": [
            "/**",
            "     * @dev Getter for the total amount of Ether already released.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Getter for the total amount of Ether already released.\n     */\n",
        "@dev": "Getter for the total amount of Ether already released.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "shares",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function shares(address account) public view returns (uint256) {\n        return _shares[account];\n    }",
        "comments": [
            "/**",
            "     * @dev Getter for the amount of shares held by an account.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Getter for the amount of shares held by an account.\n     */\n",
        "@dev": "Getter for the amount of shares held by an account.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "released",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function released(address account) public view returns (uint256) {\n        return _released[account];\n    }",
        "comments": [
            "/**",
            "     * @dev Getter for the amount of Ether already released to a payee.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Getter for the amount of Ether already released to a payee.\n     */\n",
        "@dev": "Getter for the amount of Ether already released to a payee.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "payee",
        "visibility": "public",
        "args": [
            {
                "name": "index",
                "type": "uint256"
            }
        ],
        "func": "function payee(uint256 index) public view returns (address) {\n        return _payees[index];\n    }",
        "comments": [
            "/**",
            "     * @dev Getter for the address of the payee number `index`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Getter for the address of the payee number `index`.\n     */\n",
        "@dev": "Getter for the address of the payee number `index`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "release",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address payable"
            }
        ],
        "func": "function release(address payable account) public virtual {\n        require(_shares[account] > 0, \"PaymentSplitter: account has no shares\");\n\n        uint256 totalReceived = address(this).balance.add(_totalReleased);\n        uint256 payment = totalReceived.mul(_shares[account]).div(_totalShares).sub(_released[account]);\n\n        require(payment != 0, \"PaymentSplitter: account is not due payment\");\n\n        _released[account] = _released[account].add(payment);\n        _totalReleased = _totalReleased.add(payment);\n\n        account.transfer(payment);\n        emit PaymentReleased(account, payment);\n    }",
        "comments": [
            "/**",
            "     * @dev Triggers a transfer to `account` of the amount of Ether they are owed, according to their percentage of the",
            "     * total shares and their previous withdrawals.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Triggers a transfer to `account` of the amount of Ether they are owed, according to their percentage of the\n     * total shares and their previous withdrawals.\n     */\n",
        "@dev": "Triggers a transfer to `account` of the amount of Ether they are owed, according to their percentage of the * total shares and their previous withdrawals.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "newSponsorAddress",
                "type": "address"
            }
        ],
        "func": "function transfer(address newSponsorAddress) public onlyPreExpiration() {\n        require(_getCollateral(positions[newSponsorAddress].rawCollateral).isEqual(FixedPoint.fromUnscaledUint(0)));\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.requestPassTimestamp == 0);\n        positions[newSponsorAddress] = positionData;\n        delete positions[msg.sender];\n\n        emit Transfer(msg.sender, newSponsorAddress);\n        emit NewSponsor(newSponsorAddress);\n    }",
        "comments": [
            "/**",
            "     * @notice Transfers ownership of the caller's current position to `newSponsorAddress`.",
            "     * @dev Transferring positions can only occur if the recipient does not already have a position.",
            "     * @param newSponsorAddress is the address to which the position will be transferred.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfers ownership of the caller's current position to `newSponsorAddress`.\n     * @dev Transferring positions can only occur if the recipient does not already have a position.\n     * @param newSponsorAddress is the address to which the position will be transferred.\n     */\n",
        "@notice": "Transfers ownership of the caller's current position to `newSponsorAddress`.",
        "@dev": "Transferring positions can only occur if the recipient does not already have a position.",
        "@param1": "newSponsorAddress is the address to which the position will be transferred.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "deposit",
        "visibility": "public",
        "args": [
            {
                "name": "collateralAmount",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function deposit(FixedPoint.Unsigned memory collateralAmount) public onlyPreExpiration() fees() {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.requestPassTimestamp == 0);\n        _addCollateral(positionData.rawCollateral, collateralAmount);\n        _addCollateral(rawTotalPositionCollateral, collateralAmount);\n\n        // Move collateral currency from sender to contract.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n\n        emit Deposit(msg.sender, collateralAmount.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Transfers `collateralAmount` of `collateralCurrency` into the sponsor's position.",
            "     * @dev Increases the collateralization level of a position after creation.",
            "     * @param collateralAmount total amount of collateral tokens to be sent to the sponsor's position.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfers `collateralAmount` of `collateralCurrency` into the sponsor's position.\n     * @dev Increases the collateralization level of a position after creation.\n     * @param collateralAmount total amount of collateral tokens to be sent to the sponsor's position.\n     */\n",
        "@notice": "Transfers `collateralAmount` of `collateralCurrency` into the sponsor's position.",
        "@dev": "Increases the collateralization level of a position after creation.",
        "@param1": "collateralAmount total amount of collateral tokens to be sent to the sponsor's position.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "collateralAmount",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function withdraw(FixedPoint.Unsigned memory collateralAmount)\n        public\n        onlyPreExpiration()\n        fees()\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.requestPassTimestamp == 0);\n\n        _removeCollateral(positionData.rawCollateral, collateralAmount);\n        require(_checkPositionCollateralization(positionData));\n        // We elect to withdraw the amount that the global collateral is decreased by,\n        // rather than the individual position's collateral, because we need to maintain the invariant that\n        // the global collateral is always <= the collateral owned by the contract to avoid reverts on withdrawals.\n        amountWithdrawn = _removeCollateral(rawTotalPositionCollateral, collateralAmount);\n\n        // Move collateral currency from contract to sender.\n        // Note that we move the amount of collateral that is decreased from rawCollateral (inclusive of fees)\n        // instead of the user requested amount. This eliminates precision loss that could occur\n        // where the user withdraws more collateral than rawCollateral is decremented by.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n\n        emit Withdrawal(msg.sender, amountWithdrawn.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Transfers `collateralAmount` of `collateralCurrency` from the sponsor's position to the sponsor.",
            "     * @dev Reverts if the withdrawal puts this position's collateralization ratio below the global",
            "     * collateralization ratio. In that case, use `requestWithdrawawal`. Might not withdraw the full requested",
            "     * amount in order to account for precision loss.",
            "     * @param collateralAmount is the amount of collateral to withdraw.",
            "     * @return amountWithdrawn The actual amount of collateral withdrawn.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfers `collateralAmount` of `collateralCurrency` from the sponsor's position to the sponsor.\n     * @dev Reverts if the withdrawal puts this position's collateralization ratio below the global\n     * collateralization ratio. In that case, use `requestWithdrawawal`. Might not withdraw the full requested\n     * amount in order to account for precision loss.\n     * @param collateralAmount is the amount of collateral to withdraw.\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\n     */\n",
        "@notice": "Transfers `collateralAmount` of `collateralCurrency` from the sponsor's position to the sponsor.",
        "@dev": "Reverts if the withdrawal puts this position's collateralization ratio below the global * collateralization ratio. In that case, use `requestWithdrawawal`. Might not withdraw the full requested * amount in order to account for precision loss.",
        "@param1": "collateralAmount is the amount of collateral to withdraw.",
        "@return1": "amountWithdrawn The actual amount of collateral withdrawn.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "requestWithdrawal",
        "visibility": "public",
        "args": [
            {
                "name": "collateralAmount",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function requestWithdrawal(FixedPoint.Unsigned memory collateralAmount) public onlyPreExpiration() {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.requestPassTimestamp == 0);\n\n        // Make sure the proposed expiration of this request is not post-expiry.\n        uint256 requestPassTime = getCurrentTime() + withdrawalLiveness;\n        require(requestPassTime <= expirationTimestamp);\n\n        // Update the position object for the user.\n        positionData.requestPassTimestamp = requestPassTime;\n        positionData.withdrawalRequestAmount = collateralAmount;\n\n        emit RequestWithdrawal(msg.sender, collateralAmount.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Starts a withdrawal request that, if passed, allows the sponsor to withdraw",
            "     * `collateralAmount` from their position.",
            "     * @dev The request will be pending for `withdrawalLiveness`, during which the position can be liquidated.",
            "     * @param collateralAmount the amount of collateral requested to withdraw",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Starts a withdrawal request that, if passed, allows the sponsor to withdraw\n     * `collateralAmount` from their position.\n     * @dev The request will be pending for `withdrawalLiveness`, during which the position can be liquidated.\n     * @param collateralAmount the amount of collateral requested to withdraw\n     */\n",
        "@notice": "Starts a withdrawal request that, if passed, allows the sponsor to withdraw * `collateralAmount` from their position.",
        "@dev": "The request will be pending for `withdrawalLiveness`, during which the position can be liquidated.",
        "@param1": "collateralAmount the amount of collateral requested to withdraw",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawPassedRequest",
        "visibility": "external",
        "args": [],
        "func": "function withdrawPassedRequest()\n        external\n        onlyPreExpiration()\n        fees()\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.requestPassTimestamp <= getCurrentTime());\n\n        // If withdrawal request amount is > position collateral, then withdraw the full collateral amount.\n        FixedPoint.Unsigned memory amountToWithdraw = positionData.withdrawalRequestAmount;\n        if (positionData.withdrawalRequestAmount.isGreaterThan(_getCollateral(positionData.rawCollateral))) {\n            amountToWithdraw = _getCollateral(positionData.rawCollateral);\n        }\n\n        _removeCollateral(positionData.rawCollateral, amountToWithdraw);\n        amountWithdrawn = _removeCollateral(rawTotalPositionCollateral, amountToWithdraw);\n\n        // Transfer approved withdrawal amount from the contract to the caller.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n\n        emit RequestWithdrawalExecuted(msg.sender, amountWithdrawn.rawValue);\n\n        // Reset withdrawal request\n        positionData.withdrawalRequestAmount = FixedPoint.fromUnscaledUint(0);\n        positionData.requestPassTimestamp = 0;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cancelWithdrawal",
        "visibility": "external",
        "args": [],
        "func": "function cancelWithdrawal() external onlyPreExpiration() {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.requestPassTimestamp != 0);\n\n        emit RequestWithdrawalCanceled(msg.sender, positionData.withdrawalRequestAmount.rawValue);\n\n        // Reset withdrawal request\n        positionData.requestPassTimestamp = 0;\n        positionData.withdrawalRequestAmount = FixedPoint.fromUnscaledUint(0);\n    }",
        "comments": [
            "/**",
            "     * @notice Cancels a pending withdrawal request.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Cancels a pending withdrawal request.\n     */\n",
        "@notice": "Cancels a pending withdrawal request.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "create",
        "visibility": "public",
        "args": [
            {
                "name": "collateralAmount",
                "type": "FixedPoint.Unsigned memory"
            },
            {
                "name": "numTokens",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function create(FixedPoint.Unsigned memory collateralAmount, FixedPoint.Unsigned memory numTokens)\n        public\n        onlyPreExpiration()\n        fees()\n    {\n        require(_checkCollateralization(collateralAmount, numTokens));\n\n        PositionData storage positionData = positions[msg.sender];\n        require(positionData.requestPassTimestamp == 0);\n        if (positionData.tokensOutstanding.isEqual(0)) {\n            require(numTokens.isGreaterThanOrEqual(minSponsorTokens));\n            emit NewSponsor(msg.sender);\n        }\n        _addCollateral(positionData.rawCollateral, collateralAmount);\n        positionData.tokensOutstanding = positionData.tokensOutstanding.add(numTokens);\n\n        _addCollateral(rawTotalPositionCollateral, collateralAmount);\n        totalTokensOutstanding = totalTokensOutstanding.add(numTokens);\n\n        // Transfer tokens into the contract from caller and mint the caller synthetic tokens.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n        require(tokenCurrency.mint(msg.sender, numTokens.rawValue), \"Minting synthetic tokens failed\");\n\n        emit PositionCreated(msg.sender, collateralAmount.rawValue, numTokens.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Pulls `collateralAmount` into the sponsor's position and mints `numTokens` of `tokenCurrency`.",
            "     * @dev Reverts if the minting these tokens would put the position's collateralization ratio below the",
            "     * global collateralization ratio.",
            "     * @param collateralAmount is the number of collateral tokens to collateralize the position with",
            "     * @param numTokens is the number of tokens to mint from the position.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Pulls `collateralAmount` into the sponsor's position and mints `numTokens` of `tokenCurrency`.\n     * @dev Reverts if the minting these tokens would put the position's collateralization ratio below the\n     * global collateralization ratio.\n     * @param collateralAmount is the number of collateral tokens to collateralize the position with\n     * @param numTokens is the number of tokens to mint from the position.\n     */\n",
        "@notice": "Pulls `collateralAmount` into the sponsor's position and mints `numTokens` of `tokenCurrency`.",
        "@dev": "Reverts if the minting these tokens would put the position's collateralization ratio below the * global collateralization ratio.",
        "@param1": "collateralAmount is the number of collateral tokens to collateralize the position with",
        "@param2": "numTokens is the number of tokens to mint from the position.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "redeem",
        "visibility": "public",
        "args": [
            {
                "name": "numTokens",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function redeem(FixedPoint.Unsigned memory numTokens)\n        public\n        onlyPreExpiration()\n        fees()\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.requestPassTimestamp == 0);\n        require(!numTokens.isGreaterThan(positionData.tokensOutstanding));\n\n        FixedPoint.Unsigned memory fractionRedeemed = numTokens.div(positionData.tokensOutstanding);\n        FixedPoint.Unsigned memory collateralRedeemed = fractionRedeemed.mul(\n            _getCollateral(positionData.rawCollateral)\n        );\n\n        // If redemption returns all tokens the sponsor has then we can delete their position. Else, downsize.\n        if (positionData.tokensOutstanding.isEqual(numTokens)) {\n            amountWithdrawn = _deleteSponsorPosition(msg.sender);\n        } else {\n            // Decrease the sponsors position size of collateral and tokens.\n            _removeCollateral(positionData.rawCollateral, collateralRedeemed);\n            FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n            require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens));\n            positionData.tokensOutstanding = newTokenCount;\n\n            // Decrease the contract's collateral and tokens.\n            amountWithdrawn = _removeCollateral(rawTotalPositionCollateral, collateralRedeemed);\n            totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n        }\n\n        // Transfer collateral from contract to caller and burn callers synthetic tokens.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n        tokenCurrency.burn(numTokens.rawValue);\n\n        emit Redeem(msg.sender, amountWithdrawn.rawValue, numTokens.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Burns `numTokens` of `tokenCurrency` and sends back the proportional amount of `collateralCurrency`.",
            "     * @dev Can only be called by a token sponsor. Might not redeem the full proportional amount of collateral",
            "     * in order to account for precision loss.",
            "     * @param numTokens is the number of tokens to be burnt for a commensurate amount of collateral.",
            "     * @return amountWithdrawn The actual amount of collateral withdrawn.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Burns `numTokens` of `tokenCurrency` and sends back the proportional amount of `collateralCurrency`.\n     * @dev Can only be called by a token sponsor. Might not redeem the full proportional amount of collateral\n     * in order to account for precision loss.\n     * @param numTokens is the number of tokens to be burnt for a commensurate amount of collateral.\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\n     */\n",
        "@notice": "Burns `numTokens` of `tokenCurrency` and sends back the proportional amount of `collateralCurrency`.",
        "@dev": "Can only be called by a token sponsor. Might not redeem the full proportional amount of collateral * in order to account for precision loss.",
        "@param1": "numTokens is the number of tokens to be burnt for a commensurate amount of collateral.",
        "@return1": "amountWithdrawn The actual amount of collateral withdrawn.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "settleExpired",
        "visibility": "external",
        "args": [],
        "func": "function settleExpired() external onlyPostExpiration() fees() returns (FixedPoint.Unsigned memory amountWithdrawn) {\n        // If the contract state is open and onlyPostExpiration passed then `expire()` has not yet been called.\n        require(contractState != ContractState.Open);\n\n        // Get the current settlement price and store it. If it is not resolved will revert.\n        if (contractState != ContractState.ExpiredPriceReceived) {\n            expiryPrice = _getOraclePrice(expirationTimestamp);\n            contractState = ContractState.ExpiredPriceReceived;\n        }\n\n        // Get caller's tokens balance and calculate amount of underlying entitled to them.\n        FixedPoint.Unsigned memory tokensToRedeem = FixedPoint.Unsigned(tokenCurrency.balanceOf(msg.sender));\n        FixedPoint.Unsigned memory totalRedeemableCollateral = tokensToRedeem.mul(expiryPrice);\n\n        // If the caller is a sponsor with outstanding collateral they are also entitled to their excess collateral after their debt.\n        PositionData storage positionData = positions[msg.sender];\n        if (_getCollateral(positionData.rawCollateral).isGreaterThan(0)) {\n            // Calculate the underlying entitled to a token sponsor. This is collateral - debt in underlying.\n            FixedPoint.Unsigned memory tokenDebtValueInCollateral = positionData.tokensOutstanding.mul(expiryPrice);\n            FixedPoint.Unsigned memory positionCollateral = _getCollateral(positionData.rawCollateral);\n\n            // If the debt is greater than the remaining collateral, they cannot redeem anything.\n            FixedPoint.Unsigned memory positionRedeemableCollateral = tokenDebtValueInCollateral.isLessThan(\n                positionCollateral\n            )\n                ? positionCollateral.sub(tokenDebtValueInCollateral)\n                : FixedPoint.Unsigned(0);\n\n            // Add the number of redeemable tokens for the sponsor to their total redeemable collateral.\n            totalRedeemableCollateral = totalRedeemableCollateral.add(positionRedeemableCollateral);\n\n            // Reset the position state as all the value has been removed after settlement.\n            delete positions[msg.sender];\n        }\n\n        // Take the min of the remaining collateral and the collateral \"owed\". If the contract is undercapitalized,\n        // the caller will get as much collateral as the contract can pay out.\n        FixedPoint.Unsigned memory payout = FixedPoint.min(\n            _getCollateral(rawTotalPositionCollateral),\n            totalRedeemableCollateral\n        );\n\n        // Decrement total contract collateral and outstanding debt.\n        amountWithdrawn = _removeCollateral(rawTotalPositionCollateral, payout);\n        totalTokensOutstanding = totalTokensOutstanding.sub(tokensToRedeem);\n\n        // Transfer tokens & collateral and burn the redeemed tokens.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), tokensToRedeem.rawValue);\n        tokenCurrency.burn(tokensToRedeem.rawValue);\n\n        emit SettleExpiredPosition(msg.sender, amountWithdrawn.rawValue, tokensToRedeem.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice After a contract has passed expiry all token holders can redeem their tokens for",
            "     * underlying at the prevailing price defined by the DVM from the `expire` function.",
            "     * @dev This Burns all tokens from the caller of `tokenCurrency` and sends back the proportional",
            "     * amount of `collateralCurrency`. Might not redeem the full proportional amount of collateral",
            "     * in order to account for precision loss.",
            "     * @return amountWithdrawn The actual amount of collateral withdrawn.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice After a contract has passed expiry all token holders can redeem their tokens for\n     * underlying at the prevailing price defined by the DVM from the `expire` function.\n     * @dev This Burns all tokens from the caller of `tokenCurrency` and sends back the proportional\n     * amount of `collateralCurrency`. Might not redeem the full proportional amount of collateral\n     * in order to account for precision loss.\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\n     */\n",
        "@notice": "After a contract has passed expiry all token holders can redeem their tokens for * underlying at the prevailing price defined by the DVM from the `expire` function.",
        "@dev": "This Burns all tokens from the caller of `tokenCurrency` and sends back the proportional * amount of `collateralCurrency`. Might not redeem the full proportional amount of collateral * in order to account for precision loss.",
        "@return1": "amountWithdrawn The actual amount of collateral withdrawn.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "expire",
        "visibility": "external",
        "args": [],
        "func": "function expire() external onlyPostExpiration() onlyOpenState() fees() {\n        contractState = ContractState.ExpiredPriceRequested;\n\n        // The final fee for this request is paid out of the contract rather than by the caller.\n        _payFinalFees(address(this), _computeFinalFees());\n        _requestOraclePrice(expirationTimestamp);\n\n        emit ContractExpired(msg.sender);\n    }",
        "comments": [
            "/**",
            "     * @notice Locks contract state in expired and requests oracle price.",
            "     * @dev this function can only be called once the contract is expired and cant be re-called",
            "     * due to the state modifiers applied on it.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Locks contract state in expired and requests oracle price.\n     * @dev this function can only be called once the contract is expired and cant be re-called\n     * due to the state modifiers applied on it.\n     */\n",
        "@notice": "Locks contract state in expired and requests oracle price.",
        "@dev": "this function can only be called once the contract is expired and cant be re-called * due to the state modifiers applied on it.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "emergencyShutdown",
        "visibility": "external",
        "args": [],
        "func": "function emergencyShutdown() external override onlyPreExpiration() onlyOpenState() {\n        require(msg.sender == _getFinancialContractsAdminAddress());\n\n        contractState = ContractState.ExpiredPriceRequested;\n        // Expiratory time now becomes the current time (emergency shutdown time).\n        // Price requested at this time stamp. `settleExpired` can now withdraw at this timestamp.\n        uint256 oldExpirationTimestamp = expirationTimestamp;\n        expirationTimestamp = getCurrentTime();\n        _requestOraclePrice(expirationTimestamp);\n\n        emit EmergencyShutdown(msg.sender, oldExpirationTimestamp, expirationTimestamp);\n    }",
        "comments": [
            "/**",
            "     * @notice Premature contract settlement under emergency circumstances.",
            "     * @dev Only the governor can call this function as they are permissioned within the `FinancialContractAdmin`.",
            "     * Upon emergency shutdown, the contract settlement time is set to the shutdown time. This enables withdrawal",
            "     * to occur via the standard `settleExpired` function. Contract state is set to `ExpiredPriceRequested`",
            "     * which prevents re-entry into this function or the `expire` function. No fees are paid when calling",
            "     * `emergencyShutdown` as the governor who would call the function would also receive the fees.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Premature contract settlement under emergency circumstances.\n     * @dev Only the governor can call this function as they are permissioned within the `FinancialContractAdmin`.\n     * Upon emergency shutdown, the contract settlement time is set to the shutdown time. This enables withdrawal\n     * to occur via the standard `settleExpired` function. Contract state is set to `ExpiredPriceRequested`\n     * which prevents re-entry into this function or the `expire` function. No fees are paid when calling\n     * `emergencyShutdown` as the governor who would call the function would also receive the fees.\n     */\n",
        "@notice": "Premature contract settlement under emergency circumstances.",
        "@dev": "Only the governor can call this function as they are permissioned within the `FinancialContractAdmin`. * Upon emergency shutdown, the contract settlement time is set to the shutdown time. This enables withdrawal * to occur via the standard `settleExpired` function. Contract state is set to `ExpiredPriceRequested` * which prevents re-entry into this function or the `expire` function. No fees are paid when calling * `emergencyShutdown` as the governor who would call the function would also receive the fees.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "remargin",
        "visibility": "external",
        "args": [],
        "func": "function remargin() external override onlyPreExpiration() {\n        return;\n    }",
        "comments": [
            "",
            "    // TODO is this how we want this function to be implemented?",
            "    "
        ],
        "comt": "\n    // TODO is this how we want this function to be implemented?\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCollateral",
        "visibility": "external",
        "args": [
            {
                "name": "sponsor",
                "type": "address"
            }
        ],
        "func": "function getCollateral(address sponsor) external view returns (FixedPoint.Unsigned memory) {\n        // Note: do a direct access to avoid the validity check.\n        return _getCollateral(positions[sponsor].rawCollateral);\n    }",
        "comments": [
            "/**",
            "     * @notice Accessor method for a sponsor's collateral.",
            "     * @dev This is necessary because the struct returned by the positions() method shows",
            "     * rawCollateral, which isn't a user-readable value.",
            "     * @param sponsor address whose collateral amount is retrieved.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Accessor method for a sponsor's collateral.\n     * @dev This is necessary because the struct returned by the positions() method shows\n     * rawCollateral, which isn't a user-readable value.\n     * @param sponsor address whose collateral amount is retrieved.\n     */\n",
        "@notice": "Accessor method for a sponsor's collateral.",
        "@dev": "This is necessary because the struct returned by the positions() method shows * rawCollateral, which isn't a user-readable value.",
        "@param1": "sponsor address whose collateral amount is retrieved.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalPositionCollateral",
        "visibility": "external",
        "args": [],
        "func": "function totalPositionCollateral() external view returns (FixedPoint.Unsigned memory) {\n        return _getCollateral(rawTotalPositionCollateral);\n    }",
        "comments": [
            "/**",
            "     * @notice Accessor method for the total collateral stored within the PricelessPositionManager.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Accessor method for the total collateral stored within the PricelessPositionManager.\n     */\n",
        "@notice": "Accessor method for the total collateral stored within the PricelessPositionManager.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "pfc",
        "visibility": "public",
        "args": [],
        "func": "function pfc() public virtual override view returns (FixedPoint.Unsigned memory) {\n        return _getCollateral(rawTotalPositionCollateral);\n    }",
        "comments": [
            "/**",
            "     * @dev This overrides pfc() so the PricelessPositionManager can report its profit from corruption.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev This overrides pfc() so the PricelessPositionManager can report its profit from corruption.\n     */\n",
        "@dev": "This overrides pfc() so the PricelessPositionManager can report its profit from corruption.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawPayments",
        "visibility": "public",
        "args": [
            {
                "name": "payee",
                "type": "address payable"
            }
        ],
        "func": "function withdrawPayments(address payable payee) public virtual {\n        _escrow.withdraw(payee);\n    }",
        "comments": [
            "/**",
            "     * @dev Withdraw accumulated payments, forwarding all gas to the recipient.",
            "     *",
            "     * Note that _any_ account can call this function, not just the `payee`.",
            "     * This means that contracts unaware of the `PullPayment` protocol can still",
            "     * receive funds this way, by having a separate account call",
            "     * {withdrawPayments}.",
            "     *",
            "     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.",
            "     * Make sure you trust the recipient, or are either following the",
            "     * checks-effects-interactions pattern or using {ReentrancyGuard}.",
            "     *",
            "     * @param payee Whose payments will be withdrawn.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Withdraw accumulated payments, forwarding all gas to the recipient.\n     *\n     * Note that _any_ account can call this function, not just the `payee`.\n     * This means that contracts unaware of the `PullPayment` protocol can still\n     * receive funds this way, by having a separate account call\n     * {withdrawPayments}.\n     *\n     * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.\n     * Make sure you trust the recipient, or are either following the\n     * checks-effects-interactions pattern or using {ReentrancyGuard}.\n     *\n     * @param payee Whose payments will be withdrawn.\n     */\n",
        "@dev": "Withdraw accumulated payments, forwarding all gas to the recipient. * * Note that _any_ account can call this function, not just the `payee`. * This means that contracts unaware of the `PullPayment` protocol can still * receive funds this way, by having a separate account call * {withdrawPayments}. * * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities. * Make sure you trust the recipient, or are either following the * checks-effects-interactions pattern or using {ReentrancyGuard}.",
        "@param1": "payee Whose payments will be withdrawn.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "payments",
        "visibility": "public",
        "args": [
            {
                "name": "dest",
                "type": "address"
            }
        ],
        "func": "function payments(address dest) public view returns (uint256) {\n        return _escrow.depositsOf(dest);\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the payments owed to an address.",
            "     * @param dest The creditor's address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the payments owed to an address.\n     * @param dest The creditor's address.\n     */\n",
        "@dev": "Returns the payments owed to an address.",
        "@param1": "dest The creditor's address.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setTransactionData",
        "visibility": "public",
        "args": [
            {
                "name": "_txnData",
                "type": "bytes memory"
            }
        ],
        "func": "function setTransactionData(bytes memory _txnData) public {\n        txnData = _txnData;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "state",
        "visibility": "public",
        "args": [],
        "func": "function state() public view returns (State) {\n        return _state;\n    }",
        "comments": [
            "/**",
            "     * @return The current state of the escrow.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @return The current state of the escrow.\n     */\n",
        "@return1": "The current state of the escrow.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "beneficiary",
        "visibility": "public",
        "args": [],
        "func": "function beneficiary() public view returns (address) {\n        return _beneficiary;\n    }",
        "comments": [
            "/**",
            "     * @return The beneficiary of the escrow.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @return The beneficiary of the escrow.\n     */\n",
        "@return1": "The beneficiary of the escrow.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "deposit",
        "visibility": "public",
        "args": [
            {
                "name": "refundee",
                "type": "address"
            }
        ],
        "func": "function deposit(address refundee) public payable virtual override {\n        require(_state == State.Active, \"RefundEscrow: can only deposit while active\");\n        super.deposit(refundee);\n    }",
        "comments": [
            "/**",
            "     * @dev Stores funds that may later be refunded.",
            "     * @param refundee The address funds will be sent to if a refund occurs.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Stores funds that may later be refunded.\n     * @param refundee The address funds will be sent to if a refund occurs.\n     */\n",
        "@dev": "Stores funds that may later be refunded.",
        "@param1": "refundee The address funds will be sent to if a refund occurs.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "close",
        "visibility": "public",
        "args": [],
        "func": "function close() public onlyOwner virtual {\n        require(_state == State.Active, \"RefundEscrow: can only close while active\");\n        _state = State.Closed;\n        emit RefundsClosed();\n    }",
        "comments": [
            "/**",
            "     * @dev Allows for the beneficiary to withdraw their funds, rejecting",
            "     * further deposits.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Allows for the beneficiary to withdraw their funds, rejecting\n     * further deposits.\n     */\n",
        "@dev": "Allows for the beneficiary to withdraw their funds, rejecting * further deposits.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "enableRefunds",
        "visibility": "public",
        "args": [],
        "func": "function enableRefunds() public onlyOwner virtual {\n        require(_state == State.Active, \"RefundEscrow: can only enable refunds while active\");\n        _state = State.Refunding;\n        emit RefundsEnabled();\n    }",
        "comments": [
            "/**",
            "     * @dev Allows for refunds to take place, rejecting further deposits.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Allows for refunds to take place, rejecting further deposits.\n     */\n",
        "@dev": "Allows for refunds to take place, rejecting further deposits.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "beneficiaryWithdraw",
        "visibility": "public",
        "args": [],
        "func": "function beneficiaryWithdraw() public virtual {\n        require(_state == State.Closed, \"RefundEscrow: beneficiary can only withdraw while closed\");\n        _beneficiary.transfer(address(this).balance);\n    }",
        "comments": [
            "/**",
            "     * @dev Withdraws the beneficiary's funds.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Withdraws the beneficiary's funds.\n     */\n",
        "@dev": "Withdraws the beneficiary's funds.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawalAllowed",
        "visibility": "public",
        "args": [
            {
                "name": "address",
                "type": "address"
            }
        ],
        "func": "function withdrawalAllowed(address) public view override returns (bool) {\n        return _state == State.Refunding;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns whether refundees can withdraw their deposits (be refunded). The overridden function receives a",
            "     * 'payee' argument, but we ignore it here since the condition is global, not per-payee.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns whether refundees can withdraw their deposits (be refunded). The overridden function receives a\n     * 'payee' argument, but we ignore it here since the condition is global, not per-payee.\n     */\n",
        "@dev": "Returns whether refundees can withdraw their deposits (be refunded). The overridden function receives a * 'payee' argument, but we ignore it here since the condition is global, not per-payee.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "registerContract",
        "visibility": "external",
        "args": [
            {
                "name": "parties",
                "type": "address[] calldata"
            },
            {
                "name": "contractAddress",
                "type": "address"
            }
        ],
        "func": "function registerContract(address[] calldata parties, address contractAddress)\n        external\n        override\n        onlyRoleHolder(uint256(Roles.ContractCreator))\n    {\n        FinancialContract storage financialContract = contractMap[contractAddress];\n        require(contractMap[contractAddress].valid == Validity.Invalid, \"Can only register once\");\n\n        // Store contract address as a registered contract.\n        registeredContracts.push(contractAddress);\n\n        // No length check necessary because we should never hit (2^127 - 1) contracts.\n        financialContract.index = uint128(registeredContracts.length.sub(1));\n\n        // For all parties in the array add them to the contract's parties.\n        financialContract.valid = Validity.Valid;\n        for (uint256 i = 0; i < parties.length; i = i.add(1)) {\n            _addPartyToContract(parties[i], contractAddress);\n        }\n\n        emit NewContractRegistered(contractAddress, msg.sender, parties);\n    }",
        "comments": [
            "/**",
            "     * @notice Registers a new financial contract.",
            "     * @dev Only authorized contract creators can call this method.",
            "     * @param parties array of addresses who become parties in the contract.",
            "     * @param contractAddress address of the contract against which the parties are registered.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Registers a new financial contract.\n     * @dev Only authorized contract creators can call this method.\n     * @param parties array of addresses who become parties in the contract.\n     * @param contractAddress address of the contract against which the parties are registered.\n     */\n",
        "@notice": "Registers a new financial contract.",
        "@dev": "Only authorized contract creators can call this method.",
        "@param1": "parties array of addresses who become parties in the contract.",
        "@param2": "contractAddress address of the contract against which the parties are registered.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addPartyToContract",
        "visibility": "external",
        "args": [
            {
                "name": "party",
                "type": "address"
            }
        ],
        "func": "function addPartyToContract(address party) external override {\n        address contractAddress = msg.sender;\n        require(contractMap[contractAddress].valid == Validity.Valid, \"Can only add to valid contract\");\n\n        _addPartyToContract(party, contractAddress);\n    }",
        "comments": [
            "/**",
            "     * @notice Adds a party member to the calling contract.",
            "     * @dev msg.sender will be used to determine the contract that this party is added to.",
            "     * @param party new party for the calling contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Adds a party member to the calling contract.\n     * @dev msg.sender will be used to determine the contract that this party is added to.\n     * @param party new party for the calling contract.\n     */\n",
        "@notice": "Adds a party member to the calling contract.",
        "@dev": "msg.sender will be used to determine the contract that this party is added to.",
        "@param1": "party new party for the calling contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removePartyFromContract",
        "visibility": "external",
        "args": [
            {
                "name": "partyAddress",
                "type": "address"
            }
        ],
        "func": "function removePartyFromContract(address partyAddress) external override {\n        address contractAddress = msg.sender;\n        Party storage party = partyMap[partyAddress];\n        uint256 numberOfContracts = party.contracts.length;\n\n        require(numberOfContracts != 0, \"Party has no contracts\");\n        require(contractMap[contractAddress].valid == Validity.Valid, \"Remove only from valid contract\");\n        require(isPartyMemberOfContract(partyAddress, contractAddress), \"Can only remove existing party\");\n\n        // Index of the current location of the contract to remove.\n        uint256 deleteIndex = party.contractIndex[contractAddress];\n\n        // Store the last contract's address to update the lookup map.\n        address lastContractAddress = party.contracts[numberOfContracts - 1];\n\n        // Swap the contract to be removed with the last contract.\n        party.contracts[deleteIndex] = lastContractAddress;\n\n        // Update the lookup index with the new location.\n        party.contractIndex[lastContractAddress] = deleteIndex;\n\n        // Pop the last contract from the array and update the lookup map.\n        party.contracts.pop();\n        delete party.contractIndex[contractAddress];\n\n        emit PartyRemoved(contractAddress, partyAddress);\n    }",
        "comments": [
            "/**",
            "     * @notice Removes a party member from the calling contract.",
            "     * @dev msg.sender will be used to determine the contract that this party is removed from.",
            "     * @param partyAddress address to be removed from the calling contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Removes a party member from the calling contract.\n     * @dev msg.sender will be used to determine the contract that this party is removed from.\n     * @param partyAddress address to be removed from the calling contract.\n     */\n",
        "@notice": "Removes a party member from the calling contract.",
        "@dev": "msg.sender will be used to determine the contract that this party is removed from.",
        "@param1": "partyAddress address to be removed from the calling contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isContractRegistered",
        "visibility": "external",
        "args": [
            {
                "name": "contractAddress",
                "type": "address"
            }
        ],
        "func": "function isContractRegistered(address contractAddress) external override view returns (bool) {\n        return contractMap[contractAddress].valid == Validity.Valid;\n    }",
        "comments": [
            "/**",
            "     * @notice Returns whether the contract has been registered with the registry.",
            "     * @dev If it is registered, it is an authorized participant in the UMA system.",
            "     * @param contractAddress address of the financial contract.",
            "     * @return bool indicates whether the contract is registered.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns whether the contract has been registered with the registry.\n     * @dev If it is registered, it is an authorized participant in the UMA system.\n     * @param contractAddress address of the financial contract.\n     * @return bool indicates whether the contract is registered.\n     */\n",
        "@notice": "Returns whether the contract has been registered with the registry.",
        "@dev": "If it is registered, it is an authorized participant in the UMA system.",
        "@param1": "contractAddress address of the financial contract.",
        "@return1": "bool indicates whether the contract is registered.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getRegisteredContracts",
        "visibility": "external",
        "args": [
            {
                "name": "party",
                "type": "address"
            }
        ],
        "func": "function getRegisteredContracts(address party) external override view returns (address[] memory) {\n        return partyMap[party].contracts;\n    }",
        "comments": [
            "/**",
            "     * @notice Returns a list of all contracts that are associated with a particular party.",
            "     * @param party address of the party.",
            "     * @return an array of the contracts the party is registered to.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns a list of all contracts that are associated with a particular party.\n     * @param party address of the party.\n     * @return an array of the contracts the party is registered to.\n     */\n",
        "@notice": "Returns a list of all contracts that are associated with a particular party.",
        "@param1": "party address of the party.",
        "@return1": "an array of the contracts the party is registered to.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAllRegisteredContracts",
        "visibility": "external",
        "args": [],
        "func": "function getAllRegisteredContracts() external override view returns (address[] memory) {\n        return registeredContracts;\n    }",
        "comments": [
            "/**",
            "     * @notice Returns all registered contracts.",
            "     * @return all registered contract addresses within the system.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns all registered contracts.\n     * @return all registered contract addresses within the system.\n     */\n",
        "@notice": "Returns all registered contracts.",
        "@return1": "all registered contract addresses within the system.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isPartyMemberOfContract",
        "visibility": "public",
        "args": [
            {
                "name": "party",
                "type": "address"
            },
            {
                "name": "contractAddress",
                "type": "address"
            }
        ],
        "func": "function isPartyMemberOfContract(address party, address contractAddress) public override view returns (bool) {\n        uint256 index = partyMap[party].contractIndex[contractAddress];\n        return partyMap[party].contracts.length > index && partyMap[party].contracts[index] == contractAddress;\n    }",
        "comments": [
            "/**",
            "     * @notice checks if an address is a party of a contract.",
            "     * @param party party to check.",
            "     * @param contractAddress address to check against the party.",
            "     * @return bool indicating if the address is a party of the contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice checks if an address is a party of a contract.\n     * @param party party to check.\n     * @param contractAddress address to check against the party.\n     * @return bool indicating if the address is a party of the contract.\n     */\n",
        "@notice": "checks if an address is a party of a contract.",
        "@param1": "party party to check.",
        "@param2": "contractAddress address to check against the party.",
        "@return1": "bool indicating if the address is a party of the contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapAddVote",
        "visibility": "external",
        "args": [
            {
                "name": "votePrice",
                "type": "int256"
            },
            {
                "name": "numberTokens",
                "type": "uint256"
            }
        ],
        "func": "function wrapAddVote(int256 votePrice, uint256 numberTokens) external {\n        data.addVote(votePrice, FixedPoint.Unsigned(numberTokens));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapGetResolvedPrice",
        "visibility": "external",
        "args": [
            {
                "name": "minVoteThreshold",
                "type": "uint256"
            }
        ],
        "func": "function wrapGetResolvedPrice(uint256 minVoteThreshold) external view returns (bool isResolved, int256 price) {\n        return data.getResolvedPrice(FixedPoint.Unsigned(minVoteThreshold));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapWasVoteCorrect",
        "visibility": "external",
        "args": [
            {
                "name": "revealHash",
                "type": "bytes32"
            }
        ],
        "func": "function wrapWasVoteCorrect(bytes32 revealHash) external view returns (bool) {\n        return data.wasVoteCorrect(revealHash);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapGetTotalCorrectlyVotedTokens",
        "visibility": "external",
        "args": [],
        "func": "function wrapGetTotalCorrectlyVotedTokens() external view returns (uint256) {\n        return data.getTotalCorrectlyVotedTokens().rawValue;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "payOracleFees",
        "visibility": "external",
        "args": [],
        "func": "function payOracleFees() external override payable {\n        require(msg.value > 0, \"Value sent can't be zero\");\n    }",
        "comments": [
            "/**",
            "     * @notice Pays Oracle fees in ETH to the store.",
            "     * @dev To be used by contracts whose margin currency is ETH.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Pays Oracle fees in ETH to the store.\n     * @dev To be used by contracts whose margin currency is ETH.\n     */\n",
        "@notice": "Pays Oracle fees in ETH to the store.",
        "@dev": "To be used by contracts whose margin currency is ETH.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "payOracleFeesErc20",
        "visibility": "external",
        "args": [
            {
                "name": "erc20Address",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "FixedPoint.Unsigned calldata"
            }
        ],
        "func": "function payOracleFeesErc20(address erc20Address, FixedPoint.Unsigned calldata amount) external override {\n        IERC20 erc20 = IERC20(erc20Address);\n        require(amount.isGreaterThan(0), \"Amount sent can't be zero\");\n        erc20.safeTransferFrom(msg.sender, address(this), amount.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Pays oracle fees in the margin currency, erc20Address, to the store.",
            "     * @dev To be used if the margin currency is an ERC20 token rather than ETH.",
            "     * @param erc20Address address of the ERC20 token used to pay the fee.",
            "     * @param amount number of tokens to transfer. An approval for at least this amount must exist.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Pays oracle fees in the margin currency, erc20Address, to the store.\n     * @dev To be used if the margin currency is an ERC20 token rather than ETH.\n     * @param erc20Address address of the ERC20 token used to pay the fee.\n     * @param amount number of tokens to transfer. An approval for at least this amount must exist.\n     */\n",
        "@notice": "Pays oracle fees in the margin currency, erc20Address, to the store.",
        "@dev": "To be used if the margin currency is an ERC20 token rather than ETH.",
        "@param1": "erc20Address address of the ERC20 token used to pay the fee.",
        "@param2": "amount number of tokens to transfer. An approval for at least this amount must exist.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "computeRegularFee",
        "visibility": "external",
        "args": [
            {
                "name": "startTime",
                "type": "uint256"
            },
            {
                "name": "endTime",
                "type": "uint256"
            },
            {
                "name": "pfc",
                "type": "FixedPoint.Unsigned calldata"
            }
        ],
        "func": "function computeRegularFee(\n        uint256 startTime,\n        uint256 endTime,\n        FixedPoint.Unsigned calldata pfc\n    ) external override view returns (FixedPoint.Unsigned memory regularFee, FixedPoint.Unsigned memory latePenalty) {\n        uint256 timeDiff = endTime.sub(startTime);\n\n        // Multiply by the unscaled `timeDiff` first, to get more accurate results.\n        regularFee = pfc.mul(timeDiff).mul(fixedOracleFeePerSecondPerPfc);\n\n        // Compute how long ago the start time was to compute the delay penalty.\n        uint256 paymentDelay = getCurrentTime().sub(startTime);\n\n        // Compute the additional percentage (per second) that will be charged because of the penalty.\n        // Note: if less than a week has gone by since the startTime, paymentDelay / SECONDS_PER_WEEK will truncate to\n        // 0, causing no penalty to be charged.\n        FixedPoint.Unsigned memory penaltyPercentagePerSecond = weeklyDelayFeePerSecondPerPfc.mul(\n            paymentDelay.div(SECONDS_PER_WEEK)\n        );\n\n        // Apply the penaltyPercentagePerSecond to the payment period.\n        latePenalty = pfc.mul(timeDiff).mul(penaltyPercentagePerSecond);\n    }",
        "comments": [
            "/**",
            "     * @notice Computes the regular oracle fees that a contract should pay for a period.",
            "     * @dev The late penalty is similar to the regular fee in that is is charged per second over the period between",
            "     * startTime and endTime. The late penalty percentage increases over time as follows:",
            "     * - 0-1 week since startTime: no late penalty",
            "     * - 1-2 weeks since startTime: 1x late penalty percentage is applied",
            "     * - 2-3 weeks since startTime: 2x late penalty percentage is applied",
            "     * - ...",
            "     * @param startTime defines the beginning time from which the fee is paid.",
            "     * @param endTime end time until which the fee is paid.",
            "     * @param pfc \"profit from corruption\", or the maximum amount of margin currency that a",
            "     * token sponsor could extract from the contract through corrupting the price feed in their favor.",
            "     * @return regularFee amount owed for the duration from start to end time for the given pfc.",
            "     * @return latePenalty penalty percentage, if any, for paying the fee after the deadline.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Computes the regular oracle fees that a contract should pay for a period.\n     * @dev The late penalty is similar to the regular fee in that is is charged per second over the period between\n     * startTime and endTime. The late penalty percentage increases over time as follows:\n     * - 0-1 week since startTime: no late penalty\n     * - 1-2 weeks since startTime: 1x late penalty percentage is applied\n     * - 2-3 weeks since startTime: 2x late penalty percentage is applied\n     * - ...\n     * @param startTime defines the beginning time from which the fee is paid.\n     * @param endTime end time until which the fee is paid.\n     * @param pfc \"profit from corruption\", or the maximum amount of margin currency that a\n     * token sponsor could extract from the contract through corrupting the price feed in their favor.\n     * @return regularFee amount owed for the duration from start to end time for the given pfc.\n     * @return latePenalty penalty percentage, if any, for paying the fee after the deadline.\n     */\n",
        "@notice": "Computes the regular oracle fees that a contract should pay for a period.",
        "@dev": "The late penalty is similar to the regular fee in that is is charged per second over the period between * startTime and endTime. The late penalty percentage increases over time as follows: * - 0-1 week since startTime: no late penalty * - 1-2 weeks since startTime: 1x late penalty percentage is applied * - 2-3 weeks since startTime: 2x late penalty percentage is applied * - ...",
        "@param1": "startTime defines the beginning time from which the fee is paid.",
        "@param2": "endTime end time until which the fee is paid.",
        "@param3": "pfc \"profit from corruption\", or the maximum amount of margin currency that a * token sponsor could extract from the contract through corrupting the price feed in their favor.",
        "@return1": "regularFee amount owed for the duration from start to end time for the given pfc.",
        "@return2": "latePenalty penalty percentage, if any, for paying the fee after the deadline.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "computeFinalFee",
        "visibility": "external",
        "args": [
            {
                "name": "currency",
                "type": "address"
            }
        ],
        "func": "function computeFinalFee(address currency) external override view returns (FixedPoint.Unsigned memory) {\n        return finalFees[currency];\n    }",
        "comments": [
            "/**",
            "     * @notice Computes the final oracle fees that a contract should pay at settlement.",
            "     * @param currency token used to pay the final fee.",
            "     * @return finalFee amount due denominated in units of `currency`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Computes the final oracle fees that a contract should pay at settlement.\n     * @param currency token used to pay the final fee.\n     * @return finalFee amount due denominated in units of `currency`.\n     */\n",
        "@notice": "Computes the final oracle fees that a contract should pay at settlement.",
        "@param1": "currency token used to pay the final fee.",
        "@return1": "finalFee amount due denominated in units of `currency`.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setFixedOracleFeePerSecondPerPfc",
        "visibility": "public",
        "args": [
            {
                "name": "newFixedOracleFeePerSecondPerPfc",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function setFixedOracleFeePerSecondPerPfc(FixedPoint.Unsigned memory newFixedOracleFeePerSecondPerPfc)\n        public\n        onlyRoleHolder(uint256(Roles.Owner))\n    {\n        // Oracle fees at or over 100% don't make sense.\n        require(newFixedOracleFeePerSecondPerPfc.isLessThan(1), \"Fee must be < 100% per second.\");\n        fixedOracleFeePerSecondPerPfc = newFixedOracleFeePerSecondPerPfc;\n        emit NewFixedOracleFeePerSecondPerPfc(newFixedOracleFeePerSecondPerPfc);\n    }",
        "comments": [
            "/**",
            "     * @notice Sets a new oracle fee per second.",
            "     * @param newFixedOracleFeePerSecondPerPfc new fee per second charged to use the oracle.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sets a new oracle fee per second.\n     * @param newFixedOracleFeePerSecondPerPfc new fee per second charged to use the oracle.\n     */\n",
        "@notice": "Sets a new oracle fee per second.",
        "@param1": "newFixedOracleFeePerSecondPerPfc new fee per second charged to use the oracle.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setWeeklyDelayFeePerSecondPerPfc",
        "visibility": "public",
        "args": [
            {
                "name": "newWeeklyDelayFeePerSecondPerPfc",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function setWeeklyDelayFeePerSecondPerPfc(FixedPoint.Unsigned memory newWeeklyDelayFeePerSecondPerPfc)\n        public\n        onlyRoleHolder(uint256(Roles.Owner))\n    {\n        require(newWeeklyDelayFeePerSecondPerPfc.isLessThan(1), \"weekly delay fee must be < 100%\");\n        weeklyDelayFeePerSecondPerPfc = newWeeklyDelayFeePerSecondPerPfc;\n        emit NewWeeklyDelayFeePerSecondPerPfc(newWeeklyDelayFeePerSecondPerPfc);\n    }",
        "comments": [
            "/**",
            "     * @notice Sets a new weekly delay fee.",
            "     * @param newWeeklyDelayFeePerSecondPerPfc fee escalation per week of late fee payment.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sets a new weekly delay fee.\n     * @param newWeeklyDelayFeePerSecondPerPfc fee escalation per week of late fee payment.\n     */\n",
        "@notice": "Sets a new weekly delay fee.",
        "@param1": "newWeeklyDelayFeePerSecondPerPfc fee escalation per week of late fee payment.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setFinalFee",
        "visibility": "public",
        "args": [
            {
                "name": "currency",
                "type": "address"
            },
            {
                "name": "newFinalFee",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function setFinalFee(address currency, FixedPoint.Unsigned memory newFinalFee)\n        public\n        onlyRoleHolder(uint256(Roles.Owner))\n    {\n        finalFees[currency] = newFinalFee;\n        emit NewFinalFee(newFinalFee);\n    }",
        "comments": [
            "/**",
            "     * @notice Sets a new final fee for a particular currency.",
            "     * @param currency defines the token currency used to pay the final fee.",
            "     * @param newFinalFee final fee amount.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sets a new final fee for a particular currency.\n     * @param currency defines the token currency used to pay the final fee.\n     * @param newFinalFee final fee amount.\n     */\n",
        "@notice": "Sets a new final fee for a particular currency.",
        "@param1": "currency defines the token currency used to pay the final fee.",
        "@param2": "newFinalFee final fee amount.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addMinter",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function addMinter(address account) external {\n        addMember(uint256(Roles.Minter), account);\n    }",
        "comments": [
            "/**",
            "     * @notice Add Minter role to account.",
            "     * @dev The caller must have the Owner role.",
            "     * @param account The address to which the Minter role is added.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Add Minter role to account.\n     * @dev The caller must have the Owner role.\n     * @param account The address to which the Minter role is added.\n     */\n",
        "@notice": "Add Minter role to account.",
        "@dev": "The caller must have the Owner role.",
        "@param1": "account The address to which the Minter role is added.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeMinter",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function removeMinter(address account) external {\n        removeMember(uint256(Roles.Minter), account);\n    }",
        "comments": [
            "/**",
            "     * @notice Remove Minter role from account.",
            "     * @dev The caller must have the Owner role.",
            "     * @param account The address from which the Minter role is removed.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Remove Minter role from account.\n     * @dev The caller must have the Owner role.\n     * @param account The address from which the Minter role is removed.\n     */\n",
        "@notice": "Remove Minter role from account.",
        "@dev": "The caller must have the Owner role.",
        "@param1": "account The address from which the Minter role is removed.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addBurner",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function addBurner(address account) external {\n        addMember(uint256(Roles.Burner), account);\n    }",
        "comments": [
            "/**",
            "     * @notice Add Burner role to account.",
            "     * @dev The caller must have the Owner role.",
            "     * @param account The address to which the Burner role is added.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Add Burner role to account.\n     * @dev The caller must have the Owner role.\n     * @param account The address to which the Burner role is added.\n     */\n",
        "@notice": "Add Burner role to account.",
        "@dev": "The caller must have the Owner role.",
        "@param1": "account The address to which the Burner role is added.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeBurner",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function removeBurner(address account) external {\n        removeMember(uint256(Roles.Burner), account);\n    }",
        "comments": [
            "/**",
            "     * @notice Removes Burner role from account.",
            "     * @dev The caller must have the Owner role.",
            "     * @param account The address from which the Burner role is removed.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Removes Burner role from account.\n     * @dev The caller must have the Owner role.\n     * @param account The address from which the Burner role is removed.\n     */\n",
        "@notice": "Removes Burner role from account.",
        "@dev": "The caller must have the Owner role.",
        "@param1": "account The address from which the Burner role is removed.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "resetOwner",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function resetOwner(address account) external {\n        resetMember(uint256(Roles.Owner), account);\n    }",
        "comments": [
            "/**",
            "     * @notice Reset Owner role to account.",
            "     * @dev The caller must have the Owner role.",
            "     * @param account The new holder of the Owner role.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Reset Owner role to account.\n     * @dev The caller must have the Owner role.\n     * @param account The new holder of the Owner role.\n     */\n",
        "@notice": "Reset Owner role to account.",
        "@dev": "The caller must have the Owner role.",
        "@param1": "account The new holder of the Owner role.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isMinter",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function isMinter(address account) public view returns (bool) {\n        return holdsRole(uint256(Roles.Minter), account);\n    }",
        "comments": [
            "/**",
            "     * @notice Checks if a given account holds the Minter role.",
            "     * @param account The address which is checked for the Minter role.",
            "     * @return bool True if the provided account is a Minter.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Checks if a given account holds the Minter role.\n     * @param account The address which is checked for the Minter role.\n     * @return bool True if the provided account is a Minter.\n     */\n",
        "@notice": "Checks if a given account holds the Minter role.",
        "@param1": "account The address which is checked for the Minter role.",
        "@return1": "bool True if the provided account is a Minter.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isBurner",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function isBurner(address account) public view returns (bool) {\n        return holdsRole(uint256(Roles.Burner), account);\n    }",
        "comments": [
            "/**",
            "     * @notice Checks if a given account holds the Burner role.",
            "     * @param account The address which is checked for the Burner role.",
            "     * @return bool True if the provided account is a Burner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Checks if a given account holds the Burner role.\n     * @param account The address which is checked for the Burner role.\n     * @return bool True if the provided account is a Burner.\n     */\n",
        "@notice": "Checks if a given account holds the Burner role.",
        "@param1": "account The address which is checked for the Burner role.",
        "@return1": "bool True if the provided account is a Burner.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setCurrentTime",
        "visibility": "external",
        "args": [
            {
                "name": "time",
                "type": "uint256"
            }
        ],
        "func": "function setCurrentTime(uint256 time) external onlyIfTest {\n        Timer(timerAddress).setCurrentTime(time);\n    }",
        "comments": [
            "/**",
            "     * @notice Sets the current time.",
            "     * @dev Will revert if not running in test mode.",
            "     * @param time timestamp to set current Tesable time to.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sets the current time.\n     * @dev Will revert if not running in test mode.\n     * @param time timestamp to set current Tesable time to.\n     */\n",
        "@notice": "Sets the current time.",
        "@dev": "Will revert if not running in test mode.",
        "@param1": "time timestamp to set current Tesable time to.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentTime",
        "visibility": "public",
        "args": [],
        "func": "function getCurrentTime() public view returns (uint256) {\n        if (timerAddress != address(0x0)) {\n            return Timer(timerAddress).getCurrentTime();\n        } else {\n            return now; // solhint-disable-line not-rely-on-time\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.",
            "     * Otherwise, it will return the block timestamp.",
            "     * @return uint for the current Testable timestamp.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\n     * Otherwise, it will return the block timestamp.\n     * @return uint for the current Testable timestamp.\n     */\n",
        "@notice": "Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode. * Otherwise, it will return the block timestamp.",
        "@return1": "uint for the current Testable timestamp.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getTestableTimeAndBlockTime",
        "visibility": "external",
        "args": [],
        "func": "function getTestableTimeAndBlockTime() external view returns (uint256 testableTime, uint256 blockTime) {\n        // solhint-disable-next-line not-rely-on-time\n        return (getCurrentTime(), now);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allocateTo",
        "visibility": "external",
        "args": [
            {
                "name": "ownerAddress",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint256"
            }
        ],
        "func": "function allocateTo(address ownerAddress, uint256 value) external {\n        _mint(ownerAddress, value);\n    }",
        "comments": [
            "",
            "    // Sample token information.",
            "",
            "    /**",
            "     * @notice Mints value tokens to the owner address.",
            "     * @param ownerAddress the address to mint to.",
            "     * @param value the amount of tokens to mint.",
            "     */",
            "    "
        ],
        "comt": "\n    // Sample token information.\n\n    /**\n     * @notice Mints value tokens to the owner address.\n     * @param ownerAddress the address to mint to.\n     * @param value the amount of tokens to mint.\n     */\n    ",
        "@notice": "Mints value tokens to the owner address.",
        "@param1": "ownerAddress the address to mint to.",
        "@param2": "value the amount of tokens to mint.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setCurrentTime",
        "visibility": "external",
        "args": [
            {
                "name": "time",
                "type": "uint256"
            }
        ],
        "func": "function setCurrentTime(uint256 time) external {\n        currentTime = time;\n    }",
        "comments": [
            "/**",
            "     * @notice Sets the current time.",
            "     * @dev Will revert if not running in test mode.",
            "     * @param time timestamp to set `currentTime` to.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sets the current time.\n     * @dev Will revert if not running in test mode.\n     * @param time timestamp to set `currentTime` to.\n     */\n",
        "@notice": "Sets the current time.",
        "@dev": "Will revert if not running in test mode.",
        "@param1": "time timestamp to set `currentTime` to.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentTime",
        "visibility": "public",
        "args": [],
        "func": "function getCurrentTime() public view returns (uint256) {\n        return currentTime;\n    }",
        "comments": [
            "/**",
            "     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.",
            "     * Otherwise, it will return the block timestamp.",
            "     * @return uint256 for the current Testable timestamp.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\n     * Otherwise, it will return the block timestamp.\n     * @return uint256 for the current Testable timestamp.\n     */\n",
        "@notice": "Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode. * Otherwise, it will return the block timestamp.",
        "@return1": "uint256 for the current Testable timestamp.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createToken",
        "visibility": "external",
        "args": [
            {
                "name": "tokenName",
                "type": "string calldata"
            },
            {
                "name": "tokenSymbol",
                "type": "string calldata"
            },
            {
                "name": "tokenDecimals",
                "type": "uint8"
            }
        ],
        "func": "function createToken(\n        string calldata tokenName,\n        string calldata tokenSymbol,\n        uint8 tokenDecimals\n    ) external returns (ExpandedIERC20 newToken) {\n        SyntheticToken mintableToken = new SyntheticToken(tokenName, tokenSymbol, tokenDecimals);\n        mintableToken.addMinter(msg.sender);\n        mintableToken.addBurner(msg.sender);\n        mintableToken.resetOwner(msg.sender);\n        newToken = ExpandedIERC20(address(mintableToken));\n    }",
        "comments": [
            "/**",
            "     * @notice Create a new token and return to the caller.",
            "     * @dev The caller will become the only minter and burner and the new owner capable of adding new roles.",
            "     * @param tokenName used to describe the new token.",
            "     * @param tokenSymbol short ticker abbreviation of the name. Ideally < 5 chars.",
            "     * @param tokenDecimals used to define the precision used in the tokens numerical representation.",
            "     * @return newToken an instance of the newly created token interface.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Create a new token and return to the caller.\n     * @dev The caller will become the only minter and burner and the new owner capable of adding new roles.\n     * @param tokenName used to describe the new token.\n     * @param tokenSymbol short ticker abbreviation of the name. Ideally < 5 chars.\n     * @param tokenDecimals used to define the precision used in the tokens numerical representation.\n     * @return newToken an instance of the newly created token interface.\n     */\n",
        "@notice": "Create a new token and return to the caller.",
        "@dev": "The caller will become the only minter and burner and the new owner capable of adding new roles.",
        "@param1": "tokenName used to describe the new token.",
        "@param2": "tokenSymbol short ticker abbreviation of the name. Ideally < 5 chars.",
        "@param3": "tokenDecimals used to define the precision used in the tokens numerical representation.",
        "@return1": "newToken an instance of the newly created token interface.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_depositAndCreateTokens",
        "visibility": "external",
        "args": [
            {
                "name": "s",
                "type": "TDS.Storage storage"
            },
            {
                "name": "marginForPurchase",
                "type": "uint256"
            },
            {
                "name": "tokensToPurchase",
                "type": "uint256"
            }
        ],
        "func": "function _depositAndCreateTokens(\n        TDS.Storage storage s,\n        uint256 marginForPurchase,\n        uint256 tokensToPurchase\n    ) external onlySponsorOrApDelegate(s) {\n        s._remarginInternal();\n\n        int256 newTokenNav = _computeNavForTokens(s.currentTokenState.tokenPrice, tokensToPurchase);\n\n        if (newTokenNav < 0) {\n            newTokenNav = 0;\n        }\n\n        uint256 positiveTokenNav = _safeUintCast(newTokenNav);\n\n        // Get any refund due to sending more margin than the argument indicated (should only be able to happen in the\n        // ETH case).\n        uint256 refund = s._pullSentMargin(marginForPurchase);\n\n        // Subtract newTokenNav from amount sent.\n        uint256 depositAmount = marginForPurchase.sub(positiveTokenNav);\n\n        // Deposit additional margin into the short account.\n        s._depositInternal(depositAmount);\n\n        // The _createTokensInternal call returns any refund due to the amount sent being larger than the amount\n        // required to purchase the tokens, so we add that to the running refund. This should be 0 in this case,\n        // but we leave this here in case of some refund being generated due to rounding errors or any bugs to ensure\n        // the sender never loses money.\n        refund = refund.add(s._createTokensInternal(tokensToPurchase, positiveTokenNav));\n\n        // Send the accumulated refund.\n        s._sendMargin(refund);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_redeemTokens",
        "visibility": "external",
        "args": [
            {
                "name": "s",
                "type": "TDS.Storage storage"
            },
            {
                "name": "tokensToRedeem",
                "type": "uint256"
            }
        ],
        "func": "function _redeemTokens(TDS.Storage storage s, uint256 tokensToRedeem) external {\n        require(s.state == TDS.State.Live || s.state == TDS.State.Settled);\n        require(tokensToRedeem > 0);\n\n        if (s.state == TDS.State.Live) {\n            require(msg.sender == s.externalAddresses.sponsor || msg.sender == s.externalAddresses.apDelegate);\n            s._remarginInternal();\n            require(s.state == TDS.State.Live);\n        }\n\n        ExpandedIERC20 thisErc20Token = ExpandedIERC20(address(this));\n\n        uint256 initialSupply = _totalSupply();\n        require(initialSupply > 0);\n\n        _pullAuthorizedTokens(thisErc20Token, tokensToRedeem);\n        thisErc20Token.burn(tokensToRedeem);\n        emit TokensRedeemed(s.fixedParameters.symbol, tokensToRedeem);\n\n        // Value of the tokens is just the percentage of all the tokens multiplied by the balance of the investor\n        // margin account.\n        uint256 tokenPercentage = tokensToRedeem.mul(UINT_FP_SCALING_FACTOR).div(initialSupply);\n        uint256 tokenMargin = _takePercentage(_safeUintCast(s.longBalance), tokenPercentage);\n\n        s.longBalance = s.longBalance.sub(_safeIntCast(tokenMargin));\n        assert(s.longBalance >= 0);\n        s.nav = _computeNavForTokens(s.currentTokenState.tokenPrice, _totalSupply());\n\n        s._sendMargin(tokenMargin);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_dispute",
        "visibility": "external",
        "args": [
            {
                "name": "s",
                "type": "TDS.Storage storage"
            },
            {
                "name": "depositMargin",
                "type": "uint256"
            }
        ],
        "func": "function _dispute(TDS.Storage storage s, uint256 depositMargin) external onlySponsor(s) {\n        require(s.state == TDS.State.Live, \"Contract must be Live to dispute\");\n\n        uint256 requiredDeposit = _safeUintCast(\n            _takePercentage(s._getRequiredMargin(s.currentTokenState), s.fixedParameters.disputeDeposit)\n        );\n\n        uint256 sendInconsistencyRefund = s._pullSentMargin(depositMargin);\n\n        require(depositMargin >= requiredDeposit);\n        uint256 overpaymentRefund = depositMargin.sub(requiredDeposit);\n\n        s.state = TDS.State.Disputed;\n        s.endTime = s.currentTokenState.time;\n        s.disputeInfo.disputedNav = s.nav;\n        s.disputeInfo.deposit = requiredDeposit;\n\n        // Store the default penalty in case the dispute pushes the sponsor into default.\n        s.defaultPenaltyAmount = s._computeDefaultPenalty();\n        emit Disputed(s.fixedParameters.symbol, s.endTime, s.nav);\n\n        s._requestOraclePrice(s.endTime);\n\n        // Add the two types of refunds:\n        // 1. The refund for ETH sent if it was > depositMargin.\n        // 2. The refund for depositMargin > requiredDeposit.\n        s._sendMargin(sendInconsistencyRefund.add(overpaymentRefund));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_withdraw",
        "visibility": "external",
        "args": [
            {
                "name": "s",
                "type": "TDS.Storage storage"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function _withdraw(TDS.Storage storage s, uint256 amount) external onlySponsor(s) {\n        // Remargin before allowing a withdrawal, but only if in the live state.\n        if (s.state == TDS.State.Live) {\n            s._remarginInternal();\n        }\n\n        // Make sure either in Live or Settled after any necessary remargin.\n        require(s.state == TDS.State.Live || s.state == TDS.State.Settled);\n\n        // If the contract has been settled or is in prefunded state then can\n        // withdraw up to full balance. If the contract is in live state then\n        // must leave at least the required margin. Not allowed to withdraw in\n        // other states.\n        int256 withdrawableAmount;\n        if (s.state == TDS.State.Settled) {\n            withdrawableAmount = s.shortBalance;\n        } else {\n            // Update throttling snapshot and verify that this withdrawal doesn't go past the throttle limit.\n            uint256 currentTime = s.currentTokenState.time;\n            if (s.withdrawThrottle.startTime <= currentTime.sub(SECONDS_PER_DAY)) {\n                // We've passed the previous s.withdrawThrottle window. Start new one.\n                s.withdrawThrottle.startTime = currentTime;\n                s.withdrawThrottle.remainingWithdrawal = _takePercentage(\n                    _safeUintCast(s.shortBalance),\n                    s.fixedParameters.withdrawLimit\n                );\n            }\n\n            int256 marginMaxWithdraw = s.shortBalance.sub(s._getRequiredMargin(s.currentTokenState));\n            int256 throttleMaxWithdraw = _safeIntCast(s.withdrawThrottle.remainingWithdrawal);\n\n            // Take the smallest of the two withdrawal limits.\n            withdrawableAmount = throttleMaxWithdraw < marginMaxWithdraw ? throttleMaxWithdraw : marginMaxWithdraw;\n\n            // Note: this line alone implicitly ensures the withdrawal throttle is not violated, but the above\n            // ternary is more explicit.\n            s.withdrawThrottle.remainingWithdrawal = s.withdrawThrottle.remainingWithdrawal.sub(amount);\n        }\n\n        // Can only withdraw the allowed amount.\n        require(withdrawableAmount >= _safeIntCast(amount), \"Attempting to withdraw more than allowed\");\n\n        // Transfer amount - Note: important to `-=` before the send so that the\n        // function can not be called multiple times while waiting for transfer\n        // to return.\n        s.shortBalance = s.shortBalance.sub(_safeIntCast(amount));\n        emit Withdrawal(s.fixedParameters.symbol, amount);\n        s._sendMargin(amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_acceptPriceAndSettle",
        "visibility": "external",
        "args": [
            {
                "name": "s",
                "type": "TDS.Storage storage"
            }
        ],
        "func": "function _acceptPriceAndSettle(TDS.Storage storage s) external onlySponsor(s) {\n        // Right now, only confirming prices in the defaulted state.\n        require(s.state == TDS.State.Defaulted);\n\n        // Remargin on agreed upon price.\n        s._settleAgreedPrice();\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_setApDelegate",
        "visibility": "external",
        "args": [
            {
                "name": "s",
                "type": "TDS.Storage storage"
            },
            {
                "name": "_apDelegate",
                "type": "address"
            }
        ],
        "func": "function _setApDelegate(TDS.Storage storage s, address _apDelegate) external onlySponsor(s) {\n        s.externalAddresses.apDelegate = _apDelegate;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_emergencyShutdown",
        "visibility": "external",
        "args": [
            {
                "name": "s",
                "type": "TDS.Storage storage"
            }
        ],
        "func": "function _emergencyShutdown(TDS.Storage storage s) external onlyAdmin(s) {\n        require(s.state == TDS.State.Live);\n        s.state = TDS.State.Emergency;\n        s.endTime = s.currentTokenState.time;\n        s.defaultPenaltyAmount = s._computeDefaultPenalty();\n        emit EmergencyShutdownTransition(s.fixedParameters.symbol, s.endTime);\n        s._requestOraclePrice(s.endTime);\n    }",
        "comments": [
            "",
            "    // Moves the contract into the Emergency state, where it waits on an Oracle price for the most recent remargin time.",
            "    "
        ],
        "comt": "\n    // Moves the contract into the Emergency state, where it waits on an Oracle price for the most recent remargin time.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_settle",
        "visibility": "external",
        "args": [
            {
                "name": "s",
                "type": "TDS.Storage storage"
            }
        ],
        "func": "function _settle(TDS.Storage storage s) external {\n        s._settleInternal();\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_createTokens",
        "visibility": "external",
        "args": [
            {
                "name": "s",
                "type": "TDS.Storage storage"
            },
            {
                "name": "marginForPurchase",
                "type": "uint256"
            },
            {
                "name": "tokensToPurchase",
                "type": "uint256"
            }
        ],
        "func": "function _createTokens(\n        TDS.Storage storage s,\n        uint256 marginForPurchase,\n        uint256 tokensToPurchase\n    ) external onlySponsorOrApDelegate(s) {\n        // Returns any refund due to sending more margin than the argument indicated (should only be able to happen in\n        // the ETH case).\n        uint256 refund = s._pullSentMargin(marginForPurchase);\n\n        // The _createTokensInternal call returns any refund due to the amount sent being larger than the amount\n        // required to purchase the tokens, so we add that to the running refund.\n        refund = refund.add(s._createTokensInternal(tokensToPurchase, marginForPurchase));\n\n        // Send the accumulated refund.\n        s._sendMargin(refund);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_deposit",
        "visibility": "external",
        "args": [
            {
                "name": "s",
                "type": "TDS.Storage storage"
            },
            {
                "name": "marginToDeposit",
                "type": "uint256"
            }
        ],
        "func": "function _deposit(TDS.Storage storage s, uint256 marginToDeposit) external onlySponsor(s) {\n        // Only allow the s.externalAddresses.sponsor to deposit margin.\n        uint256 refund = s._pullSentMargin(marginToDeposit);\n        s._depositInternal(marginToDeposit);\n\n        // Send any refund due to sending more margin than the argument indicated (should only be able to happen in the\n        // ETH case).\n        s._sendMargin(refund);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_remargin",
        "visibility": "external",
        "args": [
            {
                "name": "s",
                "type": "TDS.Storage storage"
            }
        ],
        "func": "function _remargin(TDS.Storage storage s) external onlySponsorOrAdmin(s) {\n        s._remarginInternal();\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_withdrawUnexpectedErc20",
        "visibility": "external",
        "args": [
            {
                "name": "s",
                "type": "TDS.Storage storage"
            },
            {
                "name": "erc20Address",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function _withdrawUnexpectedErc20(\n        TDS.Storage storage s,\n        address erc20Address,\n        uint256 amount\n    ) external onlySponsor(s) {\n        if (address(s.externalAddresses.marginCurrency) == erc20Address) {\n            uint256 currentBalance = s.externalAddresses.marginCurrency.balanceOf(address(this));\n            int256 totalBalances = s.shortBalance.add(s.longBalance);\n            assert(totalBalances >= 0);\n            uint256 withdrawableAmount = currentBalance.sub(_safeUintCast(totalBalances)).sub(s.disputeInfo.deposit);\n            require(withdrawableAmount >= amount);\n        }\n\n        IERC20 erc20 = IERC20(erc20Address);\n        require(erc20.transfer(msg.sender, amount));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_calcNAV",
        "visibility": "external",
        "args": [
            {
                "name": "s",
                "type": "TDS.Storage storage"
            }
        ],
        "func": "function _calcNAV(TDS.Storage storage s) external view returns (int256 navNew) {\n        (TDS.TokenState memory newTokenState, ) = s._calcNewTokenStateAndBalance();\n        navNew = _computeNavForTokens(newTokenState.tokenPrice, _totalSupply());\n    }",
        "comments": [
            "",
            "    // Returns the expected net asset value (NAV) of the contract using the latest available Price Feed price.",
            "    "
        ],
        "comt": "\n    // Returns the expected net asset value (NAV) of the contract using the latest available Price Feed price.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_calcTokenValue",
        "visibility": "external",
        "args": [
            {
                "name": "s",
                "type": "TDS.Storage storage"
            }
        ],
        "func": "function _calcTokenValue(TDS.Storage storage s) external view returns (int256 newTokenValue) {\n        (TDS.TokenState memory newTokenState, ) = s._calcNewTokenStateAndBalance();\n        newTokenValue = newTokenState.tokenPrice;\n    }",
        "comments": [
            "",
            "    // Returns the expected value of each the outstanding tokens of the contract using the latest available Price Feed",
            "    // price.",
            "    "
        ],
        "comt": "\n    // Returns the expected value of each the outstanding tokens of the contract using the latest available Price Feed\n    // price.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_calcShortMarginBalance",
        "visibility": "external",
        "args": [
            {
                "name": "s",
                "type": "TDS.Storage storage"
            }
        ],
        "func": "function _calcShortMarginBalance(TDS.Storage storage s) external view returns (int256 newShortMarginBalance) {\n        (, newShortMarginBalance) = s._calcNewTokenStateAndBalance();\n    }",
        "comments": [
            "",
            "    // Returns the expected balance of the short margin account using the latest available Price Feed price.",
            "    "
        ],
        "comt": "\n    // Returns the expected balance of the short margin account using the latest available Price Feed price.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_calcExcessMargin",
        "visibility": "external",
        "args": [
            {
                "name": "s",
                "type": "TDS.Storage storage"
            }
        ],
        "func": "function _calcExcessMargin(TDS.Storage storage s) external view returns (int256 newExcessMargin) {\n        (TDS.TokenState memory newTokenState, int256 newShortMarginBalance) = s._calcNewTokenStateAndBalance();\n        // If the contract is in/will be moved to a settled state, the margin requirement will be 0.\n        int256 requiredMargin = newTokenState.time >= s.endTime ? 0 : s._getRequiredMargin(newTokenState);\n        return newShortMarginBalance.sub(requiredMargin);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_getCurrentRequiredMargin",
        "visibility": "external",
        "args": [
            {
                "name": "s",
                "type": "TDS.Storage storage"
            }
        ],
        "func": "function _getCurrentRequiredMargin(TDS.Storage storage s) external view returns (int256 requiredMargin) {\n        if (s.state == TDS.State.Settled) {\n            // No margin needs to be maintained when the contract is settled.\n            return 0;\n        }\n\n        return s._getRequiredMargin(s.currentTokenState);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_canBeSettled",
        "visibility": "external",
        "args": [
            {
                "name": "s",
                "type": "TDS.Storage storage"
            }
        ],
        "func": "function _canBeSettled(TDS.Storage storage s) external view returns (bool canBeSettled) {\n        TDS.State currentState = s.state;\n\n        if (currentState == TDS.State.Settled) {\n            return false;\n        }\n\n        // Technically we should also check if price will default the contract, but that isn't a normal flow of\n        // operations that we want to simulate: we want to discourage the sponsor remargining into a default.\n        (uint256 priceFeedTime, ) = s._getLatestPrice();\n        if (currentState == TDS.State.Live && (priceFeedTime < s.endTime)) {\n            return false;\n        }\n\n        return OracleInterface(_getOracleAddress(s)).hasPrice(s.fixedParameters.product, s.endTime);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_getUpdatedUnderlyingPrice",
        "visibility": "external",
        "args": [
            {
                "name": "s",
                "type": "TDS.Storage storage"
            }
        ],
        "func": "function _getUpdatedUnderlyingPrice(TDS.Storage storage s)\n        external\n        view\n        returns (int256 underlyingPrice, uint256 time)\n    {\n        (TDS.TokenState memory newTokenState, ) = s._calcNewTokenStateAndBalance();\n        return (newTokenState.underlyingPrice, newTokenState.time);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "_initialize",
        "visibility": "public",
        "args": [
            {
                "name": "s",
                "type": "TDS.Storage storage"
            },
            {
                "name": "params",
                "type": "TokenizedDerivativeParams.ConstructorParams memory"
            },
            {
                "name": "symbol",
                "type": "string memory"
            }
        ],
        "func": "function _initialize(\n        TDS.Storage storage s,\n        TokenizedDerivativeParams.ConstructorParams memory params,\n        string memory symbol\n    ) public {\n        s._setFixedParameters(params, symbol);\n        s._setExternalAddresses(params);\n\n        // Keep the starting token price relatively close to FP_SCALING_FACTOR to prevent users from unintentionally\n        // creating rounding or overflow errors.\n        require(params.startingTokenPrice >= UINT_FP_SCALING_FACTOR.div(10**9));\n        require(params.startingTokenPrice <= UINT_FP_SCALING_FACTOR.mul(10**9));\n\n        // TODO(mrice32): we should have an ideal start time rather than blindly polling.\n        (uint256 latestTime, int256 latestUnderlyingPrice) = s.externalAddresses.priceFeed.latestPrice(\n            s.fixedParameters.product\n        );\n\n        // If nonzero, take the user input as the starting price.\n        if (params.startingUnderlyingPrice != 0) {\n            latestUnderlyingPrice = _safeIntCast(params.startingUnderlyingPrice);\n        }\n\n        require(latestUnderlyingPrice > 0);\n        require(latestTime != 0);\n\n        // Keep the ratio in case it's needed for margin computation.\n        s.fixedParameters.initialTokenUnderlyingRatio = params.startingTokenPrice.mul(UINT_FP_SCALING_FACTOR).div(\n            _safeUintCast(latestUnderlyingPrice)\n        );\n        require(s.fixedParameters.initialTokenUnderlyingRatio != 0);\n\n        // Set end time to max value of uint256 to implement no expiry.\n        if (params.expiry == 0) {\n            s.endTime = ~uint256(0);\n        } else {\n            require(params.expiry >= latestTime);\n            s.endTime = params.expiry;\n        }\n\n        s.nav = s._computeInitialNav(latestUnderlyingPrice, latestTime, params.startingTokenPrice);\n\n        s.state = TDS.State.Live;\n    }",
        "comments": [
            "",
            "    // Contract initializer. Should only be called at construction.",
            "    // Note: Must be a public function because structs cannot be passed as calldata (required data type for external",
            "    // functions).",
            "    "
        ],
        "comt": "\n    // Contract initializer. Should only be called at construction.\n    // Note: Must be a public function because structs cannot be passed as calldata (required data type for external\n    // functions).\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createTokens",
        "visibility": "external",
        "args": [
            {
                "name": "marginForPurchase",
                "type": "uint256"
            },
            {
                "name": "tokensToPurchase",
                "type": "uint256"
            }
        ],
        "func": "function createTokens(uint256 marginForPurchase, uint256 tokensToPurchase) external payable {\n        derivativeStorage._createTokens(marginForPurchase, tokensToPurchase);\n    }",
        "comments": [
            "/**",
            "     * @notice Creates tokens with sent margin and sends the caller back any additional margin.",
            "     * @param marginForPurchase Maximum amount of margin currency to use to create tokens.",
            "     * @param tokensToPurchase Number of tokens to create.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Creates tokens with sent margin and sends the caller back any additional margin.\n     * @param marginForPurchase Maximum amount of margin currency to use to create tokens.\n     * @param tokensToPurchase Number of tokens to create.\n     */\n",
        "@notice": "Creates tokens with sent margin and sends the caller back any additional margin.",
        "@param1": "marginForPurchase Maximum amount of margin currency to use to create tokens.",
        "@param2": "tokensToPurchase Number of tokens to create.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "depositAndCreateTokens",
        "visibility": "external",
        "args": [
            {
                "name": "marginForPurchase",
                "type": "uint256"
            },
            {
                "name": "tokensToPurchase",
                "type": "uint256"
            }
        ],
        "func": "function depositAndCreateTokens(uint256 marginForPurchase, uint256 tokensToPurchase) external payable {\n        derivativeStorage._depositAndCreateTokens(marginForPurchase, tokensToPurchase);\n    }",
        "comments": [
            "/**",
            "     * @notice Creates tokens with sent margin and deposits additional margin in short account.",
            "     * @param marginForPurchase Maximum amount of margin currency to use to create tokens.",
            "     * @param tokensToPurchase Number of tokens to create.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Creates tokens with sent margin and deposits additional margin in short account.\n     * @param marginForPurchase Maximum amount of margin currency to use to create tokens.\n     * @param tokensToPurchase Number of tokens to create.\n     */\n",
        "@notice": "Creates tokens with sent margin and deposits additional margin in short account.",
        "@param1": "marginForPurchase Maximum amount of margin currency to use to create tokens.",
        "@param2": "tokensToPurchase Number of tokens to create.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "redeemTokens",
        "visibility": "external",
        "args": [
            {
                "name": "tokensToRedeem",
                "type": "uint256"
            }
        ],
        "func": "function redeemTokens(uint256 tokensToRedeem) external {\n        derivativeStorage._redeemTokens(tokensToRedeem);\n    }",
        "comments": [
            "/**",
            "     * @notice Redeems tokens for margin currency.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Redeems tokens for margin currency.\n     */\n",
        "@notice": "Redeems tokens for margin currency.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "dispute",
        "visibility": "external",
        "args": [
            {
                "name": "depositMargin",
                "type": "uint256"
            }
        ],
        "func": "function dispute(uint256 depositMargin) external payable {\n        derivativeStorage._dispute(depositMargin);\n    }",
        "comments": [
            "/**",
            "     * @notice Triggers a price dispute for the most recent remargin time.",
            "     * @param depositMargin Must be at least `disputeDeposit` percent of the required margin.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Triggers a price dispute for the most recent remargin time.\n     * @param depositMargin Must be at least `disputeDeposit` percent of the required margin.\n     */\n",
        "@notice": "Triggers a price dispute for the most recent remargin time.",
        "@param1": "depositMargin Must be at least `disputeDeposit` percent of the required margin.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function withdraw(uint256 amount) external {\n        derivativeStorage._withdraw(amount);\n    }",
        "comments": [
            "/**",
            "     * @notice Withdraws `amount` from short margin account.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Withdraws `amount` from short margin account.\n     */\n",
        "@notice": "Withdraws `amount` from short margin account.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "remargin",
        "visibility": "external",
        "args": [],
        "func": "function remargin() external override {\n        derivativeStorage._remargin();\n    }",
        "comments": [
            "/**",
            "     * @notice Pays (Oracle and service) fees for the previous period, updates the contract NAV, moves margin between",
            "     * long and short accounts to reflect the new NAV, and checks if both accounts meet minimum requirements.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Pays (Oracle and service) fees for the previous period, updates the contract NAV, moves margin between\n     * long and short accounts to reflect the new NAV, and checks if both accounts meet minimum requirements.\n     */\n",
        "@notice": "Pays (Oracle and service) fees for the previous period, updates the contract NAV, moves margin between * long and short accounts to reflect the new NAV, and checks if both accounts meet minimum requirements.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "acceptPriceAndSettle",
        "visibility": "external",
        "args": [],
        "func": "function acceptPriceAndSettle() external {\n        derivativeStorage._acceptPriceAndSettle();\n    }",
        "comments": [
            "/**",
            "     * @notice Forgo the Oracle verified price and settle the contract with last remargin price.",
            "     * @dev This method is only callable on contracts in the `Defaulted` state, and the default penalty is always",
            "     * transferred from the short to the long account.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Forgo the Oracle verified price and settle the contract with last remargin price.\n     * @dev This method is only callable on contracts in the `Defaulted` state, and the default penalty is always\n     * transferred from the short to the long account.\n     */\n",
        "@notice": "Forgo the Oracle verified price and settle the contract with last remargin price.",
        "@dev": "This method is only callable on contracts in the `Defaulted` state, and the default penalty is always * transferred from the short to the long account.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setApDelegate",
        "visibility": "external",
        "args": [
            {
                "name": "apDelegate",
                "type": "address"
            }
        ],
        "func": "function setApDelegate(address apDelegate) external {\n        derivativeStorage._setApDelegate(apDelegate);\n    }",
        "comments": [
            "/**",
            "     * @notice Assigns an address to be the contract's Delegate AP that can create and redeem.",
            "     * @dev Replaces previous value. Set to 0x0 to indicate there is no Delegate AP.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Assigns an address to be the contract's Delegate AP that can create and redeem.\n     * @dev Replaces previous value. Set to 0x0 to indicate there is no Delegate AP.\n     */\n",
        "@notice": "Assigns an address to be the contract's Delegate AP that can create and redeem.",
        "@dev": "Replaces previous value. Set to 0x0 to indicate there is no Delegate AP.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "emergencyShutdown",
        "visibility": "external",
        "args": [],
        "func": "function emergencyShutdown() external override {\n        derivativeStorage._emergencyShutdown();\n    }",
        "comments": [
            "/**",
            "     * @notice Moves the contract into the Emergency state, where it waits on an Oracle price for the most recent",
            "     * remargin time.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Moves the contract into the Emergency state, where it waits on an Oracle price for the most recent\n     * remargin time.\n     */\n",
        "@notice": "Moves the contract into the Emergency state, where it waits on an Oracle price for the most recent * remargin time.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "settle",
        "visibility": "external",
        "args": [],
        "func": "function settle() external {\n        derivativeStorage._settle();\n    }",
        "comments": [
            "/**",
            "     * @notice Performs a final remargin, assesses any penalties, and moves the contract into the `Settled` state. An",
            "     * Oracle price must be available.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Performs a final remargin, assesses any penalties, and moves the contract into the `Settled` state. An\n     * Oracle price must be available.\n     */\n",
        "@notice": "Performs a final remargin, assesses any penalties, and moves the contract into the `Settled` state. An * Oracle price must be available.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "deposit",
        "visibility": "external",
        "args": [
            {
                "name": "amountToDeposit",
                "type": "uint256"
            }
        ],
        "func": "function deposit(uint256 amountToDeposit) external payable {\n        derivativeStorage._deposit(amountToDeposit);\n    }",
        "comments": [
            "/**",
            "     * @notice Adds the margin to the short account.",
            "     * @dev For ETH-margined contracts, send ETH along with the call. In the case of an ERC20 margin currency, authorize",
            "     * before calling this method.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Adds the margin to the short account.\n     * @dev For ETH-margined contracts, send ETH along with the call. In the case of an ERC20 margin currency, authorize\n     * before calling this method.\n     */\n",
        "@notice": "Adds the margin to the short account.",
        "@dev": "For ETH-margined contracts, send ETH along with the call. In the case of an ERC20 margin currency, authorize * before calling this method.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawUnexpectedErc20",
        "visibility": "external",
        "args": [
            {
                "name": "erc20Address",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function withdrawUnexpectedErc20(address erc20Address, uint256 amount) external {\n        derivativeStorage._withdrawUnexpectedErc20(erc20Address, amount);\n    }",
        "comments": [
            "/**",
            "     * @notice Withdraw any ERC20 balance that is not the margin token. Only callable by the sponsor.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Withdraw any ERC20 balance that is not the margin token. Only callable by the sponsor.\n     */\n",
        "@notice": "Withdraw any ERC20 balance that is not the margin token. Only callable by the sponsor.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "external",
        "args": [
            {
                "name": "value",
                "type": "uint256"
            }
        ],
        "func": "function burn(uint256 value) external override onlyThis {\n        _burn(msg.sender, value);\n    }",
        "comments": [
            "/**",
            "     * @notice Destroys `value` tokens from the caller.",
            "     * @dev Only this contract or its libraries are allowed to burn tokens.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Destroys `value` tokens from the caller.\n     * @dev Only this contract or its libraries are allowed to burn tokens.\n     */\n",
        "@notice": "Destroys `value` tokens from the caller.",
        "@dev": "Only this contract or its libraries are allowed to burn tokens.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint256"
            }
        ],
        "func": "function mint(address to, uint256 value) external override onlyThis returns (bool) {\n        _mint(to, value);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @notice Creates `value` tokens and assigns them to `to`, increasing the total supply.",
            "     * @dev Only this contract or its libraries are allowed to mint tokens.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Creates `value` tokens and assigns them to `to`, increasing the total supply.\n     * @dev Only this contract or its libraries are allowed to mint tokens.\n     */\n",
        "@notice": "Creates `value` tokens and assigns them to `to`, increasing the total supply.",
        "@dev": "Only this contract or its libraries are allowed to mint tokens.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "calcNAV",
        "visibility": "external",
        "args": [],
        "func": "function calcNAV() external view returns (int256 navNew) {\n        return derivativeStorage._calcNAV();\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the expected net asset value (NAV) of the contract using the latest available Price Feed price.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the expected net asset value (NAV) of the contract using the latest available Price Feed price.\n     */\n",
        "@notice": "Returns the expected net asset value (NAV) of the contract using the latest available Price Feed price.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "calcTokenValue",
        "visibility": "external",
        "args": [],
        "func": "function calcTokenValue() external view returns (int256 newTokenValue) {\n        return derivativeStorage._calcTokenValue();\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the expected value of each the outstanding tokens of the contract using the latest available",
            "     * Price Feed price.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the expected value of each the outstanding tokens of the contract using the latest available\n     * Price Feed price.\n     */\n",
        "@notice": "Returns the expected value of each the outstanding tokens of the contract using the latest available * Price Feed price.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "calcShortMarginBalance",
        "visibility": "external",
        "args": [],
        "func": "function calcShortMarginBalance() external view returns (int256 newShortMarginBalance) {\n        return derivativeStorage._calcShortMarginBalance();\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the expected balance of the short margin account using the latest available Price Feed price.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the expected balance of the short margin account using the latest available Price Feed price.\n     */\n",
        "@notice": "Returns the expected balance of the short margin account using the latest available Price Feed price.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "calcExcessMargin",
        "visibility": "external",
        "args": [],
        "func": "function calcExcessMargin() external view returns (int256 excessMargin) {\n        return derivativeStorage._calcExcessMargin();\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the expected short margin in excess of the margin requirement using the latest available Price",
            "     * Feed price.",
            "     * @dev Value will be negative if the short margin is expected to be below the margin requirement.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the expected short margin in excess of the margin requirement using the latest available Price\n     * Feed price.\n     * @dev Value will be negative if the short margin is expected to be below the margin requirement.\n     */\n",
        "@notice": "Returns the expected short margin in excess of the margin requirement using the latest available Price * Feed price.",
        "@dev": "Value will be negative if the short margin is expected to be below the margin requirement.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentRequiredMargin",
        "visibility": "external",
        "args": [],
        "func": "function getCurrentRequiredMargin() external view returns (int256 requiredMargin) {\n        return derivativeStorage._getCurrentRequiredMargin();\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the required margin, as of the last remargin.",
            "     * @dev Note that `calcExcessMargin` uses updated values using the latest available Price Feed price.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the required margin, as of the last remargin.\n     * @dev Note that `calcExcessMargin` uses updated values using the latest available Price Feed price.\n     */\n",
        "@notice": "Returns the required margin, as of the last remargin.",
        "@dev": "Note that `calcExcessMargin` uses updated values using the latest available Price Feed price.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "canBeSettled",
        "visibility": "external",
        "args": [],
        "func": "function canBeSettled() external view returns (bool canContractBeSettled) {\n        return derivativeStorage._canBeSettled();\n    }",
        "comments": [
            "/**",
            "     * @notice Returns whether the contract can be settled, i.e., is it valid to call settle() now.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns whether the contract can be settled, i.e., is it valid to call settle() now.\n     */\n",
        "@notice": "Returns whether the contract can be settled, i.e., is it valid to call settle() now.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getUpdatedUnderlyingPrice",
        "visibility": "external",
        "args": [],
        "func": "function getUpdatedUnderlyingPrice() external view returns (int256 underlyingPrice, uint256 time) {\n        return derivativeStorage._getUpdatedUnderlyingPrice();\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the updated underlying price that was used in the calc* methods above.",
            "     * @dev It will be a price feed price if the contract is Live and will remain Live, or an Oracle price if the",
            "     * contract is settled/about to be settled.  Reverts if no Oracle price is available but an Oracle price is",
            "     * required.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the updated underlying price that was used in the calc* methods above.\n     * @dev It will be a price feed price if the contract is Live and will remain Live, or an Oracle price if the\n     * contract is settled/about to be settled.  Reverts if no Oracle price is available but an Oracle price is\n     * required.\n     */\n",
        "@notice": "Returns the updated underlying price that was used in the calc* methods above.",
        "@dev": "It will be a price feed price if the contract is Live and will remain Live, or an Oracle price if the * contract is settled/about to be settled. Reverts if no Oracle price is available but an Oracle price is * required.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createTokenizedDerivative",
        "visibility": "public",
        "args": [
            {
                "name": "params",
                "type": "Params memory"
            }
        ],
        "func": "function createTokenizedDerivative(Params memory params) public returns (address derivativeAddress) {\n        TokenizedDerivative derivative = new TokenizedDerivative(_convertParams(params), params.name, params.symbol);\n\n        address[] memory parties = new address[](1);\n        parties[0] = msg.sender;\n\n        _registerContract(parties, address(derivative));\n\n        emit CreatedTokenizedDerivative(address(derivative));\n\n        return address(derivative);\n    }",
        "comments": [
            "/**",
            "     * @notice Creates a new instance of `TokenizedDerivative` with the provided `params`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Creates a new instance of `TokenizedDerivative` with the provided `params`.\n     */\n",
        "@notice": "Creates a new instance of `TokenizedDerivative` with the provided `params`.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "migrateTokens",
        "visibility": "external",
        "args": [
            {
                "name": "tokenHolder",
                "type": "address"
            }
        ],
        "func": "function migrateTokens(address tokenHolder) external {\n        require(!hasMigrated[tokenHolder], \"Already migrated tokens\");\n        hasMigrated[tokenHolder] = true;\n\n        FixedPoint.Unsigned memory oldBalance = FixedPoint.Unsigned(oldToken.balanceOfAt(tokenHolder, snapshotId));\n\n        if (!oldBalance.isGreaterThan(0)) {\n            return;\n        }\n\n        FixedPoint.Unsigned memory newBalance = oldBalance.div(rate);\n        require(newToken.mint(tokenHolder, newBalance.rawValue), \"Mint failed\");\n    }",
        "comments": [
            "/**",
            "     * @notice Migrates the tokenHolder's old tokens to new tokens.",
            "     * @dev This function can only be called once per `tokenHolder`. Anyone can call this method",
            "     * on behalf of any other token holder since there is no disadvantage to receiving the tokens earlier.",
            "     * @param tokenHolder address of the token holder to migrate.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Migrates the tokenHolder's old tokens to new tokens.\n     * @dev This function can only be called once per `tokenHolder`. Anyone can call this method\n     * on behalf of any other token holder since there is no disadvantage to receiving the tokens earlier.\n     * @param tokenHolder address of the token holder to migrate.\n     */\n",
        "@notice": "Migrates the tokenHolder's old tokens to new tokens.",
        "@dev": "This function can only be called once per `tokenHolder`. Anyone can call this method * on behalf of any other token holder since there is no disadvantage to receiving the tokens earlier.",
        "@param1": "tokenHolder address of the token holder to migrate.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "token",
        "visibility": "public",
        "args": [],
        "func": "function token() public view returns (IERC20) {\n        return _token;\n    }",
        "comments": [
            "/**",
            "     * @return the token being held.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @return the token being held.\n     */\n",
        "@return1": "the token being held.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "beneficiary",
        "visibility": "public",
        "args": [],
        "func": "function beneficiary() public view returns (address) {\n        return _beneficiary;\n    }",
        "comments": [
            "/**",
            "     * @return the beneficiary of the tokens.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @return the beneficiary of the tokens.\n     */\n",
        "@return1": "the beneficiary of the tokens.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "releaseTime",
        "visibility": "public",
        "args": [],
        "func": "function releaseTime() public view returns (uint256) {\n        return _releaseTime;\n    }",
        "comments": [
            "/**",
            "     * @return the time when the tokens are released.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @return the time when the tokens are released.\n     */\n",
        "@return1": "the time when the tokens are released.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "release",
        "visibility": "public",
        "args": [],
        "func": "function release() public virtual {\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp >= _releaseTime, \"TokenTimelock: current time is before release time\");\n\n        uint256 amount = _token.balanceOf(address(this));\n        require(amount > 0, \"TokenTimelock: no tokens to release\");\n\n        _token.safeTransfer(_beneficiary, amount);\n    }",
        "comments": [
            "/**",
            "     * @notice Transfers tokens held by timelock to beneficiary.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfers tokens held by timelock to beneficiary.\n     */\n",
        "@notice": "Transfers tokens held by timelock to beneficiary.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "beneficiary",
        "visibility": "public",
        "args": [],
        "func": "function beneficiary() public view returns (address) {\n        return _beneficiary;\n    }",
        "comments": [
            "/**",
            "     * @return the beneficiary of the tokens.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @return the beneficiary of the tokens.\n     */\n",
        "@return1": "the beneficiary of the tokens.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cliff",
        "visibility": "public",
        "args": [],
        "func": "function cliff() public view returns (uint256) {\n        return _cliff;\n    }",
        "comments": [
            "/**",
            "     * @return the cliff time of the token vesting.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @return the cliff time of the token vesting.\n     */\n",
        "@return1": "the cliff time of the token vesting.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "start",
        "visibility": "public",
        "args": [],
        "func": "function start() public view returns (uint256) {\n        return _start;\n    }",
        "comments": [
            "/**",
            "     * @return the start time of the token vesting.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @return the start time of the token vesting.\n     */\n",
        "@return1": "the start time of the token vesting.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "duration",
        "visibility": "public",
        "args": [],
        "func": "function duration() public view returns (uint256) {\n        return _duration;\n    }",
        "comments": [
            "/**",
            "     * @return the duration of the token vesting.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @return the duration of the token vesting.\n     */\n",
        "@return1": "the duration of the token vesting.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "revocable",
        "visibility": "public",
        "args": [],
        "func": "function revocable() public view returns (bool) {\n        return _revocable;\n    }",
        "comments": [
            "/**",
            "     * @return true if the vesting is revocable.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @return true if the vesting is revocable.\n     */\n",
        "@return1": "true if the vesting is revocable.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "released",
        "visibility": "public",
        "args": [
            {
                "name": "token",
                "type": "address"
            }
        ],
        "func": "function released(address token) public view returns (uint256) {\n        return _released[token];\n    }",
        "comments": [
            "/**",
            "     * @return the amount of the token released.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @return the amount of the token released.\n     */\n",
        "@return1": "the amount of the token released.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "revoked",
        "visibility": "public",
        "args": [
            {
                "name": "token",
                "type": "address"
            }
        ],
        "func": "function revoked(address token) public view returns (bool) {\n        return _revoked[token];\n    }",
        "comments": [
            "/**",
            "     * @return true if the token is revoked.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @return true if the token is revoked.\n     */\n",
        "@return1": "true if the token is revoked.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "release",
        "visibility": "public",
        "args": [
            {
                "name": "token",
                "type": "IERC20"
            }
        ],
        "func": "function release(IERC20 token) public {\n        uint256 unreleased = _releasableAmount(token);\n\n        require(unreleased > 0, \"TokenVesting: no tokens are due\");\n\n        _released[address(token)] = _released[address(token)].add(unreleased);\n\n        token.safeTransfer(_beneficiary, unreleased);\n\n        emit TokensReleased(address(token), unreleased);\n    }",
        "comments": [
            "/**",
            "     * @notice Transfers vested tokens to beneficiary.",
            "     * @param token ERC20 token which is being vested",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfers vested tokens to beneficiary.\n     * @param token ERC20 token which is being vested\n     */\n",
        "@notice": "Transfers vested tokens to beneficiary.",
        "@param1": "token ERC20 token which is being vested",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "revoke",
        "visibility": "public",
        "args": [
            {
                "name": "token",
                "type": "IERC20"
            }
        ],
        "func": "function revoke(IERC20 token) public onlyOwner {\n        require(_revocable, \"TokenVesting: cannot revoke\");\n        require(!_revoked[address(token)], \"TokenVesting: token already revoked\");\n\n        uint256 balance = token.balanceOf(address(this));\n\n        uint256 unreleased = _releasableAmount(token);\n        uint256 refund = balance.sub(unreleased);\n\n        _revoked[address(token)] = true;\n\n        token.safeTransfer(owner(), refund);\n\n        emit TokenVestingRevoked(address(token));\n    }",
        "comments": [
            "/**",
            "     * @notice Allows the owner to revoke the vesting. Tokens already vested",
            "     * remain in the contract, the rest are returned to the owner.",
            "     * @param token ERC20 token which is being vested",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Allows the owner to revoke the vesting. Tokens already vested\n     * remain in the contract, the rest are returned to the owner.\n     * @param token ERC20 token which is being vested\n     */\n",
        "@notice": "Allows the owner to revoke the vesting. Tokens already vested * remain in the contract, the rest are returned to the owner.",
        "@param1": "token ERC20 token which is being vested",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "upgrade",
        "visibility": "external",
        "args": [],
        "func": "function upgrade() external {\n        require(msg.sender == existingGovernor, \"Upgrade can only be initiated by the existing governor.\");\n\n        // Change the addresses in the Finder.\n        finder.changeImplementationAddress(OracleInterfaces.Oracle, voting);\n        finder.changeImplementationAddress(OracleInterfaces.IdentifierWhitelist, identifierWhitelist);\n        finder.changeImplementationAddress(OracleInterfaces.Store, store);\n        finder.changeImplementationAddress(OracleInterfaces.FinancialContractsAdmin, financialContractsAdmin);\n        finder.changeImplementationAddress(OracleInterfaces.Registry, registry);\n\n        // Transfer the ownership of the Finder to the new Governor now that all the addresses have been updated.\n        finder.transferOwnership(newGovernor);\n\n        // Inform the existing Voting contract of the address of the new Voting contract and transfer its\n        // ownership to the new governor to allow for any future changes to the migrated contract.\n        existingVoting.setMigrated(voting);\n        existingVoting.transferOwnership(newGovernor);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setPrice",
        "visibility": "external",
        "args": [
            {
                "name": "reserve0",
                "type": "uint112"
            },
            {
                "name": "reserve1",
                "type": "uint112"
            }
        ],
        "func": "function setPrice(uint112 reserve0, uint112 reserve1) external {\n        emit Sync(reserve0, reserve1);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapComputeCurrentRoundId",
        "visibility": "external",
        "args": [
            {
                "name": "currentTime",
                "type": "uint256"
            }
        ],
        "func": "function wrapComputeCurrentRoundId(uint256 currentTime) external view returns (uint256) {\n        return voteTiming.computeCurrentRoundId(currentTime);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapComputeCurrentPhase",
        "visibility": "external",
        "args": [
            {
                "name": "currentTime",
                "type": "uint256"
            }
        ],
        "func": "function wrapComputeCurrentPhase(uint256 currentTime) external view returns (VotingInterface.Phase) {\n        return voteTiming.computeCurrentPhase(currentTime);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "wrapInit",
        "visibility": "public",
        "args": [
            {
                "name": "phaseLength",
                "type": "uint256"
            }
        ],
        "func": "function wrapInit(uint256 phaseLength) public {\n        voteTiming.init(phaseLength);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "requestPrice",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            }
        ],
        "func": "function requestPrice(bytes32 identifier, uint256 time) external override onlyRegisteredContract() {\n        uint256 blockTime = getCurrentTime();\n        require(time <= blockTime, \"Can only request in past\");\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier), \"Unsupported identifier request\");\n\n        bytes32 priceRequestId = _encodePriceRequest(identifier, time);\n        PriceRequest storage priceRequest = priceRequests[priceRequestId];\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\n\n        RequestStatus requestStatus = _getRequestStatus(priceRequest, currentRoundId);\n\n        if (requestStatus == RequestStatus.NotRequested) {\n            // Price has never been requested.\n            // Price requests always go in the next round, so add 1 to the computed current round.\n            uint256 nextRoundId = currentRoundId.add(1);\n\n            priceRequests[priceRequestId] = PriceRequest({\n                identifier: identifier,\n                time: time,\n                lastVotingRound: nextRoundId,\n                index: pendingPriceRequests.length\n            });\n            pendingPriceRequests.push(priceRequestId);\n            emit PriceRequestAdded(nextRoundId, identifier, time);\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.",
            "     * @dev Time must be in the past and the identifier must be supported.",
            "     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.",
            "     * @param time unix timestamp for the price request.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.\n     * @dev Time must be in the past and the identifier must be supported.\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp for the price request.\n     */\n",
        "@notice": "Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.",
        "@dev": "Time must be in the past and the identifier must be supported.",
        "@param1": "identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.",
        "@param2": "time unix timestamp for the price request.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "hasPrice",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            }
        ],
        "func": "function hasPrice(bytes32 identifier, uint256 time) external override view onlyRegisteredContract() returns (bool) {\n        (bool _hasPrice, , ) = _getPriceOrError(identifier, time);\n        return _hasPrice;\n    }",
        "comments": [
            "/**",
            "     * @notice Whether the price for `identifier` and `time` is available.",
            "     * @dev Time must be in the past and the identifier must be supported.",
            "     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.",
            "     * @param time unix timestamp of for the price request.",
            "     * @return _hasPrice bool if the DVM has resolved to a price for the given identifier and timestamp.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Whether the price for `identifier` and `time` is available.\n     * @dev Time must be in the past and the identifier must be supported.\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp of for the price request.\n     * @return _hasPrice bool if the DVM has resolved to a price for the given identifier and timestamp.\n     */\n",
        "@notice": "Whether the price for `identifier` and `time` is available.",
        "@dev": "Time must be in the past and the identifier must be supported.",
        "@param1": "identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.",
        "@param2": "time unix timestamp of for the price request.",
        "@return1": "_hasPrice bool if the DVM has resolved to a price for the given identifier and timestamp.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPrice",
        "visibility": "external",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            }
        ],
        "func": "function getPrice(bytes32 identifier, uint256 time)\n        external\n        override\n        view\n        onlyRegisteredContract()\n        returns (int256)\n    {\n        (bool _hasPrice, int256 price, string memory message) = _getPriceOrError(identifier, time);\n\n        // If the price wasn't available, revert with the provided message.\n        require(_hasPrice, message);\n        return price;\n    }",
        "comments": [
            "/**",
            "     * @notice Gets the price for `identifier` and `time` if it has already been requested and resolved.",
            "     * @dev If the price is not available, the method reverts.",
            "     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.",
            "     * @param time unix timestamp of for the price request.",
            "     * @return int256 representing the resolved price for the given identifier and timestamp.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets the price for `identifier` and `time` if it has already been requested and resolved.\n     * @dev If the price is not available, the method reverts.\n     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n     * @param time unix timestamp of for the price request.\n     * @return int256 representing the resolved price for the given identifier and timestamp.\n     */\n",
        "@notice": "Gets the price for `identifier` and `time` if it has already been requested and resolved.",
        "@dev": "If the price is not available, the method reverts.",
        "@param1": "identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.",
        "@param2": "time unix timestamp of for the price request.",
        "@return1": "int256 representing the resolved price for the given identifier and timestamp.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPriceRequestStatuses",
        "visibility": "public",
        "args": [
            {
                "name": "requests",
                "type": "PendingRequest[] memory"
            }
        ],
        "func": "function getPriceRequestStatuses(PendingRequest[] memory requests) public view returns (RequestState[] memory) {\n        RequestState[] memory requestStates = new RequestState[](requests.length);\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(getCurrentTime());\n        for (uint256 i = 0; i < requests.length; i++) {\n            PriceRequest storage priceRequest = _getPriceRequest(requests[i].identifier, requests[i].time);\n\n            RequestStatus status = _getRequestStatus(priceRequest, currentRoundId);\n\n            // If it's an active request, its true lastVotingRound is the current one, even if it hasn't been updated.\n            if (status == RequestStatus.Active) {\n                requestStates[i].lastVotingRound = currentRoundId;\n            } else {\n                requestStates[i].lastVotingRound = priceRequest.lastVotingRound;\n            }\n            requestStates[i].status = status;\n        }\n        return requestStates;\n    }",
        "comments": [
            "/**",
            "     * @notice Gets the status of a list of price requests, identified by their identifier and time.",
            "     * @dev If the status for a particular request is NotRequested, the lastVotingRound will always be 0.",
            "     * @param requests array of type PendingRequest which includes an identifier and timestamp for each request.",
            "     * @return requestStates a list, in the same order as the input list, giving the status of each of the specified price requests.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets the status of a list of price requests, identified by their identifier and time.\n     * @dev If the status for a particular request is NotRequested, the lastVotingRound will always be 0.\n     * @param requests array of type PendingRequest which includes an identifier and timestamp for each request.\n     * @return requestStates a list, in the same order as the input list, giving the status of each of the specified price requests.\n     */\n",
        "@notice": "Gets the status of a list of price requests, identified by their identifier and time.",
        "@dev": "If the status for a particular request is NotRequested, the lastVotingRound will always be 0.",
        "@param1": "requests array of type PendingRequest which includes an identifier and timestamp for each request.",
        "@return1": "requestStates a list, in the same order as the input list, giving the status of each of the specified price requests.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "commitVote",
        "visibility": "public",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            },
            {
                "name": "hash",
                "type": "bytes32"
            }
        ],
        "func": "function commitVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes32 hash\n    ) public override onlyIfNotMigrated() {\n        require(hash != bytes32(0), \"Invalid provided hash\");\n        // Current time is required for all vote timing queries.\n        uint256 blockTime = getCurrentTime();\n        require(voteTiming.computeCurrentPhase(blockTime) == Phase.Commit, \"Cannot commit in reveal phase\");\n\n        // At this point, the computed and last updated round ID should be equal.\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\n\n        PriceRequest storage priceRequest = _getPriceRequest(identifier, time);\n        require(\n            _getRequestStatus(priceRequest, currentRoundId) == RequestStatus.Active,\n            \"Cannot commit inactive request\"\n        );\n\n        priceRequest.lastVotingRound = currentRoundId;\n        VoteInstance storage voteInstance = priceRequest.voteInstances[currentRoundId];\n        voteInstance.voteSubmissions[msg.sender].commit = hash;\n\n        emit VoteCommitted(msg.sender, currentRoundId, identifier, time);\n    }",
        "comments": [
            "/**",
            "     * @notice Commit a vote for a price request for `identifier` at `time`.",
            "     * @dev `identifier`, `time` must correspond to a price request that's currently in the commit phase.",
            "     * Commits can be changed.",
            "     * @dev Since transaction data is public, the salt will be revealed with the vote. While this is the system\u2019s expected behavior,",
            "     * voters should never reuse salts. If someone else is able to guess the voted price and knows that a salt will be reused, then",
            "     * they can determine the vote pre-reveal.",
            "     * @param identifier uniquely identifies the committed vote. EG BTC/USD price pair.",
            "     * @param time unix timestamp of the price being voted on.",
            "     * @param hash keccak256 hash of the `price`, `salt`, voter `address`, `time`, current `roundId`, and `identifier`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Commit a vote for a price request for `identifier` at `time`.\n     * @dev `identifier`, `time` must correspond to a price request that's currently in the commit phase.\n     * Commits can be changed.\n     * @dev Since transaction data is public, the salt will be revealed with the vote. While this is the system\u2019s expected behavior,\n     * voters should never reuse salts. If someone else is able to guess the voted price and knows that a salt will be reused, then\n     * they can determine the vote pre-reveal.\n     * @param identifier uniquely identifies the committed vote. EG BTC/USD price pair.\n     * @param time unix timestamp of the price being voted on.\n     * @param hash keccak256 hash of the `price`, `salt`, voter `address`, `time`, current `roundId`, and `identifier`.\n     */\n",
        "@notice": "Commit a vote for a price request for `identifier` at `time`.",
        "@dev": "`identifier`, `time` must correspond to a price request that's currently in the commit phase. * Commits can be changed. * Since transaction data is public, the salt will be revealed with the vote. While this is the system\u2019s expected behavior, * voters should never reuse salts. If someone else is able to guess the voted price and knows that a salt will be reused, then * they can determine the vote pre-reveal.",
        "@param1": "identifier uniquely identifies the committed vote. EG BTC/USD price pair.",
        "@param2": "time unix timestamp of the price being voted on.",
        "@param3": "hash keccak256 hash of the `price`, `salt`, voter `address`, `time`, current `roundId`, and `identifier`.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "snapshotCurrentRound",
        "visibility": "external",
        "args": [],
        "func": "function snapshotCurrentRound() external override onlyIfNotMigrated() {\n        uint256 blockTime = getCurrentTime();\n        require(voteTiming.computeCurrentPhase(blockTime) == Phase.Reveal, \"Only snapshot in reveal phase\");\n\n        uint256 roundId = voteTiming.computeCurrentRoundId(blockTime);\n        _freezeRoundVariables(roundId);\n    }",
        "comments": [
            "/**",
            "     * @notice Snapshot the current round's token balances and lock in the inflation rate and GAT.",
            "     * @dev This function can be called multiple times, but only the first call per round into this function or `revealVote`",
            "     * will create the round snapshot. Any later calls will be a no-op. Will revert unless called during reveal period.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Snapshot the current round's token balances and lock in the inflation rate and GAT.\n     * @dev This function can be called multiple times, but only the first call per round into this function or `revealVote`\n     * will create the round snapshot. Any later calls will be a no-op. Will revert unless called during reveal period.\n     */\n",
        "@notice": "Snapshot the current round's token balances and lock in the inflation rate and GAT.",
        "@dev": "This function can be called multiple times, but only the first call per round into this function or `revealVote` * will create the round snapshot. Any later calls will be a no-op. Will revert unless called during reveal period.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "revealVote",
        "visibility": "public",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            },
            {
                "name": "price",
                "type": "int256"
            },
            {
                "name": "salt",
                "type": "int256"
            }
        ],
        "func": "function revealVote(\n        bytes32 identifier,\n        uint256 time,\n        int256 price,\n        int256 salt\n    ) public override onlyIfNotMigrated() {\n        uint256 blockTime = getCurrentTime();\n        require(voteTiming.computeCurrentPhase(blockTime) == Phase.Reveal, \"Cannot reveal in commit phase\");\n        // Note: computing the current round is required to disallow people from\n        // revealing an old commit after the round is over.\n        uint256 roundId = voteTiming.computeCurrentRoundId(blockTime);\n\n        PriceRequest storage priceRequest = _getPriceRequest(identifier, time);\n        VoteInstance storage voteInstance = priceRequest.voteInstances[roundId];\n        VoteSubmission storage voteSubmission = voteInstance.voteSubmissions[msg.sender];\n\n        // 0 hashes are disallowed in the commit phase, so they indicate a different error.\n        // Cannot reveal an uncommitted or previously revealed hash\n        require(voteSubmission.commit != bytes32(0), \"Invalid hash reveal\");\n        require(\n            keccak256(abi.encodePacked(price, salt, msg.sender, time, roundId, identifier)) == voteSubmission.commit,\n            \"Revealed data != commit hash\"\n        );\n        delete voteSubmission.commit;\n\n        // Lock in round variables including snapshotId and inflation rate. Not that this will only execute a snapshot\n        // if the `snapshotCurrentRound` function was not already called for this round.\n        _freezeRoundVariables(roundId);\n\n        // Get the frozen snapshotId\n        uint256 snapshotId = rounds[roundId].snapshotId;\n\n        // Get the voter's snapshotted balance. Since balances are returned pre-scaled by 10**18, we can directly\n        // initialize the Unsigned value with the returned uint.\n        FixedPoint.Unsigned memory balance = FixedPoint.Unsigned(votingToken.balanceOfAt(msg.sender, snapshotId));\n\n        // Set the voter's submission.\n        voteSubmission.revealHash = keccak256(abi.encode(price));\n\n        // Add vote to the results.\n        voteInstance.resultComputation.addVote(price, balance);\n\n        emit VoteRevealed(msg.sender, roundId, identifier, time, price, balance.rawValue);\n    }",
        "comments": [
            "/**",
            "     * @notice Reveal a previously committed vote for `identifier` at `time`.",
            "     * @dev The revealed `price`, `salt`, `time`, `address`, `roundId`, and `identifier`, must hash to the latest `hash`",
            "     * that `commitVote()` was called with. Only the committer can reveal their vote.",
            "     * @param identifier voted on in the commit phase. EG BTC/USD price pair.",
            "     * @param time specifies the unix timestamp of the price being voted on.",
            "     * @param price voted on during the commit phase.",
            "     * @param salt value used to hide the commitment price during the commit phase.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Reveal a previously committed vote for `identifier` at `time`.\n     * @dev The revealed `price`, `salt`, `time`, `address`, `roundId`, and `identifier`, must hash to the latest `hash`\n     * that `commitVote()` was called with. Only the committer can reveal their vote.\n     * @param identifier voted on in the commit phase. EG BTC/USD price pair.\n     * @param time specifies the unix timestamp of the price being voted on.\n     * @param price voted on during the commit phase.\n     * @param salt value used to hide the commitment price during the commit phase.\n     */\n",
        "@notice": "Reveal a previously committed vote for `identifier` at `time`.",
        "@dev": "The revealed `price`, `salt`, `time`, `address`, `roundId`, and `identifier`, must hash to the latest `hash` * that `commitVote()` was called with. Only the committer can reveal their vote.",
        "@param1": "identifier voted on in the commit phase. EG BTC/USD price pair.",
        "@param2": "time specifies the unix timestamp of the price being voted on.",
        "@param3": "price voted on during the commit phase.",
        "@param4": "salt value used to hide the commitment price during the commit phase.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "commitAndEmitEncryptedVote",
        "visibility": "public",
        "args": [
            {
                "name": "identifier",
                "type": "bytes32"
            },
            {
                "name": "time",
                "type": "uint256"
            },
            {
                "name": "hash",
                "type": "bytes32"
            },
            {
                "name": "encryptedVote",
                "type": "bytes memory"
            }
        ],
        "func": "function commitAndEmitEncryptedVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes32 hash,\n        bytes memory encryptedVote\n    ) public {\n        commitVote(identifier, time, hash);\n\n        uint256 roundId = voteTiming.computeCurrentRoundId(getCurrentTime());\n        emit EncryptedVote(msg.sender, roundId, identifier, time, encryptedVote);\n    }",
        "comments": [
            "/**",
            "     * @notice commits a vote and logs an event with a data blob, typically an encrypted version of the vote",
            "     * @dev An encrypted version of the vote is emitted in an event `EncryptedVote` to allow off-chain infrastructure to",
            "     * retrieve the commit. The contents of `encryptedVote` are never used on chain: it is purely for convenience.",
            "     * @param identifier unique price pair identifier. Eg: BTC/USD price pair.",
            "     * @param time unix timestamp of for the price request.",
            "     * @param hash keccak256 hash of the price you want to vote for and a `int256 salt`.",
            "     * @param encryptedVote offchain encrypted blob containing the voters amount, time and salt.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice commits a vote and logs an event with a data blob, typically an encrypted version of the vote\n     * @dev An encrypted version of the vote is emitted in an event `EncryptedVote` to allow off-chain infrastructure to\n     * retrieve the commit. The contents of `encryptedVote` are never used on chain: it is purely for convenience.\n     * @param identifier unique price pair identifier. Eg: BTC/USD price pair.\n     * @param time unix timestamp of for the price request.\n     * @param hash keccak256 hash of the price you want to vote for and a `int256 salt`.\n     * @param encryptedVote offchain encrypted blob containing the voters amount, time and salt.\n     */\n",
        "@notice": "commits a vote and logs an event with a data blob, typically an encrypted version of the vote",
        "@dev": "An encrypted version of the vote is emitted in an event `EncryptedVote` to allow off-chain infrastructure to * retrieve the commit. The contents of `encryptedVote` are never used on chain: it is purely for convenience.",
        "@param1": "identifier unique price pair identifier. Eg: BTC/USD price pair.",
        "@param2": "time unix timestamp of for the price request.",
        "@param3": "hash keccak256 hash of the price you want to vote for and a `int256 salt`.",
        "@param4": "encryptedVote offchain encrypted blob containing the voters amount, time and salt.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "batchCommit",
        "visibility": "external",
        "args": [
            {
                "name": "commits",
                "type": "Commitment[] calldata"
            }
        ],
        "func": "function batchCommit(Commitment[] calldata commits) external override {\n        for (uint256 i = 0; i < commits.length; i++) {\n            if (commits[i].encryptedVote.length == 0) {\n                commitVote(commits[i].identifier, commits[i].time, commits[i].hash);\n            } else {\n                commitAndEmitEncryptedVote(\n                    commits[i].identifier,\n                    commits[i].time,\n                    commits[i].hash,\n                    commits[i].encryptedVote\n                );\n            }\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Submit a batch of commits in a single transaction.",
            "     * @dev Using `encryptedVote` is optional. If included then commitment is emitted in an event.",
            "     * Look at `project-root/common/Constants.js` for the tested maximum number of",
            "     * commitments that can fit in one transaction.",
            "     * @param commits struct to encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Submit a batch of commits in a single transaction.\n     * @dev Using `encryptedVote` is optional. If included then commitment is emitted in an event.\n     * Look at `project-root/common/Constants.js` for the tested maximum number of\n     * commitments that can fit in one transaction.\n     * @param commits struct to encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.\n     */\n",
        "@notice": "Submit a batch of commits in a single transaction.",
        "@dev": "Using `encryptedVote` is optional. If included then commitment is emitted in an event. * Look at `project-root/common/Constants.js` for the tested maximum number of * commitments that can fit in one transaction.",
        "@param1": "commits struct to encapsulate an `identifier`, `time`, `hash` and optional `encryptedVote`.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "batchReveal",
        "visibility": "external",
        "args": [
            {
                "name": "reveals",
                "type": "Reveal[] calldata"
            }
        ],
        "func": "function batchReveal(Reveal[] calldata reveals) external override {\n        for (uint256 i = 0; i < reveals.length; i++) {\n            revealVote(reveals[i].identifier, reveals[i].time, reveals[i].price, reveals[i].salt);\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Reveal multiple votes in a single transaction.",
            "     * Look at `project-root/common/Constants.js` for the tested maximum number of reveals.",
            "     * that can fit in one transaction.",
            "     * @dev For more information on reveals, review the comment for `revealVote`.",
            "     * @param reveals array of the Reveal struct which contains an identifier, time, price and salt.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Reveal multiple votes in a single transaction.\n     * Look at `project-root/common/Constants.js` for the tested maximum number of reveals.\n     * that can fit in one transaction.\n     * @dev For more information on reveals, review the comment for `revealVote`.\n     * @param reveals array of the Reveal struct which contains an identifier, time, price and salt.\n     */\n",
        "@notice": "Reveal multiple votes in a single transaction. * Look at `project-root/common/Constants.js` for the tested maximum number of reveals. * that can fit in one transaction.",
        "@dev": "For more information on reveals, review the comment for `revealVote`.",
        "@param1": "reveals array of the Reveal struct which contains an identifier, time, price and salt.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "retrieveRewards",
        "visibility": "public",
        "args": [
            {
                "name": "voterAddress",
                "type": "address"
            },
            {
                "name": "roundId",
                "type": "uint256"
            },
            {
                "name": "toRetrieve",
                "type": "PendingRequest[] memory"
            }
        ],
        "func": "function retrieveRewards(\n        address voterAddress,\n        uint256 roundId,\n        PendingRequest[] memory toRetrieve\n    ) public override returns (FixedPoint.Unsigned memory totalRewardToIssue) {\n        if (migratedAddress != address(0)) {\n            require(msg.sender == migratedAddress, \"Can only call from migrated\");\n        }\n        uint256 blockTime = getCurrentTime();\n        require(roundId < voteTiming.computeCurrentRoundId(blockTime), \"Invalid roundId\");\n\n        Round storage round = rounds[roundId];\n        bool isExpired = blockTime > round.rewardsExpirationTime;\n        FixedPoint.Unsigned memory snapshotBalance = FixedPoint.Unsigned(\n            votingToken.balanceOfAt(voterAddress, round.snapshotId)\n        );\n\n        // Compute the total amount of reward that will be issued for each of the votes in the round.\n        FixedPoint.Unsigned memory snapshotTotalSupply = FixedPoint.Unsigned(\n            votingToken.totalSupplyAt(round.snapshotId)\n        );\n        FixedPoint.Unsigned memory totalRewardPerVote = round.inflationRate.mul(snapshotTotalSupply);\n\n        // Keep track of the voter's accumulated token reward.\n        totalRewardToIssue = FixedPoint.Unsigned(0);\n\n        for (uint256 i = 0; i < toRetrieve.length; i++) {\n            PriceRequest storage priceRequest = _getPriceRequest(toRetrieve[i].identifier, toRetrieve[i].time);\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\n            // Only retrieve rewards for votes resolved in same round\n            require(priceRequest.lastVotingRound == roundId, \"Retrieve for votes same round\");\n\n            _resolvePriceRequest(priceRequest, voteInstance);\n\n            if (voteInstance.voteSubmissions[voterAddress].revealHash == 0) {\n                continue;\n            } else if (isExpired) {\n                // Emit a 0 token retrieval on expired rewards.\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time, 0);\n            } else if (\n                voteInstance.resultComputation.wasVoteCorrect(voteInstance.voteSubmissions[voterAddress].revealHash)\n            ) {\n                // The price was successfully resolved during the voter's last voting round, the voter revealed\n                // and was correct, so they are eligible for a reward.\n                // Compute the reward and add to the cumulative reward.\n                FixedPoint.Unsigned memory reward = snapshotBalance.mul(totalRewardPerVote).div(\n                    voteInstance.resultComputation.getTotalCorrectlyVotedTokens()\n                );\n                totalRewardToIssue = totalRewardToIssue.add(reward);\n\n                // Emit reward retrieval for this vote.\n                emit RewardsRetrieved(\n                    voterAddress,\n                    roundId,\n                    toRetrieve[i].identifier,\n                    toRetrieve[i].time,\n                    reward.rawValue\n                );\n            } else {\n                // Emit a 0 token retrieval on incorrect votes.\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time, 0);\n            }\n\n            // Delete the submission to capture any refund and clean up storage.\n            delete voteInstance.voteSubmissions[voterAddress].revealHash;\n        }\n\n        // Issue any accumulated rewards.\n        if (totalRewardToIssue.isGreaterThan(0)) {\n            require(votingToken.mint(voterAddress, totalRewardToIssue.rawValue), \"Voting token issuance failed\");\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Retrieves rewards owed for a set of resolved price requests.",
            "     * @dev Can only retrieve rewards if calling for a valid round and if the",
            "     * call is done within the timeout threshold (not expired).",
            "     * @param voterAddress voter for which rewards will be retrieved. Does not have to be the caller.",
            "     * @param roundId the round from which voting rewards will be retrieved from.",
            "     * @param toRetrieve array of PendingRequests which rewards are retrieved from.",
            "     * @return totalRewardToIssue total amount of rewards returned to the voter.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Retrieves rewards owed for a set of resolved price requests.\n     * @dev Can only retrieve rewards if calling for a valid round and if the\n     * call is done within the timeout threshold (not expired).\n     * @param voterAddress voter for which rewards will be retrieved. Does not have to be the caller.\n     * @param roundId the round from which voting rewards will be retrieved from.\n     * @param toRetrieve array of PendingRequests which rewards are retrieved from.\n     * @return totalRewardToIssue total amount of rewards returned to the voter.\n     */\n",
        "@notice": "Retrieves rewards owed for a set of resolved price requests.",
        "@dev": "Can only retrieve rewards if calling for a valid round and if the * call is done within the timeout threshold (not expired).",
        "@param1": "voterAddress voter for which rewards will be retrieved. Does not have to be the caller.",
        "@param2": "roundId the round from which voting rewards will be retrieved from.",
        "@param3": "toRetrieve array of PendingRequests which rewards are retrieved from.",
        "@return1": "totalRewardToIssue total amount of rewards returned to the voter.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPendingRequests",
        "visibility": "external",
        "args": [],
        "func": "function getPendingRequests() external override view returns (PendingRequest[] memory) {\n        uint256 blockTime = getCurrentTime();\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(blockTime);\n\n        // Solidity memory arrays aren't resizable (and reading storage is expensive). Hence this hackery to filter\n        // `pendingPriceRequests` only to those requests that have an Active RequestStatus.\n        PendingRequest[] memory unresolved = new PendingRequest[](pendingPriceRequests.length);\n        uint256 numUnresolved = 0;\n\n        for (uint256 i = 0; i < pendingPriceRequests.length; i++) {\n            PriceRequest storage priceRequest = priceRequests[pendingPriceRequests[i]];\n            if (_getRequestStatus(priceRequest, currentRoundId) == RequestStatus.Active) {\n                unresolved[numUnresolved] = PendingRequest({\n                    identifier: priceRequest.identifier,\n                    time: priceRequest.time\n                });\n                numUnresolved++;\n            }\n        }\n\n        PendingRequest[] memory pendingRequests = new PendingRequest[](numUnresolved);\n        for (uint256 i = 0; i < numUnresolved; i++) {\n            pendingRequests[i] = unresolved[i];\n        }\n        return pendingRequests;\n    }",
        "comments": [
            "/**",
            "     * @notice Gets the queries that are being voted on this round.",
            "     * @return pendingRequests array containing identifiers of type `PendingRequest`.",
            "     * and timestamps for all pending requests.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets the queries that are being voted on this round.\n     * @return pendingRequests array containing identifiers of type `PendingRequest`.\n     * and timestamps for all pending requests.\n     */\n",
        "@notice": "Gets the queries that are being voted on this round.",
        "@return1": "pendingRequests array containing identifiers of type `PendingRequest`. * and timestamps for all pending requests.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getVotePhase",
        "visibility": "external",
        "args": [],
        "func": "function getVotePhase() external override view returns (Phase) {\n        return voteTiming.computeCurrentPhase(getCurrentTime());\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the current voting phase, as a function of the current time.",
            "     * @return Phase to indicate the current phase. Either { Commit, Reveal, NUM_PHASES_PLACEHOLDER }.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the current voting phase, as a function of the current time.\n     * @return Phase to indicate the current phase. Either { Commit, Reveal, NUM_PHASES_PLACEHOLDER }.\n     */\n",
        "@notice": "Returns the current voting phase, as a function of the current time.",
        "@return1": "Phase to indicate the current phase. Either { Commit, Reveal, NUM_PHASES_PLACEHOLDER }.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentRoundId",
        "visibility": "external",
        "args": [],
        "func": "function getCurrentRoundId() external override view returns (uint256) {\n        return voteTiming.computeCurrentRoundId(getCurrentTime());\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the current round ID, as a function of the current time.",
            "     * @return uint256 representing the unique round ID.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the current round ID, as a function of the current time.\n     * @return uint256 representing the unique round ID.\n     */\n",
        "@notice": "Returns the current round ID, as a function of the current time.",
        "@return1": "uint256 representing the unique round ID.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setMigrated",
        "visibility": "external",
        "args": [
            {
                "name": "newVotingAddress",
                "type": "address"
            }
        ],
        "func": "function setMigrated(address newVotingAddress) external onlyOwner {\n        migratedAddress = newVotingAddress;\n    }",
        "comments": [
            "/**",
            "     * @notice Disables this Voting contract in favor of the migrated one.",
            "     * @dev Can only be called by the contract owner.",
            "     * @param newVotingAddress the newly migrated contract address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Disables this Voting contract in favor of the migrated one.\n     * @dev Can only be called by the contract owner.\n     * @param newVotingAddress the newly migrated contract address.\n     */\n",
        "@notice": "Disables this Voting contract in favor of the migrated one.",
        "@dev": "Can only be called by the contract owner.",
        "@param1": "newVotingAddress the newly migrated contract address.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setInflationRate",
        "visibility": "public",
        "args": [
            {
                "name": "newInflationRate",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function setInflationRate(FixedPoint.Unsigned memory newInflationRate) public onlyOwner {\n        inflationRate = newInflationRate;\n    }",
        "comments": [
            "/**",
            "     * @notice Resets the inflation rate. Note: this change only applies to rounds that have not yet begun.",
            "     * @dev This method is public because calldata structs are not currently supported by solidity.",
            "     * @param newInflationRate sets the next round's inflation rate.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Resets the inflation rate. Note: this change only applies to rounds that have not yet begun.\n     * @dev This method is public because calldata structs are not currently supported by solidity.\n     * @param newInflationRate sets the next round's inflation rate.\n     */\n",
        "@notice": "Resets the inflation rate. Note: this change only applies to rounds that have not yet begun.",
        "@dev": "This method is public because calldata structs are not currently supported by solidity.",
        "@param1": "newInflationRate sets the next round's inflation rate.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setGatPercentage",
        "visibility": "public",
        "args": [
            {
                "name": "newGatPercentage",
                "type": "FixedPoint.Unsigned memory"
            }
        ],
        "func": "function setGatPercentage(FixedPoint.Unsigned memory newGatPercentage) public onlyOwner {\n        require(newGatPercentage.isLessThan(1), \"GAT percentage must be < 100%\");\n        gatPercentage = newGatPercentage;\n    }",
        "comments": [
            "/**",
            "     * @notice Resets the Gat percentage. Note: this change only applies to rounds that have not yet begun.",
            "     * @dev This method is public because calldata structs are not currently supported by solidity.",
            "     * @param newGatPercentage sets the next round's Gat percentage.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Resets the Gat percentage. Note: this change only applies to rounds that have not yet begun.\n     * @dev This method is public because calldata structs are not currently supported by solidity.\n     * @param newGatPercentage sets the next round's Gat percentage.\n     */\n",
        "@notice": "Resets the Gat percentage. Note: this change only applies to rounds that have not yet begun.",
        "@dev": "This method is public because calldata structs are not currently supported by solidity.",
        "@param1": "newGatPercentage sets the next round's Gat percentage.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setRewardsExpirationTimeout",
        "visibility": "public",
        "args": [
            {
                "name": "NewRewardsExpirationTimeout",
                "type": "uint256"
            }
        ],
        "func": "function setRewardsExpirationTimeout(uint256 NewRewardsExpirationTimeout) public onlyOwner {\n        rewardsExpirationTimeout = NewRewardsExpirationTimeout;\n    }",
        "comments": [
            "/**",
            "     * @notice Resets the rewards expiration timeout.",
            "     * @dev This change only applies to rounds that have not yet begun.",
            "     * @param NewRewardsExpirationTimeout how long a caller can wait before choosing to withdraw their rewards.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Resets the rewards expiration timeout.\n     * @dev This change only applies to rounds that have not yet begun.\n     * @param NewRewardsExpirationTimeout how long a caller can wait before choosing to withdraw their rewards.\n     */\n",
        "@notice": "Resets the rewards expiration timeout.",
        "@dev": "This change only applies to rounds that have not yet begun.",
        "@param1": "NewRewardsExpirationTimeout how long a caller can wait before choosing to withdraw their rewards.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPendingPriceRequestsArray",
        "visibility": "external",
        "args": [],
        "func": "function getPendingPriceRequestsArray() external view returns (bytes32[] memory) {\n        return pendingPriceRequests;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "snapshot",
        "visibility": "external",
        "args": [],
        "func": "function snapshot() external returns (uint256) {\n        return _snapshot();\n    }",
        "comments": [
            "/**",
            "     * @notice Creates a new snapshot ID.",
            "     * @return uint256 Thew new snapshot ID.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Creates a new snapshot ID.\n     * @return uint256 Thew new snapshot ID.\n     */\n",
        "@notice": "Creates a new snapshot ID.",
        "@return1": "uint256 Thew new snapshot ID.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "deposit",
        "visibility": "public",
        "args": [],
        "func": "function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "wad",
                "type": "uint256"
            }
        ],
        "func": "function withdraw(uint256 wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        msg.sender.transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "guy",
                "type": "address"
            },
            {
                "name": "wad",
                "type": "uint256"
            }
        ],
        "func": "function approve(address guy, uint256 wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "dst",
                "type": "address"
            },
            {
                "name": "wad",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address dst, uint256 wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "src",
                "type": "address"
            },
            {
                "name": "dst",
                "type": "address"
            },
            {
                "name": "wad",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public returns (bool) {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] != uint256(-1)) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function withdraw(uint256 amount) external onlyRoleHolder(roleId) {\n        Address.sendValue(msg.sender, amount);\n    }",
        "comments": [
            "/**",
            "     * @notice Withdraws ETH from the contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Withdraws ETH from the contract.\n     */\n",
        "@notice": "Withdraws ETH from the contract.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawErc20",
        "visibility": "external",
        "args": [
            {
                "name": "erc20Address",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function withdrawErc20(address erc20Address, uint256 amount) external onlyRoleHolder(roleId) {\n        IERC20 erc20 = IERC20(erc20Address);\n        erc20.safeTransfer(msg.sender, amount);\n    }",
        "comments": [
            "/**",
            "     * @notice Withdraws ERC20 tokens from the contract.",
            "     * @param erc20Address ERC20 token to withdraw.",
            "     * @param amount amount of tokens to withdraw.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Withdraws ERC20 tokens from the contract.\n     * @param erc20Address ERC20 token to withdraw.\n     * @param amount amount of tokens to withdraw.\n     */\n",
        "@notice": "Withdraws ERC20 tokens from the contract.",
        "@param1": "erc20Address ERC20 token to withdraw.",
        "@param2": "amount amount of tokens to withdraw.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "pay",
        "visibility": "external",
        "args": [],
        "func": "function pay() external payable {\n        require(msg.value > 0);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setInternalWithdrawRole",
        "visibility": "public",
        "args": [
            {
                "name": "roleId",
                "type": "uint256"
            }
        ],
        "func": "function setInternalWithdrawRole(uint256 roleId) public {\n        _setWithdrawRole(roleId);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    }
]