[
    {
        "transactions": 5316,
        "function_num": 274
    },
    {
        "name": "foo",
        "visibility": "public",
        "args": [],
        "func": "function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "hasRole",
        "visibility": "public",
        "args": [
            {
                "name": "role",
                "type": "bytes32"
            },
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }",
        "comments": [
            "/**",
            "     * @dev Returns `true` if `account` has been granted `role`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n",
        "@dev": "Returns `true` if `account` has been granted `role`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getRoleMemberCount",
        "visibility": "public",
        "args": [
            {
                "name": "role",
                "type": "bytes32"
            }
        ],
        "func": "function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the number of accounts that have `role`. Can be used",
            "     * together with {getRoleMember} to enumerate all bearers of a role.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n",
        "@dev": "Returns the number of accounts that have `role`. Can be used * together with {getRoleMember} to enumerate all bearers of a role.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getRoleMember",
        "visibility": "public",
        "args": [
            {
                "name": "role",
                "type": "bytes32"
            },
            {
                "name": "index",
                "type": "uint256"
            }
        ],
        "func": "function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }",
        "comments": [
            "/**",
            "     * @dev Returns one of the accounts that have `role`. `index` must be a",
            "     * value between 0 and {getRoleMemberCount}, non-inclusive.",
            "     *",
            "     * Role bearers are not sorted in any particular way, and their ordering may",
            "     * change at any point.",
            "     *",
            "     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure",
            "     * you perform all queries on the same block. See the following",
            "     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]",
            "     * for more information.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n",
        "@dev": "Returns one of the accounts that have `role`. `index` must be a * value between 0 and {getRoleMemberCount}, non-inclusive. * * Role bearers are not sorted in any particular way, and their ordering may * change at any point. * * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure * you perform all queries on the same block. See the following * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] * for more information.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getRoleAdmin",
        "visibility": "public",
        "args": [
            {
                "name": "role",
                "type": "bytes32"
            }
        ],
        "func": "function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the admin role that controls `role`. See {grantRole} and",
            "     * {revokeRole}.",
            "     *",
            "     * To change a role's admin, use {_setRoleAdmin}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n",
        "@dev": "Returns the admin role that controls `role`. See {grantRole} and * {revokeRole}. * * To change a role's admin, use {_setRoleAdmin}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "grantRole",
        "visibility": "public",
        "args": [
            {
                "name": "role",
                "type": "bytes32"
            },
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }",
        "comments": [
            "/**",
            "     * @dev Grants `role` to `account`.",
            "     *",
            "     * If `account` had not been already granted `role`, emits a {RoleGranted}",
            "     * event.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - the caller must have ``role``'s admin role.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n",
        "@dev": "Grants `role` to `account`. * * If `account` had not been already granted `role`, emits a {RoleGranted} * event. * * Requirements: * * - the caller must have ``role``'s admin role.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "revokeRole",
        "visibility": "public",
        "args": [
            {
                "name": "role",
                "type": "bytes32"
            },
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }",
        "comments": [
            "/**",
            "     * @dev Revokes `role` from `account`.",
            "     *",
            "     * If `account` had been granted `role`, emits a {RoleRevoked} event.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - the caller must have ``role``'s admin role.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n",
        "@dev": "Revokes `role` from `account`. * * If `account` had been granted `role`, emits a {RoleRevoked} event. * * Requirements: * * - the caller must have ``role``'s admin role.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "renounceRole",
        "visibility": "public",
        "args": [
            {
                "name": "role",
                "type": "bytes32"
            },
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }",
        "comments": [
            "/**",
            "     * @dev Revokes `role` from the calling account.",
            "     *",
            "     * Roles are often managed via {grantRole} and {revokeRole}: this function's",
            "     * purpose is to provide a mechanism for accounts to lose their privileges",
            "     * if they are compromised (such as when a trusted device is misplaced).",
            "     *",
            "     * If the calling account had been granted `role`, emits a {RoleRevoked}",
            "     * event.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - the caller must be `account`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n",
        "@dev": "Revokes `role` from the calling account. * * Roles are often managed via {grantRole} and {revokeRole}: this function's * purpose is to provide a mechanism for accounts to lose their privileges * if they are compromised (such as when a trusted device is misplaced). * * If the calling account had been granted `role`, emits a {RoleRevoked} * event. * * Requirements: * * - the caller must be `account`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mine",
        "visibility": "public",
        "args": [],
        "func": "function mine() public {\n       blocksMined += 1;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "blockTime",
        "visibility": "external",
        "args": [],
        "func": "function blockTime() external view returns (uint256) {\n       return block.timestamp;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getLatestPrice",
        "visibility": "public",
        "args": [],
        "func": "function getLatestPrice() public view returns (int) {\n        (\n            , \n            int price,\n            ,\n            ,\n            \n        ) = priceFeed.latestRoundData();\n        return price;\n    }",
        "comments": [
            "/**",
            "     * Returns the latest price",
            "     */",
            ""
        ],
        "comt": "/**\n     * Returns the latest price\n     */\n",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getDecimals",
        "visibility": "public",
        "args": [],
        "func": "function getDecimals() public view returns (uint8) {\n        return priceFeed.decimals();\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getLatestPrice",
        "visibility": "public",
        "args": [],
        "func": "function getLatestPrice() public pure returns (int) {\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // (\n        //     uint80 roundID, \n        //     int price,\n        //     uint startedAt,\n        //     uint timeStamp,\n        //     uint80 answeredInRound\n        // ) = priceFeed.latestRoundData();\n        // // If the round is not complete yet, timestamp is 0\n        // require(timeStamp > 0, \"Round not complete\");\n\n        // This will return something like 32063000000\n        // Divide this by getDecimals to get the \"true\" price\n        // You can can multiply the \"true\" price by 1e6 to get the frax ecosystem 'price'\n        // return price;\n\n        return 59000000000;\n    }",
        "comments": [
            "/**",
            "     * Returns the latest price",
            "     */",
            ""
        ],
        "comt": "/**\n     * Returns the latest price\n     */\n",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getDecimals",
        "visibility": "public",
        "args": [],
        "func": "function getDecimals() public pure returns (uint8) {\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // VERY IMPORTANT: UNCOMMENT THIS LATER\n        // return priceFeed.decimals();\n        return 8;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "name",
        "visibility": "public",
        "args": [],
        "func": "function name() public view returns (string memory) {\n        return _name;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the name of the token.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the name of the token.\n     */\n",
        "@dev": "Returns the name of the token.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "symbol",
        "visibility": "public",
        "args": [],
        "func": "function symbol() public view returns (string memory) {\n        return _symbol;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the symbol of the token, usually a shorter version of the",
            "     * name.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n",
        "@dev": "Returns the symbol of the token, usually a shorter version of the * name.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decimals",
        "visibility": "public",
        "args": [],
        "func": "function decimals() public view returns (uint8) {\n        return _decimals;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the number of decimals used to get its user representation.",
            "     * For example, if `decimals` equals `2`, a balance of `505` tokens should",
            "     * be displayed to a user as `5,05` (`505 / 10 ** 2`).",
            "     *",
            "     * Tokens usually opt for a value of 18, imitating the relationship between",
            "     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is",
            "     * called.",
            "     *",
            "     * NOTE: This information is only used for _display_ purposes: it in",
            "     * no way affects any of the arithmetic of the contract, including",
            "     * {IERC20-balanceOf} and {IERC20-transfer}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n",
        "@dev": "Returns the number of decimals used to get its user representation. * For example, if `decimals` equals `2`, a balance of `505` tokens should * be displayed to a user as `5,05` (`505 / 10 ** 2`). * * Tokens usually opt for a value of 18, imitating the relationship between * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is * called. * * NOTE: This information is only used for _display_ purposes: it in * no way affects any of the arithmetic of the contract, including * {IERC20-balanceOf} and {IERC20-transfer}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-totalSupply}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-totalSupply}.\n     */\n",
        "@dev": "See {IERC20-totalSupply}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-balanceOf}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-balanceOf}.\n     */\n",
        "@dev": "See {IERC20-balanceOf}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-transfer}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `recipient` cannot be the zero address.",
            "     * - the caller must have a balance of at least `amount`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n",
        "@dev": "See {IERC20-transfer}. * * Requirements: * * - `recipient` cannot be the zero address. * - the caller must have a balance of at least `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allowance",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            }
        ],
        "func": "function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-allowance}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-allowance}.\n     */\n",
        "@dev": "See {IERC20-allowance}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-approve}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.approve(address spender, uint256 amount)",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.approve(address spender, uint256 amount)\n     */\n",
        "@dev": "See {IERC20-approve}. * * Requirements: * * - `spender` cannot be the zero address.approve(address spender, uint256 amount)",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-transferFrom}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance. This is not",
            "     * required by the EIP. See the note at the beginning of {ERC20};",
            "     *",
            "     * Requirements:",
            "     * - `sender` and `recipient` cannot be the zero address.",
            "     * - `sender` must have a balance of at least `amount`.",
            "     * - the caller must have allowance for `sender`'s tokens of at least",
            "     * `amount`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n",
        "@dev": "See {IERC20-transferFrom}. * * Emits an {Approval} event indicating the updated allowance. This is not * required by the EIP. See the note at the beginning of {ERC20}; * * Requirements: * - `sender` and `recipient` cannot be the zero address. * - `sender` must have a balance of at least `amount`. * - the caller must have allowance for `sender`'s tokens of at least * `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "increaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "addedValue",
                "type": "uint256"
            }
        ],
        "func": "function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Atomically increases the allowance granted to `spender` by the caller.",
            "     *",
            "     * This is an alternative to {approve} that can be used as a mitigation for",
            "     * problems described in {IERC20-approve}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n",
        "@dev": "Atomically increases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decreaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "subtractedValue",
                "type": "uint256"
            }
        ],
        "func": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Atomically decreases the allowance granted to `spender` by the caller.",
            "     *",
            "     * This is an alternative to {approve} that can be used as a mitigation for",
            "     * problems described in {IERC20-approve}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     * - `spender` must have allowance for the caller of at least",
            "     * `subtractedValue`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n",
        "@dev": "Atomically decreases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address. * - `spender` must have allowance for the caller of at least * `subtractedValue`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }",
        "comments": [
            "/**",
            "     * @dev Destroys `amount` tokens from the caller.",
            "     *",
            "     * See {ERC20-_burn}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n",
        "@dev": "Destroys `amount` tokens from the caller. * * See {ERC20-_burn}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burnFrom",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }",
        "comments": [
            "/**",
            "     * @dev Destroys `amount` tokens from `account`, deducting from the caller's",
            "     * allowance.",
            "     *",
            "     * See {ERC20-_burn} and {ERC20-allowance}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - the caller must have allowance for `accounts`'s tokens of at least",
            "     * `amount`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for `accounts`'s tokens of at least\n     * `amount`.\n     */\n",
        "@dev": "Destroys `amount` tokens from `account`, deducting from the caller's * allowance. * * See {ERC20-_burn} and {ERC20-allowance}. * * Requirements: * * - the caller must have allowance for `accounts`'s tokens of at least * `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-totalSupply}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-totalSupply}.\n     */\n",
        "@dev": "See {IERC20-totalSupply}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-balanceOf}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-balanceOf}.\n     */\n",
        "@dev": "See {IERC20-balanceOf}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-transfer}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `recipient` cannot be the zero address.",
            "     * - the caller must have a balance of at least `amount`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n",
        "@dev": "See {IERC20-transfer}. * * Requirements: * * - `recipient` cannot be the zero address. * - the caller must have a balance of at least `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allowance",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            }
        ],
        "func": "function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-allowance}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-allowance}.\n     */\n",
        "@dev": "See {IERC20-allowance}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-approve}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.approve(address spender, uint256 amount)",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.approve(address spender, uint256 amount)\n     */\n",
        "@dev": "See {IERC20-approve}. * * Requirements: * * - `spender` cannot be the zero address.approve(address spender, uint256 amount)",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-transferFrom}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance. This is not",
            "     * required by the EIP. See the note at the beginning of {ERC20};",
            "     *",
            "     * Requirements:",
            "     * - `sender` and `recipient` cannot be the zero address.",
            "     * - `sender` must have a balance of at least `amount`.",
            "     * - the caller must have allowance for `sender`'s tokens of at least",
            "     * `amount`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n",
        "@dev": "See {IERC20-transferFrom}. * * Emits an {Approval} event indicating the updated allowance. This is not * required by the EIP. See the note at the beginning of {ERC20}; * * Requirements: * - `sender` and `recipient` cannot be the zero address. * - `sender` must have a balance of at least `amount`. * - the caller must have allowance for `sender`'s tokens of at least * `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "increaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "addedValue",
                "type": "uint256"
            }
        ],
        "func": "function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Atomically increases the allowance granted to `spender` by the caller.",
            "     *",
            "     * This is an alternative to {approve} that can be used as a mitigation for",
            "     * problems described in {IERC20-approve}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n",
        "@dev": "Atomically increases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decreaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "subtractedValue",
                "type": "uint256"
            }
        ],
        "func": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Atomically decreases the allowance granted to `spender` by the caller.",
            "     *",
            "     * This is an alternative to {approve} that can be used as a mitigation for",
            "     * problems described in {IERC20-approve}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     * - `spender` must have allowance for the caller of at least",
            "     * `subtractedValue`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n",
        "@dev": "Atomically decreases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address. * - `spender` must have allowance for the caller of at least * `subtractedValue`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }",
        "comments": [
            "/**",
            "     * @dev Destroys `amount` tokens from the caller.",
            "     *",
            "     * See {ERC20-_burn}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n",
        "@dev": "Destroys `amount` tokens from the caller. * * See {ERC20-_burn}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burnFrom",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }",
        "comments": [
            "/**",
            "     * @dev Destroys `amount` tokens from `account`, deducting from the caller's",
            "     * allowance.",
            "     *",
            "     * See {ERC20-_burn} and {ERC20-allowance}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - the caller must have allowance for `accounts`'s tokens of at least",
            "     * `amount`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for `accounts`'s tokens of at least\n     * `amount`.\n     */\n",
        "@dev": "Destroys `amount` tokens from `account`, deducting from the caller's * allowance. * * See {ERC20-_burn} and {ERC20-allowance}. * * Requirements: * * - the caller must have allowance for `accounts`'s tokens of at least * `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "faucet",
        "visibility": "public",
        "args": [],
        "func": "function faucet() public {\n     if (used[msg.sender] == false) {\n      used[msg.sender] = true;\n      _mint(msg.sender, 1000 * (10 ** uint256(decimals)));\n     }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-totalSupply}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-totalSupply}.\n     */\n",
        "@dev": "See {IERC20-totalSupply}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-balanceOf}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-balanceOf}.\n     */\n",
        "@dev": "See {IERC20-balanceOf}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-transfer}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `recipient` cannot be the zero address.",
            "     * - the caller must have a balance of at least `amount`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n",
        "@dev": "See {IERC20-transfer}. * * Requirements: * * - `recipient` cannot be the zero address. * - the caller must have a balance of at least `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allowance",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            }
        ],
        "func": "function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-allowance}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-allowance}.\n     */\n",
        "@dev": "See {IERC20-allowance}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-approve}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.approve(address spender, uint256 amount)",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.approve(address spender, uint256 amount)\n     */\n",
        "@dev": "See {IERC20-approve}. * * Requirements: * * - `spender` cannot be the zero address.approve(address spender, uint256 amount)",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-transferFrom}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance. This is not",
            "     * required by the EIP. See the note at the beginning of {ERC20};",
            "     *",
            "     * Requirements:",
            "     * - `sender` and `recipient` cannot be the zero address.",
            "     * - `sender` must have a balance of at least `amount`.",
            "     * - the caller must have allowance for `sender`'s tokens of at least",
            "     * `amount`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n",
        "@dev": "See {IERC20-transferFrom}. * * Emits an {Approval} event indicating the updated allowance. This is not * required by the EIP. See the note at the beginning of {ERC20}; * * Requirements: * - `sender` and `recipient` cannot be the zero address. * - `sender` must have a balance of at least `amount`. * - the caller must have allowance for `sender`'s tokens of at least * `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "increaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "addedValue",
                "type": "uint256"
            }
        ],
        "func": "function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Atomically increases the allowance granted to `spender` by the caller.",
            "     *",
            "     * This is an alternative to {approve} that can be used as a mitigation for",
            "     * problems described in {IERC20-approve}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n",
        "@dev": "Atomically increases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decreaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "subtractedValue",
                "type": "uint256"
            }
        ],
        "func": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Atomically decreases the allowance granted to `spender` by the caller.",
            "     *",
            "     * This is an alternative to {approve} that can be used as a mitigation for",
            "     * problems described in {IERC20-approve}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     * - `spender` must have allowance for the caller of at least",
            "     * `subtractedValue`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n",
        "@dev": "Atomically decreases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address. * - `spender` must have allowance for the caller of at least * `subtractedValue`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }",
        "comments": [
            "/**",
            "     * @dev Destroys `amount` tokens from the caller.",
            "     *",
            "     * See {ERC20-_burn}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n",
        "@dev": "Destroys `amount` tokens from the caller. * * See {ERC20-_burn}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burnFrom",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }",
        "comments": [
            "/**",
            "     * @dev Destroys `amount` tokens from `account`, deducting from the caller's",
            "     * allowance.",
            "     *",
            "     * See {ERC20-_burn} and {ERC20-allowance}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - the caller must have allowance for `accounts`'s tokens of at least",
            "     * `amount`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for `accounts`'s tokens of at least\n     * `amount`.\n     */\n",
        "@dev": "Destroys `amount` tokens from `account`, deducting from the caller's * allowance. * * See {ERC20-_burn} and {ERC20-allowance}. * * Requirements: * * - the caller must have allowance for `accounts`'s tokens of at least * `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "frax_price",
        "visibility": "public",
        "args": [],
        "func": "function frax_price() public view returns (uint256) {\n        return oracle_price(PriceChoice.FRAX);\n    }",
        "comments": [
            "",
            "    // Returns X FRAX = 1 USD",
            "    "
        ],
        "comt": "\n    // Returns X FRAX = 1 USD\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "fxs_price",
        "visibility": "public",
        "args": [],
        "func": "function fxs_price()  public view returns (uint256) {\n        return oracle_price(PriceChoice.FXS);\n    }",
        "comments": [
            "",
            "    // Returns X FXS = 1 USD",
            "    "
        ],
        "comt": "\n    // Returns X FXS = 1 USD\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "eth_usd_price",
        "visibility": "public",
        "args": [],
        "func": "function eth_usd_price() public view returns (uint256) {\n        return uint256(eth_usd_pricer.getLatestPrice()).mul(PRICE_PRECISION).div(uint256(10) ** eth_usd_pricer_decimals);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "frax_info",
        "visibility": "public",
        "args": [],
        "func": "function frax_info() public view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\n        return (\n            oracle_price(PriceChoice.FRAX), // frax_price()\n            oracle_price(PriceChoice.FXS), // fxs_price()\n            totalSupply(), // totalSupply()\n            global_collateral_ratio, // global_collateral_ratio()\n            globalCollateralValue(), // globalCollateralValue\n            minting_fee, // minting_fee()\n            redemption_fee, // redemption_fee()\n            uint256(eth_usd_pricer.getLatestPrice()).mul(PRICE_PRECISION).div(uint256(10) ** eth_usd_pricer_decimals) //eth_usd_price\n        );\n    }",
        "comments": [
            "",
            "    // This is needed to avoid costly repeat calls to different getter functions",
            "    // It is cheaper gas-wise to just dump everything and only use some of the info",
            "    "
        ],
        "comt": "\n    // This is needed to avoid costly repeat calls to different getter functions\n    // It is cheaper gas-wise to just dump everything and only use some of the info\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "globalCollateralValue",
        "visibility": "public",
        "args": [],
        "func": "function globalCollateralValue() public view returns (uint256) {\n        uint256 total_collateral_value_d18 = 0; \n\n        for (uint i = 0; i < frax_pools_array.length; i++){ \n            // Exclude null addresses\n            if (frax_pools_array[i] != address(0)){\n                total_collateral_value_d18 = total_collateral_value_d18.add(FraxPool(frax_pools_array[i]).collatDollarBalance());\n            }\n\n        }\n        return total_collateral_value_d18;\n    }",
        "comments": [
            "",
            "    // Iterate through all frax pools and calculate all value of collateral in all pools globally ",
            "    "
        ],
        "comt": "\n    // Iterate through all frax pools and calculate all value of collateral in all pools globally \n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "refreshCollateralRatio",
        "visibility": "public",
        "args": [],
        "func": "function refreshCollateralRatio() public {\n        require(collateral_ratio_paused == false, \"Collateral Ratio has been paused\");\n        uint256 frax_price_cur = frax_price();\n        require(block.timestamp - last_call_time >= refresh_cooldown, \"Must wait for the refresh cooldown since last refresh\");\n\n        // Step increments are 0.25% (upon genesis, changable by setFraxStep()) \n        \n        if (frax_price_cur > price_target.add(price_band)) { //decrease collateral ratio\n            if(global_collateral_ratio <= frax_step){ //if within a step of 0, go to 0\n                global_collateral_ratio = 0;\n            } else {\n                global_collateral_ratio = global_collateral_ratio.sub(frax_step);\n            }\n        } else if (frax_price_cur < price_target.sub(price_band)) { //increase collateral ratio\n            if(global_collateral_ratio.add(frax_step) >= 1000000){\n                global_collateral_ratio = 1000000; // cap collateral ratio at 1.000000\n            } else {\n                global_collateral_ratio = global_collateral_ratio.add(frax_step);\n            }\n        }\n\n        last_call_time = block.timestamp; // Set the time of the last expansion\n    }",
        "comments": [
            "// Last time the refreshCollateralRatio function was called",
            "    "
        ],
        "comt": "// Last time the refreshCollateralRatio function was called\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "pool_burn_from",
        "visibility": "public",
        "args": [
            {
                "name": "b_address",
                "type": "address"
            },
            {
                "name": "b_amount",
                "type": "uint256"
            }
        ],
        "func": "function pool_burn_from(address b_address, uint256 b_amount) public onlyPools {\n        super._burnFrom(b_address, b_amount);\n        emit FRAXBurned(b_address, msg.sender, b_amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "pool_mint",
        "visibility": "public",
        "args": [
            {
                "name": "m_address",
                "type": "address"
            },
            {
                "name": "m_amount",
                "type": "uint256"
            }
        ],
        "func": "function pool_mint(address m_address, uint256 m_amount) public onlyPools {\n        super._mint(m_address, m_amount);\n        emit FRAXMinted(msg.sender, m_address, m_amount);\n    }",
        "comments": [
            "",
            "    // This function is what other frax pools will call to mint new FRAX ",
            "    "
        ],
        "comt": "\n    // This function is what other frax pools will call to mint new FRAX \n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addPool",
        "visibility": "public",
        "args": [
            {
                "name": "pool_address",
                "type": "address"
            }
        ],
        "func": "function addPool(address pool_address) public onlyByOwnerOrGovernance {\n        require(frax_pools[pool_address] == false, \"address already exists\");\n        frax_pools[pool_address] = true; \n        frax_pools_array.push(pool_address);\n    }",
        "comments": [
            "",
            "    // Adds collateral addresses supported, such as tether and busd, must be ERC20 ",
            "    "
        ],
        "comt": "\n    // Adds collateral addresses supported, such as tether and busd, must be ERC20 \n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removePool",
        "visibility": "public",
        "args": [
            {
                "name": "pool_address",
                "type": "address"
            }
        ],
        "func": "function removePool(address pool_address) public onlyByOwnerOrGovernance {\n        require(frax_pools[pool_address] == true, \"address doesn't exist already\");\n        \n        // Delete from the mapping\n        delete frax_pools[pool_address];\n\n        // 'Delete' from the array by setting the address to 0x0\n        for (uint i = 0; i < frax_pools_array.length; i++){ \n            if (frax_pools_array[i] == pool_address) {\n                frax_pools_array[i] = address(0); // This will leave a null in the array and keep the indices the same\n                break;\n            }\n        }\n    }",
        "comments": [
            "",
            "    // Remove a pool ",
            "    "
        ],
        "comt": "\n    // Remove a pool \n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setOwner",
        "visibility": "external",
        "args": [
            {
                "name": "_owner_address",
                "type": "address"
            }
        ],
        "func": "function setOwner(address _owner_address) external onlyByOwnerOrGovernance {\n        owner_address = _owner_address;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setRedemptionFee",
        "visibility": "public",
        "args": [
            {
                "name": "red_fee",
                "type": "uint256"
            }
        ],
        "func": "function setRedemptionFee(uint256 red_fee) public onlyByOwnerOrGovernance {\n        redemption_fee = red_fee;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setMintingFee",
        "visibility": "public",
        "args": [
            {
                "name": "min_fee",
                "type": "uint256"
            }
        ],
        "func": "function setMintingFee(uint256 min_fee) public onlyByOwnerOrGovernance {\n        minting_fee = min_fee;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setFraxStep",
        "visibility": "public",
        "args": [
            {
                "name": "_new_step",
                "type": "uint256"
            }
        ],
        "func": "function setFraxStep(uint256 _new_step) public onlyByOwnerOrGovernance {\n        frax_step = _new_step;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setPriceTarget ",
        "visibility": "public",
        "args": [
            {
                "name": "_new_price_target",
                "type": "uint256"
            }
        ],
        "func": "function setPriceTarget (uint256 _new_price_target) public onlyByOwnerOrGovernance {\n        price_target = _new_price_target;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setRefreshCooldown",
        "visibility": "public",
        "args": [
            {
                "name": "_new_cooldown",
                "type": "uint256"
            }
        ],
        "func": "function setRefreshCooldown(uint256 _new_cooldown) public onlyByOwnerOrGovernance {\n     refresh_cooldown = _new_cooldown;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setFXSAddress",
        "visibility": "public",
        "args": [
            {
                "name": "_fxs_address",
                "type": "address"
            }
        ],
        "func": "function setFXSAddress(address _fxs_address) public onlyByOwnerOrGovernance {\n        fxs_address = _fxs_address;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setETHUSDOracle",
        "visibility": "public",
        "args": [
            {
                "name": "_eth_usd_consumer_address",
                "type": "address"
            }
        ],
        "func": "function setETHUSDOracle(address _eth_usd_consumer_address) public onlyByOwnerOrGovernance {\n        eth_usd_consumer_address = _eth_usd_consumer_address;\n        eth_usd_pricer = ChainlinkETHUSDPriceConsumer(eth_usd_consumer_address);\n        eth_usd_pricer_decimals = eth_usd_pricer.getDecimals();\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setTimelock",
        "visibility": "external",
        "args": [
            {
                "name": "new_timelock",
                "type": "address"
            }
        ],
        "func": "function setTimelock(address new_timelock) external onlyByOwnerOrGovernance {\n        timelock_address = new_timelock;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setController",
        "visibility": "external",
        "args": [
            {
                "name": "_controller_address",
                "type": "address"
            }
        ],
        "func": "function setController(address _controller_address) external onlyByOwnerOrGovernance {\n        controller_address = _controller_address;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setPriceBand",
        "visibility": "external",
        "args": [
            {
                "name": "_price_band",
                "type": "uint256"
            }
        ],
        "func": "function setPriceBand(uint256 _price_band) external onlyByOwnerOrGovernance {\n        price_band = _price_band;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setFRAXEthOracle",
        "visibility": "public",
        "args": [
            {
                "name": "_frax_oracle_addr",
                "type": "address"
            },
            {
                "name": "_weth_address",
                "type": "address"
            }
        ],
        "func": "function setFRAXEthOracle(address _frax_oracle_addr, address _weth_address) public onlyByOwnerOrGovernance {\n        frax_eth_oracle_address = _frax_oracle_addr;\n        fraxEthOracle = UniswapPairOracle(_frax_oracle_addr); \n        weth_address = _weth_address;\n    }",
        "comments": [
            "",
            "    // Sets the FRAX_ETH Uniswap oracle address ",
            "    "
        ],
        "comt": "\n    // Sets the FRAX_ETH Uniswap oracle address \n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setFXSEthOracle",
        "visibility": "public",
        "args": [
            {
                "name": "_fxs_oracle_addr",
                "type": "address"
            },
            {
                "name": "_weth_address",
                "type": "address"
            }
        ],
        "func": "function setFXSEthOracle(address _fxs_oracle_addr, address _weth_address) public onlyByOwnerOrGovernance {\n        fxs_eth_oracle_address = _fxs_oracle_addr;\n        fxsEthOracle = UniswapPairOracle(_fxs_oracle_addr);\n        weth_address = _weth_address;\n    }",
        "comments": [
            "",
            "    // Sets the FXS_ETH Uniswap oracle address ",
            "    "
        ],
        "comt": "\n    // Sets the FXS_ETH Uniswap oracle address \n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "toggleCollateralRatio",
        "visibility": "public",
        "args": [],
        "func": "function toggleCollateralRatio() public onlyCollateralRatioPauser {\n        collateral_ratio_paused = !collateral_ratio_paused;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "collatDollarBalance",
        "visibility": "public",
        "args": [],
        "func": "function collatDollarBalance() public view returns (uint256) {\n        uint256 eth_usd_price = FRAX.eth_usd_price();\n        uint256 eth_collat_price = collatEthOracle.consult(weth_address, (PRICE_PRECISION * (10 ** missing_decimals)));\n\n        uint256 collat_usd_price = eth_usd_price.mul(PRICE_PRECISION).div(eth_collat_price);\n        return (collateral_token.balanceOf(address(this)).sub(unclaimedPoolCollateral)).mul(10 ** missing_decimals).mul(collat_usd_price).div(PRICE_PRECISION); //.mul(getCollateralPrice()).div(1e6);    \n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "availableExcessCollatDV",
        "visibility": "public",
        "args": [],
        "func": "function availableExcessCollatDV() public view returns (uint256) {\n        uint256 total_supply = FRAX.totalSupply();\n        uint256 global_collateral_ratio = FRAX.global_collateral_ratio();\n        uint256 global_collat_value = FRAX.globalCollateralValue();\n\n        if (global_collateral_ratio > COLLATERAL_RATIO_PRECISION) global_collateral_ratio = COLLATERAL_RATIO_PRECISION; // Handles an overcollateralized contract with CR > 1\n        uint256 required_collat_dollar_value_d18 = (total_supply.mul(global_collateral_ratio)).div(COLLATERAL_RATIO_PRECISION); // Calculates collateral needed to back each 1 FRAX with $1 of collateral at current collat ratio\n        if (global_collat_value > required_collat_dollar_value_d18) return global_collat_value.sub(required_collat_dollar_value_d18);\n        else return 0;\n    }",
        "comments": [
            "",
            "    // Returns the value of excess collateral held in this Frax pool, compared to what is needed to maintain the global collateral ratio",
            "    "
        ],
        "comt": "\n    // Returns the value of excess collateral held in this Frax pool, compared to what is needed to maintain the global collateral ratio\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCollateralPrice",
        "visibility": "public",
        "args": [],
        "func": "function getCollateralPrice() public view returns (uint256) {\n        if(collateralPricePaused == true){\n            return pausedPrice;\n        } else {\n            uint256 eth_usd_price = FRAX.eth_usd_price();\n            return eth_usd_price.mul(PRICE_PRECISION).div(collatEthOracle.consult(weth_address, PRICE_PRECISION * (10 ** missing_decimals)));\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setCollatETHOracle",
        "visibility": "external",
        "args": [
            {
                "name": "_collateral_weth_oracle_address",
                "type": "address"
            },
            {
                "name": "_weth_address",
                "type": "address"
            }
        ],
        "func": "function setCollatETHOracle(address _collateral_weth_oracle_address, address _weth_address) external onlyByOwnerOrGovernance {\n        collat_eth_oracle_address = _collateral_weth_oracle_address;\n        collatEthOracle = UniswapPairOracle(_collateral_weth_oracle_address);\n        weth_address = _weth_address;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint1t1FRAX",
        "visibility": "external",
        "args": [
            {
                "name": "collateral_amount",
                "type": "uint256"
            },
            {
                "name": "FRAX_out_min",
                "type": "uint256"
            }
        ],
        "func": "function mint1t1FRAX(uint256 collateral_amount, uint256 FRAX_out_min) external notMintPaused {\n        uint256 collateral_amount_d18 = collateral_amount * (10 ** missing_decimals);\n        uint256 global_collateral_ratio = FRAX.global_collateral_ratio();\n\n        require(global_collateral_ratio >= COLLATERAL_RATIO_MAX, \"Collateral ratio must be >= 1\");\n        require((collateral_token.balanceOf(address(this))).sub(unclaimedPoolCollateral).add(collateral_amount) <= pool_ceiling, \"[Pool's Closed]: Ceiling reached\");\n        \n        (uint256 frax_amount_d18) = FraxPoolLibrary.calcMint1t1FRAX(\n            getCollateralPrice(),\n            minting_fee,\n            collateral_amount_d18\n        ); //1 FRAX for each $1 worth of collateral\n\n        require(FRAX_out_min <= frax_amount_d18, \"Slippage limit reached\");\n        collateral_token.transferFrom(msg.sender, address(this), collateral_amount);\n        FRAX.pool_mint(msg.sender, frax_amount_d18);\n    }",
        "comments": [
            "",
            "    // We separate out the 1t1, fractional and algorithmic minting functions for gas efficiency ",
            "    "
        ],
        "comt": "\n    // We separate out the 1t1, fractional and algorithmic minting functions for gas efficiency \n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mintAlgorithmicFRAX",
        "visibility": "external",
        "args": [
            {
                "name": "fxs_amount_d18",
                "type": "uint256"
            },
            {
                "name": "FRAX_out_min",
                "type": "uint256"
            }
        ],
        "func": "function mintAlgorithmicFRAX(uint256 fxs_amount_d18, uint256 FRAX_out_min) external notMintPaused {\n        uint256 fxs_price = FRAX.fxs_price();\n        uint256 global_collateral_ratio = FRAX.global_collateral_ratio();\n        require(global_collateral_ratio == 0, \"Collateral ratio must be 0\");\n        \n        (uint256 frax_amount_d18) = FraxPoolLibrary.calcMintAlgorithmicFRAX(\n            minting_fee, \n            fxs_price, // X FXS / 1 USD\n            fxs_amount_d18\n        );\n\n        require(FRAX_out_min <= frax_amount_d18, \"Slippage limit reached\");\n        FXS.pool_burn_from(msg.sender, fxs_amount_d18);\n        FRAX.pool_mint(msg.sender, frax_amount_d18);\n    }",
        "comments": [
            "",
            "    // 0% collateral-backed",
            "    "
        ],
        "comt": "\n    // 0% collateral-backed\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mintFractionalFRAX",
        "visibility": "external",
        "args": [
            {
                "name": "collateral_amount",
                "type": "uint256"
            },
            {
                "name": "fxs_amount",
                "type": "uint256"
            },
            {
                "name": "FRAX_out_min",
                "type": "uint256"
            }
        ],
        "func": "function mintFractionalFRAX(uint256 collateral_amount, uint256 fxs_amount, uint256 FRAX_out_min) external notMintPaused {\n        uint256 frax_price = FRAX.frax_price();\n        uint256 fxs_price = FRAX.fxs_price();\n        uint256 global_collateral_ratio = FRAX.global_collateral_ratio();\n\n        require(global_collateral_ratio < COLLATERAL_RATIO_MAX && global_collateral_ratio > 0, \"Collateral ratio needs to be between .000001 and .999999\");\n        require(collateral_token.balanceOf(address(this)).sub(unclaimedPoolCollateral).add(collateral_amount) <= pool_ceiling, \"Pool ceiling reached, no more FRAX can be minted with this collateral\");\n\n        uint256 collateral_amount_d18 = collateral_amount * (10 ** missing_decimals);\n        FraxPoolLibrary.MintFF_Params memory input_params = FraxPoolLibrary.MintFF_Params(\n            minting_fee, \n            fxs_price,\n            frax_price,\n            getCollateralPrice(),\n            fxs_amount,\n            collateral_amount_d18,\n            (collateral_token.balanceOf(address(this)).sub(unclaimedPoolCollateral)),\n            pool_ceiling,\n            global_collateral_ratio\n        );\n\n        (uint256 mint_amount, uint256 fxs_needed) = FraxPoolLibrary.calcMintFractionalFRAX(input_params);\n\n        require(FRAX_out_min <= mint_amount, \"Slippage limit reached\");\n        require(fxs_needed <= fxs_amount, \"Not enough FXS inputted\");\n        FXS.pool_burn_from(msg.sender, fxs_needed);\n        collateral_token.transferFrom(msg.sender, address(this), collateral_amount);\n        FRAX.pool_mint(msg.sender, mint_amount);\n    }",
        "comments": [
            "",
            "    // Will fail if fully collateralized or fully algorithmic",
            "    // > 0% and < 100% collateral-backed",
            "    "
        ],
        "comt": "\n    // Will fail if fully collateralized or fully algorithmic\n    // > 0% and < 100% collateral-backed\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "redeem1t1FRAX",
        "visibility": "external",
        "args": [
            {
                "name": "FRAX_amount",
                "type": "uint256"
            },
            {
                "name": "COLLATERAL_out_min",
                "type": "uint256"
            }
        ],
        "func": "function redeem1t1FRAX(uint256 FRAX_amount, uint256 COLLATERAL_out_min) external notRedeemPaused {\n        uint256 global_collateral_ratio = FRAX.global_collateral_ratio();\n        require(global_collateral_ratio == COLLATERAL_RATIO_MAX, \"Collateral ratio must be == 1\");\n\n        // Need to adjust for decimals of collateral\n        uint256 FRAX_amount_precision = FRAX_amount.div(10 ** missing_decimals);\n        (uint256 collateral_needed) = FraxPoolLibrary.calcRedeem1t1FRAX(\n            getCollateralPrice(),\n            FRAX_amount_precision,\n            redemption_fee\n        );\n\n        require(collateral_needed <= collateral_token.balanceOf(address(this)).sub(unclaimedPoolCollateral), \"Not enough collateral in pool\");\n\n        redeemCollateralBalances[msg.sender] = redeemCollateralBalances[msg.sender].add(collateral_needed);\n        unclaimedPoolCollateral = unclaimedPoolCollateral.add(collateral_needed);\n        lastRedeemed[msg.sender] = block.number;\n\n        require(COLLATERAL_out_min <= collateral_needed, \"Slippage limit reached\");\n        \n        // Move all external functions to the end\n        FRAX.pool_burn_from(msg.sender, FRAX_amount);\n    }",
        "comments": [
            "",
            "    // Redeem collateral. 100% collateral-backed",
            "    "
        ],
        "comt": "\n    // Redeem collateral. 100% collateral-backed\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "redeemFractionalFRAX",
        "visibility": "external",
        "args": [
            {
                "name": "FRAX_amount",
                "type": "uint256"
            },
            {
                "name": "FXS_out_min",
                "type": "uint256"
            },
            {
                "name": "COLLATERAL_out_min",
                "type": "uint256"
            }
        ],
        "func": "function redeemFractionalFRAX(uint256 FRAX_amount, uint256 FXS_out_min, uint256 COLLATERAL_out_min) external notRedeemPaused {\n        uint256 fxs_price = FRAX.fxs_price();\n        uint256 global_collateral_ratio = FRAX.global_collateral_ratio();\n\n        require(global_collateral_ratio < COLLATERAL_RATIO_MAX && global_collateral_ratio > 0, \"Collateral ratio needs to be between .000001 and .999999\");\n        uint256 col_price_usd = getCollateralPrice();\n\n        uint256 FRAX_amount_post_fee = FRAX_amount.sub((FRAX_amount.mul(redemption_fee)).div(PRICE_PRECISION));\n        uint256 fxs_dollar_value_d18 = FRAX_amount_post_fee.sub(FRAX_amount_post_fee.mul(global_collateral_ratio).div(PRICE_PRECISION));\n        uint256 fxs_amount = fxs_dollar_value_d18.mul(PRICE_PRECISION).div(fxs_price);\n\n        // Need to adjust for decimals of collateral\n        uint256 FRAX_amount_precision = FRAX_amount_post_fee.div(10 ** missing_decimals);\n        uint256 collateral_dollar_value = FRAX_amount_precision.mul(global_collateral_ratio).div(PRICE_PRECISION);\n        uint256 collateral_amount = collateral_dollar_value.mul(PRICE_PRECISION).div(col_price_usd);\n\n        redeemCollateralBalances[msg.sender] = redeemCollateralBalances[msg.sender].add(collateral_amount);\n        unclaimedPoolCollateral = unclaimedPoolCollateral.add(collateral_amount);\n\n        redeemFXSBalances[msg.sender] = redeemFXSBalances[msg.sender].add(fxs_amount);\n        unclaimedPoolFXS = unclaimedPoolFXS.add(fxs_amount);\n\n        lastRedeemed[msg.sender] = block.number;\n\n        require(collateral_amount <= collateral_token.balanceOf(address(this)).sub(unclaimedPoolCollateral), \"Not enough collateral in pool\");\n        require(COLLATERAL_out_min <= collateral_amount, \"Slippage limit reached [collateral]\");\n        require(FXS_out_min <= fxs_amount, \"Slippage limit reached [FXS]\");\n        \n        // Move all external functions to the end\n        FRAX.pool_burn_from(msg.sender, FRAX_amount);\n        FXS.pool_mint(address(this), fxs_amount);\n    }",
        "comments": [
            "",
            "    // Will fail if fully collateralized or algorithmic",
            "    // Redeem FRAX for collateral and FXS. > 0% and < 100% collateral-backed",
            "    "
        ],
        "comt": "\n    // Will fail if fully collateralized or algorithmic\n    // Redeem FRAX for collateral and FXS. > 0% and < 100% collateral-backed\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "redeemAlgorithmicFRAX",
        "visibility": "external",
        "args": [
            {
                "name": "FRAX_amount",
                "type": "uint256"
            },
            {
                "name": "FXS_out_min",
                "type": "uint256"
            }
        ],
        "func": "function redeemAlgorithmicFRAX(uint256 FRAX_amount, uint256 FXS_out_min) external notRedeemPaused {\n        uint256 fxs_price = FRAX.fxs_price();\n        uint256 global_collateral_ratio = FRAX.global_collateral_ratio();\n\n        require(global_collateral_ratio == 0, \"Collateral ratio must be 0\"); \n        uint256 fxs_dollar_value_d18 = FRAX_amount;\n        fxs_dollar_value_d18 = fxs_dollar_value_d18.sub((fxs_dollar_value_d18.mul(redemption_fee)).div(PRICE_PRECISION)); //apply redemption fee\n\n        uint256 fxs_amount = fxs_dollar_value_d18.mul(PRICE_PRECISION).div(fxs_price);\n        \n        redeemFXSBalances[msg.sender] = redeemFXSBalances[msg.sender].add(fxs_amount);\n        unclaimedPoolFXS = unclaimedPoolFXS.add(fxs_amount);\n        \n        lastRedeemed[msg.sender] = block.number;\n        \n        require(FXS_out_min <= fxs_amount, \"Slippage limit reached\");\n        // Move all external functions to the end\n        FRAX.pool_burn_from(msg.sender, FRAX_amount);\n        FXS.pool_mint(address(this), fxs_amount);\n    }",
        "comments": [
            "",
            "    // Redeem FRAX for FXS. 0% collateral-backed",
            "    "
        ],
        "comt": "\n    // Redeem FRAX for FXS. 0% collateral-backed\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "collectRedemption",
        "visibility": "external",
        "args": [],
        "func": "function collectRedemption() external {\n        require((lastRedeemed[msg.sender].add(redemption_delay)) <= block.number, \"Must wait for redemption_delay blocks before collecting redemption\");\n        bool sendFXS = false;\n        bool sendCollateral = false;\n        uint FXSAmount;\n        uint CollateralAmount;\n\n        // Use Checks-Effects-Interactions pattern\n        if(redeemFXSBalances[msg.sender] > 0){\n            FXSAmount = redeemFXSBalances[msg.sender];\n            redeemFXSBalances[msg.sender] = 0;\n            unclaimedPoolFXS = unclaimedPoolFXS.sub(FXSAmount);\n\n            sendFXS = true;\n        }\n        \n        if(redeemCollateralBalances[msg.sender] > 0){\n            CollateralAmount = redeemCollateralBalances[msg.sender];\n            redeemCollateralBalances[msg.sender] = 0;\n            unclaimedPoolCollateral = unclaimedPoolCollateral.sub(CollateralAmount);\n\n            sendCollateral = true;\n        }\n\n        if(sendFXS == true){\n            FXS.transfer(msg.sender, FXSAmount);\n        }\n        if(sendCollateral == true){\n            collateral_token.transfer(msg.sender, CollateralAmount);\n        }\n    }",
        "comments": [
            "",
            "    // After a redemption happens, transfer the newly minted FXS and owed collateral from this pool",
            "    // contract to the user. Redemption is split into two functions to prevent flash loans from being able",
            "    // to take out FRAX/collateral from the system, use an AMM to trade the new price, and then mint back into the system.",
            "    "
        ],
        "comt": "\n    // After a redemption happens, transfer the newly minted FXS and owed collateral from this pool\n    // contract to the user. Redemption is split into two functions to prevent flash loans from being able\n    // to take out FRAX/collateral from the system, use an AMM to trade the new price, and then mint back into the system.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "recollateralizeFRAX",
        "visibility": "external",
        "args": [
            {
                "name": "collateral_amount",
                "type": "uint256"
            },
            {
                "name": "FXS_out_min",
                "type": "uint256"
            }
        ],
        "func": "function recollateralizeFRAX(uint256 collateral_amount, uint256 FXS_out_min) external {\n        require(recollateralizePaused == false, \"Recollateralize is paused\");\n        uint256 collateral_amount_d18 = collateral_amount * (10 ** missing_decimals);\n        uint256 fxs_price = FRAX.fxs_price();\n        uint256 frax_total_supply = FRAX.totalSupply();\n        uint256 global_collateral_ratio = FRAX.global_collateral_ratio();\n        uint256 global_collat_value = FRAX.globalCollateralValue();\n        \n        (uint256 collateral_units, uint256 amount_to_recollat) = FraxPoolLibrary.calcRecollateralizeFRAXInner(\n            collateral_amount_d18,\n            getCollateralPrice(),\n            global_collat_value,\n            frax_total_supply,\n            global_collateral_ratio\n        ); \n\n        uint256 collateral_units_precision = collateral_units.div(10 ** missing_decimals);\n\n        uint256 fxs_paid_back = amount_to_recollat.mul(uint(1e6).add(bonus_rate)).div(fxs_price);\n\n        require(FXS_out_min <= fxs_paid_back, \"Slippage limit reached\");\n        collateral_token.transferFrom(msg.sender, address(this), collateral_units_precision);\n        FXS.pool_mint(msg.sender, fxs_paid_back);\n        \n    }",
        "comments": [
            "",
            "",
            "    // When the protocol is recollateralizing, we need to give a discount of FXS to hit the new CR target",
            "    // Thus, if the target collateral ratio is higher than the actual value of collateral, minters get FXS for adding collateral",
            "    // This function simply rewards anyone that sends collateral to a pool with the same amount of FXS + the bonus rate",
            "    // Anyone can call this function to recollateralize the protocol and take the extra FXS value from the bonus rate as an arb opportunity",
            "    "
        ],
        "comt": "\n\n    // When the protocol is recollateralizing, we need to give a discount of FXS to hit the new CR target\n    // Thus, if the target collateral ratio is higher than the actual value of collateral, minters get FXS for adding collateral\n    // This function simply rewards anyone that sends collateral to a pool with the same amount of FXS + the bonus rate\n    // Anyone can call this function to recollateralize the protocol and take the extra FXS value from the bonus rate as an arb opportunity\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "buyBackFXS",
        "visibility": "external",
        "args": [
            {
                "name": "FXS_amount",
                "type": "uint256"
            },
            {
                "name": "COLLATERAL_out_min",
                "type": "uint256"
            }
        ],
        "func": "function buyBackFXS(uint256 FXS_amount, uint256 COLLATERAL_out_min) external {\n        require(buyBackPaused == false, \"Buyback is paused\");\n        uint256 fxs_price = FRAX.fxs_price();\n        \n        FraxPoolLibrary.BuybackFXS_Params memory input_params = FraxPoolLibrary.BuybackFXS_Params(\n            availableExcessCollatDV(),\n            fxs_price,\n            getCollateralPrice(),\n            FXS_amount\n        );\n\n        (uint256 collateral_equivalent_d18) = FraxPoolLibrary.calcBuyBackFXS(input_params);\n        uint256 collateral_precision = collateral_equivalent_d18.div(10 ** missing_decimals);\n\n        require(COLLATERAL_out_min <= collateral_precision, \"Slippage limit reached\");\n        // Give the sender their desired collateral and burn the FXS\n        FXS.pool_burn_from(msg.sender, FXS_amount);\n        collateral_token.transfer(msg.sender, collateral_precision);\n    }",
        "comments": [
            "",
            "    // Function can be called by an FXS holder to have the protocol buy back FXS with excess collateral value from a desired collateral pool",
            "    // This can also happen if the collateral ratio > 1",
            "    "
        ],
        "comt": "\n    // Function can be called by an FXS holder to have the protocol buy back FXS with excess collateral value from a desired collateral pool\n    // This can also happen if the collateral ratio > 1\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "toggleMinting",
        "visibility": "external",
        "args": [],
        "func": "function toggleMinting() external {\n        require(hasRole(MINT_PAUSER, msg.sender));\n        mintPaused = !mintPaused;\n    }",
        "comments": [
            "/* ========== RESTRICTED FUNCTIONS ========== */",
            ""
        ],
        "comt": "/* ========== RESTRICTED FUNCTIONS ========== */\n",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "toggleRedeeming",
        "visibility": "external",
        "args": [],
        "func": "function toggleRedeeming() external {\n        require(hasRole(REDEEM_PAUSER, msg.sender));\n        redeemPaused = !redeemPaused;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "toggleRecollateralize",
        "visibility": "external",
        "args": [],
        "func": "function toggleRecollateralize() external {\n        require(hasRole(RECOLLATERALIZE_PAUSER, msg.sender));\n        recollateralizePaused = !recollateralizePaused;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "toggleBuyBack",
        "visibility": "external",
        "args": [],
        "func": "function toggleBuyBack() external {\n        require(hasRole(BUYBACK_PAUSER, msg.sender));\n        buyBackPaused = !buyBackPaused;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "toggleCollateralPrice",
        "visibility": "external",
        "args": [],
        "func": "function toggleCollateralPrice() external {\n        require(hasRole(COLLATERAL_PRICE_PAUSER, msg.sender));\n        // If pausing, set paused price; else if unpausing, clear pausedPrice\n        if(collateralPricePaused == false){\n            pausedPrice = getCollateralPrice();\n        } else {\n            pausedPrice = 0;\n        }\n        collateralPricePaused = !collateralPricePaused;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setPoolParameters",
        "visibility": "external",
        "args": [
            {
                "name": "new_ceiling",
                "type": "uint256"
            },
            {
                "name": "new_bonus_rate",
                "type": "uint256"
            },
            {
                "name": "new_redemption_delay",
                "type": "uint256"
            }
        ],
        "func": "function setPoolParameters(uint256 new_ceiling, uint256 new_bonus_rate, uint256 new_redemption_delay) external onlyByOwnerOrGovernance {\n        pool_ceiling = new_ceiling;\n        bonus_rate = new_bonus_rate;\n        redemption_delay = new_redemption_delay;\n        minting_fee = FRAX.minting_fee();\n        redemption_fee = FRAX.redemption_fee();\n    }",
        "comments": [
            "",
            "    // Combined into one function due to 24KiB contract memory limit",
            "    "
        ],
        "comt": "\n    // Combined into one function due to 24KiB contract memory limit\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setTimelock",
        "visibility": "external",
        "args": [
            {
                "name": "new_timelock",
                "type": "address"
            }
        ],
        "func": "function setTimelock(address new_timelock) external onlyByOwnerOrGovernance {\n        timelock_address = new_timelock;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setOwner",
        "visibility": "external",
        "args": [
            {
                "name": "_owner_address",
                "type": "address"
            }
        ],
        "func": "function setOwner(address _owner_address) external onlyByOwnerOrGovernance {\n        owner_address = _owner_address;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "calcMint1t1FRAX",
        "visibility": "public",
        "args": [
            {
                "name": "col_price",
                "type": "uint256"
            },
            {
                "name": "mint_fee",
                "type": "uint256"
            },
            {
                "name": "collateral_amount_d18",
                "type": "uint256"
            }
        ],
        "func": "function calcMint1t1FRAX(uint256 col_price, uint256 mint_fee, uint256 collateral_amount_d18) public pure returns (uint256) {\n        uint256 col_price_usd = col_price;\n        uint256 c_dollar_value_d18 = (collateral_amount_d18.mul(col_price_usd)).div(1e6);\n        return c_dollar_value_d18.sub((c_dollar_value_d18.mul(mint_fee)).div(1e6));\n    }",
        "comments": [
            "",
            "    // ================ Functions ================",
            "",
            "    "
        ],
        "comt": "\n    // ================ Functions ================\n\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "calcMintAlgorithmicFRAX",
        "visibility": "public",
        "args": [
            {
                "name": "mint_fee",
                "type": "uint256"
            },
            {
                "name": "fxs_price_usd",
                "type": "uint256"
            },
            {
                "name": "fxs_amount_d18",
                "type": "uint256"
            }
        ],
        "func": "function calcMintAlgorithmicFRAX(uint256 mint_fee, uint256 fxs_price_usd, uint256 fxs_amount_d18) public pure returns (uint256) {\n        uint256 fxs_dollar_value_d18 = fxs_amount_d18.mul(fxs_price_usd).div(1e6);\n        return fxs_dollar_value_d18.sub((fxs_dollar_value_d18.mul(mint_fee)).div(1e6));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "calcRedeem1t1FRAX",
        "visibility": "public",
        "args": [
            {
                "name": "col_price_usd",
                "type": "uint256"
            },
            {
                "name": "FRAX_amount",
                "type": "uint256"
            },
            {
                "name": "redemption_fee",
                "type": "uint256"
            }
        ],
        "func": "function calcRedeem1t1FRAX(uint256 col_price_usd, uint256 FRAX_amount, uint256 redemption_fee) public pure returns (uint256) {\n        uint256 collateral_needed_d18 = FRAX_amount.mul(1e6).div(col_price_usd);\n        return collateral_needed_d18.sub((collateral_needed_d18.mul(redemption_fee)).div(1e6));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "recollateralizeAmount",
        "visibility": "public",
        "args": [
            {
                "name": "total_supply",
                "type": "uint256"
            },
            {
                "name": "global_collateral_ratio",
                "type": "uint256"
            },
            {
                "name": "global_collat_value",
                "type": "uint256"
            }
        ],
        "func": "function recollateralizeAmount(uint256 total_supply, uint256 global_collateral_ratio, uint256 global_collat_value) public pure returns (uint256) {\n        uint256 target_collat_value = total_supply.mul(global_collateral_ratio).div(1e6); // We want 18 decimals of precision so divide by 1e6; total_supply is 1e18 and global_collateral_ratio is 1e6\n        // Subtract the current value of collateral from the target value needed, if higher than 0 then system needs to recollateralize\n        uint256 recollateralization_left = target_collat_value.sub(global_collat_value); // If recollateralization is not needed, throws a subtraction underflow\n        return(recollateralization_left);\n    }",
        "comments": [
            "",
            "",
            "    // Returns value of collateral that must increase to reach recollateralization target (if 0 means no recollateralization)",
            "    "
        ],
        "comt": "\n\n    // Returns value of collateral that must increase to reach recollateralization target (if 0 means no recollateralization)\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "calcRecollateralizeFRAXInner",
        "visibility": "public",
        "args": [
            {
                "name": "collateral_amount",
                "type": "uint256"
            },
            {
                "name": "col_price",
                "type": "uint256"
            },
            {
                "name": "global_collat_value",
                "type": "uint256"
            },
            {
                "name": "frax_total_supply",
                "type": "uint256"
            },
            {
                "name": "global_collateral_ratio",
                "type": "uint256"
            }
        ],
        "func": "function calcRecollateralizeFRAXInner(\n        uint256 collateral_amount, \n        uint256 col_price,\n        uint256 global_collat_value,\n        uint256 frax_total_supply,\n        uint256 global_collateral_ratio\n    ) public pure returns (uint256, uint256) {\n        uint256 collat_value_attempted = collateral_amount.mul(col_price).div(1e6);\n        uint256 effective_collateral_ratio = global_collat_value.mul(1e6).div(frax_total_supply); //returns it in 1e6\n        uint256 recollat_possible = (global_collateral_ratio.mul(frax_total_supply).sub(frax_total_supply.mul(effective_collateral_ratio))).div(1e6);\n\n        uint256 amount_to_recollat;\n        if(collat_value_attempted <= recollat_possible){\n            amount_to_recollat = collat_value_attempted;\n        } else {\n            amount_to_recollat = recollat_possible;\n        }\n\n        return (amount_to_recollat.mul(1e6).div(col_price), amount_to_recollat);\n\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setOracle",
        "visibility": "external",
        "args": [
            {
                "name": "new_oracle",
                "type": "address"
            }
        ],
        "func": "function setOracle(address new_oracle) external onlyByOwnerOrGovernance {\n        oracle_address = new_oracle;\n    }",
        "comments": [
            "/* ========== RESTRICTED FUNCTIONS ========== */",
            ""
        ],
        "comt": "/* ========== RESTRICTED FUNCTIONS ========== */\n",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setTimelock",
        "visibility": "external",
        "args": [
            {
                "name": "new_timelock",
                "type": "address"
            }
        ],
        "func": "function setTimelock(address new_timelock) external onlyByOwnerOrGovernance {\n        timelock_address = new_timelock;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setFRAXAddress",
        "visibility": "external",
        "args": [
            {
                "name": "frax_contract_address",
                "type": "address"
            }
        ],
        "func": "function setFRAXAddress(address frax_contract_address) external onlyByOwnerOrGovernance {\n        FRAX = FRAXStablecoin(frax_contract_address);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setFXSMinDAO",
        "visibility": "external",
        "args": [
            {
                "name": "min_FXS",
                "type": "uint256"
            }
        ],
        "func": "function setFXSMinDAO(uint256 min_FXS) external onlyByOwnerOrGovernance {\n        FXS_DAO_min = min_FXS;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setOwner",
        "visibility": "external",
        "args": [
            {
                "name": "_owner_address",
                "type": "address"
            }
        ],
        "func": "function setOwner(address _owner_address) external onlyByOwnerOrGovernance {\n        owner_address = _owner_address;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "public",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function mint(address to, uint256 amount) public onlyPools {\n        _mint(to, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "pool_mint",
        "visibility": "external",
        "args": [
            {
                "name": "m_address",
                "type": "address"
            },
            {
                "name": "m_amount",
                "type": "uint256"
            }
        ],
        "func": "function pool_mint(address m_address, uint256 m_amount) external onlyPools {        \n        if(trackingVotes){\n            uint32 srcRepNum = numCheckpoints[address(this)];\n            uint96 srcRepOld = srcRepNum > 0 ? checkpoints[address(this)][srcRepNum - 1].votes : 0;\n            uint96 srcRepNew = add96(srcRepOld, uint96(m_amount), \"pool_mint new votes overflows\");\n            _writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew); // mint new votes\n            trackVotes(address(this), m_address, uint96(m_amount));\n        }\n\n        super._mint(m_address, m_amount);\n        emit FXSMinted(address(this), m_address, m_amount);\n    }",
        "comments": [
            "    ",
            "    // This function is what other frax pools will call to mint new FXS (similar to the FRAX mint) ",
            "    "
        ],
        "comt": "    \n    // This function is what other frax pools will call to mint new FXS (similar to the FRAX mint) \n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "pool_burn_from",
        "visibility": "external",
        "args": [
            {
                "name": "b_address",
                "type": "address"
            },
            {
                "name": "b_amount",
                "type": "uint256"
            }
        ],
        "func": "function pool_burn_from(address b_address, uint256 b_amount) external onlyPools {\n        if(trackingVotes){\n            trackVotes(b_address, address(this), uint96(b_amount));\n            uint32 srcRepNum = numCheckpoints[address(this)];\n            uint96 srcRepOld = srcRepNum > 0 ? checkpoints[address(this)][srcRepNum - 1].votes : 0;\n            uint96 srcRepNew = sub96(srcRepOld, uint96(b_amount), \"pool_burn_from new votes underflows\");\n            _writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew); // burn votes\n        }\n\n        super._burnFrom(b_address, b_amount);\n        emit FXSBurned(b_address, address(this), b_amount);\n    }",
        "comments": [
            "",
            "    // This function is what other frax pools will call to burn FXS ",
            "    "
        ],
        "comt": "\n    // This function is what other frax pools will call to burn FXS \n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "toggleVotes",
        "visibility": "external",
        "args": [],
        "func": "function toggleVotes() external onlyByOwnerOrGovernance {\n        trackingVotes = !trackingVotes;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        if(trackingVotes){\n            // Transfer votes\n            trackVotes(_msgSender(), recipient, uint96(amount));\n        }\n\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }",
        "comments": [
            "/* ========== OVERRIDDEN PUBLIC FUNCTIONS ========== */",
            ""
        ],
        "comt": "/* ========== OVERRIDDEN PUBLIC FUNCTIONS ========== */\n",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        if(trackingVotes){\n            // Transfer votes\n            trackVotes(sender, recipient, uint96(amount));\n        }\n\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentVotes",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function getCurrentVotes(address account) external view returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }",
        "comments": [
            "/**",
            "     * @notice Gets the current votes balance for `account`",
            "     * @param account The address to get votes balance",
            "     * @return The number of current votes for `account`",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n",
        "@notice": "Gets the current votes balance for `account`",
        "@param1": "account The address to get votes balance",
        "@return1": "The number of current votes for `account`",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPriorVotes",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            },
            {
                "name": "blockNumber",
                "type": "uint"
            }
        ],
        "func": "function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\n        require(blockNumber < block.number, \"FXS::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }",
        "comments": [
            "/**",
            "     * @notice Determine the prior number of votes for an account as of a block number",
            "     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.",
            "     * @param account The address of the account to check",
            "     * @param blockNumber The block number to get the vote balance at",
            "     * @return The number of votes the account had as of the given block",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n",
        "@notice": "Determine the prior number of votes for an account as of a block number",
        "@dev": "Block number must be a finalized block or else this function will revert to prevent misinformation.",
        "@param1": "account The address of the account to check",
        "@param2": "blockNumber The block number to get the vote balance at",
        "@return1": "The number of votes the account had as of the given block",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "quorumVotes",
        "visibility": "public",
        "args": [],
        "func": "function quorumVotes() public pure returns (uint) { return 4000000e18; }",
        "comments": [
            "",
            "    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed",
            "    "
        ],
        "comt": "\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    ",
        "@notice": "The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "proposalThreshold",
        "visibility": "public",
        "args": [],
        "func": "function proposalThreshold() public pure returns (uint) { return 1000000e18; }",
        "comments": [
            "// 4,000,000 = 4% of FXS",
            "",
            "    /// @notice The number of votes required in order for a voter to become a proposer",
            "    "
        ],
        "comt": "// 4,000,000 = 4% of FXS\n\n    /// @notice The number of votes required in order for a voter to become a proposer\n    ",
        "@notice": "The number of votes required in order for a voter to become a proposer",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "proposalMaxOperations",
        "visibility": "public",
        "args": [],
        "func": "function proposalMaxOperations() public pure returns (uint) { return 10; }",
        "comments": [
            "// 1,000,000 = 1% of FXS",
            "",
            "    /// @notice The maximum number of actions that can be included in a proposal",
            "    "
        ],
        "comt": "// 1,000,000 = 1% of FXS\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    ",
        "@notice": "The maximum number of actions that can be included in a proposal",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "votingDelay",
        "visibility": "public",
        "args": [],
        "func": "function votingDelay() public pure returns (uint) { return 1; }",
        "comments": [
            "// 10 actions",
            "",
            "    /// @notice The delay before voting on a proposal may take place, once proposed",
            "    // This also helps protect against flash loan attacks because only the vote balance at the proposal start block is considered",
            "    "
        ],
        "comt": "// 10 actions\n\n    /// @notice The delay before voting on a proposal may take place, once proposed\n    // This also helps protect against flash loan attacks because only the vote balance at the proposal start block is considered\n    ",
        "@notice": "The delay before voting on a proposal may take place, once proposed // This also helps protect against flash loan attacks because only the vote balance at the proposal start block is considered",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 1
    },
    {
        "name": "votingPeriod",
        "visibility": "public",
        "args": [],
        "func": "function votingPeriod() public pure returns (uint) { return 17280; }",
        "comments": [
            "// 1 block",
            "",
            "    /// @notice The duration of voting on a proposal, in blocks",
            "    // "
        ],
        "comt": "// 1 block\n\n    /// @notice The duration of voting on a proposal, in blocks\n    // ",
        "@notice": "The duration of voting on a proposal, in blocks",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "propose",
        "visibility": "public",
        "args": [
            {
                "name": "targets",
                "type": "address[] memory"
            },
            {
                "name": "values",
                "type": "uint[] memory"
            },
            {
                "name": "signatures",
                "type": "string[] memory"
            },
            {
                "name": "calldatas",
                "type": "bytes[] memory"
            },
            {
                "name": "title",
                "type": "string memory"
            },
            {
                "name": "description",
                "type": "string memory"
            }
        ],
        "func": "function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory title, string memory description) public returns (uint) {\n        require(fxs.getPriorVotes(msg.sender, sub256(block.number, 1)) >= proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n          ProposalState proposersLatestProposalState = state(latestProposalId);\n          require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n          require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n        }\n\n        uint startBlock = add256(block.number, votingDelay());\n        uint endBlock = add256(startBlock, votingPeriod);\n\n        proposalCount++;\n        Proposal memory newProposal = Proposal({\n            id: proposalCount,\n            proposer: msg.sender,\n            eta: 0,\n            targets: targets,\n            values: values,\n            signatures: signatures,\n            calldatas: calldatas,\n            startBlock: startBlock,\n            endBlock: endBlock,\n            forVotes: 0,\n            againstVotes: 0,\n            canceled: false,\n            executed: false,\n            title: title,\n            description: description\n        });\n\n        proposals[newProposal.id] = newProposal;\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n        return newProposal.id;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "queue",
        "visibility": "public",
        "args": [
            {
                "name": "proposalId",
                "type": "uint"
            }
        ],
        "func": "function queue(uint proposalId) public {\n        require(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it succeeded\");\n        Proposal storage proposal = proposals[proposalId];\n        uint eta = add256(block.timestamp, timelock.delay());\n        for (uint i = 0; i < proposal.targets.length; i++) {\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "execute",
        "visibility": "public",
        "args": [
            {
                "name": "proposalId",
                "type": "uint"
            }
        ],
        "func": "function execute(uint proposalId) public payable {\n        require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        }\n        emit ProposalExecuted(proposalId);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cancel",
        "visibility": "public",
        "args": [
            {
                "name": "proposalId",
                "type": "uint"
            }
        ],
        "func": "function cancel(uint proposalId) public {\n        ProposalState state = state(proposalId);\n        require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n\n        Proposal storage proposal = proposals[proposalId];\n        require(msg.sender == guardian || fxs.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(), \"GovernorAlpha::cancel: proposer at or above threshold\");\n\n        proposal.canceled = true;\n        for (uint i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        }\n\n        emit ProposalCanceled(proposalId);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getActions",
        "visibility": "public",
        "args": [
            {
                "name": "proposalId",
                "type": "uint"
            }
        ],
        "func": "function getActions(uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getReceipt",
        "visibility": "public",
        "args": [
            {
                "name": "proposalId",
                "type": "uint"
            },
            {
                "name": "voter",
                "type": "address"
            }
        ],
        "func": "function getReceipt(uint proposalId, address voter) public view returns (Receipt memory) {\n        return proposals[proposalId].receipts[voter];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "state",
        "visibility": "public",
        "args": [
            {
                "name": "proposalId",
                "type": "uint"
            }
        ],
        "func": "function state(uint proposalId) public view returns (ProposalState) {\n        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\n            return ProposalState.Defeated;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Succeeded;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "castVote",
        "visibility": "public",
        "args": [
            {
                "name": "proposalId",
                "type": "uint"
            },
            {
                "name": "support",
                "type": "bool"
            }
        ],
        "func": "function castVote(uint proposalId, bool support) public {\n        return _castVote(msg.sender, proposalId, support);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "castVoteBySig",
        "visibility": "public",
        "args": [
            {
                "name": "proposalId",
                "type": "uint"
            },
            {
                "name": "support",
                "type": "bool"
            },
            {
                "name": "v",
                "type": "uint8"
            },
            {
                "name": "r",
                "type": "bytes32"
            },
            {
                "name": "s",
                "type": "bytes32"
            }
        ],
        "func": "function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public {\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\n        return _castVote(signatory, proposalId, support);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "__acceptAdmin",
        "visibility": "public",
        "args": [],
        "func": "function __acceptAdmin() public {\n        require(msg.sender == guardian, \"GovernorAlpha::__acceptAdmin: sender must be gov guardian\");\n        timelock.acceptAdmin();\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "__abdicate",
        "visibility": "public",
        "args": [],
        "func": "function __abdicate() public {\n        require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n        guardian = address(0);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "__setVotingPeriod",
        "visibility": "public",
        "args": [
            {
                "name": "period",
                "type": "uint"
            }
        ],
        "func": "function __setVotingPeriod(uint period) public {\n        require(msg.sender == guardian, \"GovernorAlpha::__setVotingPeriod: sender must be gov guardian\");\n        votingPeriod = period;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "__setTimelockAddress",
        "visibility": "public",
        "args": [
            {
                "name": "timelock_",
                "type": "address"
            }
        ],
        "func": "function __setTimelockAddress(address timelock_) public {\n        require(msg.sender == guardian, \"GovernorAlpha::__setTimelockAddress: sender must be gov guardian\");\n        timelock = TimelockInterface(timelock_);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "__queueSetTimelockPendingAdmin",
        "visibility": "public",
        "args": [
            {
                "name": "newPendingAdmin",
                "type": "address"
            },
            {
                "name": "eta",
                "type": "uint"
            }
        ],
        "func": "function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\n        require(msg.sender == guardian, \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\n        timelock.queueTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "__executeSetTimelockPendingAdmin",
        "visibility": "public",
        "args": [
            {
                "name": "newPendingAdmin",
                "type": "address"
            },
            {
                "name": "eta",
                "type": "uint"
            }
        ],
        "func": "function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\n        require(msg.sender == guardian, \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\n        timelock.executeTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setGovToTimeLockETA",
        "visibility": "public",
        "args": [
            {
                "name": "_eta",
                "type": "uint256"
            }
        ],
        "func": "function setGovToTimeLockETA(uint256 _eta) public restricted {\n    gov_to_timelock_eta = _eta;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setCompleted",
        "visibility": "public",
        "args": [
            {
                "name": "completed",
                "type": "uint"
            }
        ],
        "func": "function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "nominateNewOwner",
        "visibility": "external",
        "args": [
            {
                "name": "_owner",
                "type": "address"
            }
        ],
        "func": "function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "acceptOwnership",
        "visibility": "external",
        "args": [],
        "func": "function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setPaused",
        "visibility": "external",
        "args": [
            {
                "name": "_paused",
                "type": "bool"
            }
        ],
        "func": "function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = now;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }",
        "comments": [
            "/**",
            "     * @notice Change the paused state of the contract",
            "     * @dev Only the contract owner may call this.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n",
        "@notice": "Change the paused state of the contract",
        "@dev": "Only the contract owner may call this.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setRewardsDistribution",
        "visibility": "external",
        "args": [
            {
                "name": "_rewardsDistribution",
                "type": "address"
            }
        ],
        "func": "function setRewardsDistribution(address _rewardsDistribution) external onlyOwner {\n        rewardsDistribution = _rewardsDistribution;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "external",
        "args": [],
        "func": "function totalSupply() external override view returns (uint256) {\n        return _staking_token_supply;\n    }",
        "comments": [
            "/* ========== VIEWS ========== */",
            ""
        ],
        "comt": "/* ========== VIEWS ========== */\n",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalBoostedSupply",
        "visibility": "external",
        "args": [],
        "func": "function totalBoostedSupply() external view returns (uint256) {\n        return _staking_token_boosted_supply;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stakingMultiplier",
        "visibility": "public",
        "args": [
            {
                "name": "secs",
                "type": "uint256"
            }
        ],
        "func": "function stakingMultiplier(uint256 secs) public view returns (uint256) {\n        uint256 multiplier = uint(MULTIPLIER_BASE).add(secs.mul(locked_stake_max_multiplier.sub(MULTIPLIER_BASE)).div(locked_stake_time_for_max_multiplier));\n        if (multiplier > locked_stake_max_multiplier) multiplier = locked_stake_max_multiplier;\n        return multiplier;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "crBoostMultiplier",
        "visibility": "public",
        "args": [],
        "func": "function crBoostMultiplier() public view returns (uint256) {\n        uint256 multiplier = uint(MULTIPLIER_BASE).add((uint(MULTIPLIER_BASE).sub(FRAX.global_collateral_ratio())).mul(cr_boost_max_multiplier.sub(MULTIPLIER_BASE)).div(MULTIPLIER_BASE) );\n        return multiplier;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address account) external override view returns (uint256) {\n        return (_unlocked_balances[account]).add(_locked_balances[account]);\n    }",
        "comments": [
            "",
            "    // Total unlocked and locked liquidity tokens",
            "    "
        ],
        "comt": "\n    // Total unlocked and locked liquidity tokens\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unlockedBalanceOf",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function unlockedBalanceOf(address account) external view returns (uint256) {\n        return _unlocked_balances[account];\n    }",
        "comments": [
            "",
            "    // Total unlocked liquidity tokens",
            "    "
        ],
        "comt": "\n    // Total unlocked liquidity tokens\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lockedBalanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function lockedBalanceOf(address account) public view returns (uint256) {\n        return _locked_balances[account];\n    }",
        "comments": [
            "",
            "    // Total locked liquidity tokens",
            "    "
        ],
        "comt": "\n    // Total locked liquidity tokens\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "boostedBalanceOf",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function boostedBalanceOf(address account) external view returns (uint256) {\n        return _boosted_balances[account];\n    }",
        "comments": [
            "",
            "    // Total 'balance' used for calculating the percent of the pool the account owns",
            "    // Takes into account the locked stake time multiplier",
            "    "
        ],
        "comt": "\n    // Total 'balance' used for calculating the percent of the pool the account owns\n    // Takes into account the locked stake time multiplier\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lockedStakesOf",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function lockedStakesOf(address account) external view returns (LockedStake[] memory) {\n        return lockedStakes[account];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stakingDecimals",
        "visibility": "external",
        "args": [],
        "func": "function stakingDecimals() external view returns (uint256) {\n        return stakingToken.decimals();\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "rewardsFor",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function rewardsFor(address account) external view returns (uint256) {\n        // You may have use earned() instead, because of the order in which the contract executes \n        return rewards[account];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lastTimeRewardApplicable",
        "visibility": "public",
        "args": [],
        "func": "function lastTimeRewardApplicable() public override view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "rewardPerToken",
        "visibility": "public",
        "args": [],
        "func": "function rewardPerToken() public override view returns (uint256) {\n        if (_staking_token_supply == 0) {\n            return rewardPerTokenStored;\n        }\n        else {\n            return rewardPerTokenStored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(crBoostMultiplier()).mul(1e18).div(PRICE_PRECISION).div(_staking_token_boosted_supply)\n            );\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "earned",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function earned(address account) public override view returns (uint256) {\n        return _boosted_balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "earned",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function earned(address account) public override view returns (uint256) {\n    //     return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).add(rewards[account]);\n    // }",
        "comments": [
            "",
            "    // "
        ],
        "comt": "\n    // ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getRewardForDuration",
        "visibility": "external",
        "args": [],
        "func": "function getRewardForDuration() external override view returns (uint256) {\n        return rewardRate.mul(rewardsDuration).mul(crBoostMultiplier()).div(PRICE_PRECISION);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stake",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function stake(uint256 amount) external override nonReentrant notPaused updateReward(msg.sender) {\n        require(amount > 0, \"Cannot stake 0\");\n        require(greylist[msg.sender] == false, \"address has been greylisted\");\n\n        // Pull the tokens from the staker\n        TransferHelper.safeTransferFrom(address(stakingToken), msg.sender, address(this), amount);\n\n        // Staking token supply and boosted supply\n        _staking_token_supply = _staking_token_supply.add(amount);\n        _staking_token_boosted_supply = _staking_token_boosted_supply.add(amount);\n\n        // Staking token balance and boosted balance\n        _unlocked_balances[msg.sender] = _unlocked_balances[msg.sender].add(amount);\n        _boosted_balances[msg.sender] = _boosted_balances[msg.sender].add(amount);\n\n        emit Staked(msg.sender, amount);\n    }",
        "comments": [
            "/* ========== MUTATIVE FUNCTIONS ========== */",
            ""
        ],
        "comt": "/* ========== MUTATIVE FUNCTIONS ========== */\n",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stakeLocked",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            },
            {
                "name": "secs",
                "type": "uint256"
            }
        ],
        "func": "function stakeLocked(uint256 amount, uint256 secs) external nonReentrant notPaused updateReward(msg.sender) {\n        require(amount > 0, \"Cannot stake 0\");\n        require(secs > 0, \"Cannot wait for a negative number\");\n        require(greylist[msg.sender] == false, \"address has been greylisted\");\n        require(secs >= locked_stake_min_time, StringHelpers.strConcat(\"Minimum stake time not met (\", locked_stake_min_time_str, \")\") );\n\n        uint256 multiplier = stakingMultiplier(secs);\n        uint256 boostedAmount = amount.mul(multiplier).div(PRICE_PRECISION);\n        lockedStakes[msg.sender].push(LockedStake(\n            keccak256(abi.encodePacked(msg.sender, block.timestamp, amount)),\n            block.timestamp,\n            amount,\n            block.timestamp.add(secs),\n            multiplier\n        ));\n\n        // Pull the tokens from the staker\n        TransferHelper.safeTransferFrom(address(stakingToken), msg.sender, address(this), amount);\n\n        // Staking token supply and boosted supply\n        _staking_token_supply = _staking_token_supply.add(amount);\n        _staking_token_boosted_supply = _staking_token_boosted_supply.add(boostedAmount);\n\n        // Staking token balance and boosted balance\n        _locked_balances[msg.sender] = _locked_balances[msg.sender].add(amount);\n        _boosted_balances[msg.sender] = _boosted_balances[msg.sender].add(boostedAmount);\n\n        emit StakeLocked(msg.sender, amount, secs);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function withdraw(uint256 amount) public override nonReentrant updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n\n        // Staking token balance and boosted balance\n        _unlocked_balances[msg.sender] = _unlocked_balances[msg.sender].sub(amount);\n        _boosted_balances[msg.sender] = _boosted_balances[msg.sender].sub(amount);\n\n        // Staking token supply and boosted supply\n        _staking_token_supply = _staking_token_supply.sub(amount);\n        _staking_token_boosted_supply = _staking_token_boosted_supply.sub(amount);\n\n        // Give the tokens to the withdrawer\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawLocked",
        "visibility": "public",
        "args": [
            {
                "name": "kek_id",
                "type": "bytes32"
            }
        ],
        "func": "function withdrawLocked(bytes32 kek_id) public nonReentrant updateReward(msg.sender) {\n        LockedStake memory thisStake;\n        thisStake.amount = 0;\n        uint theIndex;\n        for (uint i = 0; i < lockedStakes[msg.sender].length; i++){ \n            if (kek_id == lockedStakes[msg.sender][i].kek_id){\n                thisStake = lockedStakes[msg.sender][i];\n                theIndex = i;\n                break;\n            }\n        }\n        require(thisStake.kek_id == kek_id, \"Stake not found\");\n        require(block.timestamp >= thisStake.ending_timestamp || unlockedStakes == true, \"Stake is still locked!\");\n\n        uint256 theAmount = thisStake.amount;\n        uint256 boostedAmount = theAmount.mul(thisStake.multiplier).div(PRICE_PRECISION);\n        if (theAmount > 0){\n            // Staking token balance and boosted balance\n            _locked_balances[msg.sender] = _locked_balances[msg.sender].sub(theAmount);\n            _boosted_balances[msg.sender] = _boosted_balances[msg.sender].sub(boostedAmount);\n\n            // Staking token supply and boosted supply\n            _staking_token_supply = _staking_token_supply.sub(theAmount);\n            _staking_token_boosted_supply = _staking_token_boosted_supply.sub(boostedAmount);\n\n            // Remove the stake from the array\n            delete lockedStakes[msg.sender][theIndex];\n\n            // Give the tokens to the withdrawer\n            stakingToken.safeTransfer(msg.sender, theAmount);\n\n            emit WithdrawnLocked(msg.sender, theAmount, kek_id);\n        }\n\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getReward",
        "visibility": "public",
        "args": [],
        "func": "function getReward() public override nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.transfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "exit",
        "visibility": "external",
        "args": [],
        "func": "function exit() external override {\n        withdraw(_balances[msg.sender]);\n\n        // TODO: Add locked stakes too?\n\n        getReward();\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "renewIfApplicable",
        "visibility": "external",
        "args": [],
        "func": "function renewIfApplicable() external {\n        if (block.timestamp > periodFinish) {\n            retroCatchUp();\n        }\n    }",
        "comments": [
            "/*",
            "    function exit() external override {",
            "        withdraw(_balances[msg.sender]);",
            "",
            "        // TODO: Add locked stakes too?",
            "",
            "        getReward();",
            "    }",
            "*/",
            ""
        ],
        "comt": "/*\n    function exit() external override {\n        withdraw(_balances[msg.sender]);\n\n        // TODO: Add locked stakes too?\n\n        getReward();\n    }\n*/\n",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "notifyRewardAmount",
        "visibility": "external",
        "args": [
            {
                "name": "reward",
                "type": "uint256"
            }
        ],
        "func": "function notifyRewardAmount(uint256 reward) external override onlyRewardsDistribution updateReward(address(0)) {\n        // Needed to make compiler happy\n\n        \n        // if (block.timestamp >= periodFinish) {\n        //     rewardRate = reward.mul(crBoostMultiplier()).div(rewardsDuration).div(PRICE_PRECISION);\n        // } else {\n        //     uint256 remaining = periodFinish.sub(block.timestamp);\n        //     uint256 leftover = remaining.mul(rewardRate);\n        //     rewardRate = reward.mul(crBoostMultiplier()).add(leftover).div(rewardsDuration).div(PRICE_PRECISION);\n        // }\n\n        // // Ensure the provided reward amount is not more than the balance in the contract.\n        // // This keeps the reward rate in the right range, preventing overflows due to\n        // // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        // uint balance = rewardsToken.balanceOf(address(this));\n        // require(rewardRate <= balance.div(rewardsDuration), \"Provided reward too high\");\n\n        // lastUpdateTime = block.timestamp;\n        // periodFinish = block.timestamp.add(rewardsDuration);\n        // emit RewardAdded(reward);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "recoverERC20",
        "visibility": "external",
        "args": [
            {
                "name": "tokenAddress",
                "type": "address"
            },
            {
                "name": "tokenAmount",
                "type": "uint256"
            }
        ],
        "func": "function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyByOwnerOrGovernance {\n        // Admin cannot withdraw the staking token from the contract\n        require(tokenAddress != address(stakingToken));\n        ERC20(tokenAddress).transfer(owner_address, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setRewardsDuration",
        "visibility": "external",
        "args": [
            {
                "name": "_rewardsDuration",
                "type": "uint256"
            }
        ],
        "func": "function setRewardsDuration(uint256 _rewardsDuration) external onlyByOwnerOrGovernance {\n        require(\n            periodFinish == 0 || block.timestamp > periodFinish,\n            \"Previous rewards period must be complete before changing the duration for the new period\"\n        );\n        rewardsDuration = _rewardsDuration;\n        emit RewardsDurationUpdated(rewardsDuration);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setMultipliers",
        "visibility": "external",
        "args": [
            {
                "name": "_locked_stake_max_multiplier",
                "type": "uint256"
            },
            {
                "name": "_cr_boost_max_multiplier",
                "type": "uint256"
            }
        ],
        "func": "function setMultipliers(uint256 _locked_stake_max_multiplier, uint256 _cr_boost_max_multiplier) external onlyByOwnerOrGovernance {\n        require(_locked_stake_max_multiplier >= 1, \"Multiplier must be greater than or equal to 1\");\n        require(_cr_boost_max_multiplier >= 1, \"Max CR Boost must be greater than or equal to 1\");\n\n        locked_stake_max_multiplier = _locked_stake_max_multiplier;\n        cr_boost_max_multiplier = _cr_boost_max_multiplier;\n        \n        emit MaxCRBoostMultiplier(cr_boost_max_multiplier);\n        emit LockedStakeMaxMultiplierUpdated(locked_stake_max_multiplier);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setLockedStakeTimeForMinAndMaxMultiplier",
        "visibility": "external",
        "args": [
            {
                "name": "_locked_stake_time_for_max_multiplier",
                "type": "uint256"
            },
            {
                "name": "_locked_stake_min_time",
                "type": "uint256"
            }
        ],
        "func": "function setLockedStakeTimeForMinAndMaxMultiplier(uint256 _locked_stake_time_for_max_multiplier, uint256 _locked_stake_min_time) external onlyByOwnerOrGovernance {\n        require(_locked_stake_time_for_max_multiplier >= 1, \"Multiplier Max Time must be greater than or equal to 1\");\n        require(_locked_stake_min_time >= 1, \"Multiplier Min Time must be greater than or equal to 1\");\n        \n        locked_stake_time_for_max_multiplier = _locked_stake_time_for_max_multiplier;\n\n        locked_stake_min_time = _locked_stake_min_time;\n        locked_stake_min_time_str = StringHelpers.uint2str(_locked_stake_min_time);\n\n        emit LockedStakeTimeForMaxMultiplier(locked_stake_time_for_max_multiplier);\n        emit LockedStakeMinTime(_locked_stake_min_time);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "initializeDefault",
        "visibility": "external",
        "args": [],
        "func": "function initializeDefault() external onlyByOwnerOrGovernance {\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(rewardsDuration);\n        emit DefaultInitialization();\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "greylistAddress",
        "visibility": "external",
        "args": [
            {
                "name": "_address",
                "type": "address"
            }
        ],
        "func": "function greylistAddress(address _address) external onlyByOwnerOrGovernance {\n        greylist[_address] = !(greylist[_address]);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unlockStakes",
        "visibility": "external",
        "args": [],
        "func": "function unlockStakes() external onlyByOwnerOrGovernance {\n        unlockedStakes = !unlockedStakes;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setRewardRate",
        "visibility": "external",
        "args": [
            {
                "name": "_new_rate",
                "type": "uint256"
            }
        ],
        "func": "function setRewardRate(uint256 _new_rate) external onlyByOwnerOrGovernance {\n        rewardRate = _new_rate;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setOwnerAndTimelock",
        "visibility": "external",
        "args": [
            {
                "name": "_new_owner",
                "type": "address"
            },
            {
                "name": "_new_timelock",
                "type": "address"
            }
        ],
        "func": "function setOwnerAndTimelock(address _new_owner, address _new_timelock) external onlyByOwnerOrGovernance {\n        owner_address = _new_owner;\n        timelock_address = _new_timelock;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "computeProfitMaximizingTrade",
        "visibility": "public",
        "args": [
            {
                "name": "truePriceTokenA",
                "type": "uint256"
            },
            {
                "name": "truePriceTokenB",
                "type": "uint256"
            },
            {
                "name": "reserveA",
                "type": "uint256"
            },
            {
                "name": "reserveB",
                "type": "uint256"
            }
        ],
        "func": "function computeProfitMaximizingTrade(\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB,\n        uint256 reserveA,\n        uint256 reserveB\n    ) pure public returns (bool aToB, uint256 amountIn) {\n        aToB = reserveA.mul(truePriceTokenB) / reserveB < truePriceTokenA;\n\n        uint256 invariant = reserveA.mul(reserveB);\n\n        uint256 leftSide = Babylonian.sqrt(\n            invariant.mul(aToB ? truePriceTokenA : truePriceTokenB).mul(1000) /\n            uint256(aToB ? truePriceTokenB : truePriceTokenA).mul(997)\n        );\n        uint256 rightSide = (aToB ? reserveA.mul(1000) : reserveB.mul(1000)) / 997;\n\n        // compute the amount that must be sent to move the price to the profit-maximizing price\n        amountIn = leftSide.sub(rightSide);\n    }",
        "comments": [
            "",
            "    // computes the direction and magnitude of the profit-maximizing trade",
            "    "
        ],
        "comt": "\n    // computes the direction and magnitude of the profit-maximizing trade\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapToPrice",
        "visibility": "public",
        "args": [
            {
                "name": "tokenA",
                "type": "address"
            },
            {
                "name": "tokenB",
                "type": "address"
            },
            {
                "name": "truePriceTokenA",
                "type": "uint256"
            },
            {
                "name": "truePriceTokenB",
                "type": "uint256"
            },
            {
                "name": "maxSpendTokenA",
                "type": "uint256"
            },
            {
                "name": "maxSpendTokenB",
                "type": "uint256"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint256"
            }
        ],
        "func": "function swapToPrice(\n        address tokenA,\n        address tokenB,\n        uint256 truePriceTokenA,\n        uint256 truePriceTokenB,\n        uint256 maxSpendTokenA,\n        uint256 maxSpendTokenB,\n        address to,\n        uint256 deadline\n    ) public {\n        // true price is expressed as a ratio, so both values must be non-zero\n        require(truePriceTokenA != 0 && truePriceTokenB != 0, \"ExampleSwapToPrice: ZERO_PRICE\");\n        // caller can specify 0 for either if they wish to swap in only one direction, but not both\n        require(maxSpendTokenA != 0 || maxSpendTokenB != 0, \"ExampleSwapToPrice: ZERO_SPEND\");\n\n        bool aToB;\n        uint256 amountIn;\n        {\n            (uint256 reserveA, uint256 reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n            (aToB, amountIn) = computeProfitMaximizingTrade(\n                truePriceTokenA, truePriceTokenB,\n                reserveA, reserveB\n            );\n        }\n\n        // spend up to the allowance of the token in\n        uint256 maxSpend = aToB ? maxSpendTokenA : maxSpendTokenB;\n        if (amountIn > maxSpend) {\n            amountIn = maxSpend;\n        }\n\n        address tokenIn = aToB ? tokenA : tokenB;\n        address tokenOut = aToB ? tokenB : tokenA;\n        TransferHelper.safeTransferFrom(tokenIn, msg.sender, address(this), amountIn);\n        TransferHelper.safeApprove(tokenIn, address(router), amountIn);\n\n        address[] memory path = new address[](2);\n        path[0] = tokenIn;\n        path[1] = tokenOut;\n\n        router.swapExactTokensForTokens(\n            amountIn,\n            0, // amountOutMin: we can skip computing this number because the math is tested\n            path,\n            to,\n            deadline\n        );\n    }",
        "comments": [
            "",
            "    // swaps an amount of either token such that the trade is profit-maximizing, given an external true price",
            "    // true price is expressed in the ratio of token A to token B",
            "    // caller must approve this contract to spend whichever token is intended to be swapped",
            "    "
        ],
        "comt": "\n    // swaps an amount of either token such that the trade is profit-maximizing, given an external true price\n    // true price is expressed in the ratio of token A to token B\n    // caller must approve this contract to spend whichever token is intended to be swapped\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPath",
        "visibility": "public",
        "args": [],
        "func": "function getPath() public returns (address[] memory) {\n  address[] memory path = new address[](2);\n  path[0] = USDT_address;\n  path[1] = WETH_address;\n  return path;\n }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapUSDTforETH",
        "visibility": "public",
        "args": [
            {
                "name": "amountIn",
                "type": "uint256"
            },
            {
                "name": "amountOutMin",
                "type": "uint256"
            }
        ],
        "func": "function swapUSDTforETH(uint256 amountIn, uint256 amountOutMin) public payable {\n  require(USDT.transferFrom(msg.sender, address(this), amountIn), \"transferFrom failed.\");\n  require(USDT.approve(address(router), amountIn), \"approve failed.\");\n\n  address[] memory path = new address[](2);\n  path[0] = USDT_address;\n  path[1] = WETH_address;\n\n  router.swapExactTokensForETH(amountIn, amountOutMin, path, msg.sender, block.timestamp);\n }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setDelay",
        "visibility": "public",
        "args": [
            {
                "name": "delay_",
                "type": "uint"
            }
        ],
        "func": "function setDelay(uint delay_) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "acceptAdmin",
        "visibility": "public",
        "args": [],
        "func": "function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setPendingAdmin",
        "visibility": "public",
        "args": [
            {
                "name": "pendingAdmin_",
                "type": "address"
            }
        ],
        "func": "function setPendingAdmin(address pendingAdmin_) public {\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "queueTransaction",
        "visibility": "public",
        "args": [
            {
                "name": "target",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint"
            },
            {
                "name": "signature",
                "type": "string memory"
            },
            {
                "name": "data",
                "type": "bytes memory"
            },
            {
                "name": "eta",
                "type": "uint"
            }
        ],
        "func": "function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cancelTransaction",
        "visibility": "public",
        "args": [
            {
                "name": "target",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint"
            },
            {
                "name": "signature",
                "type": "string memory"
            },
            {
                "name": "data",
                "type": "bytes memory"
            },
            {
                "name": "eta",
                "type": "uint"
            }
        ],
        "func": "function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "executeTransaction",
        "visibility": "public",
        "args": [
            {
                "name": "target",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint"
            },
            {
                "name": "signature",
                "type": "string memory"
            },
            {
                "name": "data",
                "type": "bytes memory"
            },
            {
                "name": "eta",
                "type": "uint"
            }
        ],
        "func": "function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // Execute the call\n        (bool success, bytes memory returnData) = target.call{ value: value }(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setFXSAddress",
        "visibility": "public",
        "args": [
            {
                "name": "FXS_address",
                "type": "address"
            }
        ],
        "func": "function setFXSAddress(address FXS_address) public {\n        require(msg.sender == _owner, \"must be set by the owner\");\n        _FXS_contract_address = FXS_address;\n        FXS = ERC20(FXS_address);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setTimelockAddress",
        "visibility": "public",
        "args": [
            {
                "name": "timelock_address",
                "type": "address"
            }
        ],
        "func": "function setTimelockAddress(address timelock_address) public {\n        require(msg.sender == _owner, \"must be set by the owner\");\n        _timelock_address = timelock_address;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getBeneficiary",
        "visibility": "public",
        "args": [],
        "func": "function getBeneficiary() public view returns (address) {\n        return _beneficiary;\n    }",
        "comments": [
            "/**",
            "     * @return the beneficiary of the tokens.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @return the beneficiary of the tokens.\n     */\n",
        "@return1": "the beneficiary of the tokens.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCliff",
        "visibility": "public",
        "args": [],
        "func": "function getCliff() public view returns (uint256) {\n        return _cliff;\n    }",
        "comments": [
            "/**",
            "     * @return the cliff time of the token vesting.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @return the cliff time of the token vesting.\n     */\n",
        "@return1": "the cliff time of the token vesting.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getStart",
        "visibility": "public",
        "args": [],
        "func": "function getStart() public view returns (uint256) {\n        return _start;\n    }",
        "comments": [
            "/**",
            "     * @return the start time of the token vesting.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @return the start time of the token vesting.\n     */\n",
        "@return1": "the start time of the token vesting.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getDuration",
        "visibility": "public",
        "args": [],
        "func": "function getDuration() public view returns (uint256) {\n        return _duration;\n    }",
        "comments": [
            "/**",
            "     * @return the duration of the token vesting.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @return the duration of the token vesting.\n     */\n",
        "@return1": "the duration of the token vesting.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getRevocable",
        "visibility": "public",
        "args": [],
        "func": "function getRevocable() public view returns (bool) {\n        return _revocable;\n    }",
        "comments": [
            "/**",
            "     * @return true if the vesting is revocable.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @return true if the vesting is revocable.\n     */\n",
        "@return1": "true if the vesting is revocable.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getReleased",
        "visibility": "public",
        "args": [],
        "func": "function getReleased() public view returns (uint256) {\n        return _released;\n    }",
        "comments": [
            "/**",
            "     * @return the amount of the token released.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @return the amount of the token released.\n     */\n",
        "@return1": "the amount of the token released.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getRevoked",
        "visibility": "public",
        "args": [],
        "func": "function getRevoked() public view returns (bool) {\n        return _revoked;\n    }",
        "comments": [
            "/**",
            "     * @return true if the token is revoked.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @return true if the token is revoked.\n     */\n",
        "@return1": "true if the token is revoked.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "release",
        "visibility": "public",
        "args": [],
        "func": "function release() public {\n        require(msg.sender == _beneficiary, \"must be the beneficiary to release tokens\");\n        uint256 unreleased = _releasableAmount();\n\n        require(unreleased > 0, \"TokenVesting: no tokens are due\");\n\n        _released = _released.add(unreleased);\n\n        FXS.transfer(_beneficiary, unreleased);\n\n        emit TokensReleased(unreleased);\n    }",
        "comments": [
            "/**",
            "     * @notice Transfers vested tokens to beneficiary.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfers vested tokens to beneficiary.\n     */\n",
        "@notice": "Transfers vested tokens to beneficiary.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "revoke",
        "visibility": "public",
        "args": [],
        "func": "function revoke() public {\n        require(msg.sender == _timelock_address, \"Must be called by the timelock contract\");\n        require(_revocable, \"TokenVesting: cannot revoke\");\n        require(!_revoked, \"TokenVesting: token already revoked\");\n\n        uint256 balance = FXS.balanceOf(address(this));\n\n        uint256 unreleased = _releasableAmount();\n        uint256 refund = balance.sub(unreleased);\n\n        _revoked = true;\n\n        FXS.transfer(_owner, refund);\n\n        emit TokenVestingRevoked();\n    }",
        "comments": [
            "/**",
            "     * @notice Allows the owner to revoke the vesting. Tokens already vested",
            "     * remain in the contract, the rest are returned to the owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Allows the owner to revoke the vesting. Tokens already vested\n     * remain in the contract, the rest are returned to the owner.\n     */\n",
        "@notice": "Allows the owner to revoke the vesting. Tokens already vested * remain in the contract, the rest are returned to the owner.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "recoverERC20",
        "visibility": "external",
        "args": [
            {
                "name": "tokenAddress",
                "type": "address"
            },
            {
                "name": "tokenAmount",
                "type": "uint256"
            }
        ],
        "func": "function recoverERC20(address tokenAddress, uint256 tokenAmount) external {\n        require(msg.sender == _beneficiary, \"Must be called by the beneficiary\");\n\n        // Cannot recover the staking token or the rewards token\n        require(tokenAddress != _FXS_contract_address, \"Cannot withdraw the FXS through this function\");\n        ERC20(tokenAddress).transfer(_beneficiary, tokenAmount);\n    }",
        "comments": [
            "",
            "    // Added to support recovering possible airdrops",
            "    "
        ],
        "comt": "\n    // Added to support recovering possible airdrops\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setOwner",
        "visibility": "external",
        "args": [
            {
                "name": "_owner_address",
                "type": "address"
            }
        ],
        "func": "function setOwner(address _owner_address) external onlyByOwnerOrGovernance {\n        owner_address = _owner_address;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setTimelock",
        "visibility": "external",
        "args": [
            {
                "name": "_timelock_address",
                "type": "address"
            }
        ],
        "func": "function setTimelock(address _timelock_address) external onlyByOwnerOrGovernance {\n        timelock_address = _timelock_address;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setPeriod",
        "visibility": "external",
        "args": [
            {
                "name": "_period",
                "type": "uint"
            }
        ],
        "func": "function setPeriod(uint _period) external onlyByOwnerOrGovernance {\n        PERIOD = _period;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setConsultLeniency",
        "visibility": "external",
        "args": [
            {
                "name": "_consult_leniency",
                "type": "uint"
            }
        ],
        "func": "function setConsultLeniency(uint _consult_leniency) external onlyByOwnerOrGovernance {\n        CONSULT_LENIENCY = _consult_leniency;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setAllowStaleConsults",
        "visibility": "external",
        "args": [
            {
                "name": "_allow_stale_consults",
                "type": "bool"
            }
        ],
        "func": "function setAllowStaleConsults(bool _allow_stale_consults) external onlyByOwnerOrGovernance {\n        ALLOW_STALE_CONSULTS = _allow_stale_consults;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "canUpdate",
        "visibility": "public",
        "args": [],
        "func": "function canUpdate() public view returns (bool) {\n        uint32 blockTimestamp = UniswapV2OracleLibrary.currentBlockTimestamp();\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // Overflow is desired\n        return (timeElapsed >= PERIOD);\n    }",
        "comments": [
            "",
            "    // Check if update() can be called instead of wasting gas calling it",
            "    "
        ],
        "comt": "\n    // Check if update() can be called instead of wasting gas calling it\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "update",
        "visibility": "external",
        "args": [],
        "func": "function update() external {\n        (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) =\n            UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // Overflow is desired\n\n        // Ensure that at least one full period has passed since the last update\n        require(timeElapsed >= PERIOD, 'UniswapPairOracle: PERIOD_NOT_ELAPSED');\n\n        // Overflow is desired, casting never truncates\n        // Cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n        price0Average = FixedPoint.uq112x112(uint224((price0Cumulative - price0CumulativeLast) / timeElapsed));\n        price1Average = FixedPoint.uq112x112(uint224((price1Cumulative - price1CumulativeLast) / timeElapsed));\n\n        price0CumulativeLast = price0Cumulative;\n        price1CumulativeLast = price1Cumulative;\n        blockTimestampLast = blockTimestamp;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "consult",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "amountIn",
                "type": "uint"
            }
        ],
        "func": "function consult(address token, uint amountIn) external view returns (uint amountOut) {\n        uint32 blockTimestamp = UniswapV2OracleLibrary.currentBlockTimestamp();\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // Overflow is desired\n\n        // Ensure that the price is not stale\n        require((timeElapsed < (PERIOD + CONSULT_LENIENCY)) || ALLOW_STALE_CONSULTS, 'UniswapPairOracle: PRICE_IS_STALE_NEED_TO_CALL_UPDATE');\n\n        if (token == token0) {\n            amountOut = price0Average.mul(amountIn).decode144();\n        } else {\n            require(token == token1, 'UniswapPairOracle: INVALID_TOKEN');\n            amountOut = price1Average.mul(amountIn).decode144();\n        }\n    }",
        "comments": [
            "",
            "    // Note this will always return 0 before update has been called successfully for the first time.",
            "    "
        ],
        "comt": "\n    // Note this will always return 0 before update has been called successfully for the first time.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setOwner",
        "visibility": "external",
        "args": [
            {
                "name": "_owner_address",
                "type": "address"
            }
        ],
        "func": "function setOwner(address _owner_address) external onlyByOwnerOrGovernance {\n        owner_address = _owner_address;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setTimelock",
        "visibility": "external",
        "args": [
            {
                "name": "_timelock_address",
                "type": "address"
            }
        ],
        "func": "function setTimelock(address _timelock_address) external onlyByOwnerOrGovernance {\n        timelock_address = _timelock_address;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setPeriod",
        "visibility": "external",
        "args": [
            {
                "name": "_period",
                "type": "uint"
            }
        ],
        "func": "function setPeriod(uint _period) external onlyByOwnerOrGovernance {\n        PERIOD = _period;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "update",
        "visibility": "external",
        "args": [],
        "func": "function update() external {\n        (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) =\n            UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // Overflow is desired\n\n        // Ensure that at least one full period has passed since the last update\n        require(timeElapsed >= PERIOD, 'UniswapPairOracle: PERIOD_NOT_ELAPSED');\n\n        // Overflow is desired, casting never truncates\n        // Cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n        price0Average = FixedPoint.uq112x112(uint224((price0Cumulative - price0CumulativeLast) / timeElapsed));\n        price1Average = FixedPoint.uq112x112(uint224((price1Cumulative - price1CumulativeLast) / timeElapsed));\n\n        price0CumulativeLast = price0Cumulative;\n        price1CumulativeLast = price1Cumulative;\n        blockTimestampLast = blockTimestamp;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "consult",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "amountIn",
                "type": "uint"
            }
        ],
        "func": "function consult(address token, uint amountIn) external view returns (uint amountOut) {\n        if (token == token0) {\n            amountOut = price0Average.mul(amountIn).decode144();\n        } else {\n            require(token == token1, 'UniswapPairOracle: INVALID_TOKEN');\n            amountOut = price1Average.mul(amountIn).decode144();\n        }\n    }",
        "comments": [
            "",
            "    // Note this will always return 0 before update has been called successfully for the first time.",
            "    "
        ],
        "comt": "\n    // Note this will always return 0 before update has been called successfully for the first time.\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "external",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint"
            }
        ],
        "func": "function approve(address spender, uint value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint"
            }
        ],
        "func": "function transfer(address to, uint value) external override returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint"
            }
        ],
        "func": "function transferFrom(address from, address to, uint value) external override returns (bool) {\n        if (allowance[from][msg.sender] != uint(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "permit",
        "visibility": "external",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint"
            },
            {
                "name": "deadline",
                "type": "uint"
            },
            {
                "name": "v",
                "type": "uint8"
            },
            {
                "name": "r",
                "type": "bytes32"
            },
            {
                "name": "s",
                "type": "bytes32"
            }
        ],
        "func": "function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external override {\n        require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');\n        _approve(owner, spender, value);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allPairsLength",
        "visibility": "external",
        "args": [],
        "func": "function allPairsLength() external override view returns (uint) {\n        return allPairs.length;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createPair",
        "visibility": "external",
        "args": [
            {
                "name": "tokenA",
                "type": "address"
            },
            {
                "name": "tokenB",
                "type": "address"
            }
        ],
        "func": "function createPair(address tokenA, address tokenB) external override returns (address pair) {\n        require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');\n        require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient\n        bytes memory bytecode = type(UniswapV2Pair).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n\n        // This creates a new contract\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        IUniswapV2Pair(pair).initialize(token0, token1);\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setFeeTo",
        "visibility": "external",
        "args": [
            {
                "name": "_feeTo",
                "type": "address"
            }
        ],
        "func": "function setFeeTo(address _feeTo) external override {\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\n        feeTo = _feeTo;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setFeeToSetter",
        "visibility": "external",
        "args": [
            {
                "name": "_feeToSetter",
                "type": "address"
            }
        ],
        "func": "function setFeeToSetter(address _feeToSetter) external override {\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\n        feeToSetter = _feeToSetter;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getReserves",
        "visibility": "public",
        "args": [],
        "func": "function getReserves() public override view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "initialize",
        "visibility": "external",
        "args": [
            {
                "name": "_token0",
                "type": "address"
            },
            {
                "name": "_token1",
                "type": "address"
            }
        ],
        "func": "function initialize(address _token0, address _token1) external override {\n        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    }",
        "comments": [
            "",
            "    // called once by the factory at time of deployment",
            "    "
        ],
        "comt": "\n    // called once by the factory at time of deployment\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            }
        ],
        "func": "function mint(address to) external override lock returns (uint liquidity) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        uint balance0 = IERC20(token0).balanceOf(address(this));\n        uint balance1 = IERC20(token1).balanceOf(address(this));\n        uint amount0 = balance0.sub(_reserve0);\n        uint amount1 = balance1.sub(_reserve1);\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n           _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n        }\n\n        require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    }",
        "comments": [
            "",
            "    // this low-level function should be called from a contract which performs important safety checks",
            "    "
        ],
        "comt": "\n    // this low-level function should be called from a contract which performs important safety checks\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            }
        ],
        "func": "function burn(address to) external override lock returns (uint amount0, uint amount1) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        address _token0 = token0;                                // gas savings\n        address _token1 = token1;                                // gas savings\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\n        uint liquidity = balanceOf[address(this)];\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, amount0, amount1, to);\n    }",
        "comments": [
            "",
            "    // this low-level function should be called from a contract which performs important safety checks",
            "    "
        ],
        "comt": "\n    // this low-level function should be called from a contract which performs important safety checks\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swap",
        "visibility": "external",
        "args": [
            {
                "name": "amount0Out",
                "type": "uint"
            },
            {
                "name": "amount1Out",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "data",
                "type": "bytes calldata"
            }
        ],
        "func": "function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external override lock {\n        require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');\n\n        uint balance0;\n        uint balance1;\n        { // scope for _token{0,1}, avoids stack too deep errors\n        address _token0 = token0;\n        address _token1 = token1;\n        require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n        if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');\n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\n        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\n        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }",
        "comments": [
            "",
            "    // this low-level function should be called from a contract which performs important safety checks",
            "    "
        ],
        "comt": "\n    // this low-level function should be called from a contract which performs important safety checks\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "skim",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            }
        ],
        "func": "function skim(address to) external override lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\n    }",
        "comments": [
            "",
            "    // force balances to match reserves",
            "    "
        ],
        "comt": "\n    // force balances to match reserves\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sync",
        "visibility": "external",
        "args": [],
        "func": "function sync() external override lock {\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n    }",
        "comments": [
            "",
            "    // force reserves to match balances",
            "    "
        ],
        "comt": "\n    // force reserves to match balances\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "external",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint"
            }
        ],
        "func": "function approve(address spender, uint value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint"
            }
        ],
        "func": "function transfer(address to, uint value) external override returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint"
            }
        ],
        "func": "function transferFrom(address from, address to, uint value) external override returns (bool) {\n        if (allowance[from][msg.sender] != uint(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "permit",
        "visibility": "external",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint"
            },
            {
                "name": "deadline",
                "type": "uint"
            },
            {
                "name": "v",
                "type": "uint8"
            },
            {
                "name": "r",
                "type": "bytes32"
            },
            {
                "name": "s",
                "type": "bytes32"
            }
        ],
        "func": "function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external override {\n        require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');\n        _approve(owner, spender, value);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addLiquidity",
        "visibility": "external",
        "args": [
            {
                "name": "tokenA",
                "type": "address"
            },
            {
                "name": "tokenB",
                "type": "address"
            },
            {
                "name": "amountADesired",
                "type": "uint"
            },
            {
                "name": "amountBDesired",
                "type": "uint"
            },
            {
                "name": "amountAMin",
                "type": "uint"
            },
            {
                "name": "amountBMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IUniswapV2Pair(pair).mint(to);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addLiquidityETH",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "amountTokenDesired",
                "type": "uint"
            },
            {
                "name": "amountTokenMin",
                "type": "uint"
            },
            {
                "name": "amountETHMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\n        (amountToken, amountETH) = _addLiquidity(\n            token,\n            WETH,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountETHMin\n        );\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        IWETH(WETH).deposit{value: amountETH}();\n        assert(IWETH(WETH).transfer(pair, amountETH));\n        liquidity = IUniswapV2Pair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidity",
        "visibility": "public",
        "args": [
            {
                "name": "tokenA",
                "type": "address"
            },
            {
                "name": "tokenB",
                "type": "address"
            },
            {
                "name": "liquidity",
                "type": "uint"
            },
            {
                "name": "amountAMin",
                "type": "uint"
            },
            {
                "name": "amountBMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n        (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);\n        (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n        require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n    }",
        "comments": [
            "",
            "    // **** REMOVE LIQUIDITY ****",
            "    "
        ],
        "comt": "\n    // **** REMOVE LIQUIDITY ****\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityETH",
        "visibility": "public",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "liquidity",
                "type": "uint"
            },
            {
                "name": "amountTokenMin",
                "type": "uint"
            },
            {
                "name": "amountETHMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\n        (amountToken, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, amountToken);\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityWithPermit",
        "visibility": "external",
        "args": [
            {
                "name": "tokenA",
                "type": "address"
            },
            {
                "name": "tokenB",
                "type": "address"
            },
            {
                "name": "liquidity",
                "type": "uint"
            },
            {
                "name": "amountAMin",
                "type": "uint"
            },
            {
                "name": "amountBMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            },
            {
                "name": "approveMax",
                "type": "bool"
            },
            {
                "name": "v",
                "type": "uint8"
            },
            {
                "name": "r",
                "type": "bytes32"
            },
            {
                "name": "s",
                "type": "bytes32"
            }
        ],
        "func": "function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountA, uint amountB) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityETHWithPermit",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "liquidity",
                "type": "uint"
            },
            {
                "name": "amountTokenMin",
                "type": "uint"
            },
            {
                "name": "amountETHMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            },
            {
                "name": "approveMax",
                "type": "bool"
            },
            {
                "name": "v",
                "type": "uint8"
            },
            {
                "name": "r",
                "type": "bytes32"
            },
            {
                "name": "s",
                "type": "bytes32"
            }
        ],
        "func": "function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountToken, uint amountETH) {\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityETHSupportingFeeOnTransferTokens",
        "visibility": "public",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "liquidity",
                "type": "uint"
            },
            {
                "name": "amountTokenMin",
                "type": "uint"
            },
            {
                "name": "amountETHMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountETH) {\n        (, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }",
        "comments": [
            "",
            "    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****",
            "    "
        ],
        "comt": "\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityETHWithPermitSupportingFeeOnTransferTokens",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "liquidity",
                "type": "uint"
            },
            {
                "name": "amountTokenMin",
                "type": "uint"
            },
            {
                "name": "amountETHMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            },
            {
                "name": "approveMax",
                "type": "bool"
            },
            {
                "name": "v",
                "type": "uint8"
            },
            {
                "name": "r",
                "type": "bytes32"
            },
            {
                "name": "s",
                "type": "bytes32"
            }
        ],
        "func": "function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountETH) {\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n            token, liquidity, amountTokenMin, amountETHMin, to, deadline\n        );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapExactTokensForTokens",
        "visibility": "external",
        "args": [
            {
                "name": "amountIn",
                "type": "uint"
            },
            {
                "name": "amountOutMin",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapTokensForExactTokens",
        "visibility": "external",
        "args": [
            {
                "name": "amountOut",
                "type": "uint"
            },
            {
                "name": "amountInMax",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapExactETHForTokens",
        "visibility": "external",
        "args": [
            {
                "name": "amountOutMin",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapTokensForExactETH",
        "visibility": "external",
        "args": [
            {
                "name": "amountOut",
                "type": "uint"
            },
            {
                "name": "amountInMax",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapExactTokensForETH",
        "visibility": "external",
        "args": [
            {
                "name": "amountIn",
                "type": "uint"
            },
            {
                "name": "amountOutMin",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapETHForExactTokens",
        "visibility": "external",
        "args": [
            {
                "name": "amountOut",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapExactTokensForTokensSupportingFeeOnTransferTokens",
        "visibility": "external",
        "args": [
            {
                "name": "amountIn",
                "type": "uint"
            },
            {
                "name": "amountOutMin",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\n        );\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapExactETHForTokensSupportingFeeOnTransferTokens",
        "visibility": "external",
        "args": [
            {
                "name": "amountOutMin",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n    {\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        uint amountIn = msg.value;\n        IWETH(WETH).deposit{value: amountIn}();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapExactTokensForETHSupportingFeeOnTransferTokens",
        "visibility": "external",
        "args": [
            {
                "name": "amountIn",
                "type": "uint"
            },
            {
                "name": "amountOutMin",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n    {\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\n        );\n        _swapSupportingFeeOnTransferTokens(path, address(this));\n        uint amountOut = IERC20(WETH).balanceOf(address(this));\n        require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).withdraw(amountOut);\n        TransferHelper.safeTransferETH(to, amountOut);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "quote",
        "visibility": "public",
        "args": [
            {
                "name": "amountA",
                "type": "uint"
            },
            {
                "name": "reserveA",
                "type": "uint"
            },
            {
                "name": "reserveB",
                "type": "uint"
            }
        ],
        "func": "function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {\n        return UniswapV2Library.quote(amountA, reserveA, reserveB);\n    }",
        "comments": [
            "",
            "    // **** LIBRARY FUNCTIONS ****",
            "    "
        ],
        "comt": "\n    // **** LIBRARY FUNCTIONS ****\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAmountOut",
        "visibility": "public",
        "args": [
            {
                "name": "amountIn",
                "type": "uint"
            },
            {
                "name": "reserveIn",
                "type": "uint"
            },
            {
                "name": "reserveOut",
                "type": "uint"
            }
        ],
        "func": "function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\n        public\n        pure\n        virtual\n        override\n        returns (uint amountOut)\n    {\n        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAmountIn",
        "visibility": "public",
        "args": [
            {
                "name": "amountOut",
                "type": "uint"
            },
            {
                "name": "reserveIn",
                "type": "uint"
            },
            {
                "name": "reserveOut",
                "type": "uint"
            }
        ],
        "func": "function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\n        public\n        pure\n        virtual\n        override\n        returns (uint amountIn)\n    {\n        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAmountsOut",
        "visibility": "public",
        "args": [
            {
                "name": "amountIn",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] memory"
            }
        ],
        "func": "function getAmountsOut(uint amountIn, address[] memory path)\n        public\n        view\n        virtual\n        override\n        returns (uint[] memory amounts)\n    {\n        return UniswapV2Library.getAmountsOut(factory, amountIn, path);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAmountsIn",
        "visibility": "public",
        "args": [
            {
                "name": "amountOut",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] memory"
            }
        ],
        "func": "function getAmountsIn(uint amountOut, address[] memory path)\n        public\n        view\n        virtual\n        override\n        returns (uint[] memory amounts)\n    {\n        return UniswapV2Library.getAmountsIn(factory, amountOut, path);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addLiquidity",
        "visibility": "external",
        "args": [
            {
                "name": "tokenA",
                "type": "address"
            },
            {
                "name": "tokenB",
                "type": "address"
            },
            {
                "name": "amountADesired",
                "type": "uint"
            },
            {
                "name": "amountBDesired",
                "type": "uint"
            },
            {
                "name": "amountAMin",
                "type": "uint"
            },
            {
                "name": "amountBMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IUniswapV2Pair(pair).mint(to);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addLiquidityETH",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "amountTokenDesired",
                "type": "uint"
            },
            {
                "name": "amountTokenMin",
                "type": "uint"
            },
            {
                "name": "amountETHMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\n        (amountToken, amountETH) = _addLiquidity(\n            token,\n            WETH,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountETHMin\n        );\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        \n        \n        TransferHelper.safeTransferFrom(WETH, msg.sender, pair, amountETH);\n\n        // IWETH(WETH).transferFrom(msg.sender, pair, amountETH);\n        // IWETH(WETH).deposit{value: amountETH}();\n        // assert(IWETH(WETH).transfer(pair, amountETH));\n\n        // require(false, \"HELLO: HOW ARE YOU TODAY!\");\n\n        liquidity = IUniswapV2Pair(pair).mint(to); // << PROBLEM IS HERE\n\n        // refund dust eth, if any\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidity",
        "visibility": "public",
        "args": [
            {
                "name": "tokenA",
                "type": "address"
            },
            {
                "name": "tokenB",
                "type": "address"
            },
            {
                "name": "liquidity",
                "type": "uint"
            },
            {
                "name": "amountAMin",
                "type": "uint"
            },
            {
                "name": "amountBMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n        (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);\n        (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n        require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n    }",
        "comments": [
            "",
            "    // **** REMOVE LIQUIDITY ****",
            "    "
        ],
        "comt": "\n    // **** REMOVE LIQUIDITY ****\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityETH",
        "visibility": "public",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "liquidity",
                "type": "uint"
            },
            {
                "name": "amountTokenMin",
                "type": "uint"
            },
            {
                "name": "amountETHMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\n        (amountToken, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, amountToken);\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityWithPermit",
        "visibility": "external",
        "args": [
            {
                "name": "tokenA",
                "type": "address"
            },
            {
                "name": "tokenB",
                "type": "address"
            },
            {
                "name": "liquidity",
                "type": "uint"
            },
            {
                "name": "amountAMin",
                "type": "uint"
            },
            {
                "name": "amountBMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            },
            {
                "name": "approveMax",
                "type": "bool"
            },
            {
                "name": "v",
                "type": "uint8"
            },
            {
                "name": "r",
                "type": "bytes32"
            },
            {
                "name": "s",
                "type": "bytes32"
            }
        ],
        "func": "function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountA, uint amountB) {\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityETHWithPermit",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "liquidity",
                "type": "uint"
            },
            {
                "name": "amountTokenMin",
                "type": "uint"
            },
            {
                "name": "amountETHMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            },
            {
                "name": "approveMax",
                "type": "bool"
            },
            {
                "name": "v",
                "type": "uint8"
            },
            {
                "name": "r",
                "type": "bytes32"
            },
            {
                "name": "s",
                "type": "bytes32"
            }
        ],
        "func": "function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountToken, uint amountETH) {\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityETHSupportingFeeOnTransferTokens",
        "visibility": "public",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "liquidity",
                "type": "uint"
            },
            {
                "name": "amountTokenMin",
                "type": "uint"
            },
            {
                "name": "amountETHMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountETH) {\n        (, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }",
        "comments": [
            "",
            "    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****",
            "    "
        ],
        "comt": "\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityETHWithPermitSupportingFeeOnTransferTokens",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "liquidity",
                "type": "uint"
            },
            {
                "name": "amountTokenMin",
                "type": "uint"
            },
            {
                "name": "amountETHMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            },
            {
                "name": "approveMax",
                "type": "bool"
            },
            {
                "name": "v",
                "type": "uint8"
            },
            {
                "name": "r",
                "type": "bytes32"
            },
            {
                "name": "s",
                "type": "bytes32"
            }
        ],
        "func": "function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountETH) {\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n            token, liquidity, amountTokenMin, amountETHMin, to, deadline\n        );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapExactTokensForTokens",
        "visibility": "external",
        "args": [
            {
                "name": "amountIn",
                "type": "uint"
            },
            {
                "name": "amountOutMin",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapTokensForExactTokens",
        "visibility": "external",
        "args": [
            {
                "name": "amountOut",
                "type": "uint"
            },
            {
                "name": "amountInMax",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapExactETHForTokens",
        "visibility": "external",
        "args": [
            {
                "name": "amountOutMin",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapTokensForExactETH",
        "visibility": "external",
        "args": [
            {
                "name": "amountOut",
                "type": "uint"
            },
            {
                "name": "amountInMax",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapExactTokensForETH",
        "visibility": "external",
        "args": [
            {
                "name": "amountIn",
                "type": "uint"
            },
            {
                "name": "amountOutMin",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapETHForExactTokens",
        "visibility": "external",
        "args": [
            {
                "name": "amountOut",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapExactTokensForTokensSupportingFeeOnTransferTokens",
        "visibility": "external",
        "args": [
            {
                "name": "amountIn",
                "type": "uint"
            },
            {
                "name": "amountOutMin",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) {\n        // TransferHelper.safeTransferFrom(\n        //     path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\n        // );\n        // uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        // _swapSupportingFeeOnTransferTokens(path, to);\n        // require(\n        //     IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n        //     'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n        // );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapExactETHForTokensSupportingFeeOnTransferTokens",
        "visibility": "external",
        "args": [
            {
                "name": "amountOutMin",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n    {\n        // require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        // uint amountIn = msg.value;\n        // IWETH(WETH).deposit{value: amountIn}();\n        // assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));\n        // uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        // _swapSupportingFeeOnTransferTokens(path, to);\n        // require(\n        //     IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n        //     'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n        // );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapExactTokensForETHSupportingFeeOnTransferTokens",
        "visibility": "external",
        "args": [
            {
                "name": "amountIn",
                "type": "uint"
            },
            {
                "name": "amountOutMin",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n    {\n        // require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        // TransferHelper.safeTransferFrom(\n        //     path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\n        // );\n        // _swapSupportingFeeOnTransferTokens(path, address(this));\n        // uint amountOut = IERC20(WETH).balanceOf(address(this));\n        // require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        // IWETH(WETH).withdraw(amountOut);\n        // TransferHelper.safeTransferETH(to, amountOut);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "quote",
        "visibility": "public",
        "args": [
            {
                "name": "amountA",
                "type": "uint"
            },
            {
                "name": "reserveA",
                "type": "uint"
            },
            {
                "name": "reserveB",
                "type": "uint"
            }
        ],
        "func": "function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {\n        return UniswapV2Library.quote(amountA, reserveA, reserveB);\n    }",
        "comments": [
            "",
            "    // **** LIBRARY FUNCTIONS ****",
            "    "
        ],
        "comt": "\n    // **** LIBRARY FUNCTIONS ****\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAmountOut",
        "visibility": "public",
        "args": [
            {
                "name": "amountIn",
                "type": "uint"
            },
            {
                "name": "reserveIn",
                "type": "uint"
            },
            {
                "name": "reserveOut",
                "type": "uint"
            }
        ],
        "func": "function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\n        public\n        pure\n        virtual\n        override\n        returns (uint amountOut)\n    {\n        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAmountIn",
        "visibility": "public",
        "args": [
            {
                "name": "amountOut",
                "type": "uint"
            },
            {
                "name": "reserveIn",
                "type": "uint"
            },
            {
                "name": "reserveOut",
                "type": "uint"
            }
        ],
        "func": "function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\n        public\n        pure\n        virtual\n        override\n        returns (uint amountIn)\n    {\n        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAmountsOut",
        "visibility": "public",
        "args": [
            {
                "name": "amountIn",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] memory"
            }
        ],
        "func": "function getAmountsOut(uint amountIn, address[] memory path)\n        public\n        view\n        virtual\n        override\n        returns (uint[] memory amounts)\n    {\n        return UniswapV2Library.getAmountsOut(factory, amountIn, path);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAmountsIn",
        "visibility": "public",
        "args": [
            {
                "name": "amountOut",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] memory"
            }
        ],
        "func": "function getAmountsIn(uint amountOut, address[] memory path)\n        public\n        view\n        virtual\n        override\n        returns (uint[] memory amounts)\n    {\n        return UniswapV2Library.getAmountsIn(factory, amountOut, path);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "deposit",
        "visibility": "public",
        "args": [],
        "func": "function deposit() public override payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "wad",
                "type": "uint"
            }
        ],
        "func": "function withdraw(uint wad) override public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        msg.sender.transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view returns (uint) {\n        return address(this).balance;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "guy",
                "type": "address"
            },
            {
                "name": "wad",
                "type": "uint"
            }
        ],
        "func": "function approve(address guy, uint wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "dst",
                "type": "address"
            },
            {
                "name": "wad",
                "type": "uint"
            }
        ],
        "func": "function transfer(address dst, uint wad) public override returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "src",
                "type": "address"
            },
            {
                "name": "dst",
                "type": "address"
            },
            {
                "name": "wad",
                "type": "uint"
            }
        ],
        "func": "function transferFrom(address src, address dst, uint wad)\n        public\n        override\n        returns (bool)\n    {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    }
]