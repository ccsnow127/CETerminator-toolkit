[
    {
        "transactions": 817,
        "function_num": 203
    },
    {
        "name": "setRelayer",
        "visibility": "external",
        "args": [
            {
                "name": "_relayer",
                "type": "address"
            }
        ],
        "func": "function setRelayer(address _relayer) external onlyGov {\n    relayer = _relayer;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateRoot",
        "visibility": "external",
        "args": [
            {
                "name": "_root",
                "type": "bytes32"
            }
        ],
        "func": "function updateRoot(bytes32 _root) external {\n    require(msg.sender == relayer || msg.sender == governor, '!relayer');\n    root = _root;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "deposit",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function deposit(uint amount) external nonReentrant {\n    uint uBalanceBefore = uToken.balanceOf(address(this));\n    uToken.safeTransferFrom(msg.sender, address(this), amount);\n    uint uBalanceAfter = uToken.balanceOf(address(this));\n    uint cBalanceBefore = cToken.balanceOf(address(this));\n    require(cToken.mint(uBalanceAfter.sub(uBalanceBefore)) == 0, '!mint');\n    uint cBalanceAfter = cToken.balanceOf(address(this));\n    _mint(msg.sender, cBalanceAfter.sub(cBalanceBefore));\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function withdraw(uint amount) public nonReentrant {\n    _burn(msg.sender, amount);\n    uint uBalanceBefore = uToken.balanceOf(address(this));\n    require(cToken.redeem(amount) == 0, '!redeem');\n    uint uBalanceAfter = uToken.balanceOf(address(this));\n    uToken.safeTransfer(msg.sender, uBalanceAfter.sub(uBalanceBefore));\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "claim",
        "visibility": "public",
        "args": [
            {
                "name": "totalReward",
                "type": "uint"
            },
            {
                "name": "proof",
                "type": "bytes32[] memory"
            }
        ],
        "func": "function claim(uint totalReward, bytes32[] memory proof) public nonReentrant {\n    bytes32 leaf = keccak256(abi.encodePacked(msg.sender, totalReward));\n    require(MerkleProof.verify(proof, root, leaf), '!proof');\n    uint send = totalReward.sub(claimed[msg.sender]);\n    claimed[msg.sender] = totalReward;\n    uToken.safeTransfer(msg.sender, send);\n    emit Claim(msg.sender, send);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "adminClaim",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function adminClaim(uint amount) external onlyGov {\n    uToken.safeTransfer(msg.sender, amount);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "claimAndWithdraw",
        "visibility": "external",
        "args": [
            {
                "name": "claimAmount",
                "type": "uint"
            },
            {
                "name": "proof",
                "type": "bytes32[] memory"
            },
            {
                "name": "withdrawAmount",
                "type": "uint"
            }
        ],
        "func": "function claimAndWithdraw(\n    uint claimAmount,\n    bytes32[] memory proof,\n    uint withdrawAmount\n  ) external {\n    claim(claimAmount, proof);\n    withdraw(withdrawAmount);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setPendingGovernor",
        "visibility": "external",
        "args": [
            {
                "name": "_pendingGovernor",
                "type": "address"
            }
        ],
        "func": "function setPendingGovernor(address _pendingGovernor) external onlyGov {\n    pendingGovernor = _pendingGovernor;\n  }",
        "comments": [
            "",
            "  /// @dev Set the pending governor, which will be the governor once accepted.",
            "  /// @param _pendingGovernor The address to become the pending governor.",
            "  "
        ],
        "comt": "\n  /// @dev Set the pending governor, which will be the governor once accepted.\n  /// @param _pendingGovernor The address to become the pending governor.\n  ",
        "@dev": "Set the pending governor, which will be the governor once accepted.",
        "@param1": "_pendingGovernor The address to become the pending governor.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "acceptGovernor",
        "visibility": "external",
        "args": [],
        "func": "function acceptGovernor() external {\n    require(msg.sender == pendingGovernor, 'not the pending governor');\n    pendingGovernor = address(0);\n    governor = msg.sender;\n  }",
        "comments": [
            "",
            "  /// @dev Accept to become the new governor. Must be called by the pending governor.",
            "  "
        ],
        "comt": "\n  /// @dev Accept to become the new governor. Must be called by the pending governor.\n  ",
        "@dev": "Accept to become the new governor. Must be called by the pending governor.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getUnderlyingToken",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint"
            }
        ],
        "func": "function getUnderlyingToken(uint id) external view override returns (address) {\n    address token = address(id);\n    require(uint(token) == id, 'id overflow');\n    return token;\n  }",
        "comments": [
            "",
            "  /// @dev Return the underlying ERC-20 for the given ERC-1155 token id.",
            "  "
        ],
        "comt": "\n  /// @dev Return the underlying ERC-20 for the given ERC-1155 token id.\n  ",
        "@dev": "Return the underlying ERC-20 for the given ERC-1155 token id.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getUnderlyingRate",
        "visibility": "external",
        "args": [
            {
                "name": "uint",
                "type": "uint"
            }
        ],
        "func": "function getUnderlyingRate(uint) external view override returns (uint) {\n    return 2**112;\n  }",
        "comments": [
            "",
            "  /// @dev Return the conversion rate from ERC-1155 to ERC-20, multiplied by 2**112.",
            "  "
        ],
        "comt": "\n  /// @dev Return the conversion rate from ERC-1155 to ERC-20, multiplied by 2**112.\n  ",
        "@dev": "Return the conversion rate from ERC-1155 to ERC-20, multiplied by 2**112.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOfERC20",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "user",
                "type": "address"
            }
        ],
        "func": "function balanceOfERC20(address token, address user) external view override returns (uint) {\n    return balanceOf(user, uint(token));\n  }",
        "comments": [
            "",
            "  /// @dev Return the underlying ERC20 balance for the user.",
            "  "
        ],
        "comt": "\n  /// @dev Return the underlying ERC20 balance for the user.\n  ",
        "@dev": "Return the underlying ERC20 balance for the user.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function mint(address token, uint amount) external override nonReentrant {\n    uint balanceBefore = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n    uint balanceAfter = IERC20(token).balanceOf(address(this));\n    _mint(msg.sender, uint(token), balanceAfter.sub(balanceBefore), '');\n  }",
        "comments": [
            "",
            "  /// @dev Mint ERC1155 token for the given ERC20 token.",
            "  "
        ],
        "comt": "\n  /// @dev Mint ERC1155 token for the given ERC20 token.\n  ",
        "@dev": "Mint ERC1155 token for the given ERC20 token.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function burn(address token, uint amount) external override nonReentrant {\n    _burn(msg.sender, uint(token), amount);\n    IERC20(token).safeTransfer(msg.sender, amount);\n  }",
        "comments": [
            "",
            "  /// @dev Burn ERC1155 token to redeem ERC20 token back.",
            "  "
        ],
        "comt": "\n  /// @dev Burn ERC1155 token to redeem ERC20 token back.\n  ",
        "@dev": "Burn ERC1155 token to redeem ERC20 token back.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getUnderlyingToken",
        "visibility": "external",
        "args": [
            {
                "name": "uint",
                "type": "uint"
            }
        ],
        "func": "function getUnderlyingToken(uint) external view override returns (address) {\n    return underlying;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getUnderlyingRate",
        "visibility": "external",
        "args": [
            {
                "name": "uint",
                "type": "uint"
            }
        ],
        "func": "function getUnderlyingRate(uint) external view override returns (uint) {\n    return 2**112;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function mint(uint amount) external nonReentrant returns (uint) {\n    IERC20(underlying).safeTransferFrom(msg.sender, address(this), amount);\n    IStakingRewards(staking).stake(amount);\n    uint rewardPerToken = IStakingRewards(staking).rewardPerToken();\n    _mint(msg.sender, rewardPerToken, amount, '');\n    return rewardPerToken;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint"
            },
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function burn(uint id, uint amount) external nonReentrant returns (uint) {\n    if (amount == uint(-1)) {\n      amount = balanceOf(msg.sender, id);\n    }\n    _burn(msg.sender, id, amount);\n    IStakingRewards(staking).withdraw(amount);\n    IStakingRewards(staking).getReward();\n    IERC20(underlying).safeTransfer(msg.sender, amount);\n    uint stRewardPerToken = id;\n    uint enRewardPerToken = IStakingRewards(staking).rewardPerToken();\n    uint stReward = stRewardPerToken.mul(amount).divCeil(1e18);\n    uint enReward = enRewardPerToken.mul(amount).div(1e18);\n    if (enReward > stReward) {\n      IERC20(reward).safeTransfer(msg.sender, enReward.sub(stReward));\n    }\n    return enRewardPerToken;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "encodeId",
        "visibility": "public",
        "args": [
            {
                "name": "pid",
                "type": "uint"
            },
            {
                "name": "gid",
                "type": "uint"
            },
            {
                "name": "crvPerShare",
                "type": "uint"
            }
        ],
        "func": "function encodeId(\n    uint pid,\n    uint gid,\n    uint crvPerShare\n  ) public pure returns (uint id) {\n    require(pid < (1 << 8), 'bad pid');\n    require(gid < (1 << 8), 'bad gid');\n    require(crvPerShare < (1 << 240), 'bad crv per share');\n    return (pid << 248) | (gid << 240) | crvPerShare;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decodeId",
        "visibility": "public",
        "args": [
            {
                "name": "id",
                "type": "uint"
            }
        ],
        "func": "function decodeId(uint id)\n    public\n    pure\n    returns (\n      uint pid,\n      uint gid,\n      uint crvPerShare\n    )\n  {\n    pid = id >> 248; // First 8 bits\n    gid = (id >> 240) & (255); // Next 8 bits\n    crvPerShare = id & ((1 << 240) - 1); // Last 240 bits\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getUnderlyingToken",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint"
            }
        ],
        "func": "function getUnderlyingToken(uint id) external view override returns (address) {\n    (uint pid, uint gid, ) = decodeId(id);\n    ILiquidityGauge impl = gauges[pid][gid].impl;\n    require(address(impl) != address(0), 'no gauge');\n    return impl.lp_token();\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getUnderlyingRate",
        "visibility": "external",
        "args": [
            {
                "name": "uint",
                "type": "uint"
            }
        ],
        "func": "function getUnderlyingRate(uint) external view override returns (uint) {\n    return 2**112;\n  }",
        "comments": [
            "",
            "  /// @dev Return the conversion rate from ERC-1155 to ERC-20, multiplied by 2**112.",
            "  "
        ],
        "comt": "\n  /// @dev Return the conversion rate from ERC-1155 to ERC-20, multiplied by 2**112.\n  ",
        "@dev": "Return the conversion rate from ERC-1155 to ERC-20, multiplied by 2**112.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "registerGauge",
        "visibility": "external",
        "args": [
            {
                "name": "pid",
                "type": "uint"
            },
            {
                "name": "gid",
                "type": "uint"
            }
        ],
        "func": "function registerGauge(uint pid, uint gid) external onlyGov {\n    require(address(gauges[pid][gid].impl) == address(0), 'gauge already exists');\n    address pool = registry.pool_list(pid);\n    require(pool != address(0), 'no pool');\n    (address[10] memory _gauges, ) = registry.get_gauges(pool);\n    address gauge = _gauges[gid];\n    require(gauge != address(0), 'no gauge');\n    IERC20 lpToken = IERC20(ILiquidityGauge(gauge).lp_token());\n    lpToken.approve(gauge, 0);\n    lpToken.approve(gauge, uint(-1));\n    gauges[pid][gid] = GaugeInfo({impl: ILiquidityGauge(gauge), accCrvPerShare: 0});\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "external",
        "args": [
            {
                "name": "pid",
                "type": "uint"
            },
            {
                "name": "gid",
                "type": "uint"
            },
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function mint(\n    uint pid,\n    uint gid,\n    uint amount\n  ) external nonReentrant returns (uint) {\n    GaugeInfo storage gauge = gauges[pid][gid];\n    ILiquidityGauge impl = gauge.impl;\n    require(address(impl) != address(0), 'gauge not registered');\n    mintCrv(gauge);\n    IERC20 lpToken = IERC20(impl.lp_token());\n    lpToken.safeTransferFrom(msg.sender, address(this), amount);\n    impl.deposit(amount);\n    uint id = encodeId(pid, gid, gauge.accCrvPerShare);\n    _mint(msg.sender, id, amount, '');\n    return id;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint"
            },
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function burn(uint id, uint amount) external nonReentrant returns (uint) {\n    if (amount == uint(-1)) {\n      amount = balanceOf(msg.sender, id);\n    }\n    (uint pid, uint gid, uint stCrvPerShare) = decodeId(id);\n    _burn(msg.sender, id, amount);\n    GaugeInfo storage gauge = gauges[pid][gid];\n    ILiquidityGauge impl = gauge.impl;\n    require(address(impl) != address(0), 'gauge not registered');\n    mintCrv(gauge);\n    impl.withdraw(amount);\n    IERC20(impl.lp_token()).safeTransfer(msg.sender, amount);\n    uint stCrv = stCrvPerShare.mul(amount).divCeil(1e18);\n    uint enCrv = gauge.accCrvPerShare.mul(amount).div(1e18);\n    if (enCrv > stCrv) {\n      crv.safeTransfer(msg.sender, enCrv.sub(stCrv));\n    }\n    return pid;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "encodeId",
        "visibility": "public",
        "args": [
            {
                "name": "pid",
                "type": "uint"
            },
            {
                "name": "sushiPerShare",
                "type": "uint"
            }
        ],
        "func": "function encodeId(uint pid, uint sushiPerShare) public pure returns (uint id) {\n    require(pid < (1 << 16), 'bad pid');\n    require(sushiPerShare < (1 << 240), 'bad sushi per share');\n    return (pid << 240) | sushiPerShare;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decodeId",
        "visibility": "public",
        "args": [
            {
                "name": "id",
                "type": "uint"
            }
        ],
        "func": "function decodeId(uint id) public pure returns (uint pid, uint sushiPerShare) {\n    pid = id >> 240; // First 16 bits\n    sushiPerShare = id & ((1 << 240) - 1); // Last 240 bits\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getUnderlyingToken",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint"
            }
        ],
        "func": "function getUnderlyingToken(uint id) external view override returns (address) {\n    (uint pid, ) = decodeId(id);\n    (address lpToken, , , ) = chef.poolInfo(pid);\n    return lpToken;\n  }",
        "comments": [
            "",
            "  /// @dev Return the underlying ERC-20 for the given ERC-1155 token id.",
            "  "
        ],
        "comt": "\n  /// @dev Return the underlying ERC-20 for the given ERC-1155 token id.\n  ",
        "@dev": "Return the underlying ERC-20 for the given ERC-1155 token id.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getUnderlyingRate",
        "visibility": "external",
        "args": [
            {
                "name": "uint",
                "type": "uint"
            }
        ],
        "func": "function getUnderlyingRate(uint) external view override returns (uint) {\n    return 2**112;\n  }",
        "comments": [
            "",
            "  /// @dev Return the conversion rate from ERC-1155 to ERC-20, multiplied by 2**112.",
            "  "
        ],
        "comt": "\n  /// @dev Return the conversion rate from ERC-1155 to ERC-20, multiplied by 2**112.\n  ",
        "@dev": "Return the conversion rate from ERC-1155 to ERC-20, multiplied by 2**112.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "external",
        "args": [
            {
                "name": "pid",
                "type": "uint"
            },
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function mint(uint pid, uint amount) external nonReentrant returns (uint) {\n    (address lpToken, , , ) = chef.poolInfo(pid);\n    IERC20(lpToken).safeTransferFrom(msg.sender, address(this), amount);\n    if (IERC20(lpToken).allowance(address(this), address(chef)) != uint(-1)) {\n      // We only need to do this once per pool, as LP token's allowance won't decrease if it's -1.\n      IERC20(lpToken).approve(address(chef), uint(-1));\n    }\n    chef.deposit(pid, amount);\n    (, , , uint sushiPerShare) = chef.poolInfo(pid);\n    uint id = encodeId(pid, sushiPerShare);\n    _mint(msg.sender, id, amount, '');\n    return id;\n  }",
        "comments": [
            "",
            "  /// @dev Mint ERC1155 token for the given pool id.",
            "  /// @return The token id that got minted.",
            "  "
        ],
        "comt": "\n  /// @dev Mint ERC1155 token for the given pool id.\n  /// @return The token id that got minted.\n  ",
        "@dev": "Mint ERC1155 token for the given pool id.",
        "@return1": "The token id that got minted.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint"
            },
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function burn(uint id, uint amount) external nonReentrant returns (uint) {\n    if (amount == uint(-1)) {\n      amount = balanceOf(msg.sender, id);\n    }\n    (uint pid, uint stSushiPerShare) = decodeId(id);\n    _burn(msg.sender, id, amount);\n    chef.withdraw(pid, amount);\n    (address lpToken, , , uint enSushiPerShare) = chef.poolInfo(pid);\n    IERC20(lpToken).safeTransfer(msg.sender, amount);\n    uint stSushi = stSushiPerShare.mul(amount).divCeil(1e12);\n    uint enSushi = enSushiPerShare.mul(amount).div(1e12);\n    if (enSushi > stSushi) {\n      sushi.safeTransfer(msg.sender, enSushi.sub(stSushi));\n    }\n    return pid;\n  }",
        "comments": [
            "",
            "  /// @dev Burn ERC1155 token to redeem LP ERC20 token back plus SUSHI rewards.",
            "  /// @return The pool id that that you received LP token back.",
            "  "
        ],
        "comt": "\n  /// @dev Burn ERC1155 token to redeem LP ERC20 token back plus SUSHI rewards.\n  /// @return The pool id that that you received LP token back.\n  ",
        "@dev": "Burn ERC1155 token to redeem LP ERC20 token back plus SUSHI rewards.",
        "@return1": "The pool id that that you received LP token back.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "emergencyBurn",
        "visibility": "external",
        "args": [
            {
                "name": "id",
                "type": "uint"
            },
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function emergencyBurn(uint id, uint amount) external nonReentrant returns (uint) {\n    (uint pid, ) = decodeId(id);\n    _burn(msg.sender, id, amount);\n    chef.withdraw(pid, amount);\n    (address lpToken, , , ) = chef.poolInfo(pid);\n    IERC20(lpToken).safeTransfer(msg.sender, amount);\n    return pid;\n  }",
        "comments": [
            "",
            "  /// @dev Burn ERC1155 token to redeem LP ERC20 token back without taking SUSHI rewards.",
            "  /// @return The pool id that that you received LP token back.",
            "  "
        ],
        "comt": "\n  /// @dev Burn ERC1155 token to redeem LP ERC20 token back without taking SUSHI rewards.\n  /// @return The pool id that that you received LP token back.\n  ",
        "@dev": "Burn ERC1155 token to redeem LP ERC20 token back without taking SUSHI rewards.",
        "@return1": "The pool id that that you received LP token back.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPair",
        "visibility": "public",
        "args": [
            {
                "name": "tokenA",
                "type": "address"
            },
            {
                "name": "tokenB",
                "type": "address"
            }
        ],
        "func": "function getPair(address tokenA, address tokenB) public returns (address) {\n    address lp = pairs[tokenA][tokenB];\n    if (lp == address(0)) {\n      lp = factory.getPair(tokenA, tokenB);\n      require(lp != address(0), 'no lp token');\n      ensureApprove(tokenA, address(router));\n      ensureApprove(tokenB, address(router));\n      ensureApprove(lp, address(router));\n      pairs[tokenA][tokenB] = lp;\n      pairs[tokenB][tokenA] = lp;\n    }\n    return lp;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addLiquidityWERC20",
        "visibility": "external",
        "args": [
            {
                "name": "tokenA",
                "type": "address"
            },
            {
                "name": "tokenB",
                "type": "address"
            },
            {
                "name": "amt",
                "type": "Amounts calldata"
            }
        ],
        "func": "function addLiquidityWERC20(\n    address tokenA,\n    address tokenB,\n    Amounts calldata amt\n  ) external payable {\n    address lp = getPair(tokenA, tokenB);\n    // 1-5. add liquidity\n    addLiquidityInternal(tokenA, tokenB, amt);\n\n    // 6. Put collateral\n    doPutCollateral(lp, IERC20(lp).balanceOf(address(this)));\n\n    // 7. Refund leftovers to users\n    doRefundETH();\n    doRefund(tokenA);\n    doRefund(tokenB);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addLiquidityWStakingRewards",
        "visibility": "external",
        "args": [
            {
                "name": "tokenA",
                "type": "address"
            },
            {
                "name": "tokenB",
                "type": "address"
            },
            {
                "name": "amt",
                "type": "Amounts calldata"
            },
            {
                "name": "wstaking",
                "type": "address"
            }
        ],
        "func": "function addLiquidityWStakingRewards(\n    address tokenA,\n    address tokenB,\n    Amounts calldata amt,\n    address wstaking\n  ) external payable {\n    address lp = getPair(tokenA, tokenB);\n    address reward = IWStakingRewards(wstaking).reward();\n\n    // 1-5. add liquidity\n    addLiquidityInternal(tokenA, tokenB, amt);\n\n    // 6. Take out collateral\n    uint positionId = bank.POSITION_ID();\n    (, address collToken, uint collId, uint collSize) = bank.getPositionInfo(positionId);\n    if (collSize > 0) {\n      require(IWStakingRewards(collToken).getUnderlyingToken(collId) == lp, 'incorrect underlying');\n      bank.takeCollateral(wstaking, collId, collSize);\n      IWStakingRewards(wstaking).burn(collId, collSize);\n    }\n\n    // 7. Put collateral\n    ensureApprove(lp, wstaking);\n    uint amount = IERC20(lp).balanceOf(address(this));\n    uint id = IWStakingRewards(wstaking).mint(amount);\n    if (!IWStakingRewards(wstaking).isApprovedForAll(address(this), address(bank))) {\n      IWStakingRewards(wstaking).setApprovalForAll(address(bank), true);\n    }\n    bank.putCollateral(address(wstaking), id, amount);\n\n    // 8. Refund leftovers to users\n    doRefundETH();\n    doRefund(tokenA);\n    doRefund(tokenB);\n\n    // 9. Refund reward\n    doRefund(reward);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityWERC20",
        "visibility": "external",
        "args": [
            {
                "name": "tokenA",
                "type": "address"
            },
            {
                "name": "tokenB",
                "type": "address"
            },
            {
                "name": "amt",
                "type": "RepayAmounts calldata"
            }
        ],
        "func": "function removeLiquidityWERC20(\n    address tokenA,\n    address tokenB,\n    RepayAmounts calldata amt\n  ) external {\n    address lp = getPair(tokenA, tokenB);\n\n    // 1. Take out collateral\n    doTakeCollateral(lp, amt.amtLPTake);\n\n    // 2-8. remove liquidity\n    removeLiquidityInternal(tokenA, tokenB, amt);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityWStakingRewards",
        "visibility": "external",
        "args": [
            {
                "name": "tokenA",
                "type": "address"
            },
            {
                "name": "tokenB",
                "type": "address"
            },
            {
                "name": "amt",
                "type": "RepayAmounts calldata"
            },
            {
                "name": "wstaking",
                "type": "address"
            }
        ],
        "func": "function removeLiquidityWStakingRewards(\n    address tokenA,\n    address tokenB,\n    RepayAmounts calldata amt,\n    address wstaking\n  ) external {\n    address lp = getPair(tokenA, tokenB);\n    uint positionId = bank.POSITION_ID();\n    (, address collToken, uint collId, ) = bank.getPositionInfo(positionId);\n    address reward = IWStakingRewards(wstaking).reward();\n\n    // 1. Take out collateral\n    require(IWStakingRewards(collToken).getUnderlyingToken(collId) == lp, 'incorrect underlying');\n    bank.takeCollateral(wstaking, collId, amt.amtLPTake);\n    IWStakingRewards(wstaking).burn(collId, amt.amtLPTake);\n\n    // 2-8. remove liquidity\n    removeLiquidityInternal(tokenA, tokenB, amt);\n\n    // 9. Refund reward\n    doRefund(reward);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "harvestWStakingRewards",
        "visibility": "external",
        "args": [
            {
                "name": "wstaking",
                "type": "address"
            }
        ],
        "func": "function harvestWStakingRewards(address wstaking) external {\n    address reward = IWStakingRewards(wstaking).reward();\n    uint positionId = bank.POSITION_ID();\n    (, , uint collId, ) = bank.getPositionInfo(positionId);\n    address lp = IWStakingRewards(wstaking).getUnderlyingToken(collId);\n\n    // 1. Take out collateral\n    bank.takeCollateral(wstaking, collId, uint(-1));\n    IWStakingRewards(wstaking).burn(collId, uint(-1));\n\n    // 2. put collateral\n    uint amount = IERC20(lp).balanceOf(address(this));\n    ensureApprove(lp, wstaking);\n    uint id = IWStakingRewards(wstaking).mint(amount);\n    bank.putCollateral(wstaking, id, amount);\n\n    // 3. Refund reward\n    doRefund(reward);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "ensureApprove",
        "visibility": "public",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            }
        ],
        "func": "function ensureApprove(address token, address spender) public {\n    if (!approved[token][spender]) {\n      IERC20(token).safeApprove(spender, uint(-1));\n      approved[token][spender] = true;\n    }\n  }",
        "comments": [
            "",
            "  /// @dev Ensure that the spell approve the given spender to spend all of its tokens.",
            "  /// @param token The token to approve.",
            "  /// @param spender The spender to allow spending.",
            "  /// NOTE: This is safe because spell is never built to hold fund custody.",
            "  "
        ],
        "comt": "\n  /// @dev Ensure that the spell approve the given spender to spend all of its tokens.\n  /// @param token The token to approve.\n  /// @param spender The spender to allow spending.\n  /// NOTE: This is safe because spell is never built to hold fund custody.\n  ",
        "@dev": "Ensure that the spell approve the given spender to spend all of its tokens.",
        "@param1": "token The token to approve.",
        "@param2": "spender The spender to allow spending. /// NOTE: This is safe because spell is never built to hold fund custody.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "onERC1155Received",
        "visibility": "external",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint"
            },
            {
                "name": "value",
                "type": "uint"
            },
            {
                "name": "data",
                "type": "bytes calldata"
            }
        ],
        "func": "function onERC1155Received(\n    address operator,\n    address from,\n    uint id,\n    uint value,\n    bytes calldata data\n  ) external override returns (bytes4) {\n    return this.onERC1155Received.selector;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "onERC1155BatchReceived",
        "visibility": "external",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "ids",
                "type": "uint[] calldata"
            },
            {
                "name": "values",
                "type": "uint[] calldata"
            },
            {
                "name": "data",
                "type": "bytes calldata"
            }
        ],
        "func": "function onERC1155BatchReceived(\n    address operator,\n    address from,\n    uint[] calldata ids,\n    uint[] calldata values,\n    bytes calldata data\n  ) external override returns (bytes4) {\n    return this.onERC1155BatchReceived.selector;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPool",
        "visibility": "public",
        "args": [
            {
                "name": "lp",
                "type": "address"
            }
        ],
        "func": "function getPool(address lp) public returns (address) {\n    address pool = poolOf[lp];\n    if (pool == address(0)) {\n      require(lp != address(0), 'no lp token');\n      pool = registry.get_pool_from_lp_token(lp);\n      require(pool != address(0), 'no corresponding pool for lp token');\n      poolOf[lp] = pool;\n      uint n = registry.get_n_coins(pool);\n      address[8] memory tokens = registry.get_coins(pool);\n      ulTokens[lp] = new address[](n);\n      for (uint i = 0; i < n; i++) {\n        ulTokens[lp][i] = tokens[i];\n      }\n    }\n    return pool;\n  }",
        "comments": [
            "",
            "  /// @dev Return pool address given LP token and update pool info if not exist.",
            "  /// @param lp LP token to find the corresponding pool.",
            "  "
        ],
        "comt": "\n  /// @dev Return pool address given LP token and update pool info if not exist.\n  /// @param lp LP token to find the corresponding pool.\n  ",
        "@dev": "Return pool address given LP token and update pool info if not exist.",
        "@param1": "lp LP token to find the corresponding pool.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "ensureApproveN",
        "visibility": "public",
        "args": [
            {
                "name": "lp",
                "type": "address"
            },
            {
                "name": "n",
                "type": "uint"
            }
        ],
        "func": "function ensureApproveN(address lp, uint n) public {\n    require(ulTokens[lp].length == n, 'incorrect pool length');\n    address pool = poolOf[lp];\n    address[] memory tokens = ulTokens[lp];\n    for (uint idx = 0; idx < n; idx++) {\n      ensureApprove(tokens[idx], pool);\n    }\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addLiquidity2",
        "visibility": "external",
        "args": [
            {
                "name": "lp",
                "type": "address"
            },
            {
                "name": "amtsUser",
                "type": "uint[2] calldata"
            },
            {
                "name": "amtLPUser",
                "type": "uint"
            },
            {
                "name": "amtsBorrow",
                "type": "uint[2] calldata"
            },
            {
                "name": "amtLPBorrow",
                "type": "uint"
            },
            {
                "name": "minLPMint",
                "type": "uint"
            },
            {
                "name": "pid",
                "type": "uint"
            },
            {
                "name": "gid",
                "type": "uint"
            }
        ],
        "func": "function addLiquidity2(\n    address lp,\n    uint[2] calldata amtsUser,\n    uint amtLPUser,\n    uint[2] calldata amtsBorrow,\n    uint amtLPBorrow,\n    uint minLPMint,\n    uint pid,\n    uint gid\n  ) external {\n    address pool = getPool(lp);\n    require(ulTokens[lp].length == 2, 'incorrect pool length');\n    require(wgauge.getUnderlyingToken(wgauge.encodeId(pid, gid, 0)) == lp, 'incorrect underlying');\n    address[] memory tokens = ulTokens[lp];\n\n    // 0. Take out collateral\n    uint positionId = bank.POSITION_ID();\n    (, , uint collId, uint collSize) = bank.getPositionInfo(positionId);\n    if (collSize > 0) {\n      (uint decodedPid, uint decodedGid, ) = wgauge.decodeId(collId);\n      require(decodedPid == pid && decodedGid == gid, 'incorrect coll id');\n      bank.takeCollateral(address(wgauge), collId, collSize);\n      wgauge.burn(collId, collSize);\n    }\n\n    // 1. Ensure approve 2 underlying tokens\n    ensureApproveN(lp, 2);\n\n    // 2. Get user input amounts\n    for (uint i = 0; i < 2; i++) doTransmit(tokens[i], amtsUser[i]);\n    doTransmit(lp, amtLPUser);\n\n    // 3. Borrow specified amounts\n    for (uint i = 0; i < 2; i++) doBorrow(tokens[i], amtsBorrow[i]);\n    doBorrow(lp, amtLPBorrow);\n\n    // 4. add liquidity\n    uint[2] memory suppliedAmts;\n    for (uint i = 0; i < 2; i++) {\n      suppliedAmts[i] = IERC20(tokens[i]).balanceOf(address(this));\n    }\n    ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n\n    // 5. Put collateral\n    uint amount = IERC20(lp).balanceOf(address(this));\n    ensureApprove(lp, address(wgauge));\n    uint id = wgauge.mint(pid, gid, amount);\n    bank.putCollateral(address(wgauge), id, amount);\n\n    // 6. Refund\n    for (uint i = 0; i < 2; i++) doRefund(tokens[i]);\n\n    // 7. Refund crv\n    doRefund(crv);\n  }",
        "comments": [
            "",
            "  /// @dev add liquidity for pools with 2 underlying tokens",
            "  "
        ],
        "comt": "\n  /// @dev add liquidity for pools with 2 underlying tokens\n  ",
        "@dev": "add liquidity for pools with 2 underlying tokens",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addLiquidity3",
        "visibility": "external",
        "args": [
            {
                "name": "lp",
                "type": "address"
            },
            {
                "name": "amtsUser",
                "type": "uint[3] calldata"
            },
            {
                "name": "amtLPUser",
                "type": "uint"
            },
            {
                "name": "amtsBorrow",
                "type": "uint[3] calldata"
            },
            {
                "name": "amtLPBorrow",
                "type": "uint"
            },
            {
                "name": "minLPMint",
                "type": "uint"
            },
            {
                "name": "pid",
                "type": "uint"
            },
            {
                "name": "gid",
                "type": "uint"
            }
        ],
        "func": "function addLiquidity3(\n    address lp,\n    uint[3] calldata amtsUser,\n    uint amtLPUser,\n    uint[3] calldata amtsBorrow,\n    uint amtLPBorrow,\n    uint minLPMint,\n    uint pid,\n    uint gid\n  ) external {\n    address pool = getPool(lp);\n    require(ulTokens[lp].length == 3, 'incorrect pool length');\n    require(wgauge.getUnderlyingToken(wgauge.encodeId(pid, gid, 0)) == lp, 'incorrect underlying');\n    address[] memory tokens = ulTokens[lp];\n\n    // 0. take out collateral\n    uint positionId = bank.POSITION_ID();\n    (, , uint collId, uint collSize) = bank.getPositionInfo(positionId);\n    if (collSize > 0) {\n      (uint decodedPid, uint decodedGid, ) = wgauge.decodeId(collId);\n      require(decodedPid == pid && decodedGid == gid, 'incorrect coll id');\n      bank.takeCollateral(address(wgauge), collId, collSize);\n      wgauge.burn(collId, collSize);\n    }\n\n    // 1. Ensure approve 3 underlying tokens\n    ensureApproveN(lp, 3);\n\n    // 2. Get user input amounts\n    for (uint i = 0; i < 3; i++) doTransmit(tokens[i], amtsUser[i]);\n    doTransmit(lp, amtLPUser);\n\n    // 3. Borrow specified amounts\n    for (uint i = 0; i < 3; i++) doBorrow(tokens[i], amtsBorrow[i]);\n    doBorrow(lp, amtLPBorrow);\n\n    // 4. add liquidity\n    uint[3] memory suppliedAmts;\n    for (uint i = 0; i < 3; i++) {\n      suppliedAmts[i] = IERC20(tokens[i]).balanceOf(address(this));\n    }\n    ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n\n    // 5. put collateral\n    uint amount = IERC20(lp).balanceOf(address(this));\n    ensureApprove(lp, address(wgauge));\n    uint id = wgauge.mint(pid, gid, amount);\n    bank.putCollateral(address(wgauge), id, amount);\n\n    // 6. Refund\n    for (uint i = 0; i < 3; i++) doRefund(tokens[i]);\n\n    // 7. Refund crv\n    doRefund(crv);\n  }",
        "comments": [
            "",
            "  /// @dev add liquidity for pools with 3 underlying tokens",
            "  "
        ],
        "comt": "\n  /// @dev add liquidity for pools with 3 underlying tokens\n  ",
        "@dev": "add liquidity for pools with 3 underlying tokens",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addLiquidity4",
        "visibility": "external",
        "args": [
            {
                "name": "lp",
                "type": "address"
            },
            {
                "name": "amtsUser",
                "type": "uint[4] calldata"
            },
            {
                "name": "amtLPUser",
                "type": "uint"
            },
            {
                "name": "amtsBorrow",
                "type": "uint[4] calldata"
            },
            {
                "name": "amtLPBorrow",
                "type": "uint"
            },
            {
                "name": "minLPMint",
                "type": "uint"
            },
            {
                "name": "pid",
                "type": "uint"
            },
            {
                "name": "gid",
                "type": "uint"
            }
        ],
        "func": "function addLiquidity4(\n    address lp,\n    uint[4] calldata amtsUser,\n    uint amtLPUser,\n    uint[4] calldata amtsBorrow,\n    uint amtLPBorrow,\n    uint minLPMint,\n    uint pid,\n    uint gid\n  ) external {\n    address pool = getPool(lp);\n    require(ulTokens[lp].length == 4, 'incorrect pool length');\n    require(wgauge.getUnderlyingToken(wgauge.encodeId(pid, gid, 0)) == lp, 'incorrect underlying');\n    address[] memory tokens = ulTokens[lp];\n\n    // 0. Take out collateral\n    uint positionId = bank.POSITION_ID();\n    (, , uint collId, uint collSize) = bank.getPositionInfo(positionId);\n    if (collSize > 0) {\n      (uint decodedPid, uint decodedGid, ) = wgauge.decodeId(collId);\n      require(decodedPid == pid && decodedGid == gid, 'incorrect coll id');\n      bank.takeCollateral(address(wgauge), collId, collSize);\n      wgauge.burn(collId, collSize);\n    }\n\n    // 1. Ensure approve 4 underlying tokens\n    ensureApproveN(lp, 4);\n\n    // 2. Get user input amounts\n    for (uint i = 0; i < 4; i++) doTransmit(tokens[i], amtsUser[i]);\n    doTransmit(lp, amtLPUser);\n\n    // 3. Borrow specified amounts\n    for (uint i = 0; i < 4; i++) doBorrow(tokens[i], amtsBorrow[i]);\n    doBorrow(lp, amtLPBorrow);\n\n    // 4. add liquidity\n    uint[4] memory suppliedAmts;\n    for (uint i = 0; i < 4; i++) {\n      suppliedAmts[i] = IERC20(tokens[i]).balanceOf(address(this));\n    }\n    ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n\n    // 5. Put collateral\n    uint amount = IERC20(lp).balanceOf(address(this));\n    ensureApprove(lp, address(wgauge));\n    uint id = wgauge.mint(pid, gid, amount);\n    bank.putCollateral(address(wgauge), id, amount);\n\n    // 6. Refund\n    for (uint i = 0; i < 4; i++) doRefund(tokens[i]);\n\n    // 7. Refund crv\n    doRefund(crv);\n  }",
        "comments": [
            "",
            "  /// @dev add liquidity for pools with 4 underlying tokens",
            "  "
        ],
        "comt": "\n  /// @dev add liquidity for pools with 4 underlying tokens\n  ",
        "@dev": "add liquidity for pools with 4 underlying tokens",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidity2",
        "visibility": "external",
        "args": [
            {
                "name": "lp",
                "type": "address"
            },
            {
                "name": "amtLPTake",
                "type": "uint"
            },
            {
                "name": "amtLPWithdraw",
                "type": "uint"
            },
            {
                "name": "amtsRepay",
                "type": "uint[2] calldata"
            },
            {
                "name": "amtLPRepay",
                "type": "uint"
            },
            {
                "name": "amtsMin",
                "type": "uint[2] calldata"
            }
        ],
        "func": "function removeLiquidity2(\n    address lp,\n    uint amtLPTake,\n    uint amtLPWithdraw,\n    uint[2] calldata amtsRepay,\n    uint amtLPRepay,\n    uint[2] calldata amtsMin\n  ) external {\n    address pool = getPool(lp);\n    uint positionId = bank.POSITION_ID();\n    (, address collToken, uint collId, ) = bank.getPositionInfo(positionId);\n    require(IWLiquidityGauge(collToken).getUnderlyingToken(collId) == lp, 'incorrect underlying');\n    address[] memory tokens = ulTokens[lp];\n\n    // 0. Ensure approve\n    ensureApproveN(lp, 2);\n\n    // 1. Compute repay amount if MAX_INT is supplied (max debt)\n    uint[2] memory actualAmtsRepay;\n    for (uint i = 0; i < 2; i++) {\n      actualAmtsRepay[i] = amtsRepay[i] == uint(-1)\n        ? bank.borrowBalanceCurrent(positionId, tokens[i])\n        : amtsRepay[i];\n    }\n    uint[2] memory amtsDesired;\n    for (uint i = 0; i < 2; i++) {\n      amtsDesired[i] = actualAmtsRepay[i].add(amtsMin[i]); // repay amt + slippage control\n    }\n\n    // 2. Take out collateral\n    bank.takeCollateral(address(wgauge), collId, amtLPTake);\n    wgauge.burn(collId, amtLPTake);\n\n    // 3. Compute amount to actually remove. Remove to repay just enough\n    uint amtLPToRemove;\n    if (amtsDesired[0] > 0 || amtsDesired[1] > 0) {\n      amtLPToRemove = IERC20(lp).balanceOf(address(this)).sub(amtLPWithdraw);\n      ICurvePool(pool).remove_liquidity_imbalance(amtsDesired, amtLPToRemove);\n    }\n\n    // 4. Compute leftover amount to remove. Remove balancedly.\n    amtLPToRemove = IERC20(lp).balanceOf(address(this)).sub(amtLPWithdraw);\n    uint[2] memory mins;\n    ICurvePool(pool).remove_liquidity(amtLPToRemove, mins);\n\n    // 5. Repay\n    for (uint i = 0; i < 2; i++) {\n      doRepay(tokens[i], actualAmtsRepay[i]);\n    }\n    doRepay(lp, amtLPRepay);\n\n    // 6. Refund\n    for (uint i = 0; i < 2; i++) {\n      doRefund(tokens[i]);\n    }\n    doRefund(lp);\n\n    // 7. Refund crv\n    doRefund(crv);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidity3",
        "visibility": "external",
        "args": [
            {
                "name": "lp",
                "type": "address"
            },
            {
                "name": "amtLPTake",
                "type": "uint"
            },
            {
                "name": "amtLPWithdraw",
                "type": "uint"
            },
            {
                "name": "amtsRepay",
                "type": "uint[3] calldata"
            },
            {
                "name": "amtLPRepay",
                "type": "uint"
            },
            {
                "name": "amtsMin",
                "type": "uint[3] calldata"
            }
        ],
        "func": "function removeLiquidity3(\n    address lp,\n    uint amtLPTake,\n    uint amtLPWithdraw,\n    uint[3] calldata amtsRepay,\n    uint amtLPRepay,\n    uint[3] calldata amtsMin\n  ) external {\n    address pool = getPool(lp);\n    uint positionId = bank.POSITION_ID();\n    (, address collToken, uint collId, ) = bank.getPositionInfo(positionId);\n    require(IWLiquidityGauge(collToken).getUnderlyingToken(collId) == lp, 'incorrect underlying');\n    address[] memory tokens = ulTokens[lp];\n\n    // 0. Ensure approve\n    ensureApproveN(lp, 3);\n\n    // 1. Compute repay amount if MAX_INT is supplied (max debt)\n    uint[3] memory actualAmtsRepay;\n    for (uint i = 0; i < 3; i++) {\n      actualAmtsRepay[i] = amtsRepay[i] == uint(-1)\n        ? bank.borrowBalanceCurrent(positionId, tokens[i])\n        : amtsRepay[i];\n    }\n    uint[3] memory amtsDesired;\n    for (uint i = 0; i < 3; i++) {\n      amtsDesired[i] = actualAmtsRepay[i].add(amtsMin[i]); // repay amt + slippage control\n    }\n\n    // 2. Take out collateral\n    bank.takeCollateral(address(wgauge), collId, amtLPTake);\n    wgauge.burn(collId, amtLPTake);\n\n    // 3. Compute amount to actually remove. Remove to repay just enough\n    uint amtLPToRemove;\n    if (amtsDesired[0] > 0 || amtsDesired[1] > 0 || amtsDesired[2] > 0) {\n      amtLPToRemove = IERC20(lp).balanceOf(address(this)).sub(amtLPWithdraw);\n      ICurvePool(pool).remove_liquidity_imbalance(amtsDesired, amtLPToRemove);\n    }\n\n    // 4. Compute leftover amount to remove. Remove balancedly.\n    amtLPToRemove = IERC20(lp).balanceOf(address(this)).sub(amtLPWithdraw);\n    uint[3] memory mins;\n    ICurvePool(pool).remove_liquidity(amtLPToRemove, mins);\n\n    // 5. Repay\n    for (uint i = 0; i < 3; i++) {\n      doRepay(tokens[i], actualAmtsRepay[i]);\n    }\n    doRepay(lp, amtLPRepay);\n\n    // 6. Refund\n    for (uint i = 0; i < 3; i++) {\n      doRefund(tokens[i]);\n    }\n    doRefund(lp);\n\n    // 7. Refund crv\n    doRefund(crv);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidity4",
        "visibility": "external",
        "args": [
            {
                "name": "lp",
                "type": "address"
            },
            {
                "name": "amtLPTake",
                "type": "uint"
            },
            {
                "name": "amtLPWithdraw",
                "type": "uint"
            },
            {
                "name": "amtsRepay",
                "type": "uint[4] calldata"
            },
            {
                "name": "amtLPRepay",
                "type": "uint"
            },
            {
                "name": "amtsMin",
                "type": "uint[4] calldata"
            }
        ],
        "func": "function removeLiquidity4(\n    address lp,\n    uint amtLPTake,\n    uint amtLPWithdraw,\n    uint[4] calldata amtsRepay,\n    uint amtLPRepay,\n    uint[4] calldata amtsMin\n  ) external {\n    address pool = getPool(lp);\n    uint positionId = bank.POSITION_ID();\n    (, address collToken, uint collId, ) = bank.getPositionInfo(positionId);\n    require(IWLiquidityGauge(collToken).getUnderlyingToken(collId) == lp, 'incorrect underlying');\n    address[] memory tokens = ulTokens[lp];\n\n    // 0. Ensure approve\n    ensureApproveN(lp, 4);\n\n    // 1. Compute repay amount if MAX_INT is supplied (max debt)\n    uint[4] memory actualAmtsRepay;\n    for (uint i = 0; i < 4; i++) {\n      actualAmtsRepay[i] = amtsRepay[i] == uint(-1)\n        ? bank.borrowBalanceCurrent(positionId, tokens[i])\n        : amtsRepay[i];\n    }\n    uint[4] memory amtsDesired;\n    for (uint i = 0; i < 4; i++) {\n      amtsDesired[i] = actualAmtsRepay[i].add(amtsMin[i]); // repay amt + slippage control\n    }\n\n    // 2. Take out collateral\n    bank.takeCollateral(address(wgauge), collId, amtLPTake);\n    wgauge.burn(collId, amtLPTake);\n\n    // 3. Compute amount to actually remove. Remove to repay just enough\n    uint amtLPToRemove;\n    if (amtsDesired[0] > 0 || amtsDesired[1] > 0 || amtsDesired[2] > 0 || amtsDesired[3] > 0) {\n      amtLPToRemove = IERC20(lp).balanceOf(address(this)).sub(amtLPWithdraw);\n      ICurvePool(pool).remove_liquidity_imbalance(amtsDesired, amtLPToRemove);\n    }\n\n    // 4. Compute leftover amount to remove. Remove balancedly.\n    amtLPToRemove = IERC20(lp).balanceOf(address(this)).sub(amtLPWithdraw);\n    uint[4] memory mins;\n    ICurvePool(pool).remove_liquidity(amtLPToRemove, mins);\n\n    // 5. Repay\n    for (uint i = 0; i < 4; i++) {\n      doRepay(tokens[i], actualAmtsRepay[i]);\n    }\n    doRepay(lp, amtLPRepay);\n\n    // 6. Refund\n    for (uint i = 0; i < 4; i++) {\n      doRefund(tokens[i]);\n    }\n    doRefund(lp);\n\n    // 7. Refund crv\n    doRefund(crv);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "harvest",
        "visibility": "external",
        "args": [],
        "func": "function harvest() external {\n    uint positionId = bank.POSITION_ID();\n    (, , uint collId, uint collSize) = bank.getPositionInfo(positionId);\n    (uint pid, uint gid, ) = wgauge.decodeId(collId);\n    address lp = wgauge.getUnderlyingToken(collId);\n\n    // 1. Take out collateral\n    bank.takeCollateral(address(wgauge), collId, collSize);\n    wgauge.burn(collId, collSize);\n\n    // 2. Put collateral\n    uint amount = IERC20(lp).balanceOf(address(this));\n    ensureApprove(lp, address(wgauge));\n    uint id = wgauge.mint(pid, gid, amount);\n    bank.putCollateral(address(wgauge), id, amount);\n\n    // 3. Refund crv\n    doRefund(crv);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPair",
        "visibility": "public",
        "args": [
            {
                "name": "tokenA",
                "type": "address"
            },
            {
                "name": "tokenB",
                "type": "address"
            }
        ],
        "func": "function getPair(address tokenA, address tokenB) public returns (address) {\n    address lp = pairs[tokenA][tokenB];\n    if (lp == address(0)) {\n      lp = factory.getPair(tokenA, tokenB);\n      require(lp != address(0), 'no lp token');\n      ensureApprove(tokenA, address(router));\n      ensureApprove(tokenB, address(router));\n      ensureApprove(lp, address(router));\n      pairs[tokenA][tokenB] = lp;\n      pairs[tokenB][tokenA] = lp;\n    }\n    return lp;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addLiquidityWERC20",
        "visibility": "external",
        "args": [
            {
                "name": "tokenA",
                "type": "address"
            },
            {
                "name": "tokenB",
                "type": "address"
            },
            {
                "name": "amt",
                "type": "Amounts calldata"
            }
        ],
        "func": "function addLiquidityWERC20(\n    address tokenA,\n    address tokenB,\n    Amounts calldata amt\n  ) external payable {\n    address lp = getPair(tokenA, tokenB);\n    // 1-5. add liquidity\n    addLiquidityInternal(tokenA, tokenB, amt);\n\n    // 6. Put collateral\n    doPutCollateral(lp, IERC20(lp).balanceOf(address(this)));\n\n    // 7. Refund leftovers to users\n    doRefundETH();\n    doRefund(tokenA);\n    doRefund(tokenB);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addLiquidityWMasterChef",
        "visibility": "external",
        "args": [
            {
                "name": "tokenA",
                "type": "address"
            },
            {
                "name": "tokenB",
                "type": "address"
            },
            {
                "name": "amt",
                "type": "Amounts calldata"
            },
            {
                "name": "pid",
                "type": "uint"
            }
        ],
        "func": "function addLiquidityWMasterChef(\n    address tokenA,\n    address tokenB,\n    Amounts calldata amt,\n    uint pid\n  ) external payable {\n    address lp = getPair(tokenA, tokenB);\n    (address lpToken, , , ) = wmasterchef.chef().poolInfo(pid);\n    require(lpToken == lp, 'incorrect lp token');\n\n    // 1-5. add liquidity\n    addLiquidityInternal(tokenA, tokenB, amt);\n\n    // 6. Take out collateral\n    uint positionId = bank.POSITION_ID();\n    (, , uint collId, uint collSize) = bank.getPositionInfo(positionId);\n    if (collSize > 0) {\n      (uint decodedPid, ) = wmasterchef.decodeId(collId);\n      require(pid == decodedPid, 'incorrect pid');\n      bank.takeCollateral(address(wmasterchef), collId, collSize);\n      wmasterchef.burn(collId, collSize);\n    }\n\n    // 7. Put collateral\n    ensureApprove(lp, address(wmasterchef));\n    uint amount = IERC20(lp).balanceOf(address(this));\n    uint id = wmasterchef.mint(pid, amount);\n    bank.putCollateral(address(wmasterchef), id, amount);\n\n    // 8. Refund leftovers to users\n    doRefundETH();\n    doRefund(tokenA);\n    doRefund(tokenB);\n\n    // 9. Refund sushi\n    doRefund(sushi);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityWERC20",
        "visibility": "external",
        "args": [
            {
                "name": "tokenA",
                "type": "address"
            },
            {
                "name": "tokenB",
                "type": "address"
            },
            {
                "name": "amt",
                "type": "RepayAmounts calldata"
            }
        ],
        "func": "function removeLiquidityWERC20(\n    address tokenA,\n    address tokenB,\n    RepayAmounts calldata amt\n  ) external {\n    address lp = getPair(tokenA, tokenB);\n\n    // 1. Take out collateral\n    doTakeCollateral(lp, amt.amtLPTake);\n\n    // 2-8. remove liquidity\n    removeLiquidityInternal(tokenA, tokenB, amt);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityWMasterChef",
        "visibility": "external",
        "args": [
            {
                "name": "tokenA",
                "type": "address"
            },
            {
                "name": "tokenB",
                "type": "address"
            },
            {
                "name": "amt",
                "type": "RepayAmounts calldata"
            }
        ],
        "func": "function removeLiquidityWMasterChef(\n    address tokenA,\n    address tokenB,\n    RepayAmounts calldata amt\n  ) external {\n    address lp = getPair(tokenA, tokenB);\n    uint positionId = bank.POSITION_ID();\n    (, address collToken, uint collId, ) = bank.getPositionInfo(positionId);\n    require(IWMasterChef(collToken).getUnderlyingToken(collId) == lp, 'incorrect underlying');\n\n    // 1. Take out collateral\n    bank.takeCollateral(address(wmasterchef), collId, amt.amtLPTake);\n    wmasterchef.burn(collId, amt.amtLPTake);\n\n    // 2-8. remove liquidity\n    removeLiquidityInternal(tokenA, tokenB, amt);\n\n    // 9. Refund sushi\n    doRefund(sushi);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "harvestWMasterChef",
        "visibility": "external",
        "args": [],
        "func": "function harvestWMasterChef() external {\n    uint positionId = bank.POSITION_ID();\n    (, , uint collId, ) = bank.getPositionInfo(positionId);\n    (uint pid, ) = wmasterchef.decodeId(collId);\n    address lp = wmasterchef.getUnderlyingToken(collId);\n\n    // 1. Take out collateral\n    bank.takeCollateral(address(wmasterchef), collId, uint(-1));\n    wmasterchef.burn(collId, uint(-1));\n\n    // 2. put collateral\n    uint amount = IERC20(lp).balanceOf(address(this));\n    ensureApprove(lp, address(wmasterchef));\n    uint id = wmasterchef.mint(pid, amount);\n    bank.putCollateral(address(wmasterchef), id, amount);\n\n    // 3. Refund sushi\n    doRefund(sushi);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPair",
        "visibility": "public",
        "args": [
            {
                "name": "lp",
                "type": "address"
            }
        ],
        "func": "function getPair(address lp) public returns (address tokenA, address tokenB) {\n    address[2] memory ulTokens = pairs[lp];\n    tokenA = ulTokens[0];\n    tokenB = ulTokens[1];\n    if (tokenA == address(0) || tokenB == address(0)) {\n      address[] memory tokens = IBalancerPool(lp).getFinalTokens();\n      require(tokens.length == 2, 'underlying tokens not 2');\n      tokenA = tokens[0];\n      tokenB = tokens[1];\n      ensureApprove(tokenA, lp);\n      ensureApprove(tokenB, lp);\n    }\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addLiquidityWERC20",
        "visibility": "external",
        "args": [
            {
                "name": "lp",
                "type": "address"
            },
            {
                "name": "amt",
                "type": "Amounts calldata"
            }
        ],
        "func": "function addLiquidityWERC20(address lp, Amounts calldata amt) external payable {\n    // 1-4. add liquidity\n    addLiquidityInternal(lp, amt);\n\n    // 5. Put collateral\n    doPutCollateral(lp, IERC20(lp).balanceOf(address(this)));\n\n    // 6. Refund leftovers to users\n    (address tokenA, address tokenB) = getPair(lp);\n    doRefundETH();\n    doRefund(tokenA);\n    doRefund(tokenB);\n  }",
        "comments": [
            "",
            "  /// @dev Add liquidity to Balancer pool (with 2 underlying tokens)",
            "  "
        ],
        "comt": "\n  /// @dev Add liquidity to Balancer pool (with 2 underlying tokens)\n  ",
        "@dev": "Add liquidity to Balancer pool (with 2 underlying tokens)",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addLiquidityWStakingRewards",
        "visibility": "external",
        "args": [
            {
                "name": "lp",
                "type": "address"
            },
            {
                "name": "amt",
                "type": "Amounts calldata"
            },
            {
                "name": "wstaking",
                "type": "address"
            }
        ],
        "func": "function addLiquidityWStakingRewards(\n    address lp,\n    Amounts calldata amt,\n    address wstaking\n  ) external payable {\n    // 1-4. add liquidity\n    addLiquidityInternal(lp, amt);\n\n    // 5. Take out collateral\n    uint positionId = bank.POSITION_ID();\n    (, address collToken, uint collId, uint collSize) = bank.getPositionInfo(positionId);\n    if (collSize > 0) {\n      require(IWStakingRewards(collToken).getUnderlyingToken(collId) == lp, 'incorrect underlying');\n      bank.takeCollateral(wstaking, collId, collSize);\n      IWStakingRewards(wstaking).burn(collId, collSize);\n    }\n\n    // 6. Put collateral\n    ensureApprove(lp, wstaking);\n    uint amount = IERC20(lp).balanceOf(address(this));\n    uint id = IWStakingRewards(wstaking).mint(amount);\n    if (!IWStakingRewards(wstaking).isApprovedForAll(address(this), address(bank))) {\n      IWStakingRewards(wstaking).setApprovalForAll(address(bank), true);\n    }\n    bank.putCollateral(address(wstaking), id, amount);\n\n    // 7. Refund leftovers to users\n    (address tokenA, address tokenB) = getPair(lp);\n    doRefundETH();\n    doRefund(tokenA);\n    doRefund(tokenB);\n\n    // 8. Refund reward\n    doRefund(IWStakingRewards(wstaking).reward());\n  }",
        "comments": [
            "",
            "  /// @dev Add liquidity to Balancer pool (with 2 underlying tokens)",
            "  "
        ],
        "comt": "\n  /// @dev Add liquidity to Balancer pool (with 2 underlying tokens)\n  ",
        "@dev": "Add liquidity to Balancer pool (with 2 underlying tokens)",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityWERC20",
        "visibility": "external",
        "args": [
            {
                "name": "lp",
                "type": "address"
            },
            {
                "name": "amt",
                "type": "RepayAmounts calldata"
            }
        ],
        "func": "function removeLiquidityWERC20(address lp, RepayAmounts calldata amt) external {\n    // 1. Take out collateral\n    doTakeCollateral(lp, amt.amtLPTake);\n\n    // 2-6. remove liquidity\n    removeLiquidityInternal(lp, amt);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityWStakingRewards",
        "visibility": "external",
        "args": [
            {
                "name": "lp",
                "type": "address"
            },
            {
                "name": "amt",
                "type": "RepayAmounts calldata"
            },
            {
                "name": "wstaking",
                "type": "address"
            }
        ],
        "func": "function removeLiquidityWStakingRewards(\n    address lp,\n    RepayAmounts calldata amt,\n    address wstaking\n  ) external {\n    uint positionId = bank.POSITION_ID();\n    (, address collToken, uint collId, ) = bank.getPositionInfo(positionId);\n\n    // 1. Take out collateral\n    require(IWStakingRewards(collToken).getUnderlyingToken(collId) == lp, 'incorrect underlying');\n    bank.takeCollateral(wstaking, collId, amt.amtLPTake);\n    IWStakingRewards(wstaking).burn(collId, amt.amtLPTake);\n\n    // 2-6. remove liquidity\n    removeLiquidityInternal(lp, amt);\n\n    // 7. Refund reward\n    doRefund(IWStakingRewards(wstaking).reward());\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "harvestWStakingRewards",
        "visibility": "external",
        "args": [
            {
                "name": "wstaking",
                "type": "address"
            }
        ],
        "func": "function harvestWStakingRewards(address wstaking) external {\n    uint positionId = bank.POSITION_ID();\n    (, , uint collId, ) = bank.getPositionInfo(positionId);\n    address lp = IWStakingRewards(wstaking).getUnderlyingToken(collId);\n\n    // 1. Take out collateral\n    bank.takeCollateral(wstaking, collId, uint(-1));\n    IWStakingRewards(wstaking).burn(collId, uint(-1));\n\n    // 2. put collateral\n    uint amount = IERC20(lp).balanceOf(address(this));\n    ensureApprove(lp, wstaking);\n    uint id = IWStakingRewards(wstaking).mint(amount);\n    bank.putCollateral(wstaking, id, amount);\n\n    // 3. Refund reward\n    doRefund(IWStakingRewards(wstaking).reward());\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "borrowETH",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function borrowETH(uint amount) external {\n    doBorrow(weth, amount);\n    doRefundETH();\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "borrow",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function borrow(address token, uint amount) external {\n    doBorrow(token, amount);\n    doRefund(token);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repayETH",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function repayETH(uint amount) external payable {\n    doTransmitETH();\n    doRepay(weth, amount);\n    doRefundETH();\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repay",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function repay(address token, uint amount) external {\n    doTransmit(token, amount);\n    doRepay(token, IERC20(token).balanceOf(address(this)));\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "putCollateral",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function putCollateral(address token, uint amount) external {\n    doTransmit(token, amount);\n    doPutCollateral(token, IERC20(token).balanceOf(address(this)));\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "takeCollateral",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function takeCollateral(address token, uint amount) external {\n    doTakeCollateral(token, amount);\n    doRefund(token);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "external",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint"
            }
        ],
        "func": "function approve(address spender, uint value) external returns (bool) {\n    _approve(msg.sender, spender, value);\n    return true;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint"
            }
        ],
        "func": "function transfer(address to, uint value) external returns (bool) {\n    _transfer(msg.sender, to, value);\n    return true;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "external",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint"
            }
        ],
        "func": "function transferFrom(\n    address from,\n    address to,\n    uint value\n  ) external returns (bool) {\n    if (allowance[from][msg.sender] != uint(-1)) {\n      allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n    }\n    _transfer(from, to, value);\n    return true;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "permit",
        "visibility": "external",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint"
            },
            {
                "name": "deadline",
                "type": "uint"
            },
            {
                "name": "v",
                "type": "uint8"
            },
            {
                "name": "r",
                "type": "bytes32"
            },
            {
                "name": "s",
                "type": "bytes32"
            }
        ],
        "func": "function permit(\n    address owner,\n    address spender,\n    uint value,\n    uint deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');\n    bytes32 digest =\n      keccak256(\n        abi.encodePacked(\n          '\\x19\\x01',\n          DOMAIN_SEPARATOR,\n          keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n        )\n      );\n    address recoveredAddress = ecrecover(digest, v, r, s);\n    require(\n      recoveredAddress != address(0) && recoveredAddress == owner,\n      'UniswapV2: INVALID_SIGNATURE'\n    );\n    _approve(owner, spender, value);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getReserves",
        "visibility": "public",
        "args": [],
        "func": "function getReserves()\n    public\n    view\n    returns (\n      uint112 _reserve0,\n      uint112 _reserve1,\n      uint32 _blockTimestampLast\n    )\n  {\n    _reserve0 = reserve0;\n    _reserve1 = reserve1;\n    _blockTimestampLast = blockTimestampLast;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "initialize",
        "visibility": "external",
        "args": [
            {
                "name": "_token0",
                "type": "address"
            },
            {
                "name": "_token1",
                "type": "address"
            }
        ],
        "func": "function initialize(address _token0, address _token1) external {\n    require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\n    token0 = _token0;\n    token1 = _token1;\n  }",
        "comments": [
            "",
            "  // called once by the factory at time of deployment",
            "  "
        ],
        "comt": "\n  // called once by the factory at time of deployment\n  ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            }
        ],
        "func": "function mint(address to) external lock returns (uint liquidity) {\n    (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n    uint balance0 = MockUniswapV2FactoryIERC20(token0).balanceOf(address(this));\n    uint balance1 = MockUniswapV2FactoryIERC20(token1).balanceOf(address(this));\n    uint amount0 = balance0.sub(_reserve0);\n    uint amount1 = balance1.sub(_reserve1);\n\n    bool feeOn = _mintFee(_reserve0, _reserve1);\n    uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n    if (_totalSupply == 0) {\n      liquidity = MockUniswapV2FactoryMah.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n      _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n    } else {\n      liquidity = MockUniswapV2FactoryMah.min(\n        amount0.mul(_totalSupply) / _reserve0,\n        amount1.mul(_totalSupply) / _reserve1\n      );\n    }\n    require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');\n    _mint(to, liquidity);\n\n    _update(balance0, balance1, _reserve0, _reserve1);\n    if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n    emit Mint(msg.sender, amount0, amount1);\n  }",
        "comments": [
            "",
            "  // this low-level function should be called from a contract which performs important safety checks",
            "  "
        ],
        "comt": "\n  // this low-level function should be called from a contract which performs important safety checks\n  ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            }
        ],
        "func": "function burn(address to) external lock returns (uint amount0, uint amount1) {\n    (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n    address _token0 = token0; // gas savings\n    address _token1 = token1; // gas savings\n    uint balance0 = MockUniswapV2FactoryIERC20(_token0).balanceOf(address(this));\n    uint balance1 = MockUniswapV2FactoryIERC20(_token1).balanceOf(address(this));\n    uint liquidity = balanceOf[address(this)];\n\n    bool feeOn = _mintFee(_reserve0, _reserve1);\n    uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n    amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n    amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n    require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');\n    _burn(address(this), liquidity);\n    _safeTransfer(_token0, to, amount0);\n    _safeTransfer(_token1, to, amount1);\n    balance0 = MockUniswapV2FactoryIERC20(_token0).balanceOf(address(this));\n    balance1 = MockUniswapV2FactoryIERC20(_token1).balanceOf(address(this));\n\n    _update(balance0, balance1, _reserve0, _reserve1);\n    if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n    emit Burn(msg.sender, amount0, amount1, to);\n  }",
        "comments": [
            "",
            "  // this low-level function should be called from a contract which performs important safety checks",
            "  "
        ],
        "comt": "\n  // this low-level function should be called from a contract which performs important safety checks\n  ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swap",
        "visibility": "external",
        "args": [
            {
                "name": "amount0Out",
                "type": "uint"
            },
            {
                "name": "amount1Out",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "data",
                "type": "bytes calldata"
            }
        ],
        "func": "function swap(\n    uint amount0Out,\n    uint amount1Out,\n    address to,\n    bytes calldata data\n  ) external lock {\n    require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');\n    (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n    require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');\n\n    uint balance0;\n    uint balance1;\n    {\n      // scope for _token{0,1}, avoids stack too deep errors\n      address _token0 = token0;\n      address _token1 = token1;\n      require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');\n      if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n      if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n      if (data.length > 0)\n        IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\n      balance0 = MockUniswapV2FactoryIERC20(_token0).balanceOf(address(this));\n      balance1 = MockUniswapV2FactoryIERC20(_token1).balanceOf(address(this));\n    }\n    uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n    uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n    require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');\n    {\n      // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n      uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\n      uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\n      require(\n        balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2),\n        'UniswapV2: K'\n      );\n    }\n\n    _update(balance0, balance1, _reserve0, _reserve1);\n    emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n  }",
        "comments": [
            "",
            "  // this low-level function should be called from a contract which performs important safety checks",
            "  "
        ],
        "comt": "\n  // this low-level function should be called from a contract which performs important safety checks\n  ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "skim",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            }
        ],
        "func": "function skim(address to) external lock {\n    address _token0 = token0; // gas savings\n    address _token1 = token1; // gas savings\n    _safeTransfer(\n      _token0,\n      to,\n      MockUniswapV2FactoryIERC20(_token0).balanceOf(address(this)).sub(reserve0)\n    );\n    _safeTransfer(\n      _token1,\n      to,\n      MockUniswapV2FactoryIERC20(_token1).balanceOf(address(this)).sub(reserve1)\n    );\n  }",
        "comments": [
            "",
            "  // force balances to match reserves",
            "  "
        ],
        "comt": "\n  // force balances to match reserves\n  ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sync",
        "visibility": "external",
        "args": [],
        "func": "function sync() external lock {\n    _update(\n      MockUniswapV2FactoryIERC20(token0).balanceOf(address(this)),\n      MockUniswapV2FactoryIERC20(token1).balanceOf(address(this)),\n      reserve0,\n      reserve1\n    );\n  }",
        "comments": [
            "",
            "  // force reserves to match balances",
            "  "
        ],
        "comt": "\n  // force reserves to match balances\n  ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allPairsLength",
        "visibility": "external",
        "args": [],
        "func": "function allPairsLength() external view returns (uint) {\n    return allPairs.length;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createPair",
        "visibility": "external",
        "args": [
            {
                "name": "tokenA",
                "type": "address"
            },
            {
                "name": "tokenB",
                "type": "address"
            }
        ],
        "func": "function createPair(address tokenA, address tokenB) external returns (address pair) {\n    require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');\n    (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');\n    require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient\n    bytes memory bytecode = type(MockUniswapV2FactoryUniswapV2Pair).creationCode;\n    bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n    assembly {\n      pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n    }\n    MockUniswapV2FactoryIUniswapV2Pair(pair).initialize(token0, token1);\n    getPair[token0][token1] = pair;\n    getPair[token1][token0] = pair; // populate mapping in the reverse direction\n    allPairs.push(pair);\n    emit PairCreated(token0, token1, pair, allPairs.length);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setFeeTo",
        "visibility": "external",
        "args": [
            {
                "name": "_feeTo",
                "type": "address"
            }
        ],
        "func": "function setFeeTo(address _feeTo) external {\n    require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\n    feeTo = _feeTo;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setFeeToSetter",
        "visibility": "external",
        "args": [
            {
                "name": "_feeToSetter",
                "type": "address"
            }
        ],
        "func": "function setFeeToSetter(address _feeToSetter) external {\n    require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\n    feeToSetter = _feeToSetter;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "public",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function mint(address to, uint amount) public {\n    _mint(to, amount);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setMintRate",
        "visibility": "external",
        "args": [
            {
                "name": "_mintRate",
                "type": "uint"
            }
        ],
        "func": "function setMintRate(uint _mintRate) external override {\n    mintRate = _mintRate;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "underlying",
        "visibility": "external",
        "args": [],
        "func": "function underlying() external override returns (address) {\n    return address(token);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "external",
        "args": [
            {
                "name": "mintAmount",
                "type": "uint"
            }
        ],
        "func": "function mint(uint mintAmount) external override returns (uint) {\n    uint amountIn = mintAmount.mul(mintRate).div(1e18);\n    IERC20(token).safeTransferFrom(msg.sender, address(this), amountIn);\n    totalSupply = totalSupply.add(mintAmount);\n    balanceOf[msg.sender] = balanceOf[msg.sender].add(mintAmount);\n    return 0;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "redeem",
        "visibility": "external",
        "args": [
            {
                "name": "redeemAmount",
                "type": "uint"
            }
        ],
        "func": "function redeem(uint redeemAmount) external override returns (uint) {\n    uint amountOut = redeemAmount.mul(1e18).div(mintRate);\n    IERC20(token).safeTransfer(msg.sender, amountOut);\n    totalSupply = totalSupply.sub(redeemAmount);\n    balanceOf[msg.sender] = balanceOf[msg.sender].sub(redeemAmount);\n    return 0;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addLiquidity",
        "visibility": "external",
        "args": [
            {
                "name": "tokenA",
                "type": "address"
            },
            {
                "name": "tokenB",
                "type": "address"
            },
            {
                "name": "amountADesired",
                "type": "uint"
            },
            {
                "name": "amountBDesired",
                "type": "uint"
            },
            {
                "name": "amountAMin",
                "type": "uint"
            },
            {
                "name": "amountBMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n  )\n    external\n    virtual\n    override\n    ensure(deadline)\n    returns (\n      uint amountA,\n      uint amountB,\n      uint liquidity\n    )\n  {\n    (amountA, amountB) = _addLiquidity(\n      tokenA,\n      tokenB,\n      amountADesired,\n      amountBDesired,\n      amountAMin,\n      amountBMin\n    );\n    address pair = MockUniswapV2Router02UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    MockUniswapV2Router02TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n    MockUniswapV2Router02TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n    liquidity = MockUniswapV2Router02IUniswapV2Pair(pair).mint(to);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addLiquidityETH",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "amountTokenDesired",
                "type": "uint"
            },
            {
                "name": "amountTokenMin",
                "type": "uint"
            },
            {
                "name": "amountETHMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function addLiquidityETH(\n    address token,\n    uint amountTokenDesired,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  )\n    external\n    payable\n    virtual\n    override\n    ensure(deadline)\n    returns (\n      uint amountToken,\n      uint amountETH,\n      uint liquidity\n    )\n  {\n    (amountToken, amountETH) = _addLiquidity(\n      token,\n      WETH,\n      amountTokenDesired,\n      msg.value,\n      amountTokenMin,\n      amountETHMin\n    );\n    address pair = MockUniswapV2Router02UniswapV2Library.pairFor(factory, token, WETH);\n    MockUniswapV2Router02TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n    MockUniswapV2Router02IWETH(WETH).deposit{value: amountETH}();\n    assert(MockUniswapV2Router02IWETH(WETH).transfer(pair, amountETH));\n    liquidity = MockUniswapV2Router02IUniswapV2Pair(pair).mint(to);\n    // refund dust eth, if any\n    if (msg.value > amountETH)\n      MockUniswapV2Router02TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidity",
        "visibility": "public",
        "args": [
            {
                "name": "tokenA",
                "type": "address"
            },
            {
                "name": "tokenB",
                "type": "address"
            },
            {
                "name": "liquidity",
                "type": "uint"
            },
            {
                "name": "amountAMin",
                "type": "uint"
            },
            {
                "name": "amountBMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n  ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\n    address pair = MockUniswapV2Router02UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    MockUniswapV2Router02IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n    (uint amount0, uint amount1) = MockUniswapV2Router02IUniswapV2Pair(pair).burn(to);\n    (address token0, ) = MockUniswapV2Router02UniswapV2Library.sortTokens(tokenA, tokenB);\n    (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n    require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n    require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n  }",
        "comments": [
            "",
            "  // **** REMOVE LIQUIDITY ****",
            "  "
        ],
        "comt": "\n  // **** REMOVE LIQUIDITY ****\n  ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityETH",
        "visibility": "public",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "liquidity",
                "type": "uint"
            },
            {
                "name": "amountTokenMin",
                "type": "uint"
            },
            {
                "name": "amountETHMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function removeLiquidityETH(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\n    (amountToken, amountETH) = removeLiquidity(\n      token,\n      WETH,\n      liquidity,\n      amountTokenMin,\n      amountETHMin,\n      address(this),\n      deadline\n    );\n    MockUniswapV2Router02TransferHelper.safeTransfer(token, to, amountToken);\n    MockUniswapV2Router02IWETH(WETH).withdraw(amountETH);\n    MockUniswapV2Router02TransferHelper.safeTransferETH(to, amountETH);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityWithPermit",
        "visibility": "external",
        "args": [
            {
                "name": "tokenA",
                "type": "address"
            },
            {
                "name": "tokenB",
                "type": "address"
            },
            {
                "name": "liquidity",
                "type": "uint"
            },
            {
                "name": "amountAMin",
                "type": "uint"
            },
            {
                "name": "amountBMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            },
            {
                "name": "approveMax",
                "type": "bool"
            },
            {
                "name": "v",
                "type": "uint8"
            },
            {
                "name": "r",
                "type": "bytes32"
            },
            {
                "name": "s",
                "type": "bytes32"
            }
        ],
        "func": "function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external virtual override returns (uint amountA, uint amountB) {\n    address pair = MockUniswapV2Router02UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    uint value = approveMax ? uint(-1) : liquidity;\n    MockUniswapV2Router02IUniswapV2Pair(pair).permit(\n      msg.sender,\n      address(this),\n      value,\n      deadline,\n      v,\n      r,\n      s\n    );\n    (amountA, amountB) = removeLiquidity(\n      tokenA,\n      tokenB,\n      liquidity,\n      amountAMin,\n      amountBMin,\n      to,\n      deadline\n    );\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityETHWithPermit",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "liquidity",
                "type": "uint"
            },
            {
                "name": "amountTokenMin",
                "type": "uint"
            },
            {
                "name": "amountETHMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            },
            {
                "name": "approveMax",
                "type": "bool"
            },
            {
                "name": "v",
                "type": "uint8"
            },
            {
                "name": "r",
                "type": "bytes32"
            },
            {
                "name": "s",
                "type": "bytes32"
            }
        ],
        "func": "function removeLiquidityETHWithPermit(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external virtual override returns (uint amountToken, uint amountETH) {\n    address pair = MockUniswapV2Router02UniswapV2Library.pairFor(factory, token, WETH);\n    uint value = approveMax ? uint(-1) : liquidity;\n    MockUniswapV2Router02IUniswapV2Pair(pair).permit(\n      msg.sender,\n      address(this),\n      value,\n      deadline,\n      v,\n      r,\n      s\n    );\n    (amountToken, amountETH) = removeLiquidityETH(\n      token,\n      liquidity,\n      amountTokenMin,\n      amountETHMin,\n      to,\n      deadline\n    );\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityETHSupportingFeeOnTransferTokens",
        "visibility": "public",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "liquidity",
                "type": "uint"
            },
            {
                "name": "amountTokenMin",
                "type": "uint"
            },
            {
                "name": "amountETHMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  ) public virtual override ensure(deadline) returns (uint amountETH) {\n    (, amountETH) = removeLiquidity(\n      token,\n      WETH,\n      liquidity,\n      amountTokenMin,\n      amountETHMin,\n      address(this),\n      deadline\n    );\n    MockUniswapV2Router02TransferHelper.safeTransfer(\n      token,\n      to,\n      IERC20(token).balanceOf(address(this))\n    );\n    MockUniswapV2Router02IWETH(WETH).withdraw(amountETH);\n    MockUniswapV2Router02TransferHelper.safeTransferETH(to, amountETH);\n  }",
        "comments": [
            "",
            "  // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****",
            "  "
        ],
        "comt": "\n  // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n  ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityETHWithPermitSupportingFeeOnTransferTokens",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "liquidity",
                "type": "uint"
            },
            {
                "name": "amountTokenMin",
                "type": "uint"
            },
            {
                "name": "amountETHMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            },
            {
                "name": "approveMax",
                "type": "bool"
            },
            {
                "name": "v",
                "type": "uint8"
            },
            {
                "name": "r",
                "type": "bytes32"
            },
            {
                "name": "s",
                "type": "bytes32"
            }
        ],
        "func": "function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external virtual override returns (uint amountETH) {\n    address pair = MockUniswapV2Router02UniswapV2Library.pairFor(factory, token, WETH);\n    uint value = approveMax ? uint(-1) : liquidity;\n    MockUniswapV2Router02IUniswapV2Pair(pair).permit(\n      msg.sender,\n      address(this),\n      value,\n      deadline,\n      v,\n      r,\n      s\n    );\n    amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n      token,\n      liquidity,\n      amountTokenMin,\n      amountETHMin,\n      to,\n      deadline\n    );\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapExactTokensForTokens",
        "visibility": "external",
        "args": [
            {
                "name": "amountIn",
                "type": "uint"
            },
            {
                "name": "amountOutMin",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapExactTokensForTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n    amounts = MockUniswapV2Router02UniswapV2Library.getAmountsOut(factory, amountIn, path);\n    require(\n      amounts[amounts.length - 1] >= amountOutMin,\n      'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n    );\n    MockUniswapV2Router02TransferHelper.safeTransferFrom(\n      path[0],\n      msg.sender,\n      MockUniswapV2Router02UniswapV2Library.pairFor(factory, path[0], path[1]),\n      amounts[0]\n    );\n    _swap(amounts, path, to);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapTokensForExactTokens",
        "visibility": "external",
        "args": [
            {
                "name": "amountOut",
                "type": "uint"
            },
            {
                "name": "amountInMax",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapTokensForExactTokens(\n    uint amountOut,\n    uint amountInMax,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n    amounts = MockUniswapV2Router02UniswapV2Library.getAmountsIn(factory, amountOut, path);\n    require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n    MockUniswapV2Router02TransferHelper.safeTransferFrom(\n      path[0],\n      msg.sender,\n      MockUniswapV2Router02UniswapV2Library.pairFor(factory, path[0], path[1]),\n      amounts[0]\n    );\n    _swap(amounts, path, to);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapExactETHForTokens",
        "visibility": "external",
        "args": [
            {
                "name": "amountOutMin",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapExactETHForTokens(\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external payable virtual override ensure(deadline) returns (uint[] memory amounts) {\n    require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n    amounts = MockUniswapV2Router02UniswapV2Library.getAmountsOut(factory, msg.value, path);\n    require(\n      amounts[amounts.length - 1] >= amountOutMin,\n      'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n    );\n    MockUniswapV2Router02IWETH(WETH).deposit{value: amounts[0]}();\n    assert(\n      MockUniswapV2Router02IWETH(WETH).transfer(\n        MockUniswapV2Router02UniswapV2Library.pairFor(factory, path[0], path[1]),\n        amounts[0]\n      )\n    );\n    _swap(amounts, path, to);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapTokensForExactETH",
        "visibility": "external",
        "args": [
            {
                "name": "amountOut",
                "type": "uint"
            },
            {
                "name": "amountInMax",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapTokensForExactETH(\n    uint amountOut,\n    uint amountInMax,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n    require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n    amounts = MockUniswapV2Router02UniswapV2Library.getAmountsIn(factory, amountOut, path);\n    require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n    MockUniswapV2Router02TransferHelper.safeTransferFrom(\n      path[0],\n      msg.sender,\n      MockUniswapV2Router02UniswapV2Library.pairFor(factory, path[0], path[1]),\n      amounts[0]\n    );\n    _swap(amounts, path, address(this));\n    MockUniswapV2Router02IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n    MockUniswapV2Router02TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapExactTokensForETH",
        "visibility": "external",
        "args": [
            {
                "name": "amountIn",
                "type": "uint"
            },
            {
                "name": "amountOutMin",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapExactTokensForETH(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n    require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n    amounts = MockUniswapV2Router02UniswapV2Library.getAmountsOut(factory, amountIn, path);\n    require(\n      amounts[amounts.length - 1] >= amountOutMin,\n      'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n    );\n    MockUniswapV2Router02TransferHelper.safeTransferFrom(\n      path[0],\n      msg.sender,\n      MockUniswapV2Router02UniswapV2Library.pairFor(factory, path[0], path[1]),\n      amounts[0]\n    );\n    _swap(amounts, path, address(this));\n    MockUniswapV2Router02IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n    MockUniswapV2Router02TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapETHForExactTokens",
        "visibility": "external",
        "args": [
            {
                "name": "amountOut",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapETHForExactTokens(\n    uint amountOut,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external payable virtual override ensure(deadline) returns (uint[] memory amounts) {\n    require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n    amounts = MockUniswapV2Router02UniswapV2Library.getAmountsIn(factory, amountOut, path);\n    require(amounts[0] <= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n    MockUniswapV2Router02IWETH(WETH).deposit{value: amounts[0]}();\n    assert(\n      MockUniswapV2Router02IWETH(WETH).transfer(\n        MockUniswapV2Router02UniswapV2Library.pairFor(factory, path[0], path[1]),\n        amounts[0]\n      )\n    );\n    _swap(amounts, path, to);\n    // refund dust eth, if any\n    if (msg.value > amounts[0])\n      MockUniswapV2Router02TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapExactTokensForTokensSupportingFeeOnTransferTokens",
        "visibility": "external",
        "args": [
            {
                "name": "amountIn",
                "type": "uint"
            },
            {
                "name": "amountOutMin",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external virtual override ensure(deadline) {\n    MockUniswapV2Router02TransferHelper.safeTransferFrom(\n      path[0],\n      msg.sender,\n      MockUniswapV2Router02UniswapV2Library.pairFor(factory, path[0], path[1]),\n      amountIn\n    );\n    uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n    _swapSupportingFeeOnTransferTokens(path, to);\n    require(\n      IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n      'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n    );\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapExactETHForTokensSupportingFeeOnTransferTokens",
        "visibility": "external",
        "args": [
            {
                "name": "amountOutMin",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external payable virtual override ensure(deadline) {\n    require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n    uint amountIn = msg.value;\n    MockUniswapV2Router02IWETH(WETH).deposit{value: amountIn}();\n    assert(\n      MockUniswapV2Router02IWETH(WETH).transfer(\n        MockUniswapV2Router02UniswapV2Library.pairFor(factory, path[0], path[1]),\n        amountIn\n      )\n    );\n    uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n    _swapSupportingFeeOnTransferTokens(path, to);\n    require(\n      IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n      'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n    );\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapExactTokensForETHSupportingFeeOnTransferTokens",
        "visibility": "external",
        "args": [
            {
                "name": "amountIn",
                "type": "uint"
            },
            {
                "name": "amountOutMin",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] calldata"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external virtual override ensure(deadline) {\n    require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n    MockUniswapV2Router02TransferHelper.safeTransferFrom(\n      path[0],\n      msg.sender,\n      MockUniswapV2Router02UniswapV2Library.pairFor(factory, path[0], path[1]),\n      amountIn\n    );\n    _swapSupportingFeeOnTransferTokens(path, address(this));\n    uint amountOut = IERC20(WETH).balanceOf(address(this));\n    require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n    MockUniswapV2Router02IWETH(WETH).withdraw(amountOut);\n    MockUniswapV2Router02TransferHelper.safeTransferETH(to, amountOut);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "quote",
        "visibility": "public",
        "args": [
            {
                "name": "amountA",
                "type": "uint"
            },
            {
                "name": "reserveA",
                "type": "uint"
            },
            {
                "name": "reserveB",
                "type": "uint"
            }
        ],
        "func": "function quote(\n    uint amountA,\n    uint reserveA,\n    uint reserveB\n  ) public pure virtual override returns (uint amountB) {\n    return MockUniswapV2Router02UniswapV2Library.quote(amountA, reserveA, reserveB);\n  }",
        "comments": [
            "",
            "  // **** LIBRARY FUNCTIONS ****",
            "  "
        ],
        "comt": "\n  // **** LIBRARY FUNCTIONS ****\n  ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAmountOut",
        "visibility": "public",
        "args": [
            {
                "name": "amountIn",
                "type": "uint"
            },
            {
                "name": "reserveIn",
                "type": "uint"
            },
            {
                "name": "reserveOut",
                "type": "uint"
            }
        ],
        "func": "function getAmountOut(\n    uint amountIn,\n    uint reserveIn,\n    uint reserveOut\n  ) public pure virtual override returns (uint amountOut) {\n    return MockUniswapV2Router02UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAmountIn",
        "visibility": "public",
        "args": [
            {
                "name": "amountOut",
                "type": "uint"
            },
            {
                "name": "reserveIn",
                "type": "uint"
            },
            {
                "name": "reserveOut",
                "type": "uint"
            }
        ],
        "func": "function getAmountIn(\n    uint amountOut,\n    uint reserveIn,\n    uint reserveOut\n  ) public pure virtual override returns (uint amountIn) {\n    return MockUniswapV2Router02UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAmountsOut",
        "visibility": "public",
        "args": [
            {
                "name": "amountIn",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] memory"
            }
        ],
        "func": "function getAmountsOut(uint amountIn, address[] memory path)\n    public\n    view\n    virtual\n    override\n    returns (uint[] memory amounts)\n  {\n    return MockUniswapV2Router02UniswapV2Library.getAmountsOut(factory, amountIn, path);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAmountsIn",
        "visibility": "public",
        "args": [
            {
                "name": "amountOut",
                "type": "uint"
            },
            {
                "name": "path",
                "type": "address[] memory"
            }
        ],
        "func": "function getAmountsIn(uint amountOut, address[] memory path)\n    public\n    view\n    virtual\n    override\n    returns (uint[] memory amounts)\n  {\n    return MockUniswapV2Router02UniswapV2Library.getAmountsIn(factory, amountOut, path);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decimals",
        "visibility": "external",
        "args": [],
        "func": "function decimals() external override returns (uint8) {\n    return 8;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "underlying",
        "visibility": "external",
        "args": [],
        "func": "function underlying() external override returns (address) {\n    return address(token);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "external",
        "args": [
            {
                "name": "mintAmount",
                "type": "uint"
            }
        ],
        "func": "function mint(uint mintAmount) external override returns (uint) {\n    // Not implemented\n    return 0;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "redeem",
        "visibility": "external",
        "args": [
            {
                "name": "redeemTokens",
                "type": "uint"
            }
        ],
        "func": "function redeem(uint redeemTokens) external override returns (uint) {\n    // Not implemented\n    return 0;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "external",
        "args": [
            {
                "name": "user",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address user) external view override returns (uint) {\n    // Not implemented\n    return 0;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "borrowBalanceCurrent",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function borrowBalanceCurrent(address account) public override returns (uint) {\n    uint timePast = now - lastBlock[account];\n    if (timePast > 0) {\n      uint interest = borrows[account].mul(interestPerYear).div(100e16).mul(timePast).div(365 days);\n      borrows[account] = borrows[account].add(interest);\n      lastBlock[account] = now;\n    }\n    return borrows[account];\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "borrowBalanceStored",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function borrowBalanceStored(address account) external view override returns (uint) {\n    return borrows[account];\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "borrow",
        "visibility": "external",
        "args": [
            {
                "name": "borrowAmount",
                "type": "uint"
            }
        ],
        "func": "function borrow(uint borrowAmount) external override returns (uint) {\n    borrowBalanceCurrent(msg.sender);\n    token.transfer(msg.sender, borrowAmount);\n    borrows[msg.sender] = borrows[msg.sender].add(borrowAmount);\n    return 0;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repayBorrow",
        "visibility": "external",
        "args": [
            {
                "name": "repayAmount",
                "type": "uint"
            }
        ],
        "func": "function repayBorrow(uint repayAmount) external override returns (uint) {\n    borrowBalanceCurrent(msg.sender);\n    token.transferFrom(msg.sender, address(this), repayAmount);\n    borrows[msg.sender] = borrows[msg.sender].sub(repayAmount);\n    return 0;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "deposit",
        "visibility": "public",
        "args": [],
        "func": "function deposit() public payable {\n    balanceOf[msg.sender] += msg.value;\n    emit Deposit(msg.sender, msg.value);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "wad",
                "type": "uint"
            }
        ],
        "func": "function withdraw(uint wad) public {\n    require(balanceOf[msg.sender] >= wad);\n    balanceOf[msg.sender] -= wad;\n    msg.sender.transfer(wad);\n    emit Withdrawal(msg.sender, wad);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view returns (uint) {\n    return address(this).balance;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "guy",
                "type": "address"
            },
            {
                "name": "wad",
                "type": "uint"
            }
        ],
        "func": "function approve(address guy, uint wad) public returns (bool) {\n    allowance[msg.sender][guy] = wad;\n    emit Approval(msg.sender, guy, wad);\n    return true;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "dst",
                "type": "address"
            },
            {
                "name": "wad",
                "type": "uint"
            }
        ],
        "func": "function transfer(address dst, uint wad) public returns (bool) {\n    return transferFrom(msg.sender, dst, wad);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "src",
                "type": "address"
            },
            {
                "name": "dst",
                "type": "address"
            },
            {
                "name": "wad",
                "type": "uint"
            }
        ],
        "func": "function transferFrom(\n    address src,\n    address dst,\n    uint wad\n  ) public returns (bool) {\n    require(balanceOf[src] >= wad);\n\n    if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n      require(allowance[src][msg.sender] >= wad);\n      allowance[src][msg.sender] -= wad;\n    }\n\n    balanceOf[src] -= wad;\n    balanceOf[dst] += wad;\n\n    emit Transfer(src, dst, wad);\n\n    return true;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getETHPx",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            }
        ],
        "func": "function getETHPx(address token) external view override returns (uint) {\n    uint px = prices[token];\n    require(px != 0, 'no px');\n    return px;\n  }",
        "comments": [
            "",
            "  /// @dev Return the value of the given input as ETH per unit, multiplied by 2**112.",
            "  /// @param token The ERC-20 token to check the value.",
            "  "
        ],
        "comt": "\n  /// @dev Return the value of the given input as ETH per unit, multiplied by 2**112.\n  /// @param token The ERC-20 token to check the value.\n  ",
        "@dev": "Return the value of the given input as ETH per unit, multiplied by 2**112.",
        "@param1": "token The ERC-20 token to check the value.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setETHPx",
        "visibility": "external",
        "args": [
            {
                "name": "tokens",
                "type": "address[] memory"
            },
            {
                "name": "pxs",
                "type": "uint[] memory"
            }
        ],
        "func": "function setETHPx(address[] memory tokens, uint[] memory pxs) external onlyGov {\n    require(tokens.length == pxs.length, 'inconsistent length');\n    for (uint idx = 0; idx < tokens.length; idx++) {\n      prices[tokens[idx]] = pxs[idx];\n      emit SetETHPx(tokens[idx], pxs[idx]);\n    }\n  }",
        "comments": [
            "",
            "  /// @dev Set the prices of the given token addresses.",
            "  /// @param tokens The token addresses to set the prices.",
            "  /// @param pxs The price data points, representing token value in ETH times 2**112.",
            "  "
        ],
        "comt": "\n  /// @dev Set the prices of the given token addresses.\n  /// @param tokens The token addresses to set the prices.\n  /// @param pxs The price data points, representing token value in ETH times 2**112.\n  ",
        "@dev": "Set the prices of the given token addresses.",
        "@param1": "tokens The token addresses to set the prices.",
        "@param2": "pxs The price data points, representing token value in ETH times 2**112.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getETHPx",
        "visibility": "external",
        "args": [
            {
                "name": "pair",
                "type": "address"
            }
        ],
        "func": "function getETHPx(address pair) external view override returns (uint) {\n    address token0 = IUniswapV2Pair(pair).token0();\n    address token1 = IUniswapV2Pair(pair).token1();\n    uint totalSupply = IUniswapV2Pair(pair).totalSupply();\n    (uint r0, uint r1, ) = IUniswapV2Pair(pair).getReserves();\n    uint sqrtK = HomoraMath.sqrt(r0.mul(r1)).fdiv(totalSupply); // in 2**112\n    uint px0 = base.getETHPx(token0);\n    uint px1 = base.getETHPx(token1);\n    return sqrtK.mul(2).mul(HomoraMath.sqrt(px0)).div(2**56).mul(HomoraMath.sqrt(px1)).div(2**56);\n  }",
        "comments": [
            "",
            "  /// @dev Return the value of the given input as ETH per unit, multiplied by 2**112.",
            "  /// @param pair The Uniswap pair to check the value.",
            "  "
        ],
        "comt": "\n  /// @dev Return the value of the given input as ETH per unit, multiplied by 2**112.\n  /// @param pair The Uniswap pair to check the value.\n  ",
        "@dev": "Return the value of the given input as ETH per unit, multiplied by 2**112.",
        "@param1": "pair The Uniswap pair to check the value.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getETHPx",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            }
        ],
        "func": "function getETHPx(address token) external view override returns (uint) {\n    IBalancerPool pool = IBalancerPool(token);\n    require(pool.getNumTokens() == 2, 'num tokens must be 2');\n    address[] memory tokens = pool.getFinalTokens();\n    address tokenA = tokens[0];\n    address tokenB = tokens[1];\n    uint pxA = base.getETHPx(tokenA);\n    uint pxB = base.getETHPx(tokenB);\n    (uint fairResA, uint fairResB) =\n      computeFairReserves(\n        pool.getBalance(tokenA),\n        pool.getBalance(tokenB),\n        pool.getNormalizedWeight(tokenA),\n        pool.getNormalizedWeight(tokenB),\n        pxA,\n        pxB\n      );\n    return fairResA.mul(pxA).add(fairResB.mul(pxB)).div(pool.totalSupply());\n  }",
        "comments": [
            "",
            "  /// @dev Return the value of the given input as ETH per unit, multiplied by 2**112.",
            "  /// @param token The ERC-20 token to check the value.",
            "  "
        ],
        "comt": "\n  /// @dev Return the value of the given input as ETH per unit, multiplied by 2**112.\n  /// @param token The ERC-20 token to check the value.\n  ",
        "@dev": "Return the value of the given input as ETH per unit, multiplied by 2**112.",
        "@param1": "token The ERC-20 token to check the value.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "registerPool",
        "visibility": "external",
        "args": [
            {
                "name": "lp",
                "type": "address"
            }
        ],
        "func": "function registerPool(address lp) external {\n    address pool = poolOf[lp];\n    require(pool == address(0), 'lp is already registered');\n    pool = registry.get_pool_from_lp_token(lp);\n    require(pool != address(0), 'no corresponding pool for lp token');\n    poolOf[lp] = pool;\n    uint n = registry.get_n_coins(pool);\n    address[8] memory tokens = registry.get_coins(pool);\n    for (uint i = 0; i < n; i++) {\n      ulTokens[lp].push(\n        UnderlyingToken({token: tokens[i], decimals: IERC20Decimal(tokens[i]).decimals()})\n      );\n    }\n  }",
        "comments": [
            "",
            "  /// @dev Register the pool given LP token address and set the pool info.",
            "  /// @param lp LP token to find the corresponding pool.",
            "  "
        ],
        "comt": "\n  /// @dev Register the pool given LP token address and set the pool info.\n  /// @param lp LP token to find the corresponding pool.\n  ",
        "@dev": "Register the pool given LP token address and set the pool info.",
        "@param1": "lp LP token to find the corresponding pool.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getETHPx",
        "visibility": "external",
        "args": [
            {
                "name": "lp",
                "type": "address"
            }
        ],
        "func": "function getETHPx(address lp) external view override returns (uint) {\n    address pool = poolOf[lp];\n    require(pool != address(0), 'lp is not registered');\n    UnderlyingToken[] memory tokens = ulTokens[lp];\n    uint minPx = uint(-1);\n    uint n = tokens.length;\n    for (uint idx = 0; idx < n; idx++) {\n      UnderlyingToken memory ulToken = tokens[idx];\n      uint tokenPx = base.getETHPx(ulToken.token);\n      if (ulToken.decimals < 18) tokenPx = tokenPx.div(10**(18 - uint(ulToken.decimals)));\n      if (ulToken.decimals > 18) tokenPx = tokenPx.mul(10**(uint(ulToken.decimals) - 18));\n      if (tokenPx < minPx) minPx = tokenPx;\n    }\n    require(minPx != uint(-1), 'no min px');\n    return minPx.mul(ICurvePool(pool).get_virtual_price()).div(1e18);\n  }",
        "comments": [
            "",
            "  /// @dev Return the value of the given input as ETH per unit, multiplied by 2**112.",
            "  /// @param lp The ERC-20 LP token to check the value.",
            "  "
        ],
        "comt": "\n  /// @dev Return the value of the given input as ETH per unit, multiplied by 2**112.\n  /// @param lp The ERC-20 LP token to check the value.\n  ",
        "@dev": "Return the value of the given input as ETH per unit, multiplied by 2**112.",
        "@param1": "lp The ERC-20 LP token to check the value.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getETHPx",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            }
        ],
        "func": "function getETHPx(address token) external view override returns (uint) {\n    if (token == weth || token == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n      return 2**112;\n    }\n    address pair = IUniswapV2Factory(factory).getPair(token, weth);\n    if (token < weth) {\n      return price0TWAP(pair);\n    } else {\n      return price1TWAP(pair);\n    }\n  }",
        "comments": [
            "",
            "  /// @dev Return the value of the given input as ETH per unit, multiplied by 2**112.",
            "  /// @param token The ERC-20 token to check the value.",
            "  "
        ],
        "comt": "\n  /// @dev Return the value of the given input as ETH per unit, multiplied by 2**112.\n  /// @param token The ERC-20 token to check the value.\n  ",
        "@dev": "Return the value of the given input as ETH per unit, multiplied by 2**112.",
        "@param1": "token The ERC-20 token to check the value.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "price0TWAP",
        "visibility": "public",
        "args": [
            {
                "name": "pair",
                "type": "address"
            }
        ],
        "func": "function price0TWAP(address pair) public view returns (uint) {\n    uint length = kp3r.observationLength(pair);\n    require(length > 0, 'no length-1 observation');\n    (uint lastTime, uint lastPx0Cumu, ) = kp3r.observations(pair, length - 1);\n    if (lastTime > now - MIN_TWAP_TIME) {\n      require(length > 1, 'no length-2 observation');\n      (lastTime, lastPx0Cumu, ) = kp3r.observations(pair, length - 2);\n    }\n    uint elapsedTime = now - lastTime;\n    require(elapsedTime >= MIN_TWAP_TIME && elapsedTime <= MAX_TWAP_TIME, 'bad TWAP time');\n    uint currPx0Cumu = currentPx0Cumu(pair);\n    return (currPx0Cumu - lastPx0Cumu) / (now - lastTime); // overflow is desired\n  }",
        "comments": [
            "",
            "  /// @dev Return the TWAP value price0. Revert if TWAP time range is not within the threshold.",
            "  /// @param pair The pair to query for price0.",
            "  "
        ],
        "comt": "\n  /// @dev Return the TWAP value price0. Revert if TWAP time range is not within the threshold.\n  /// @param pair The pair to query for price0.\n  ",
        "@dev": "Return the TWAP value price0. Revert if TWAP time range is not within the threshold.",
        "@param1": "pair The pair to query for price0.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "price1TWAP",
        "visibility": "public",
        "args": [
            {
                "name": "pair",
                "type": "address"
            }
        ],
        "func": "function price1TWAP(address pair) public view returns (uint) {\n    uint length = kp3r.observationLength(pair);\n    require(length > 0, 'no length-1 observation');\n    (uint lastTime, , uint lastPx1Cumu) = kp3r.observations(pair, length - 1);\n    if (lastTime > now - MIN_TWAP_TIME) {\n      require(length > 1, 'no length-2 observation');\n      (lastTime, , lastPx1Cumu) = kp3r.observations(pair, length - 2);\n    }\n    uint elapsedTime = now - lastTime;\n    require(elapsedTime >= MIN_TWAP_TIME && elapsedTime <= MAX_TWAP_TIME, 'bad TWAP time');\n    uint currPx1Cumu = currentPx1Cumu(pair);\n    return (currPx1Cumu - lastPx1Cumu) / (now - lastTime); // overflow is desired\n  }",
        "comments": [
            "",
            "  /// @dev Return the TWAP value price1. Revert if TWAP time range is not within the threshold.",
            "  /// @param pair The pair to query for price1.",
            "  "
        ],
        "comt": "\n  /// @dev Return the TWAP value price1. Revert if TWAP time range is not within the threshold.\n  /// @param pair The pair to query for price1.\n  ",
        "@dev": "Return the TWAP value price1. Revert if TWAP time range is not within the threshold.",
        "@param1": "pair The pair to query for price1.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "currentPx0Cumu",
        "visibility": "public",
        "args": [
            {
                "name": "pair",
                "type": "address"
            }
        ],
        "func": "function currentPx0Cumu(address pair) public view returns (uint px0Cumu) {\n    uint32 currTime = uint32(now);\n    px0Cumu = IUniswapV2Pair(pair).price0CumulativeLast();\n    (uint reserve0, uint reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n    if (lastTime != now) {\n      uint32 timeElapsed = currTime - lastTime; // overflow is desired\n      px0Cumu += uint((reserve1 << 112) / reserve0) * timeElapsed; // overflow is desired\n    }\n  }",
        "comments": [
            "",
            "  /// @dev Return the current price0 cumulative value on uniswap.",
            "  /// @param pair The uniswap pair to query for price0 cumulative value.",
            "  "
        ],
        "comt": "\n  /// @dev Return the current price0 cumulative value on uniswap.\n  /// @param pair The uniswap pair to query for price0 cumulative value.\n  ",
        "@dev": "Return the current price0 cumulative value on uniswap.",
        "@param1": "pair The uniswap pair to query for price0 cumulative value.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "currentPx1Cumu",
        "visibility": "public",
        "args": [
            {
                "name": "pair",
                "type": "address"
            }
        ],
        "func": "function currentPx1Cumu(address pair) public view returns (uint px1Cumu) {\n    uint32 currTime = uint32(now);\n    px1Cumu = IUniswapV2Pair(pair).price1CumulativeLast();\n    (uint reserve0, uint reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n    if (lastTime != currTime) {\n      uint32 timeElapsed = currTime - lastTime; // overflow is desired\n      px1Cumu += uint((reserve0 << 112) / reserve1) * timeElapsed; // overflow is desired\n    }\n  }",
        "comments": [
            "",
            "  /// @dev Return the current price1 cumulative value on uniswap.",
            "  /// @param pair The uniswap pair to query for price1 cumulative value.",
            "  "
        ],
        "comt": "\n  /// @dev Return the current price1 cumulative value on uniswap.\n  /// @param pair The uniswap pair to query for price1 cumulative value.\n  ",
        "@dev": "Return the current price1 cumulative value on uniswap.",
        "@param1": "pair The uniswap pair to query for price1 cumulative value.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setOracles",
        "visibility": "external",
        "args": [
            {
                "name": "tokens",
                "type": "address[] memory"
            },
            {
                "name": "info",
                "type": "Oracle[] memory"
            }
        ],
        "func": "function setOracles(address[] memory tokens, Oracle[] memory info) external onlyGov {\n    require(tokens.length == info.length, 'inconsistent length');\n    for (uint idx = 0; idx < tokens.length; idx++) {\n      require(info[idx].borrowFactor >= 10000, 'borrow factor must be at least 100%');\n      require(info[idx].collateralFactor <= 10000, 'collateral factor must be at most 100%');\n      require(info[idx].liqIncentive >= 10000, 'incentive must be at least 100%');\n      require(info[idx].liqIncentive <= 20000, 'incentive must be at most 200%');\n      oracles[tokens[idx]] = info[idx];\n      emit SetOracle(tokens[idx], info[idx]);\n    }\n  }",
        "comments": [
            "",
            "  /// @dev Set oracle information for the given list of token addresses.",
            "  "
        ],
        "comt": "\n  /// @dev Set oracle information for the given list of token addresses.\n  ",
        "@dev": "Set oracle information for the given list of token addresses.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "unsetOracles",
        "visibility": "external",
        "args": [
            {
                "name": "tokens",
                "type": "address[] memory"
            }
        ],
        "func": "function unsetOracles(address[] memory tokens) external onlyGov {\n    for (uint idx = 0; idx < tokens.length; idx++) {\n      oracles[tokens[idx]] = Oracle(0, 0, 0);\n      emit UnsetOracle(tokens[idx]);\n    }\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setWhitelistERC1155",
        "visibility": "external",
        "args": [
            {
                "name": "tokens",
                "type": "address[] memory"
            },
            {
                "name": "ok",
                "type": "bool"
            }
        ],
        "func": "function setWhitelistERC1155(address[] memory tokens, bool ok) external onlyGov {\n    for (uint idx = 0; idx < tokens.length; idx++) {\n      whitelistERC1155[tokens[idx]] = ok;\n      emit SetWhitelist(tokens[idx], ok);\n    }\n  }",
        "comments": [
            "",
            "  /// @dev Set whitelist status for the given list of token addresses.",
            "  "
        ],
        "comt": "\n  /// @dev Set whitelist status for the given list of token addresses.\n  ",
        "@dev": "Set whitelist status for the given list of token addresses.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "support",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint"
            }
        ],
        "func": "function support(address token, uint id) external view override returns (bool) {\n    if (!whitelistERC1155[token]) return false;\n    address tokenUnderlying = IERC20Wrapper(token).getUnderlyingToken(id);\n    return oracles[tokenUnderlying].liqIncentive != 0;\n  }",
        "comments": [
            "",
            "  /// @dev Return whether the oracle supports evaluating collateral value of the given token.",
            "  "
        ],
        "comt": "\n  /// @dev Return whether the oracle supports evaluating collateral value of the given token.\n  ",
        "@dev": "Return whether the oracle supports evaluating collateral value of the given token.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "convertForLiquidation",
        "visibility": "external",
        "args": [
            {
                "name": "tokenIn",
                "type": "address"
            },
            {
                "name": "tokenOut",
                "type": "address"
            },
            {
                "name": "tokenOutId",
                "type": "uint"
            },
            {
                "name": "amountIn",
                "type": "uint"
            }
        ],
        "func": "function convertForLiquidation(\n    address tokenIn,\n    address tokenOut,\n    uint tokenOutId,\n    uint amountIn\n  ) external view override returns (uint) {\n    require(whitelistERC1155[tokenOut], 'bad token');\n    address tokenOutUnderlying = IERC20Wrapper(tokenOut).getUnderlyingToken(tokenOutId);\n    uint rateUnderlying = IERC20Wrapper(tokenOut).getUnderlyingRate(tokenOutId);\n    Oracle memory oracleIn = oracles[tokenIn];\n    Oracle memory oracleOut = oracles[tokenOutUnderlying];\n    require(oracleIn.liqIncentive != 0, 'bad underlying in');\n    require(oracleOut.liqIncentive != 0, 'bad underlying out');\n    uint pxIn = source.getETHPx(tokenIn);\n    uint pxOut = source.getETHPx(tokenOutUnderlying);\n    uint amountOut = amountIn.mul(pxIn).div(pxOut);\n    amountOut = amountOut.mul(2**112).div(rateUnderlying);\n    return amountOut.mul(oracleIn.liqIncentive).mul(oracleOut.liqIncentive).div(10000 * 10000);\n  }",
        "comments": [
            "",
            "  /// @dev Return the amount of token out as liquidation reward for liquidating token in.",
            "  "
        ],
        "comt": "\n  /// @dev Return the amount of token out as liquidation reward for liquidating token in.\n  ",
        "@dev": "Return the amount of token out as liquidation reward for liquidating token in.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "asETHCollateral",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint"
            },
            {
                "name": "amount",
                "type": "uint"
            },
            {
                "name": "owner",
                "type": "address"
            }
        ],
        "func": "function asETHCollateral(\n    address token,\n    uint id,\n    uint amount,\n    address owner\n  ) external view override returns (uint) {\n    require(whitelistERC1155[token], 'bad token');\n    address tokenUnderlying = IERC20Wrapper(token).getUnderlyingToken(id);\n    uint rateUnderlying = IERC20Wrapper(token).getUnderlyingRate(id);\n    uint amountUnderlying = amount.mul(rateUnderlying).div(2**112);\n    Oracle memory oracle = oracles[tokenUnderlying];\n    require(oracle.liqIncentive != 0, 'bad underlying collateral');\n    uint ethValue = source.getETHPx(tokenUnderlying).mul(amountUnderlying).div(2**112);\n    return ethValue.mul(oracle.collateralFactor).div(10000);\n  }",
        "comments": [
            "",
            "  /// @dev Return the value of the given input as ETH for collateral purpose.",
            "  "
        ],
        "comt": "\n  /// @dev Return the value of the given input as ETH for collateral purpose.\n  ",
        "@dev": "Return the value of the given input as ETH for collateral purpose.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "asETHBorrow",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint"
            },
            {
                "name": "owner",
                "type": "address"
            }
        ],
        "func": "function asETHBorrow(\n    address token,\n    uint amount,\n    address owner\n  ) external view override returns (uint) {\n    Oracle memory oracle = oracles[token];\n    require(oracle.liqIncentive != 0, 'bad underlying borrow');\n    uint ethValue = source.getETHPx(token).mul(amount).div(2**112);\n    return ethValue.mul(oracle.borrowFactor).div(10000);\n  }",
        "comments": [
            "",
            "  /// @dev Return the value of the given input as ETH for borrow purpose.",
            "  "
        ],
        "comt": "\n  /// @dev Return the value of the given input as ETH for borrow purpose.\n  ",
        "@dev": "Return the value of the given input as ETH for borrow purpose.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setRoute",
        "visibility": "external",
        "args": [
            {
                "name": "tokens",
                "type": "address[] calldata"
            },
            {
                "name": "targets",
                "type": "address[] calldata"
            }
        ],
        "func": "function setRoute(address[] calldata tokens, address[] calldata targets) external onlyGov {\n    require(tokens.length == targets.length, 'inconsistent length');\n    for (uint idx = 0; idx < tokens.length; idx++) {\n      routes[tokens[idx]] = targets[idx];\n      emit SetRoute(tokens[idx], targets[idx]);\n    }\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getETHPx",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            }
        ],
        "func": "function getETHPx(address token) external view override returns (uint) {\n    uint px = IBaseOracle(routes[token]).getETHPx(token);\n    require(px != 0, 'no px');\n    return px;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapExactETHToAlpha",
        "visibility": "external",
        "args": [
            {
                "name": "amountOutMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapExactETHToAlpha(\n    uint amountOutMin,\n    address to,\n    uint deadline\n  ) external payable {\n    ibETHv2.deposit{value: msg.value}();\n    address[] memory path = new address[](2);\n    path[0] = address(ibETHv2);\n    path[1] = address(alpha);\n    router.swapExactTokensForTokens(\n      ibETHv2.balanceOf(address(this)),\n      amountOutMin,\n      path,\n      to,\n      deadline\n    );\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "swapExactAlphaToETH",
        "visibility": "external",
        "args": [
            {
                "name": "amountIn",
                "type": "uint"
            },
            {
                "name": "amountOutMin",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function swapExactAlphaToETH(\n    uint amountIn,\n    uint amountOutMin,\n    address to,\n    uint deadline\n  ) external {\n    alpha.transferFrom(msg.sender, address(this), amountIn);\n    address[] memory path = new address[](2);\n    path[0] = address(alpha);\n    path[1] = address(ibETHv2);\n    router.swapExactTokensForTokens(amountIn, 0, path, address(this), deadline);\n    ibETHv2.withdraw(ibETHv2.balanceOf(address(this)));\n    uint ethBalance = address(this).balance;\n    require(ethBalance >= amountOutMin, '!amountOutMin');\n    (bool success, ) = to.call{value: ethBalance}(new bytes(0));\n    require(success, '!eth');\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addLiquidityETHAlphaOptimal",
        "visibility": "external",
        "args": [
            {
                "name": "amountAlpha",
                "type": "uint"
            },
            {
                "name": "minLp",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function addLiquidityETHAlphaOptimal(\n    uint amountAlpha,\n    uint minLp,\n    address to,\n    uint deadline\n  ) external payable {\n    if (amountAlpha > 0) alpha.transferFrom(msg.sender, address(this), amountAlpha);\n    ibETHv2.deposit{value: msg.value}();\n    uint amountIbETHv2 = ibETHv2.balanceOf(address(this));\n    uint swapAmt;\n    bool isReversed;\n    {\n      (uint r0, uint r1, ) = lpToken.getReserves();\n      (uint ibETHv2Reserve, uint alphaReserve) =\n        lpToken.token0() == address(ibETHv2) ? (r0, r1) : (r1, r0);\n      (swapAmt, isReversed) = optimalDeposit(\n        amountIbETHv2,\n        amountAlpha,\n        ibETHv2Reserve,\n        alphaReserve\n      );\n    }\n    if (swapAmt > 0) {\n      address[] memory path = new address[](2);\n      (path[0], path[1]) = isReversed\n        ? (address(alpha), address(ibETHv2))\n        : (address(ibETHv2), address(alpha));\n      router.swapExactTokensForTokens(swapAmt, 0, path, address(this), deadline);\n    }\n    (, , uint liquidity) =\n      router.addLiquidity(\n        address(alpha),\n        address(ibETHv2),\n        alpha.balanceOf(address(this)),\n        ibETHv2.balanceOf(address(this)),\n        0,\n        0,\n        to,\n        deadline\n      );\n    require(liquidity >= minLp, '!minLP');\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addLiquidityIbETHv2AlphaOptimal",
        "visibility": "external",
        "args": [
            {
                "name": "amountIbETHv2",
                "type": "uint"
            },
            {
                "name": "amountAlpha",
                "type": "uint"
            },
            {
                "name": "minLp",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function addLiquidityIbETHv2AlphaOptimal(\n    uint amountIbETHv2,\n    uint amountAlpha,\n    uint minLp,\n    address to,\n    uint deadline\n  ) external {\n    if (amountAlpha > 0) alpha.transferFrom(msg.sender, address(this), amountAlpha);\n    if (amountIbETHv2 > 0) ibETHv2.transferFrom(msg.sender, address(this), amountIbETHv2);\n    uint swapAmt;\n    bool isReversed;\n    {\n      (uint r0, uint r1, ) = lpToken.getReserves();\n      (uint ibETHv2Reserve, uint alphaReserve) =\n        lpToken.token0() == address(ibETHv2) ? (r0, r1) : (r1, r0);\n      (swapAmt, isReversed) = optimalDeposit(\n        amountIbETHv2,\n        amountAlpha,\n        ibETHv2Reserve,\n        alphaReserve\n      );\n    }\n    if (swapAmt > 0) {\n      address[] memory path = new address[](2);\n      (path[0], path[1]) = isReversed\n        ? (address(alpha), address(ibETHv2))\n        : (address(ibETHv2), address(alpha));\n      router.swapExactTokensForTokens(swapAmt, 0, path, address(this), deadline);\n    }\n    (, , uint liquidity) =\n      router.addLiquidity(\n        address(alpha),\n        address(ibETHv2),\n        alpha.balanceOf(address(this)),\n        ibETHv2.balanceOf(address(this)),\n        0,\n        0,\n        to,\n        deadline\n      );\n    require(liquidity >= minLp, '!minLP');\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityETHAlpha",
        "visibility": "external",
        "args": [
            {
                "name": "liquidity",
                "type": "uint"
            },
            {
                "name": "minETH",
                "type": "uint"
            },
            {
                "name": "minAlpha",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function removeLiquidityETHAlpha(\n    uint liquidity,\n    uint minETH,\n    uint minAlpha,\n    address to,\n    uint deadline\n  ) external {\n    lpToken.transferFrom(msg.sender, address(this), liquidity);\n    router.removeLiquidity(\n      address(alpha),\n      address(ibETHv2),\n      liquidity,\n      minAlpha,\n      0,\n      address(this),\n      deadline\n    );\n    alpha.transfer(msg.sender, alpha.balanceOf(address(this)));\n    ibETHv2.withdraw(ibETHv2.balanceOf(address(this)));\n    uint ethBalance = address(this).balance;\n    require(ethBalance >= minETH, '!minETH');\n    (bool success, ) = to.call{value: ethBalance}(new bytes(0));\n    require(success, '!eth');\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "removeLiquidityAlphaOnly",
        "visibility": "external",
        "args": [
            {
                "name": "liquidity",
                "type": "uint"
            },
            {
                "name": "minAlpha",
                "type": "uint"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "deadline",
                "type": "uint"
            }
        ],
        "func": "function removeLiquidityAlphaOnly(\n    uint liquidity,\n    uint minAlpha,\n    address to,\n    uint deadline\n  ) external {\n    lpToken.transferFrom(msg.sender, address(this), liquidity);\n    router.removeLiquidity(\n      address(alpha),\n      address(ibETHv2),\n      liquidity,\n      0,\n      0,\n      address(this),\n      deadline\n    );\n    address[] memory path = new address[](2);\n    path[0] = address(ibETHv2);\n    path[1] = address(alpha);\n    router.swapExactTokensForTokens(\n      ibETHv2.balanceOf(address(this)),\n      0,\n      path,\n      address(this),\n      deadline\n    );\n    uint alphaBalance = alpha.balanceOf(address(this));\n    require(alphaBalance >= minAlpha, '!minAlpha');\n    alpha.transfer(to, alphaBalance);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cast",
        "visibility": "external",
        "args": [
            {
                "name": "target",
                "type": "address"
            },
            {
                "name": "data",
                "type": "bytes calldata"
            }
        ],
        "func": "function cast(address target, bytes calldata data) external payable {\n    (bool ok, bytes memory returndata) = target.call{value: msg.value}(data);\n    if (!ok) {\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert('bad cast call');\n      }\n    }\n  }",
        "comments": [
            "  /// @dev Call to the target using the given data.",
            "  /// @param target The address target to call.",
            "  /// @param data The data used in the call.",
            "  "
        ],
        "comt": "  /// @dev Call to the target using the given data.\n  /// @param target The address target to call.\n  /// @param data The data used in the call.\n  ",
        "@dev": "Call to the target using the given data.",
        "@param1": "target The address target to call.",
        "@param2": "data The data used in the call.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "initialize",
        "visibility": "external",
        "args": [
            {
                "name": "_oracle",
                "type": "IOracle"
            },
            {
                "name": "_feeBps",
                "type": "uint"
            }
        ],
        "func": "function initialize(IOracle _oracle, uint _feeBps) external initializer {\n    __Governable__init();\n    _GENERAL_LOCK = _NOT_ENTERED;\n    _IN_EXEC_LOCK = _NOT_ENTERED;\n    POSITION_ID = _NO_ID;\n    SPELL = _NO_ADDRESS;\n    caster = address(new HomoraCaster());\n    oracle = _oracle;\n    require(address(_oracle) != address(0), 'bad oracle address');\n    feeBps = _feeBps;\n    nextPositionId = 1;\n    emit SetOracle(address(_oracle));\n    emit SetFeeBps(_feeBps);\n  }",
        "comments": [
            "",
            "  /// @dev Initialize the bank smart contract, using msg.sender as the first governor.",
            "  /// @param _oracle The oracle smart contract address.",
            "  /// @param _feeBps The fee collected to Homora bank.",
            "  "
        ],
        "comt": "\n  /// @dev Initialize the bank smart contract, using msg.sender as the first governor.\n  /// @param _oracle The oracle smart contract address.\n  /// @param _feeBps The fee collected to Homora bank.\n  ",
        "@dev": "Initialize the bank smart contract, using msg.sender as the first governor.",
        "@param1": "_oracle The oracle smart contract address.",
        "@param2": "_feeBps The fee collected to Homora bank.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "EXECUTOR",
        "visibility": "external",
        "args": [],
        "func": "function EXECUTOR() external view override returns (address) {\n    uint positionId = POSITION_ID;\n    require(positionId != _NO_ID, 'not under execution');\n    return positions[positionId].owner;\n  }",
        "comments": [
            "",
            "  /// @dev Return the current executor (the owner of the current position).",
            "  "
        ],
        "comt": "\n  /// @dev Return the current executor (the owner of the current position).\n  ",
        "@dev": "Return the current executor (the owner of the current position).",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "accrue",
        "visibility": "public",
        "args": [
            {
                "name": "token",
                "type": "address"
            }
        ],
        "func": "function accrue(address token) public override {\n    Bank storage bank = banks[token];\n    require(bank.isListed, 'bank not exists');\n    uint totalDebt = bank.totalDebt;\n    uint debt = ICErc20(bank.cToken).borrowBalanceCurrent(address(this));\n    if (debt > totalDebt) {\n      uint fee = debt.sub(totalDebt).mul(feeBps).div(10000);\n      bank.totalDebt = debt;\n      bank.pendingReserve = bank.pendingReserve.add(fee);\n    } else if (totalDebt != debt) {\n      // We should never reach here because CREAMv2 does not support *repayBorrowBehalf*\n      // functionality. We set bank.totalDebt = debt nonetheless to ensure consistency. But do\n      // note that if *repayBorrowBehalf* exists, an attacker can maliciously deflate debt\n      // share value and potentially make this contract stop working due to math overflow.\n      bank.totalDebt = debt;\n    }\n  }",
        "comments": [
            "",
            "  /// @dev Trigger interest accrual for the given bank.",
            "  /// @param token The underlying token to trigger the interest accrual.",
            "  "
        ],
        "comt": "\n  /// @dev Trigger interest accrual for the given bank.\n  /// @param token The underlying token to trigger the interest accrual.\n  ",
        "@dev": "Trigger interest accrual for the given bank.",
        "@param1": "token The underlying token to trigger the interest accrual.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "accrueAll",
        "visibility": "external",
        "args": [
            {
                "name": "tokens",
                "type": "address[] memory"
            }
        ],
        "func": "function accrueAll(address[] memory tokens) external {\n    for (uint idx = 0; idx < tokens.length; idx++) {\n      accrue(tokens[idx]);\n    }\n  }",
        "comments": [
            "",
            "  /// @dev Convenient function to trigger interest accrual for a list of banks.",
            "  /// @param tokens The list of banks to trigger interest accrual.",
            "  "
        ],
        "comt": "\n  /// @dev Convenient function to trigger interest accrual for a list of banks.\n  /// @param tokens The list of banks to trigger interest accrual.\n  ",
        "@dev": "Convenient function to trigger interest accrual for a list of banks.",
        "@param1": "tokens The list of banks to trigger interest accrual.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "resolveReserve",
        "visibility": "public",
        "args": [
            {
                "name": "token",
                "type": "address"
            }
        ],
        "func": "function resolveReserve(address token) public lock poke(token) {\n    Bank storage bank = banks[token];\n    require(bank.isListed, 'bank not exists');\n    uint pendingReserve = bank.pendingReserve;\n    bank.pendingReserve = 0;\n    bank.reserve = bank.reserve.add(doBorrow(token, pendingReserve));\n  }",
        "comments": [
            "",
            "  /// @dev Trigger reserve resolve by borrowing the pending amount for reserve.",
            "  /// @param token The underlying token to trigger reserve resolve.",
            "  "
        ],
        "comt": "\n  /// @dev Trigger reserve resolve by borrowing the pending amount for reserve.\n  /// @param token The underlying token to trigger reserve resolve.\n  ",
        "@dev": "Trigger reserve resolve by borrowing the pending amount for reserve.",
        "@param1": "token The underlying token to trigger reserve resolve.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "resolveReserveAll",
        "visibility": "external",
        "args": [
            {
                "name": "tokens",
                "type": "address[] memory"
            }
        ],
        "func": "function resolveReserveAll(address[] memory tokens) external {\n    for (uint idx = 0; idx < tokens.length; idx++) {\n      resolveReserve(tokens[idx]);\n    }\n  }",
        "comments": [
            "",
            "  /// @dev Convenient function to trigger reserve resolve for the list of banks.",
            "  /// @param tokens The list of banks to trigger reserve resolve.",
            "  "
        ],
        "comt": "\n  /// @dev Convenient function to trigger reserve resolve for the list of banks.\n  /// @param tokens The list of banks to trigger reserve resolve.\n  ",
        "@dev": "Convenient function to trigger reserve resolve for the list of banks.",
        "@param1": "tokens The list of banks to trigger reserve resolve.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "borrowBalanceStored",
        "visibility": "public",
        "args": [
            {
                "name": "positionId",
                "type": "uint"
            },
            {
                "name": "token",
                "type": "address"
            }
        ],
        "func": "function borrowBalanceStored(uint positionId, address token) public view override returns (uint) {\n    uint totalDebt = banks[token].totalDebt;\n    uint totalShare = banks[token].totalShare;\n    uint share = positions[positionId].debtShareOf[token];\n    if (share == 0 || totalDebt == 0) {\n      return 0;\n    } else {\n      return share.mul(totalDebt).div(totalShare);\n    }\n  }",
        "comments": [
            "",
            "  /// @dev Return the borrow balance for given positon and token without trigger interest accrual.",
            "  /// @param positionId The position to query for borrow balance.",
            "  /// @param token The token to query for borrow balance.",
            "  "
        ],
        "comt": "\n  /// @dev Return the borrow balance for given positon and token without trigger interest accrual.\n  /// @param positionId The position to query for borrow balance.\n  /// @param token The token to query for borrow balance.\n  ",
        "@dev": "Return the borrow balance for given positon and token without trigger interest accrual.",
        "@param1": "positionId The position to query for borrow balance.",
        "@param2": "token The token to query for borrow balance.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "borrowBalanceCurrent",
        "visibility": "external",
        "args": [
            {
                "name": "positionId",
                "type": "uint"
            },
            {
                "name": "token",
                "type": "address"
            }
        ],
        "func": "function borrowBalanceCurrent(uint positionId, address token) external override returns (uint) {\n    accrue(token);\n    return borrowBalanceStored(positionId, token);\n  }",
        "comments": [
            "",
            "  /// @dev Trigger interest accrual and return the current borrow balance.",
            "  /// @param positionId The position to query for borrow balance.",
            "  /// @param token The token to query for borrow balance.",
            "  "
        ],
        "comt": "\n  /// @dev Trigger interest accrual and return the current borrow balance.\n  /// @param positionId The position to query for borrow balance.\n  /// @param token The token to query for borrow balance.\n  ",
        "@dev": "Trigger interest accrual and return the current borrow balance.",
        "@param1": "positionId The position to query for borrow balance.",
        "@param2": "token The token to query for borrow balance.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getBankInfo",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            }
        ],
        "func": "function getBankInfo(address token)\n    external\n    view\n    override\n    returns (\n      bool isListed,\n      address cToken,\n      uint reserve,\n      uint totalDebt,\n      uint totalShare\n    )\n  {\n    Bank storage bank = banks[token];\n    return (bank.isListed, bank.cToken, bank.reserve, bank.totalDebt, bank.totalShare);\n  }",
        "comments": [
            "",
            "  /// @dev Return bank information for the given token.",
            "  /// @param token The token address to query for bank information.",
            "  "
        ],
        "comt": "\n  /// @dev Return bank information for the given token.\n  /// @param token The token address to query for bank information.\n  ",
        "@dev": "Return bank information for the given token.",
        "@param1": "token The token address to query for bank information.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPositionInfo",
        "visibility": "external",
        "args": [
            {
                "name": "positionId",
                "type": "uint"
            }
        ],
        "func": "function getPositionInfo(uint positionId)\n    external\n    view\n    override\n    returns (\n      address owner,\n      address collToken,\n      uint collId,\n      uint collateralSize\n    )\n  {\n    Position storage pos = positions[positionId];\n    return (pos.owner, pos.collToken, pos.collId, pos.collateralSize);\n  }",
        "comments": [
            "",
            "  /// @dev Return position information for the given position id.",
            "  /// @param positionId The position id to query for position information.",
            "  "
        ],
        "comt": "\n  /// @dev Return position information for the given position id.\n  /// @param positionId The position id to query for position information.\n  ",
        "@dev": "Return position information for the given position id.",
        "@param1": "positionId The position id to query for position information.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPositionDebtShareOf",
        "visibility": "external",
        "args": [
            {
                "name": "positionId",
                "type": "uint"
            },
            {
                "name": "token",
                "type": "address"
            }
        ],
        "func": "function getPositionDebtShareOf(uint positionId, address token) external view returns (uint) {\n    return positions[positionId].debtShareOf[token];\n  }",
        "comments": [
            "",
            "  /// @dev Return the debt share of the given bank token for the given position id.",
            "  "
        ],
        "comt": "\n  /// @dev Return the debt share of the given bank token for the given position id.\n  ",
        "@dev": "Return the debt share of the given bank token for the given position id.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPositionDebts",
        "visibility": "external",
        "args": [
            {
                "name": "positionId",
                "type": "uint"
            }
        ],
        "func": "function getPositionDebts(uint positionId)\n    external\n    view\n    returns (address[] memory tokens, uint[] memory debts)\n  {\n    Position storage pos = positions[positionId];\n    uint count = 0;\n    uint bitMap = pos.debtMap;\n    while (bitMap > 0) {\n      if ((bitMap & 1) != 0) {\n        count++;\n      }\n      bitMap >>= 1;\n    }\n    tokens = new address[](count);\n    debts = new uint[](count);\n    bitMap = pos.debtMap;\n    count = 0;\n    uint idx = 0;\n    while (bitMap > 0) {\n      if ((bitMap & 1) != 0) {\n        address token = allBanks[idx];\n        Bank storage bank = banks[token];\n        tokens[count] = token;\n        debts[count] = pos.debtShareOf[token].mul(bank.totalDebt).div(bank.totalShare);\n        count++;\n      }\n      idx++;\n      bitMap >>= 1;\n    }\n  }",
        "comments": [
            "",
            "  /// @dev Return the list of all debts for the given position id.",
            "  "
        ],
        "comt": "\n  /// @dev Return the list of all debts for the given position id.\n  ",
        "@dev": "Return the list of all debts for the given position id.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCollateralETHValue",
        "visibility": "public",
        "args": [
            {
                "name": "positionId",
                "type": "uint"
            }
        ],
        "func": "function getCollateralETHValue(uint positionId) public view returns (uint) {\n    Position storage pos = positions[positionId];\n    uint size = pos.collateralSize;\n    if (size == 0) {\n      return 0;\n    } else {\n      require(pos.collToken != address(0), 'bad collateral token');\n      return oracle.asETHCollateral(pos.collToken, pos.collId, size, pos.owner);\n    }\n  }",
        "comments": [
            "",
            "  /// @dev Return the total collateral value of the given position in ETH.",
            "  /// @param positionId The position ID to query for the collateral value.",
            "  "
        ],
        "comt": "\n  /// @dev Return the total collateral value of the given position in ETH.\n  /// @param positionId The position ID to query for the collateral value.\n  ",
        "@dev": "Return the total collateral value of the given position in ETH.",
        "@param1": "positionId The position ID to query for the collateral value.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getBorrowETHValue",
        "visibility": "public",
        "args": [
            {
                "name": "positionId",
                "type": "uint"
            }
        ],
        "func": "function getBorrowETHValue(uint positionId) public view override returns (uint) {\n    uint value = 0;\n    Position storage pos = positions[positionId];\n    address owner = pos.owner;\n    uint bitMap = pos.debtMap;\n    uint idx = 0;\n    while (bitMap > 0) {\n      if ((bitMap & 1) != 0) {\n        address token = allBanks[idx];\n        uint share = pos.debtShareOf[token];\n        Bank storage bank = banks[token];\n        uint debt = share.mul(bank.totalDebt).div(bank.totalShare);\n        value = value.add(oracle.asETHBorrow(token, debt, owner));\n      }\n      idx++;\n      bitMap >>= 1;\n    }\n    return value;\n  }",
        "comments": [
            "",
            "  /// @dev Return the total borrow value of the given position in ETH.",
            "  /// @param positionId The position ID to query for the borrow value.",
            "  "
        ],
        "comt": "\n  /// @dev Return the total borrow value of the given position in ETH.\n  /// @param positionId The position ID to query for the borrow value.\n  ",
        "@dev": "Return the total borrow value of the given position in ETH.",
        "@param1": "positionId The position ID to query for the borrow value.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addBank",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "cToken",
                "type": "address"
            }
        ],
        "func": "function addBank(address token, address cToken) external onlyGov {\n    Bank storage bank = banks[token];\n    require(!cTokenInBank[cToken], 'cToken already exists');\n    require(!bank.isListed, 'bank already exists');\n    cTokenInBank[cToken] = true;\n    bank.isListed = true;\n    require(allBanks.length < 256, 'reach bank limit');\n    bank.index = uint8(allBanks.length);\n    bank.cToken = cToken;\n    IERC20(token).safeApprove(cToken, 0);\n    IERC20(token).safeApprove(cToken, uint(-1));\n    allBanks.push(token);\n    emit AddBank(token, cToken);\n  }",
        "comments": [
            "",
            "  /// @dev Add a new bank to the ecosystem.",
            "  /// @param token The underlying token for the bank.",
            "  /// @param cToken The address of the cToken smart contract.",
            "  "
        ],
        "comt": "\n  /// @dev Add a new bank to the ecosystem.\n  /// @param token The underlying token for the bank.\n  /// @param cToken The address of the cToken smart contract.\n  ",
        "@dev": "Add a new bank to the ecosystem.",
        "@param1": "token The underlying token for the bank.",
        "@param2": "cToken The address of the cToken smart contract.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setOracle",
        "visibility": "external",
        "args": [
            {
                "name": "_oracle",
                "type": "IOracle"
            }
        ],
        "func": "function setOracle(IOracle _oracle) external onlyGov {\n    oracle = _oracle;\n    emit SetOracle(address(_oracle));\n  }",
        "comments": [
            "",
            "  /// @dev Set the oracle smart contract address.",
            "  /// @param _oracle The new oracle smart contract address.",
            "  "
        ],
        "comt": "\n  /// @dev Set the oracle smart contract address.\n  /// @param _oracle The new oracle smart contract address.\n  ",
        "@dev": "Set the oracle smart contract address.",
        "@param1": "_oracle The new oracle smart contract address.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setFeeBps",
        "visibility": "external",
        "args": [
            {
                "name": "_feeBps",
                "type": "uint"
            }
        ],
        "func": "function setFeeBps(uint _feeBps) external onlyGov {\n    require(_feeBps <= 10000, 'fee too high');\n    feeBps = _feeBps;\n    emit SetFeeBps(_feeBps);\n  }",
        "comments": [
            "",
            "  /// @dev Set the fee bps value that Homora bank charges.",
            "  /// @param _feeBps The new fee bps value.",
            "  "
        ],
        "comt": "\n  /// @dev Set the fee bps value that Homora bank charges.\n  /// @param _feeBps The new fee bps value.\n  ",
        "@dev": "Set the fee bps value that Homora bank charges.",
        "@param1": "_feeBps The new fee bps value.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawReserve",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function withdrawReserve(address token, uint amount) external onlyGov lock {\n    Bank storage bank = banks[token];\n    require(bank.isListed, 'bank not exists');\n    bank.reserve = bank.reserve.sub(amount);\n    IERC20(token).safeTransfer(msg.sender, amount);\n    emit WithdrawReserve(msg.sender, token, amount);\n  }",
        "comments": [
            "",
            "  /// @dev Withdraw the reserve portion of the bank.",
            "  /// @param amount The amount of tokens to withdraw.",
            "  "
        ],
        "comt": "\n  /// @dev Withdraw the reserve portion of the bank.\n  /// @param amount The amount of tokens to withdraw.\n  ",
        "@dev": "Withdraw the reserve portion of the bank.",
        "@param1": "amount The amount of tokens to withdraw.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "liquidate",
        "visibility": "external",
        "args": [
            {
                "name": "positionId",
                "type": "uint"
            },
            {
                "name": "debtToken",
                "type": "address"
            },
            {
                "name": "amountCall",
                "type": "uint"
            }
        ],
        "func": "function liquidate(\n    uint positionId,\n    address debtToken,\n    uint amountCall\n  ) external override lock poke(debtToken) {\n    uint collateralValue = getCollateralETHValue(positionId);\n    uint borrowValue = getBorrowETHValue(positionId);\n    require(collateralValue < borrowValue, 'position still healthy');\n    Position storage pos = positions[positionId];\n    (uint amountPaid, uint share) = repayInternal(positionId, debtToken, amountCall);\n    require(pos.collToken != address(0), 'bad collateral token');\n    uint bounty =\n      Math.min(\n        oracle.convertForLiquidation(debtToken, pos.collToken, pos.collId, amountPaid),\n        pos.collateralSize\n      );\n    pos.collateralSize = pos.collateralSize.sub(bounty);\n    IERC1155(pos.collToken).safeTransferFrom(address(this), msg.sender, pos.collId, bounty, '');\n    emit Liquidate(positionId, msg.sender, debtToken, amountPaid, share, bounty);\n  }",
        "comments": [
            "",
            "  /// @dev Liquidate a position. Pay debt for its owner and take the collateral.",
            "  /// @param positionId The position ID to liquidate.",
            "  /// @param debtToken The debt token to repay.",
            "  /// @param amountCall The amount to repay when doing transferFrom call.",
            "  "
        ],
        "comt": "\n  /// @dev Liquidate a position. Pay debt for its owner and take the collateral.\n  /// @param positionId The position ID to liquidate.\n  /// @param debtToken The debt token to repay.\n  /// @param amountCall The amount to repay when doing transferFrom call.\n  ",
        "@dev": "Liquidate a position. Pay debt for its owner and take the collateral.",
        "@param1": "positionId The position ID to liquidate.",
        "@param2": "debtToken The debt token to repay.",
        "@param3": "amountCall The amount to repay when doing transferFrom call.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "execute",
        "visibility": "external",
        "args": [
            {
                "name": "positionId",
                "type": "uint"
            },
            {
                "name": "spell",
                "type": "address"
            },
            {
                "name": "data",
                "type": "bytes memory"
            }
        ],
        "func": "function execute(\n    uint positionId,\n    address spell,\n    bytes memory data\n  ) external payable lock returns (uint) {\n    if (positionId == 0) {\n      positionId = nextPositionId++;\n      positions[positionId].owner = msg.sender;\n    } else {\n      require(positionId < nextPositionId, 'position id not exists');\n      require(msg.sender == positions[positionId].owner, 'not position owner');\n    }\n    POSITION_ID = positionId;\n    SPELL = spell;\n    HomoraCaster(caster).cast{value: msg.value}(spell, data);\n    uint collateralValue = getCollateralETHValue(positionId);\n    uint borrowValue = getBorrowETHValue(positionId);\n    require(collateralValue >= borrowValue, 'insufficient collateral');\n    POSITION_ID = _NO_ID;\n    SPELL = _NO_ADDRESS;\n    return positionId;\n  }",
        "comments": [
            "",
            "  /// @dev Execute the action via HomoraCaster, calling its function with the supplied data.",
            "  /// @param positionId The position ID to execute the action, or zero for new position.",
            "  /// @param spell The target spell to invoke the execution via HomoraCaster.",
            "  /// @param data Extra data to pass to the target for the execution.",
            "  "
        ],
        "comt": "\n  /// @dev Execute the action via HomoraCaster, calling its function with the supplied data.\n  /// @param positionId The position ID to execute the action, or zero for new position.\n  /// @param spell The target spell to invoke the execution via HomoraCaster.\n  /// @param data Extra data to pass to the target for the execution.\n  ",
        "@dev": "Execute the action via HomoraCaster, calling its function with the supplied data.",
        "@param1": "positionId The position ID to execute the action, or zero for new position.",
        "@param2": "spell The target spell to invoke the execution via HomoraCaster.",
        "@param3": "data Extra data to pass to the target for the execution.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "borrow",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function borrow(address token, uint amount) external override inExec poke(token) {\n    Bank storage bank = banks[token];\n    require(bank.isListed, 'bank not exists');\n    Position storage pos = positions[POSITION_ID];\n    uint totalShare = bank.totalShare;\n    uint totalDebt = bank.totalDebt;\n    uint share = totalShare == 0 ? amount : amount.mul(totalShare).div(totalDebt);\n    bank.totalShare = bank.totalShare.add(share);\n    uint newShare = pos.debtShareOf[token].add(share);\n    pos.debtShareOf[token] = newShare;\n    if (newShare > 0) {\n      pos.debtMap |= (1 << uint(bank.index));\n    }\n    IERC20(token).safeTransfer(msg.sender, doBorrow(token, amount));\n    emit Borrow(POSITION_ID, msg.sender, token, amount, share);\n  }",
        "comments": [
            "",
            "  /// @dev Borrow tokens from that bank. Must only be called while under execution.",
            "  /// @param token The token to borrow from the bank.",
            "  /// @param amount The amount of tokens to borrow.",
            "  "
        ],
        "comt": "\n  /// @dev Borrow tokens from that bank. Must only be called while under execution.\n  /// @param token The token to borrow from the bank.\n  /// @param amount The amount of tokens to borrow.\n  ",
        "@dev": "Borrow tokens from that bank. Must only be called while under execution.",
        "@param1": "token The token to borrow from the bank.",
        "@param2": "amount The amount of tokens to borrow.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repay",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "amountCall",
                "type": "uint"
            }
        ],
        "func": "function repay(address token, uint amountCall) external override inExec poke(token) {\n    (uint amount, uint share) = repayInternal(POSITION_ID, token, amountCall);\n    emit Repay(POSITION_ID, msg.sender, token, amount, share);\n  }",
        "comments": [
            "",
            "  /// @dev Repay tokens to the bank. Must only be called while under execution.",
            "  /// @param token The token to repay to the bank.",
            "  /// @param amountCall The amount of tokens to repay via transferFrom.",
            "  "
        ],
        "comt": "\n  /// @dev Repay tokens to the bank. Must only be called while under execution.\n  /// @param token The token to repay to the bank.\n  /// @param amountCall The amount of tokens to repay via transferFrom.\n  ",
        "@dev": "Repay tokens to the bank. Must only be called while under execution.",
        "@param1": "token The token to repay to the bank.",
        "@param2": "amountCall The amount of tokens to repay via transferFrom.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transmit",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function transmit(address token, uint amount) external override inExec {\n    Position storage pos = positions[POSITION_ID];\n    IERC20(token).safeTransferFrom(pos.owner, msg.sender, amount);\n  }",
        "comments": [
            "",
            "  /// @dev Transmit user assets to the caller, so users only need to approve Bank for spending.",
            "  /// @param token The token to transfer from user to the caller.",
            "  /// @param amount The amount to transfer.",
            "  "
        ],
        "comt": "\n  /// @dev Transmit user assets to the caller, so users only need to approve Bank for spending.\n  /// @param token The token to transfer from user to the caller.\n  /// @param amount The amount to transfer.\n  ",
        "@dev": "Transmit user assets to the caller, so users only need to approve Bank for spending.",
        "@param1": "token The token to transfer from user to the caller.",
        "@param2": "amount The amount to transfer.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "putCollateral",
        "visibility": "external",
        "args": [
            {
                "name": "collToken",
                "type": "address"
            },
            {
                "name": "collId",
                "type": "uint"
            },
            {
                "name": "amountCall",
                "type": "uint"
            }
        ],
        "func": "function putCollateral(\n    address collToken,\n    uint collId,\n    uint amountCall\n  ) external override inExec {\n    Position storage pos = positions[POSITION_ID];\n    if (pos.collToken != collToken || pos.collId != collId) {\n      require(oracle.support(collToken, collId), 'collateral not supported');\n      require(pos.collateralSize == 0, 'another type of collateral already exists');\n      pos.collToken = collToken;\n      pos.collId = collId;\n    }\n    uint amount = doERC1155TransferIn(collToken, collId, amountCall);\n    pos.collateralSize = pos.collateralSize.add(amount);\n    emit PutCollateral(POSITION_ID, msg.sender, collToken, collId, amount);\n  }",
        "comments": [
            "",
            "  /// @dev Put more collateral for users. Must only be called during execution.",
            "  /// @param collToken The ERC1155 token to collateral.",
            "  /// @param collId The token id to collateral.",
            "  /// @param amountCall The amount of tokens to put via transferFrom.",
            "  "
        ],
        "comt": "\n  /// @dev Put more collateral for users. Must only be called during execution.\n  /// @param collToken The ERC1155 token to collateral.\n  /// @param collId The token id to collateral.\n  /// @param amountCall The amount of tokens to put via transferFrom.\n  ",
        "@dev": "Put more collateral for users. Must only be called during execution.",
        "@param1": "collToken The ERC1155 token to collateral.",
        "@param2": "collId The token id to collateral.",
        "@param3": "amountCall The amount of tokens to put via transferFrom.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "takeCollateral",
        "visibility": "external",
        "args": [
            {
                "name": "collToken",
                "type": "address"
            },
            {
                "name": "collId",
                "type": "uint"
            },
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function takeCollateral(\n    address collToken,\n    uint collId,\n    uint amount\n  ) external override inExec {\n    Position storage pos = positions[POSITION_ID];\n    require(collToken == pos.collToken, 'invalid collateral token');\n    require(collId == pos.collId, 'invalid collateral token');\n    if (amount == uint(-1)) {\n      amount = pos.collateralSize;\n    }\n    pos.collateralSize = pos.collateralSize.sub(amount);\n    IERC1155(collToken).safeTransferFrom(address(this), msg.sender, collId, amount, '');\n    emit TakeCollateral(POSITION_ID, msg.sender, collToken, collId, amount);\n  }",
        "comments": [
            "",
            "  /// @dev Take some collateral back. Must only be called during execution.",
            "  /// @param collToken The ERC1155 token to take back.",
            "  /// @param collId The token id to take back.",
            "  /// @param amount The amount of tokens to take back via transfer.",
            "  "
        ],
        "comt": "\n  /// @dev Take some collateral back. Must only be called during execution.\n  /// @param collToken The ERC1155 token to take back.\n  /// @param collId The token id to take back.\n  /// @param amount The amount of tokens to take back via transfer.\n  ",
        "@dev": "Take some collateral back. Must only be called during execution.",
        "@param1": "collToken The ERC1155 token to take back.",
        "@param2": "collId The token id to take back.",
        "@param3": "amount The amount of tokens to take back via transfer.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setRelayer",
        "visibility": "external",
        "args": [
            {
                "name": "_relayer",
                "type": "address"
            }
        ],
        "func": "function setRelayer(address _relayer) external onlyGov {\n    relayer = _relayer;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateRoot",
        "visibility": "external",
        "args": [
            {
                "name": "_root",
                "type": "bytes32"
            }
        ],
        "func": "function updateRoot(bytes32 _root) external {\n    require(msg.sender == relayer || msg.sender == governor, '!relayer');\n    root = _root;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "deposit",
        "visibility": "external",
        "args": [],
        "func": "function deposit() external payable nonReentrant {\n    weth.deposit{value: msg.value}();\n    uint cBalanceBefore = cToken.balanceOf(address(this));\n    require(cToken.mint(msg.value) == 0, '!mint');\n    uint cBalanceAfter = cToken.balanceOf(address(this));\n    _mint(msg.sender, cBalanceAfter.sub(cBalanceBefore));\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function withdraw(uint amount) public nonReentrant {\n    _burn(msg.sender, amount);\n    uint wethBalanceBefore = weth.balanceOf(address(this));\n    require(cToken.redeem(amount) == 0, '!redeem');\n    uint wethBalanceAfter = weth.balanceOf(address(this));\n    uint wethAmount = wethBalanceAfter.sub(wethBalanceBefore);\n    weth.withdraw(wethAmount);\n    (bool success, ) = msg.sender.call{value: wethAmount}(new bytes(0));\n    require(success, '!withdraw');\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "claim",
        "visibility": "public",
        "args": [
            {
                "name": "totalReward",
                "type": "uint"
            },
            {
                "name": "proof",
                "type": "bytes32[] memory"
            }
        ],
        "func": "function claim(uint totalReward, bytes32[] memory proof) public nonReentrant {\n    bytes32 leaf = keccak256(abi.encodePacked(msg.sender, totalReward));\n    require(MerkleProof.verify(proof, root, leaf), '!proof');\n    uint send = totalReward.sub(claimed[msg.sender]);\n    claimed[msg.sender] = totalReward;\n    weth.withdraw(send);\n    (bool success, ) = msg.sender.call{value: send}(new bytes(0));\n    require(success, '!claim');\n    emit Claim(msg.sender, send);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "adminClaim",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function adminClaim(uint amount) external onlyGov {\n    weth.withdraw(amount);\n    (bool success, ) = msg.sender.call{value: amount}(new bytes(0));\n    require(success, '!adminClaim');\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "claimAndWithdraw",
        "visibility": "external",
        "args": [
            {
                "name": "claimAmount",
                "type": "uint"
            },
            {
                "name": "proof",
                "type": "bytes32[] memory"
            },
            {
                "name": "withdrawAmount",
                "type": "uint"
            }
        ],
        "func": "function claimAndWithdraw(\n    uint claimAmount,\n    bytes32[] memory proof,\n    uint withdrawAmount\n  ) external {\n    claim(claimAmount, proof);\n    withdraw(withdrawAmount);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "name",
        "visibility": "public",
        "args": [],
        "func": "function name() public view returns (string memory) {\n        return _name;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the name of the token.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the name of the token.\n     */\n",
        "@dev": "Returns the name of the token.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "symbol",
        "visibility": "public",
        "args": [],
        "func": "function symbol() public view returns (string memory) {\n        return _symbol;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the symbol of the token, usually a shorter version of the",
            "     * name.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n",
        "@dev": "Returns the symbol of the token, usually a shorter version of the * name.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decimals",
        "visibility": "public",
        "args": [],
        "func": "function decimals() public view returns (uint8) {\n        return _decimals;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the number of decimals used to get its user representation.",
            "     * For example, if `decimals` equals `2`, a balance of `505` tokens should",
            "     * be displayed to a user as `5,05` (`505 / 10 ** 2`).",
            "     *",
            "     * Tokens usually opt for a value of 18, imitating the relationship between",
            "     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is",
            "     * called.",
            "     *",
            "     * NOTE: This information is only used for _display_ purposes: it in",
            "     * no way affects any of the arithmetic of the contract, including",
            "     * {IERC20-balanceOf} and {IERC20-transfer}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n",
        "@dev": "Returns the number of decimals used to get its user representation. * For example, if `decimals` equals `2`, a balance of `505` tokens should * be displayed to a user as `5,05` (`505 / 10 ** 2`). * * Tokens usually opt for a value of 18, imitating the relationship between * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is * called. * * NOTE: This information is only used for _display_ purposes: it in * no way affects any of the arithmetic of the contract, including * {IERC20-balanceOf} and {IERC20-transfer}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-totalSupply}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-totalSupply}.\n     */\n",
        "@dev": "See {IERC20-totalSupply}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-balanceOf}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-balanceOf}.\n     */\n",
        "@dev": "See {IERC20-balanceOf}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-transfer}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `recipient` cannot be the zero address.",
            "     * - the caller must have a balance of at least `amount`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n",
        "@dev": "See {IERC20-transfer}. * * Requirements: * * - `recipient` cannot be the zero address. * - the caller must have a balance of at least `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allowance",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            }
        ],
        "func": "function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-allowance}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-allowance}.\n     */\n",
        "@dev": "See {IERC20-allowance}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-approve}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n",
        "@dev": "See {IERC20-approve}. * * Requirements: * * - `spender` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-transferFrom}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance. This is not",
            "     * required by the EIP. See the note at the beginning of {ERC20};",
            "     *",
            "     * Requirements:",
            "     * - `sender` and `recipient` cannot be the zero address.",
            "     * - `sender` must have a balance of at least `amount`.",
            "     * - the caller must have allowance for ``sender``'s tokens of at least",
            "     * `amount`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n",
        "@dev": "See {IERC20-transferFrom}. * * Emits an {Approval} event indicating the updated allowance. This is not * required by the EIP. See the note at the beginning of {ERC20}; * * Requirements: * - `sender` and `recipient` cannot be the zero address. * - `sender` must have a balance of at least `amount`. * - the caller must have allowance for ``sender``'s tokens of at least * `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "increaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "addedValue",
                "type": "uint256"
            }
        ],
        "func": "function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Atomically increases the allowance granted to `spender` by the caller.",
            "     *",
            "     * This is an alternative to {approve} that can be used as a mitigation for",
            "     * problems described in {IERC20-approve}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n",
        "@dev": "Atomically increases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decreaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "subtractedValue",
                "type": "uint256"
            }
        ],
        "func": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Atomically decreases the allowance granted to `spender` by the caller.",
            "     *",
            "     * This is an alternative to {approve} that can be used as a mitigation for",
            "     * problems described in {IERC20-approve}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     * - `spender` must have allowance for the caller of at least",
            "     * `subtractedValue`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n",
        "@dev": "Atomically decreases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address. * - `spender` must have allowance for the caller of at least * `subtractedValue`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "uri",
        "visibility": "external",
        "args": [
            {
                "name": "uint256",
                "type": "uint256"
            }
        ],
        "func": "function uri(uint256) external view override returns (string memory) {\n        return _uri;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC1155MetadataURI-uri}.",
            "     *",
            "     * This implementation returns the same URI for *all* token types. It relies",
            "     * on the token type ID substitution mechanism",
            "     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].",
            "     *",
            "     * Clients calling this function must replace the `\\{id\\}` substring with the",
            "     * actual token type ID.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n",
        "@dev": "See {IERC1155MetadataURI-uri}. * * This implementation returns the same URI for *all* token types. It relies * on the token type ID substitution mechanism * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. * * Clients calling this function must replace the `\\{id\\}` substring with the * actual token type ID.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function balanceOf(address account, uint256 id) public view override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC1155-balanceOf}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `account` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n",
        "@dev": "See {IERC1155-balanceOf}. * * Requirements: * * - `account` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOfBatch",
        "visibility": "public",
        "args": [
            {
                "name": "accounts",
                "type": "address[] memory"
            },
            {
                "name": "ids",
                "type": "uint256[] memory"
            }
        ],
        "func": "function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            require(accounts[i] != address(0), \"ERC1155: batch balance query for the zero address\");\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\n        }\n\n        return batchBalances;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC1155-balanceOfBatch}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `accounts` and `ids` must have the same length.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n",
        "@dev": "See {IERC1155-balanceOfBatch}. * * Requirements: * * - `accounts` and `ids` must have the same length.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setApprovalForAll",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "approved",
                "type": "bool"
            }
        ],
        "func": "function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC1155-setApprovalForAll}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n",
        "@dev": "See {IERC1155-setApprovalForAll}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isApprovedForAll",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            },
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function isApprovedForAll(address account, address operator) public view override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC1155-isApprovedForAll}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n",
        "@dev": "See {IERC1155-isApprovedForAll}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "safeTransferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            },
            {
                "name": "amount",
                "type": "uint256"
            },
            {
                "name": "data",
                "type": "bytes memory"
            }
        ],
        "func": "function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC1155-safeTransferFrom}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n",
        "@dev": "See {IERC1155-safeTransferFrom}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "safeBatchTransferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "ids",
                "type": "uint256[] memory"
            },
            {
                "name": "amounts",
                "type": "uint256[] memory"
            },
            {
                "name": "data",
                "type": "bytes memory"
            }
        ],
        "func": "function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC1155-safeBatchTransferFrom}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n",
        "@dev": "See {IERC1155-safeBatchTransferFrom}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "supportsInterface",
        "visibility": "public",
        "args": [
            {
                "name": "interfaceId",
                "type": "bytes4"
            }
        ],
        "func": "function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC165-supportsInterface}.",
            "     *",
            "     * Time complexity O(1), guaranteed to always use less than 30 000 gas.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n",
        "@dev": "See {IERC165-supportsInterface}. * * Time complexity O(1), guaranteed to always use less than 30 000 gas.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    }
]