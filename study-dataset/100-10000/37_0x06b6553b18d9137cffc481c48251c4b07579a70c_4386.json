[
    {
        "transactions": 4386,
        "function_num": 37
    },
    {
        "name": "mint",
        "visibility": "external",
        "args": [
            {
                "name": "quantity",
                "type": "uint256"
            }
        ],
        "func": "function mint(uint256 quantity)\n        external\n        payable\n        whenMintIsPublic\n        rightPublicPrice(quantity)\n        belowTotalSupply(quantity)\n        belowPublicLimit(quantity)\n    {\n        _safeMint(msg.sender, quantity);\n    }",
        "comments": [
            "",
            "    /// @notice Mint your NFT(s) (public sale)",
            "    /// @param quantity number of NFT to mint",
            "    /// no gift allowed nor minting from other smartcontracts",
            "    "
        ],
        "comt": "\n    /// @notice Mint your NFT(s) (public sale)\n    /// @param quantity number of NFT to mint\n    /// no gift allowed nor minting from other smartcontracts\n    ",
        "@notice": "Mint your NFT(s) (public sale)",
        "@param1": "quantity number of NFT to mint /// no gift allowed nor minting from other smartcontracts",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mintTo",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "quantity",
                "type": "uint256"
            }
        ],
        "func": "function mintTo(address to, uint256 quantity)\n        external\n        payable\n        whenMintIsPublic\n        rightPublicPrice(quantity)\n        belowTotalSupply(quantity)\n        belowPublicLimit(quantity)\n    {\n        require(msg.sender == CROSSMINT_ADDRESS, \"for crossmint only.\");\n        _safeMint(to, quantity);\n    }",
        "comments": [
            "",
            "    /// @notice Mint NFT(s) by Credit Card with Crossmint (public sale)",
            "    /// @param to NFT recipient",
            "    /// @param quantity number of NFT to mint",
            "    "
        ],
        "comt": "\n    /// @notice Mint NFT(s) by Credit Card with Crossmint (public sale)\n    /// @param to NFT recipient\n    /// @param quantity number of NFT to mint\n    ",
        "@notice": "Mint NFT(s) by Credit Card with Crossmint (public sale)",
        "@param1": "to NFT recipient",
        "@param2": "quantity number of NFT to mint",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mintPresale",
        "visibility": "external",
        "args": [
            {
                "name": "quantity",
                "type": "uint256"
            },
            {
                "name": "max",
                "type": "uint256"
            },
            {
                "name": "nonce",
                "type": "uint256"
            },
            {
                "name": "sig",
                "type": "bytes memory"
            }
        ],
        "func": "function mintPresale(\n        uint256 quantity,\n        uint256 max,\n        uint256 nonce,\n        bytes memory sig\n    )\n        external\n        payable\n        whenMintIsPresale\n        rightPresalePrice(quantity)\n        belowTotalSupply(quantity)\n        belowMaxAllowed(quantity, max)\n    {\n        string memory phase = step == MintStep.ALLOWLIST\n            ? \"allowlist\"\n            : \"waitlist\";\n        require(!_nonces[nonce], \"presale nonce already used.\");\n        _nonces[nonce] = true;\n        _validateSig(phase, msg.sender, max, nonce, sig);\n\n        _safeMint(msg.sender, quantity);\n    }",
        "comments": [
            "",
            "    /// @notice Mint NFT(s) during allowlist/waitlist sale",
            "    /// Can only be done once.",
            "    /// @param quantity number of NFT to mint",
            "    /// @param max Max number of token allowed to mint",
            "    /// @param nonce Random number providing a mint spot",
            "    /// @param sig ECDSA signature allowing the mint",
            "    "
        ],
        "comt": "\n    /// @notice Mint NFT(s) during allowlist/waitlist sale\n    /// Can only be done once.\n    /// @param quantity number of NFT to mint\n    /// @param max Max number of token allowed to mint\n    /// @param nonce Random number providing a mint spot\n    /// @param sig ECDSA signature allowing the mint\n    ",
        "@notice": "Mint NFT(s) during allowlist/waitlist sale /// Can only be done once.",
        "@param1": "quantity number of NFT to mint",
        "@param2": "max Max number of token allowed to mint",
        "@param3": "nonce Random number providing a mint spot",
        "@param4": "sig ECDSA signature allowing the mint",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mintPresaleWithGiveaway",
        "visibility": "external",
        "args": [
            {
                "name": "quantityGiveaway",
                "type": "uint256"
            },
            {
                "name": "nonceGiveaway",
                "type": "uint256"
            },
            {
                "name": "quantityPresale",
                "type": "uint256"
            },
            {
                "name": "maxPresale",
                "type": "uint256"
            },
            {
                "name": "noncePresale",
                "type": "uint256"
            },
            {
                "name": "sigGiveaway",
                "type": "bytes memory"
            },
            {
                "name": "sigPresale",
                "type": "bytes memory"
            }
        ],
        "func": "function mintPresaleWithGiveaway(\n        uint256 quantityGiveaway,\n        uint256 nonceGiveaway,\n        uint256 quantityPresale,\n        uint256 maxPresale,\n        uint256 noncePresale,\n        bytes memory sigGiveaway,\n        bytes memory sigPresale\n    ) external payable whenMintIsPresale {\n        if (quantityPresale > 0) {\n            require(quantityPresale <= maxPresale, \"quantity above max\");\n            require(!_nonces[noncePresale], \"presale nonce already used.\");\n            require(\n                totalSupply() + quantityPresale <= maxSupply - giveaway,\n                \"not enough tokens left.\"\n            );\n            require(\n                quantityPresale * presalePrice <= msg.value,\n                \"incorrect price\"\n            );\n            _nonces[noncePresale] = true;\n            string memory phase = step == MintStep.ALLOWLIST\n                ? \"allowlist\"\n                : \"waitlist\";\n            _validateSig(\n                phase,\n                msg.sender,\n                maxPresale,\n                noncePresale,\n                sigPresale\n            );\n        }\n        if (quantityGiveaway > 0) {\n            require(!_nonces[nonceGiveaway], \"giveaway nonce already used.\");\n            uint256 giveaway_ = giveaway;\n            require(\n                quantityGiveaway <= giveaway_,\n                \"cannot exceed max giveaway.\"\n            );\n            _nonces[nonceGiveaway] = true;\n            giveaway = giveaway_ - quantityGiveaway;\n            _validateSig(\n                \"giveaway\",\n                msg.sender,\n                quantityGiveaway,\n                nonceGiveaway,\n                sigGiveaway\n            );\n        }\n\n        _safeMint(msg.sender, quantityGiveaway + quantityPresale);\n    }",
        "comments": [
            "",
            "    /// @notice Mint NFT(s) during allowlist/waitlist sale",
            "    /// along with giveaway to save gas.",
            "    /// Can only be done once.",
            "    /// @param quantityGiveaway number of giveaway NFT to mint",
            "    /// @param nonceGiveaway Random number providing a mint spot",
            "    /// @param quantityPresale number of presale NFT to mint",
            "    /// @param maxPresale Max number of token allowed to mint",
            "    /// @param noncePresale Random number providing a mint spot",
            "    /// @param sigGiveaway ECDSA signature allowing the mint",
            "    /// @param sigPresale ECDSA signature allowing the mint",
            "    "
        ],
        "comt": "\n    /// @notice Mint NFT(s) during allowlist/waitlist sale\n    /// along with giveaway to save gas.\n    /// Can only be done once.\n    /// @param quantityGiveaway number of giveaway NFT to mint\n    /// @param nonceGiveaway Random number providing a mint spot\n    /// @param quantityPresale number of presale NFT to mint\n    /// @param maxPresale Max number of token allowed to mint\n    /// @param noncePresale Random number providing a mint spot\n    /// @param sigGiveaway ECDSA signature allowing the mint\n    /// @param sigPresale ECDSA signature allowing the mint\n    ",
        "@notice": "Mint NFT(s) during allowlist/waitlist sale /// along with giveaway to save gas. /// Can only be done once.",
        "@param1": "quantityGiveaway number of giveaway NFT to mint",
        "@param2": "nonceGiveaway Random number providing a mint spot",
        "@param3": "quantityPresale number of presale NFT to mint",
        "@param4": "maxPresale Max number of token allowed to mint",
        "@param5": "noncePresale Random number providing a mint spot",
        "@param6": "sigGiveaway ECDSA signature allowing the mint",
        "@param7": "sigPresale ECDSA signature allowing the mint",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mintWithGiveaway",
        "visibility": "external",
        "args": [
            {
                "name": "quantityPublic",
                "type": "uint256"
            },
            {
                "name": "quantityGiveaway",
                "type": "uint256"
            },
            {
                "name": "nonceGiveaway",
                "type": "uint256"
            },
            {
                "name": "sigGiveaway",
                "type": "bytes memory"
            }
        ],
        "func": "function mintWithGiveaway(\n        uint256 quantityPublic,\n        uint256 quantityGiveaway,\n        uint256 nonceGiveaway,\n        bytes memory sigGiveaway\n    )\n        external\n        payable\n        whenMintIsPublic\n        rightPublicPrice(quantityPublic)\n        belowTotalSupply(quantityPublic)\n        belowPublicLimit(quantityPublic)\n    {\n        if (quantityGiveaway > 0) {\n            require(!_nonces[nonceGiveaway], \"giveaway nonce already used.\");\n            uint256 giveaway_ = giveaway;\n            require(\n                quantityGiveaway <= giveaway_,\n                \"cannot exceed max giveaway.\"\n            );\n            _nonces[nonceGiveaway] = true;\n            giveaway = giveaway_ - quantityGiveaway;\n            _validateSig(\n                \"giveaway\",\n                msg.sender,\n                quantityGiveaway,\n                nonceGiveaway,\n                sigGiveaway\n            );\n        }\n\n        _safeMint(msg.sender, quantityGiveaway + quantityPublic);\n    }",
        "comments": [
            "",
            "    /// @notice Mint NFT(s) during public sale",
            "    /// along with giveaway to save gas.",
            "    /// Can only be done once.",
            "    /// @param quantityPublic number of public NFT to mint",
            "    /// @param quantityGiveaway number of giveaway NFT to mint",
            "    /// @param nonceGiveaway Random number providing a mint spot",
            "    /// @param sigGiveaway ECDSA signature allowing the mint",
            "    "
        ],
        "comt": "\n    /// @notice Mint NFT(s) during public sale\n    /// along with giveaway to save gas.\n    /// Can only be done once.\n    /// @param quantityPublic number of public NFT to mint\n    /// @param quantityGiveaway number of giveaway NFT to mint\n    /// @param nonceGiveaway Random number providing a mint spot\n    /// @param sigGiveaway ECDSA signature allowing the mint\n    ",
        "@notice": "Mint NFT(s) during public sale /// along with giveaway to save gas. /// Can only be done once.",
        "@param1": "quantityPublic number of public NFT to mint",
        "@param2": "quantityGiveaway number of giveaway NFT to mint",
        "@param3": "nonceGiveaway Random number providing a mint spot",
        "@param4": "sigGiveaway ECDSA signature allowing the mint",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mintGiveaway",
        "visibility": "external",
        "args": [
            {
                "name": "quantity",
                "type": "uint256"
            },
            {
                "name": "nonce",
                "type": "uint256"
            },
            {
                "name": "sig",
                "type": "bytes memory"
            }
        ],
        "func": "function mintGiveaway(\n        uint256 quantity,\n        uint256 nonce,\n        bytes memory sig\n    ) external whenMintIsNotClosed {\n        require(!_nonces[nonce], \"giveaway nonce already used.\");\n        uint256 giveaway_ = giveaway;\n        require(quantity <= giveaway_, \"cannot exceed max giveaway.\");\n        _nonces[nonce] = true;\n        giveaway = giveaway_ - quantity;\n        _validateSig(\"giveaway\", msg.sender, quantity, nonce, sig);\n\n        _safeMint(msg.sender, quantity);\n    }",
        "comments": [
            "",
            "    /// @notice Mint giveaway NFT(s) during any sale phase",
            "    /// Can only be done once.",
            "    /// @param quantity number of giveaway NFT to mint",
            "    /// @param nonce Random number providing a mint spot",
            "    /// @param sig ECDSA signature allowing the mint",
            "    "
        ],
        "comt": "\n    /// @notice Mint giveaway NFT(s) during any sale phase\n    /// Can only be done once.\n    /// @param quantity number of giveaway NFT to mint\n    /// @param nonce Random number providing a mint spot\n    /// @param sig ECDSA signature allowing the mint\n    ",
        "@notice": "Mint giveaway NFT(s) during any sale phase /// Can only be done once.",
        "@param1": "quantity number of giveaway NFT to mint",
        "@param2": "nonce Random number providing a mint spot",
        "@param3": "sig ECDSA signature allowing the mint",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "validNonce",
        "visibility": "external",
        "args": [
            {
                "name": "nonce",
                "type": "uint256"
            }
        ],
        "func": "function validNonce(uint256 nonce) external view returns (bool) {\n        return !_nonces[nonce];\n    }",
        "comments": [
            "",
            "    /// @notice Check whether nonce was used",
            "    /// @param nonce value to be checked",
            "    "
        ],
        "comt": "\n    /// @notice Check whether nonce was used\n    /// @param nonce value to be checked\n    ",
        "@notice": "Check whether nonce was used",
        "@param1": "nonce value to be checked",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "supportsInterface",
        "visibility": "public",
        "args": [
            {
                "name": "interfaceId",
                "type": "bytes4"
            }
        ],
        "func": "function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return\n            interfaceId == this.royaltyInfo.selector ||\n            super.supportsInterface(interfaceId);\n    }",
        "comments": [
            "",
            "    /// @inheritdoc ERC721A",
            "    "
        ],
        "comt": "\n    /// @inheritdoc ERC721A\n    ",
        "@inheritdoc": "ERC721A",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "royaltyInfo",
        "visibility": "public",
        "args": [
            {
                "name": "uint256",
                "type": "uint256"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function royaltyInfo(uint256, uint256 amount)\n        public\n        view\n        returns (address, uint256)\n    {\n        // (royaltiesRecipient || owner), 7.5%\n        return (beneficiary, (amount * 750) / 10000);\n    }",
        "comments": [
            "",
            "    ////////////////////////////////////////////////////",
            "    ///// Royalties                                   //",
            "    ////////////////////////////////////////////////////",
            "",
            "    /// @dev Royalties are the same for every token that's why we don't use OZ's impl.",
            "    "
        ],
        "comt": "\n    ////////////////////////////////////////////////////\n    ///// Royalties                                   //\n    ////////////////////////////////////////////////////\n\n    /// @dev Royalties are the same for every token that's why we don't use OZ's impl.\n    ",
        "@dev": "Royalties are the same for every token that's why we don't use OZ's impl.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "gift",
        "visibility": "external",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "quantity",
                "type": "uint256"
            }
        ],
        "func": "function gift(address to, uint256 quantity) external onlyOwner {\n        uint256 giveaway_ = giveaway;\n        require(quantity <= giveaway_, \"cannot exceed max giveaway.\");\n        giveaway = giveaway_ - quantity;\n        _safeMint(to, quantity);\n    }",
        "comments": [
            "",
            "    ////////////////////////////////////////////////////",
            "    ///// Only Owner                                  //",
            "    ////////////////////////////////////////////////////",
            "",
            "    /// @notice Gift a NFT to someone i.e. a team member, only done by owner",
            "    /// @param to recipient address",
            "    /// @param quantity number of NFT to mint and gift",
            "    "
        ],
        "comt": "\n    ////////////////////////////////////////////////////\n    ///// Only Owner                                  //\n    ////////////////////////////////////////////////////\n\n    /// @notice Gift a NFT to someone i.e. a team member, only done by owner\n    /// @param to recipient address\n    /// @param quantity number of NFT to mint and gift\n    ",
        "@notice": "Gift a NFT to someone i.e. a team member, only done by owner",
        "@param1": "to recipient address",
        "@param2": "quantity number of NFT to mint and gift",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setBaseURI",
        "visibility": "external",
        "args": [
            {
                "name": "newBaseURI",
                "type": "string calldata"
            }
        ],
        "func": "function setBaseURI(string calldata newBaseURI) external onlyOwner {\n        baseURI = newBaseURI;\n    }",
        "comments": [
            "",
            "    /// @notice Allow the owner to change the baseURI",
            "    /// @param newBaseURI the new uri",
            "    "
        ],
        "comt": "\n    /// @notice Allow the owner to change the baseURI\n    /// @param newBaseURI the new uri\n    ",
        "@notice": "Allow the owner to change the baseURI",
        "@param1": "newBaseURI the new uri",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setProvenanceHash",
        "visibility": "external",
        "args": [
            {
                "name": "provenanceHash_",
                "type": "string memory"
            }
        ],
        "func": "function setProvenanceHash(string memory provenanceHash_)\n        external\n        onlyOwner\n    {\n        provenanceHash = provenanceHash_;\n    }",
        "comments": [
            "",
            "    /// @notice Allow the owner to set the provenancehash",
            "    /// Should be set before sales open.",
            "    /// @param provenanceHash_ the new hash",
            "    "
        ],
        "comt": "\n    /// @notice Allow the owner to set the provenancehash\n    /// Should be set before sales open.\n    /// @param provenanceHash_ the new hash\n    ",
        "@notice": "Allow the owner to set the provenancehash /// Should be set before sales open.",
        "@param1": "provenanceHash_ the new hash",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setBeneficiary",
        "visibility": "external",
        "args": [
            {
                "name": "newBeneficiary",
                "type": "address"
            }
        ],
        "func": "function setBeneficiary(address newBeneficiary) external onlyOwner {\n        require(newBeneficiary != address(0), 'cannot set null address as beneficiary.');\n        beneficiary = newBeneficiary;\n    }",
        "comments": [
            "",
            "    /// @notice Allow owner to set the royalties recipient",
            "    /// @param newBeneficiary the new contract uri",
            "    "
        ],
        "comt": "\n    /// @notice Allow owner to set the royalties recipient\n    /// @param newBeneficiary the new contract uri\n    ",
        "@notice": "Allow owner to set the royalties recipient",
        "@param1": "newBeneficiary the new contract uri",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setContractURI",
        "visibility": "external",
        "args": [
            {
                "name": "newContractURI",
                "type": "string calldata"
            }
        ],
        "func": "function setContractURI(string calldata newContractURI) external onlyOwner {\n        contractURI = newContractURI;\n    }",
        "comments": [
            "",
            "    /// @notice Allow owner to set contract URI",
            "    /// @param newContractURI the new contract URI",
            "    "
        ],
        "comt": "\n    /// @notice Allow owner to set contract URI\n    /// @param newContractURI the new contract URI\n    ",
        "@notice": "Allow owner to set contract URI",
        "@param1": "newContractURI the new contract URI",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setStep",
        "visibility": "external",
        "args": [
            {
                "name": "newStep",
                "type": "MintStep"
            }
        ],
        "func": "function setStep(MintStep newStep) external onlyOwner {\n        step = newStep;\n        // Set starting index after people minted\n        _setStartingIndex();\n        emit MintStepUpdated(newStep);\n    }",
        "comments": [
            "",
            "    /// @notice Allow owner to change minting step",
            "    /// @param newStep the new step",
            "    "
        ],
        "comt": "\n    /// @notice Allow owner to change minting step\n    /// @param newStep the new step\n    ",
        "@notice": "Allow owner to change minting step",
        "@param1": "newStep the new step",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setLimitPerPublicMint",
        "visibility": "external",
        "args": [
            {
                "name": "newLimit",
                "type": "uint256"
            }
        ],
        "func": "function setLimitPerPublicMint(uint256 newLimit) external onlyOwner {\n        limitPerPublicMint = newLimit;\n    }",
        "comments": [
            "",
            "    /// @notice Allow owner to update the limit per wallet for public mint",
            "    /// @param newLimit the new limit e.g. 7 for public mint per wallet",
            "    "
        ],
        "comt": "\n    /// @notice Allow owner to update the limit per wallet for public mint\n    /// @param newLimit the new limit e.g. 7 for public mint per wallet\n    ",
        "@notice": "Allow owner to update the limit per wallet for public mint",
        "@param1": "newLimit the new limit e.g. 7 for public mint per wallet",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setPublicPrice",
        "visibility": "external",
        "args": [
            {
                "name": "newPrice",
                "type": "uint256"
            }
        ],
        "func": "function setPublicPrice(uint256 newPrice) external onlyOwner {\n        publicPrice = newPrice;\n    }",
        "comments": [
            "",
            "    /// @notice Allow owner to update price for public mint",
            "    /// @param newPrice the new price for public mint",
            "    "
        ],
        "comt": "\n    /// @notice Allow owner to update price for public mint\n    /// @param newPrice the new price for public mint\n    ",
        "@notice": "Allow owner to update price for public mint",
        "@param1": "newPrice the new price for public mint",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setPresalePrice",
        "visibility": "external",
        "args": [
            {
                "name": "newPrice",
                "type": "uint256"
            }
        ],
        "func": "function setPresalePrice(uint256 newPrice) external onlyOwner {\n        presalePrice = newPrice;\n    }",
        "comments": [
            "",
            "    /// @notice Allow owner to update price for presale mint",
            "    /// @param newPrice the new price for presale mint",
            "    "
        ],
        "comt": "\n    /// @notice Allow owner to update price for presale mint\n    /// @param newPrice the new price for presale mint\n    ",
        "@notice": "Allow owner to update price for presale mint",
        "@param1": "newPrice the new price for presale mint",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "external",
        "args": [],
        "func": "function withdraw() external {\n        Address.sendValue(payable(beneficiary), address(this).balance);\n    }",
        "comments": [
            "",
            "    /// @notice Allow everyone to withdraw contract balance and send it to owner",
            "    "
        ],
        "comt": "\n    /// @notice Allow everyone to withdraw contract balance and send it to owner\n    ",
        "@notice": "Allow everyone to withdraw contract balance and send it to owner",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawERC20",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "IERC20"
            }
        ],
        "func": "function withdrawERC20(IERC20 token) external {\n        SafeERC20.safeTransfer(\n            token,\n            beneficiary,\n            token.balanceOf(address(this))\n        );\n    }",
        "comments": [
            "",
            "    /// @notice Allow everyone to withdraw contract ERC20 balance and send it to owner",
            "    "
        ],
        "comt": "\n    /// @notice Allow everyone to withdraw contract ERC20 balance and send it to owner\n    ",
        "@notice": "Allow everyone to withdraw contract ERC20 balance and send it to owner",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "owner",
        "visibility": "public",
        "args": [],
        "func": "function owner() public view virtual returns (address) {\n        return _owner;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the address of the current owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the address of the current owner.\n     */\n",
        "@dev": "Returns the address of the current owner.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "renounceOwnership",
        "visibility": "public",
        "args": [],
        "func": "function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }",
        "comments": [
            "/**",
            "     * @dev Leaves the contract without owner. It will not be possible to call",
            "     * `onlyOwner` functions anymore. Can only be called by the current owner.",
            "     *",
            "     * NOTE: Renouncing ownership will leave the contract without an owner,",
            "     * thereby removing any functionality that is only available to the owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n",
        "@dev": "Leaves the contract without owner. It will not be possible to call * `onlyOwner` functions anymore. Can only be called by the current owner. * * NOTE: Renouncing ownership will leave the contract without an owner, * thereby removing any functionality that is only available to the owner.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferOwnership",
        "visibility": "public",
        "args": [
            {
                "name": "newOwner",
                "type": "address"
            }
        ],
        "func": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }",
        "comments": [
            "/**",
            "     * @dev Transfers ownership of the contract to a new account (`newOwner`).",
            "     * Can only be called by the current owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n",
        "@dev": "Transfers ownership of the contract to a new account (`newOwner`). * Can only be called by the current owner.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view virtual override returns (uint256) {\n        // Counter underflow is impossible as _burnCounter cannot be incremented\n        // more than `_currentIndex - _startTokenId()` times.\n        unchecked {\n            return _currentIndex - _burnCounter - _startTokenId();\n        }\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the total number of tokens in existence.",
            "     * Burned tokens will reduce the count.",
            "     * To get the total number of tokens minted, please see {_totalMinted}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n",
        "@dev": "Returns the total number of tokens in existence. * Burned tokens will reduce the count. * To get the total number of tokens minted, please see {_totalMinted}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address owner) public view virtual override returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\n    }",
        "comments": [
            "",
            "    // =============================================================",
            "    //                    ADDRESS DATA OPERATIONS",
            "    // =============================================================",
            "",
            "    /**",
            "     * @dev Returns the number of tokens in `owner`'s account.",
            "     */",
            "    "
        ],
        "comt": "\n    // =============================================================\n    //                    ADDRESS DATA OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the number of tokens in `owner`'s account.\n     */\n    ",
        "@dev": "Returns the number of tokens in `owner`'s account.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "supportsInterface",
        "visibility": "public",
        "args": [
            {
                "name": "interfaceId",
                "type": "bytes4"
            }
        ],
        "func": "function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        // The interface IDs are constants representing the first 4 bytes\n        // of the XOR of all function selectors in the interface.\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\n    }",
        "comments": [
            "",
            "    // =============================================================",
            "    //                            IERC165",
            "    // =============================================================",
            "",
            "    /**",
            "     * @dev Returns true if this contract implements the interface defined by",
            "     * `interfaceId`. See the corresponding",
            "     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)",
            "     * to learn more about how these ids are created.",
            "     *",
            "     * This function call must use less than 30000 gas.",
            "     */",
            "    "
        ],
        "comt": "\n    // =============================================================\n    //                            IERC165\n    // =============================================================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    ",
        "@dev": "Returns true if this contract implements the interface defined by * `interfaceId`. See the corresponding * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified) * to learn more about how these ids are created. * * This function call must use less than 30000 gas.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "name",
        "visibility": "public",
        "args": [],
        "func": "function name() public view virtual override returns (string memory) {\n        return _name;\n    }",
        "comments": [
            "",
            "    // =============================================================",
            "    //                        IERC721Metadata",
            "    // =============================================================",
            "",
            "    /**",
            "     * @dev Returns the token collection name.",
            "     */",
            "    "
        ],
        "comt": "\n    // =============================================================\n    //                        IERC721Metadata\n    // =============================================================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    ",
        "@dev": "Returns the token collection name.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "symbol",
        "visibility": "public",
        "args": [],
        "func": "function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the token collection symbol.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the token collection symbol.\n     */\n",
        "@dev": "Returns the token collection symbol.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "tokenURI",
        "visibility": "public",
        "args": [
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n",
        "@dev": "Returns the Uniform Resource Identifier (URI) for `tokenId` token.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "ownerOf",
        "visibility": "public",
        "args": [
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return address(uint160(_packedOwnershipOf(tokenId)));\n    }",
        "comments": [
            "",
            "    // =============================================================",
            "    //                     OWNERSHIPS OPERATIONS",
            "    // =============================================================",
            "",
            "    /**",
            "     * @dev Returns the owner of the `tokenId` token.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `tokenId` must exist.",
            "     */",
            "    "
        ],
        "comt": "\n    // =============================================================\n    //                     OWNERSHIPS OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    ",
        "@dev": "Returns the owner of the `tokenId` token. * * Requirements: * * - `tokenId` must exist.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ownerOf(tokenId);\n\n        if (_msgSenderERC721A() != owner)\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\n                revert ApprovalCallerNotOwnerNorApproved();\n            }\n\n        _tokenApprovals[tokenId].value = to;\n        emit Approval(owner, to, tokenId);\n    }",
        "comments": [
            "/**",
            "     * @dev Gives permission to `to` to transfer `tokenId` token to another account.",
            "     * The approval is cleared when the token is transferred.",
            "     *",
            "     * Only a single account can be approved at a time, so approving the",
            "     * zero address clears previous approvals.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - The caller must own the token or be an approved operator.",
            "     * - `tokenId` must exist.",
            "     *",
            "     * Emits an {Approval} event.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n",
        "@dev": "Gives permission to `to` to transfer `tokenId` token to another account. * The approval is cleared when the token is transferred. * * Only a single account can be approved at a time, so approving the * zero address clears previous approvals. * * Requirements: * * - The caller must own the token or be an approved operator. * - `tokenId` must exist. * * Emits an {Approval} event.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getApproved",
        "visibility": "public",
        "args": [
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\n\n        return _tokenApprovals[tokenId].value;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the account approved for `tokenId` token.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `tokenId` must exist.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n",
        "@dev": "Returns the account approved for `tokenId` token. * * Requirements: * * - `tokenId` must exist.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setApprovalForAll",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "approved",
                "type": "bool"
            }
        ],
        "func": "function setApprovalForAll(address operator, bool approved) public virtual override {\n        if (operator == _msgSenderERC721A()) revert ApproveToCaller();\n\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }",
        "comments": [
            "/**",
            "     * @dev Approve or remove `operator` as an operator for the caller.",
            "     * Operators can call {transferFrom} or {safeTransferFrom}",
            "     * for any token owned by the caller.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - The `operator` cannot be the caller.",
            "     *",
            "     * Emits an {ApprovalForAll} event.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n",
        "@dev": "Approve or remove `operator` as an operator for the caller. * Operators can call {transferFrom} or {safeTransferFrom} * for any token owned by the caller. * * Requirements: * * - The `operator` cannot be the caller. * * Emits an {ApprovalForAll} event.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isApprovedForAll",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }",
        "comments": [
            "/**",
            "     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.",
            "     *",
            "     * See {setApprovalForAll}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}.\n     */\n",
        "@dev": "Returns if the `operator` is allowed to manage all of the assets of `owner`. * * See {setApprovalForAll}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\n\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\n\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\n\n        // The nested ifs save around 20+ gas over a compound boolean condition.\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\n\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        _beforeTokenTransfers(from, to, tokenId, 1);\n\n        // Clear approvals from the previous owner.\n        assembly {\n            if approvedAddress {\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\n                sstore(approvedAddressSlot, 0)\n            }\n        }\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\n        unchecked {\n            // We can directly increment and decrement the balances.\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\n\n            // Updates:\n            // - `address` to the next owner.\n            // - `startTimestamp` to the timestamp of transfering.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `true`.\n            _packedOwnerships[tokenId] = _packOwnershipData(\n                to,\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\n            );\n\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\n                if (_packedOwnerships[nextTokenId] == 0) {\n                    // If the next slot is within bounds.\n                    if (nextTokenId != _currentIndex) {\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfers(from, to, tokenId, 1);\n    }",
        "comments": [
            "/**",
            "     * @dev Transfers `tokenId` from `from` to `to`.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `from` cannot be the zero address.",
            "     * - `to` cannot be the zero address.",
            "     * - `tokenId` token must be owned by `from`.",
            "     * - If the caller is not `from`, it must be approved to move this token",
            "     * by either {approve} or {setApprovalForAll}.",
            "     *",
            "     * Emits a {Transfer} event.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n",
        "@dev": "Transfers `tokenId` from `from` to `to`. * * Requirements: * * - `from` cannot be the zero address. * - `to` cannot be the zero address. * - `tokenId` token must be owned by `from`. * - If the caller is not `from`, it must be approved to move this token * by either {approve} or {setApprovalForAll}. * * Emits a {Transfer} event.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "safeTransferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, '');\n    }",
        "comments": [
            "/**",
            "     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n     */\n",
        "@dev": "Equivalent to `safeTransferFrom(from, to, tokenId, '')`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "safeTransferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "name": "_data",
                "type": "bytes memory"
            }
        ],
        "func": "function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        transferFrom(from, to, tokenId);\n        if (to.code.length != 0)\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\n                revert TransferToNonERC721ReceiverImplementer();\n            }\n    }",
        "comments": [
            "/**",
            "     * @dev Safely transfers `tokenId` token from `from` to `to`.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `from` cannot be the zero address.",
            "     * - `to` cannot be the zero address.",
            "     * - `tokenId` token must exist and be owned by `from`.",
            "     * - If the caller is not `from`, it must be approved to move this token",
            "     * by either {approve} or {setApprovalForAll}.",
            "     * - If `to` refers to a smart contract, it must implement",
            "     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.",
            "     *",
            "     * Emits a {Transfer} event.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n",
        "@dev": "Safely transfers `tokenId` token from `from` to `to`. * * Requirements: * * - `from` cannot be the zero address. * - `to` cannot be the zero address. * - `tokenId` token must exist and be owned by `from`. * - If the caller is not `from`, it must be approved to move this token * by either {approve} or {setApprovalForAll}. * - If `to` refers to a smart contract, it must implement * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. * * Emits a {Transfer} event.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    }
]