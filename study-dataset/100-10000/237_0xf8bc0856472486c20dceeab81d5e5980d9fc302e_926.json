[
    {
        "transactions": 926,
        "function_num": 237
    },
    {
        "name": "init",
        "visibility": "public",
        "args": [
            {
                "name": "_compoundTokenAddr",
                "type": "address"
            },
            {
                "name": "_cycleNumber",
                "type": "uint256"
            },
            {
                "name": "_stake",
                "type": "uint256"
            },
            {
                "name": "_collateralAmountInUSDC",
                "type": "uint256"
            },
            {
                "name": "_loanAmountInUSDC",
                "type": "uint256"
            },
            {
                "name": "_orderType",
                "type": "bool"
            },
            {
                "name": "_usdcAddr",
                "type": "address"
            },
            {
                "name": "_kyberAddr",
                "type": "address payable"
            },
            {
                "name": "_comptrollerAddr",
                "type": "address"
            },
            {
                "name": "_priceOracleAddr",
                "type": "address"
            },
            {
                "name": "_cUSDCAddr",
                "type": "address"
            },
            {
                "name": "_cETHAddr",
                "type": "address"
            }
        ],
        "func": "function init(\n    address _compoundTokenAddr,\n    uint256 _cycleNumber,\n    uint256 _stake,\n    uint256 _collateralAmountInUSDC,\n    uint256 _loanAmountInUSDC,\n    bool _orderType,\n    address _usdcAddr,\n    address payable _kyberAddr,\n    address _comptrollerAddr,\n    address _priceOracleAddr,\n    address _cUSDCAddr,\n    address _cETHAddr\n  ) public {\n    require(!initialized);\n    initialized = true;\n\n    // Initialize details of order\n    require(_compoundTokenAddr != _cUSDCAddr);\n    require(_stake > 0 && _collateralAmountInUSDC > 0 && _loanAmountInUSDC > 0); // Validate inputs\n    stake = _stake;\n    collateralAmountInUSDC = _collateralAmountInUSDC;\n    loanAmountInUSDC = _loanAmountInUSDC;\n    cycleNumber = _cycleNumber;\n    compoundTokenAddr = _compoundTokenAddr;\n    orderType = _orderType;\n\n    COMPTROLLER = Comptroller(_comptrollerAddr);\n    ORACLE = PriceOracle(_priceOracleAddr);\n    CUSDC = CERC20(_cUSDCAddr);\n    CETH_ADDR = _cETHAddr;\n    USDC_ADDR = _usdcAddr;\n    KYBER_ADDR = _kyberAddr;\n    usdc = ERC20Detailed(_usdcAddr);\n    kyber = KyberNetwork(_kyberAddr);\n\n    // transfer ownership to msg.sender\n    _transferOwnership(msg.sender);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "emergencyExitTokens",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_receiver",
                "type": "address"
            }
        ],
        "func": "function emergencyExitTokens(address _tokenAddr, address _receiver) public onlyOwner {\n    ERC20Detailed token = ERC20Detailed(_tokenAddr);\n    token.safeTransfer(_receiver, token.balanceOf(address(this)));\n  }",
        "comments": [
            "/**",
            "   * @notice Emergency method, which allow to transfer selected tokens to the fund address",
            "   * @param _tokenAddr address of withdrawn token",
            "   * @param _receiver address who should receive tokens",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Emergency method, which allow to transfer selected tokens to the fund address\n   * @param _tokenAddr address of withdrawn token\n   * @param _receiver address who should receive tokens\n   */\n",
        "@notice": "Emergency method, which allow to transfer selected tokens to the fund address",
        "@param1": "_tokenAddr address of withdrawn token",
        "@param2": "_receiver address who should receive tokens",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentProfitInUSDC",
        "visibility": "public",
        "args": [],
        "func": "function getCurrentProfitInUSDC() public returns (bool _isNegative, uint256 _amount) {\n    uint256 l;\n    uint256 r;\n    if (isSold) {\n      l = outputAmount;\n      r = collateralAmountInUSDC;\n    } else {\n      uint256 cash = getCurrentCashInUSDC();\n      uint256 supply = getCurrentCollateralInUSDC();\n      uint256 borrow = getCurrentBorrowInUSDC();\n      if (cash >= borrow) {\n        l = supply.add(cash);\n        r = borrow.add(collateralAmountInUSDC);\n      } else {\n        l = supply;\n        r = borrow.sub(cash).mul(PRECISION).div(getMarketCollateralFactor()).add(collateralAmountInUSDC);\n      }\n    }\n\n    if (l >= r) {\n      return (false, l.sub(r));\n    } else {\n      return (true, r.sub(l));\n    }\n  }",
        "comments": [
            "/**",
            "   * @notice Calculates the current profit in USDC",
            "   * @return the profit amount",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Calculates the current profit in USDC\n   * @return the profit amount\n   */\n",
        "@notice": "Calculates the current profit in USDC",
        "@return1": "the profit amount",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentCollateralRatioInUSDC",
        "visibility": "public",
        "args": [],
        "func": "function getCurrentCollateralRatioInUSDC() public returns (uint256 _amount) {\n    uint256 supply = getCurrentCollateralInUSDC();\n    uint256 borrow = getCurrentBorrowInUSDC();\n    if (borrow == 0) {\n      return uint256(-1);\n    }\n    return supply.mul(PRECISION).div(borrow);\n  }",
        "comments": [
            "/**",
            "   * @notice Calculates the current collateral ratio on Compound, using 18 decimals",
            "   * @return the collateral ratio",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Calculates the current collateral ratio on Compound, using 18 decimals\n   * @return the collateral ratio\n   */\n",
        "@notice": "Calculates the current collateral ratio on Compound, using 18 decimals",
        "@return1": "the collateral ratio",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentLiquidityInUSDC",
        "visibility": "public",
        "args": [],
        "func": "function getCurrentLiquidityInUSDC() public returns (bool _isNegative, uint256 _amount) {\n    uint256 supply = getCurrentCollateralInUSDC();\n    uint256 borrow = getCurrentBorrowInUSDC().mul(PRECISION).div(getMarketCollateralFactor());\n    if (supply >= borrow) {\n      return (false, supply.sub(borrow));\n    } else {\n      return (true, borrow.sub(supply));\n    }\n  }",
        "comments": [
            "/**",
            "   * @notice Calculates the current liquidity (supply - collateral) on the Compound platform",
            "   * @return the liquidity",
            "   */",
            ""
        ],
        "comt": "/**\n   * @notice Calculates the current liquidity (supply - collateral) on the Compound platform\n   * @return the liquidity\n   */\n",
        "@notice": "Calculates the current liquidity (supply - collateral) on the Compound platform",
        "@return1": "the liquidity",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "owner",
        "visibility": "public",
        "args": [],
        "func": "function owner() public view returns (address) {\n        return _owner;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the address of the current owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the address of the current owner.\n     */\n",
        "@dev": "Returns the address of the current owner.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isOwner",
        "visibility": "public",
        "args": [],
        "func": "function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns true if the caller is the current owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns true if the caller is the current owner.\n     */\n",
        "@dev": "Returns true if the caller is the current owner.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "renounceOwnership",
        "visibility": "public",
        "args": [],
        "func": "function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }",
        "comments": [
            "/**",
            "     * @dev Leaves the contract without owner. It will not be possible to call",
            "     * `onlyOwner` functions anymore. Can only be called by the current owner.",
            "     *",
            "     * NOTE: Renouncing ownership will leave the contract without an owner,",
            "     * thereby removing any functionality that is only available to the owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n",
        "@dev": "Leaves the contract without owner. It will not be possible to call * `onlyOwner` functions anymore. Can only be called by the current owner. * * NOTE: Renouncing ownership will leave the contract without an owner, * thereby removing any functionality that is only available to the owner.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferOwnership",
        "visibility": "public",
        "args": [
            {
                "name": "newOwner",
                "type": "address"
            }
        ],
        "func": "function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }",
        "comments": [
            "/**",
            "     * @dev Transfers ownership of the contract to a new account (`newOwner`).",
            "     * Can only be called by the current owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n",
        "@dev": "Transfers ownership of the contract to a new account (`newOwner`). * Can only be called by the current owner.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "name",
        "visibility": "public",
        "args": [],
        "func": "function name() public view returns (string memory) {\n        return _name;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the name of the token.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the name of the token.\n     */\n",
        "@dev": "Returns the name of the token.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "symbol",
        "visibility": "public",
        "args": [],
        "func": "function symbol() public view returns (string memory) {\n        return _symbol;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the symbol of the token, usually a shorter version of the",
            "     * name.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n",
        "@dev": "Returns the symbol of the token, usually a shorter version of the * name.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decimals",
        "visibility": "public",
        "args": [],
        "func": "function decimals() public view returns (uint8) {\n        return _decimals;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the number of decimals used to get its user representation.",
            "     * For example, if `decimals` equals `2`, a balance of `505` tokens should",
            "     * be displayed to a user as `5,05` (`505 / 10 ** 2`).",
            "     *",
            "     * Tokens usually opt for a value of 18, imitating the relationship between",
            "     * Ether and Wei.",
            "     *",
            "     * NOTE: This information is only used for _display_ purposes: it in",
            "     * no way affects any of the arithmetic of the contract, including",
            "     * {IERC20-balanceOf} and {IERC20-transfer}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n",
        "@dev": "Returns the number of decimals used to get its user representation. * For example, if `decimals` equals `2`, a balance of `505` tokens should * be displayed to a user as `5,05` (`505 / 10 ** 2`). * * Tokens usually opt for a value of 18, imitating the relationship between * Ether and Wei. * * NOTE: This information is only used for _display_ purposes: it in * no way affects any of the arithmetic of the contract, including * {IERC20-balanceOf} and {IERC20-transfer}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createOrder",
        "visibility": "external",
        "args": [
            {
                "name": "_compoundTokenAddr",
                "type": "address"
            },
            {
                "name": "_cycleNumber",
                "type": "uint256"
            },
            {
                "name": "_stake",
                "type": "uint256"
            },
            {
                "name": "_collateralAmountInUSDC",
                "type": "uint256"
            },
            {
                "name": "_loanAmountInUSDC",
                "type": "uint256"
            },
            {
                "name": "_orderType",
                "type": "bool"
            }
        ],
        "func": "function createOrder(\n    address _compoundTokenAddr,\n    uint256 _cycleNumber,\n    uint256 _stake,\n    uint256 _collateralAmountInUSDC,\n    uint256 _loanAmountInUSDC,\n    bool _orderType\n  ) external returns (CompoundOrder) {\n    require(_compoundTokenAddr != address(0));\n\n    CompoundOrder order;\n\n    address payable clone;\n    if (_compoundTokenAddr != CETH_ADDR) {\n      if (_orderType) {\n        // Short CERC20 Order\n        clone = toPayableAddr(createClone(SHORT_CERC20_LOGIC_CONTRACT));\n      } else {\n        // Long CERC20 Order\n        clone = toPayableAddr(createClone(LONG_CERC20_LOGIC_CONTRACT));\n      }\n    } else {\n      if (_orderType) {\n        // Short CEther Order\n        clone = toPayableAddr(createClone(SHORT_CEther_LOGIC_CONTRACT));\n      } else {\n        // Long CEther Order\n        clone = toPayableAddr(createClone(LONG_CEther_LOGIC_CONTRACT));\n      }\n    }\n    order = CompoundOrder(clone);\n    order.init(_compoundTokenAddr, _cycleNumber, _stake, _collateralAmountInUSDC, _loanAmountInUSDC, _orderType,\n      USDC_ADDR, KYBER_ADDR, COMPTROLLER_ADDR, ORACLE_ADDR, CUSDC_ADDR, CETH_ADDR);\n    order.transferOwnership(msg.sender);\n    return order;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMarketCollateralFactor",
        "visibility": "external",
        "args": [
            {
                "name": "_compoundTokenAddr",
                "type": "address"
            }
        ],
        "func": "function getMarketCollateralFactor(address _compoundTokenAddr) external view returns (uint256) {\n    Comptroller troll = Comptroller(COMPTROLLER_ADDR);\n    (, uint256 factor) = troll.markets(_compoundTokenAddr);\n    return factor;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "tokenIsListed",
        "visibility": "external",
        "args": [
            {
                "name": "_compoundTokenAddr",
                "type": "address"
            }
        ],
        "func": "function tokenIsListed(address _compoundTokenAddr) external view returns (bool) {\n    Comptroller troll = Comptroller(COMPTROLLER_ADDR);\n    (bool isListed,) = troll.markets(_compoundTokenAddr);\n    return isListed;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "executeOrder",
        "visibility": "public",
        "args": [
            {
                "name": "_minPrice",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            }
        ],
        "func": "function executeOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidToken(compoundTokenAddr)\n    isValidPrice(_minPrice, _maxPrice)\n  {\n    buyTime = now;\n\n    // Get funds in USDC from PeakDeFiFund\n    usdc.safeTransferFrom(owner(), address(this), collateralAmountInUSDC); // Transfer USDC from PeakDeFiFund\n\n    // Convert received USDC to longing token\n    (,uint256 actualTokenAmount) = __sellUSDCForToken(collateralAmountInUSDC);\n\n    // Enter Compound markets\n    CERC20 market = CERC20(compoundTokenAddr);\n    address[] memory markets = new address[](2);\n    markets[0] = compoundTokenAddr;\n    markets[1] = address(CUSDC);\n    uint[] memory errors = COMPTROLLER.enterMarkets(markets);\n    require(errors[0] == 0 && errors[1] == 0);\n\n    // Get loan from Compound in USDC\n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    token.safeApprove(compoundTokenAddr, 0); // Clear token allowance of Compound\n    token.safeApprove(compoundTokenAddr, actualTokenAmount); // Approve token transfer to Compound\n    require(market.mint(actualTokenAmount) == 0); // Transfer tokens into Compound as supply\n    token.safeApprove(compoundTokenAddr, 0); // Clear token allowance of Compound\n    require(CUSDC.borrow(loanAmountInUSDC) == 0);// Take out loan in USDC\n    (bool negLiquidity, ) = getCurrentLiquidityInUSDC();\n    require(!negLiquidity); // Ensure account liquidity is positive\n\n    // Convert borrowed USDC to longing token\n    __sellUSDCForToken(loanAmountInUSDC);\n\n    // Repay leftover USDC to avoid complications\n    if (usdc.balanceOf(address(this)) > 0) {\n      uint256 repayAmount = usdc.balanceOf(address(this));\n      usdc.safeApprove(address(CUSDC), 0);\n      usdc.safeApprove(address(CUSDC), repayAmount);\n      require(CUSDC.repayBorrow(repayAmount) == 0);\n      usdc.safeApprove(address(CUSDC), 0);\n    }\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sellOrder",
        "visibility": "public",
        "args": [
            {
                "name": "_minPrice",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            }
        ],
        "func": "function sellOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidPrice(_minPrice, _maxPrice)\n    returns (uint256 _inputAmount, uint256 _outputAmount)\n  {\n    require(buyTime > 0); // Ensure the order has been executed\n    require(isSold == false);\n    isSold = true;\n    \n    // Siphon remaining collateral by repaying x USDC and getting back 1.5x USDC collateral\n    // Repeat to ensure debt is exhausted\n    CERC20 market = CERC20(compoundTokenAddr);\n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    for (uint256 i = 0; i < MAX_REPAY_STEPS; i++) {\n      uint256 currentDebt = getCurrentBorrowInUSDC();\n      if (currentDebt > NEGLIGIBLE_DEBT) {\n        // Determine amount to be repaid this step\n        uint256 currentBalance = getCurrentCashInUSDC();\n        uint256 repayAmount = 0; // amount to be repaid in USDC\n        if (currentDebt <= currentBalance) {\n          // Has enough money, repay all debt\n          repayAmount = currentDebt;\n        } else {\n          // Doesn't have enough money, repay whatever we can repay\n          repayAmount = currentBalance;\n        }\n\n        // Repay debt\n        repayLoan(repayAmount);\n      }\n\n      // Withdraw all available liquidity\n      (bool isNeg, uint256 liquidity) = getCurrentLiquidityInUSDC();\n      if (!isNeg) {\n        liquidity = __usdcToToken(compoundTokenAddr, liquidity);\n        uint256 errorCode = market.redeemUnderlying(liquidity.mul(PRECISION.sub(DEFAULT_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n        if (errorCode != 0) {\n          // error\n          // try again with fallback slippage\n          errorCode = market.redeemUnderlying(liquidity.mul(PRECISION.sub(FALLBACK_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          if (errorCode != 0) {\n            // error\n            // try again with max slippage\n            market.redeemUnderlying(liquidity.mul(PRECISION.sub(MAX_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          }\n        }\n      }\n\n      if (currentDebt <= NEGLIGIBLE_DEBT) {\n        break;\n      }\n    }\n\n    // Sell all longing token to USDC\n    __sellTokenForUSDC(token.balanceOf(address(this)));\n\n    // Send USDC back to PeakDeFiFund and return\n    _inputAmount = collateralAmountInUSDC;\n    _outputAmount = usdc.balanceOf(address(this));\n    outputAmount = _outputAmount;\n    usdc.safeTransfer(owner(), usdc.balanceOf(address(this)));\n    uint256 leftoverTokens = token.balanceOf(address(this));\n    if (leftoverTokens > 0) {\n      token.safeTransfer(owner(), leftoverTokens); // Send back potential leftover tokens\n    }\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repayLoan",
        "visibility": "public",
        "args": [
            {
                "name": "_repayAmountInUSDC",
                "type": "uint256"
            }
        ],
        "func": "function repayLoan(uint256 _repayAmountInUSDC) public onlyOwner {\n    require(buyTime > 0); // Ensure the order has been executed\n\n    // Convert longing token to USDC\n    uint256 repayAmountInToken = __usdcToToken(compoundTokenAddr, _repayAmountInUSDC);\n    (uint256 actualUSDCAmount,) = __sellTokenForUSDC(repayAmountInToken);\n    \n    // Check if amount is greater than borrow balance\n    uint256 currentDebt = CUSDC.borrowBalanceCurrent(address(this));\n    if (actualUSDCAmount > currentDebt) {\n      actualUSDCAmount = currentDebt;\n    }\n    \n    // Repay loan to Compound\n    usdc.safeApprove(address(CUSDC), 0);\n    usdc.safeApprove(address(CUSDC), actualUSDCAmount);\n    require(CUSDC.repayBorrow(actualUSDCAmount) == 0);\n    usdc.safeApprove(address(CUSDC), 0);\n  }",
        "comments": [
            "",
            "  // Allows manager to repay loan to avoid liquidation",
            "  "
        ],
        "comt": "\n  // Allows manager to repay loan to avoid liquidation\n  ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMarketCollateralFactor",
        "visibility": "public",
        "args": [],
        "func": "function getMarketCollateralFactor() public view returns (uint256) {\n    (, uint256 ratio) = COMPTROLLER.markets(address(compoundTokenAddr));\n    return ratio;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentCollateralInUSDC",
        "visibility": "public",
        "args": [],
        "func": "function getCurrentCollateralInUSDC() public returns (uint256 _amount) {\n    CERC20 market = CERC20(compoundTokenAddr);\n    uint256 supply = __tokenToUSDC(compoundTokenAddr, market.balanceOf(address(this)).mul(market.exchangeRateCurrent()).div(PRECISION));\n    return supply;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentBorrowInUSDC",
        "visibility": "public",
        "args": [],
        "func": "function getCurrentBorrowInUSDC() public returns (uint256 _amount) {\n    uint256 borrow = CUSDC.borrowBalanceCurrent(address(this));\n    return borrow;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentCashInUSDC",
        "visibility": "public",
        "args": [],
        "func": "function getCurrentCashInUSDC() public view returns (uint256 _amount) {\n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    uint256 cash = __tokenToUSDC(compoundTokenAddr, getBalance(token, address(this)));\n    return cash;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "executeOrder",
        "visibility": "public",
        "args": [
            {
                "name": "_minPrice",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            }
        ],
        "func": "function executeOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidToken(compoundTokenAddr)\n    isValidPrice(_minPrice, _maxPrice)\n  {\n    buyTime = now;\n    \n    // Get funds in USDC from PeakDeFiFund\n    usdc.safeTransferFrom(owner(), address(this), collateralAmountInUSDC); // Transfer USDC from PeakDeFiFund\n\n    // Convert received USDC to longing token\n    (,uint256 actualTokenAmount) = __sellUSDCForToken(collateralAmountInUSDC);\n\n    // Enter Compound markets\n    CEther market = CEther(compoundTokenAddr);\n    address[] memory markets = new address[](2);\n    markets[0] = compoundTokenAddr;\n    markets[1] = address(CUSDC);\n    uint[] memory errors = COMPTROLLER.enterMarkets(markets);\n    require(errors[0] == 0 && errors[1] == 0);\n    \n    // Get loan from Compound in USDC\n    market.mint.value(actualTokenAmount)(); // Transfer tokens into Compound as supply\n    require(CUSDC.borrow(loanAmountInUSDC) == 0);// Take out loan in USDC\n    (bool negLiquidity, ) = getCurrentLiquidityInUSDC();\n    require(!negLiquidity); // Ensure account liquidity is positive\n\n    // Convert borrowed USDC to longing token\n    __sellUSDCForToken(loanAmountInUSDC);\n\n    // Repay leftover USDC to avoid complications\n    if (usdc.balanceOf(address(this)) > 0) {\n      uint256 repayAmount = usdc.balanceOf(address(this));\n      usdc.safeApprove(address(CUSDC), 0);\n      usdc.safeApprove(address(CUSDC), repayAmount);\n      require(CUSDC.repayBorrow(repayAmount) == 0);\n      usdc.safeApprove(address(CUSDC), 0);\n    }\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sellOrder",
        "visibility": "public",
        "args": [
            {
                "name": "_minPrice",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            }
        ],
        "func": "function sellOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidPrice(_minPrice, _maxPrice)\n    returns (uint256 _inputAmount, uint256 _outputAmount)\n  {\n    require(buyTime > 0); // Ensure the order has been executed\n    require(isSold == false);\n    isSold = true;\n\n    // Siphon remaining collateral by repaying x USDC and getting back 1.5x USDC collateral\n    // Repeat to ensure debt is exhausted\n    CEther market = CEther(compoundTokenAddr);\n    for (uint256 i = 0; i < MAX_REPAY_STEPS; i++) {\n      uint256 currentDebt = getCurrentBorrowInUSDC();\n      if (currentDebt > NEGLIGIBLE_DEBT) {\n        // Determine amount to be repaid this step\n        uint256 currentBalance = getCurrentCashInUSDC();\n        uint256 repayAmount = 0; // amount to be repaid in USDC\n        if (currentDebt <= currentBalance) {\n          // Has enough money, repay all debt\n          repayAmount = currentDebt;\n        } else {\n          // Doesn't have enough money, repay whatever we can repay\n          repayAmount = currentBalance;\n        }\n\n        // Repay debt\n        repayLoan(repayAmount);\n      }\n\n      // Withdraw all available liquidity\n      (bool isNeg, uint256 liquidity) = getCurrentLiquidityInUSDC();\n      if (!isNeg) {\n        liquidity = __usdcToToken(compoundTokenAddr, liquidity);\n        uint256 errorCode = market.redeemUnderlying(liquidity.mul(PRECISION.sub(DEFAULT_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n        if (errorCode != 0) {\n          // error\n          // try again with fallback slippage\n          errorCode = market.redeemUnderlying(liquidity.mul(PRECISION.sub(FALLBACK_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          if (errorCode != 0) {\n            // error\n            // try again with max slippage\n            market.redeemUnderlying(liquidity.mul(PRECISION.sub(MAX_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          }\n        }\n      }\n\n      if (currentDebt <= NEGLIGIBLE_DEBT) {\n        break;\n      }\n    }\n\n    // Sell all longing token to USDC\n    __sellTokenForUSDC(address(this).balance);\n\n    // Send USDC back to PeakDeFiFund and return\n    _inputAmount = collateralAmountInUSDC;\n    _outputAmount = usdc.balanceOf(address(this));\n    outputAmount = _outputAmount;\n    usdc.safeTransfer(owner(), usdc.balanceOf(address(this)));\n    toPayableAddr(owner()).transfer(address(this).balance); // Send back potential leftover tokens\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repayLoan",
        "visibility": "public",
        "args": [
            {
                "name": "_repayAmountInUSDC",
                "type": "uint256"
            }
        ],
        "func": "function repayLoan(uint256 _repayAmountInUSDC) public onlyOwner {\n    require(buyTime > 0); // Ensure the order has been executed\n\n    // Convert longing token to USDC\n    uint256 repayAmountInToken = __usdcToToken(compoundTokenAddr, _repayAmountInUSDC);\n    (uint256 actualUSDCAmount,) = __sellTokenForUSDC(repayAmountInToken);\n    \n    // Check if amount is greater than borrow balance\n    uint256 currentDebt = CUSDC.borrowBalanceCurrent(address(this));\n    if (actualUSDCAmount > currentDebt) {\n      actualUSDCAmount = currentDebt;\n    }\n\n    // Repay loan to Compound\n    usdc.safeApprove(address(CUSDC), 0);\n    usdc.safeApprove(address(CUSDC), actualUSDCAmount);\n    require(CUSDC.repayBorrow(actualUSDCAmount) == 0);\n    usdc.safeApprove(address(CUSDC), 0);\n  }",
        "comments": [
            "",
            "  // Allows manager to repay loan to avoid liquidation",
            "  "
        ],
        "comt": "\n  // Allows manager to repay loan to avoid liquidation\n  ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMarketCollateralFactor",
        "visibility": "public",
        "args": [],
        "func": "function getMarketCollateralFactor() public view returns (uint256) {\n    (, uint256 ratio) = COMPTROLLER.markets(address(compoundTokenAddr));\n    return ratio;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentCollateralInUSDC",
        "visibility": "public",
        "args": [],
        "func": "function getCurrentCollateralInUSDC() public returns (uint256 _amount) {\n    CEther market = CEther(compoundTokenAddr);\n    uint256 supply = __tokenToUSDC(compoundTokenAddr, market.balanceOf(address(this)).mul(market.exchangeRateCurrent()).div(PRECISION));\n    return supply;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentBorrowInUSDC",
        "visibility": "public",
        "args": [],
        "func": "function getCurrentBorrowInUSDC() public returns (uint256 _amount) {\n    uint256 borrow = CUSDC.borrowBalanceCurrent(address(this));\n    return borrow;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentCashInUSDC",
        "visibility": "public",
        "args": [],
        "func": "function getCurrentCashInUSDC() public view returns (uint256 _amount) {\n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    uint256 cash = __tokenToUSDC(compoundTokenAddr, getBalance(token, address(this)));\n    return cash;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "executeOrder",
        "visibility": "public",
        "args": [
            {
                "name": "_minPrice",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            }
        ],
        "func": "function executeOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidToken(compoundTokenAddr)\n    isValidPrice(_minPrice, _maxPrice)\n  {\n    buyTime = now;\n\n    // Get funds in USDC from PeakDeFiFund\n    usdc.safeTransferFrom(owner(), address(this), collateralAmountInUSDC); // Transfer USDC from PeakDeFiFund\n\n    // Enter Compound markets\n    CERC20 market = CERC20(compoundTokenAddr);\n    address[] memory markets = new address[](2);\n    markets[0] = compoundTokenAddr;\n    markets[1] = address(CUSDC);\n    uint[] memory errors = COMPTROLLER.enterMarkets(markets);\n    require(errors[0] == 0 && errors[1] == 0);\n    \n    // Get loan from Compound in tokenAddr\n    uint256 loanAmountInToken = __usdcToToken(compoundTokenAddr, loanAmountInUSDC);\n    usdc.safeApprove(address(CUSDC), 0); // Clear USDC allowance of Compound USDC market\n    usdc.safeApprove(address(CUSDC), collateralAmountInUSDC); // Approve USDC transfer to Compound USDC market\n    require(CUSDC.mint(collateralAmountInUSDC) == 0); // Transfer USDC into Compound as supply\n    usdc.safeApprove(address(CUSDC), 0);\n    require(market.borrow(loanAmountInToken) == 0);// Take out loan\n    (bool negLiquidity, ) = getCurrentLiquidityInUSDC();\n    require(!negLiquidity); // Ensure account liquidity is positive\n\n    // Convert loaned tokens to USDC\n    (uint256 actualUSDCAmount,) = __sellTokenForUSDC(loanAmountInToken);\n    loanAmountInUSDC = actualUSDCAmount; // Change loan amount to actual USDC received\n\n    // Repay leftover tokens to avoid complications\n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    if (token.balanceOf(address(this)) > 0) {\n      uint256 repayAmount = token.balanceOf(address(this));\n      token.safeApprove(compoundTokenAddr, 0);\n      token.safeApprove(compoundTokenAddr, repayAmount);\n      require(market.repayBorrow(repayAmount) == 0);\n      token.safeApprove(compoundTokenAddr, 0);\n    }\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sellOrder",
        "visibility": "public",
        "args": [
            {
                "name": "_minPrice",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            }
        ],
        "func": "function sellOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidPrice(_minPrice, _maxPrice)\n    returns (uint256 _inputAmount, uint256 _outputAmount)\n  {\n    require(buyTime > 0); // Ensure the order has been executed\n    require(isSold == false);\n    isSold = true;\n\n    // Siphon remaining collateral by repaying x USDC and getting back 1.5x USDC collateral\n    // Repeat to ensure debt is exhausted\n    for (uint256 i = 0; i < MAX_REPAY_STEPS; i++) {\n      uint256 currentDebt = getCurrentBorrowInUSDC();\n      if (currentDebt > NEGLIGIBLE_DEBT) {\n        // Determine amount to be repaid this step\n        uint256 currentBalance = getCurrentCashInUSDC();\n        uint256 repayAmount = 0; // amount to be repaid in USDC\n        if (currentDebt <= currentBalance) {\n          // Has enough money, repay all debt\n          repayAmount = currentDebt;\n        } else {\n          // Doesn't have enough money, repay whatever we can repay\n          repayAmount = currentBalance;\n        }\n\n        // Repay debt\n        repayLoan(repayAmount);\n      }\n\n      // Withdraw all available liquidity\n      (bool isNeg, uint256 liquidity) = getCurrentLiquidityInUSDC();\n      if (!isNeg) {\n        uint256 errorCode = CUSDC.redeemUnderlying(liquidity.mul(PRECISION.sub(DEFAULT_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n        if (errorCode != 0) {\n          // error\n          // try again with fallback slippage\n          errorCode = CUSDC.redeemUnderlying(liquidity.mul(PRECISION.sub(FALLBACK_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          if (errorCode != 0) {\n            // error\n            // try again with max slippage\n            CUSDC.redeemUnderlying(liquidity.mul(PRECISION.sub(MAX_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          }\n        }\n      }\n\n      if (currentDebt <= NEGLIGIBLE_DEBT) {\n        break;\n      }\n    }\n\n    // Send USDC back to PeakDeFiFund and return\n    _inputAmount = collateralAmountInUSDC;\n    _outputAmount = usdc.balanceOf(address(this));\n    outputAmount = _outputAmount;\n    usdc.safeTransfer(owner(), usdc.balanceOf(address(this)));\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repayLoan",
        "visibility": "public",
        "args": [
            {
                "name": "_repayAmountInUSDC",
                "type": "uint256"
            }
        ],
        "func": "function repayLoan(uint256 _repayAmountInUSDC) public onlyOwner {\n    require(buyTime > 0); // Ensure the order has been executed\n\n    // Convert USDC to shorting token\n    (,uint256 actualTokenAmount) = __sellUSDCForToken(_repayAmountInUSDC);\n\n    // Check if amount is greater than borrow balance\n    CERC20 market = CERC20(compoundTokenAddr);\n    uint256 currentDebt = market.borrowBalanceCurrent(address(this));\n    if (actualTokenAmount > currentDebt) {\n      actualTokenAmount = currentDebt;\n    }\n\n    // Repay loan to Compound\n    ERC20Detailed token = __underlyingToken(compoundTokenAddr);\n    token.safeApprove(compoundTokenAddr, 0);\n    token.safeApprove(compoundTokenAddr, actualTokenAmount);\n    require(market.repayBorrow(actualTokenAmount) == 0);\n    token.safeApprove(compoundTokenAddr, 0);\n  }",
        "comments": [
            "",
            "  // Allows manager to repay loan to avoid liquidation",
            "  "
        ],
        "comt": "\n  // Allows manager to repay loan to avoid liquidation\n  ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMarketCollateralFactor",
        "visibility": "public",
        "args": [],
        "func": "function getMarketCollateralFactor() public view returns (uint256) {\n    (, uint256 ratio) = COMPTROLLER.markets(address(CUSDC));\n    return ratio;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentCollateralInUSDC",
        "visibility": "public",
        "args": [],
        "func": "function getCurrentCollateralInUSDC() public returns (uint256 _amount) {\n    uint256 supply = CUSDC.balanceOf(address(this)).mul(CUSDC.exchangeRateCurrent()).div(PRECISION);\n    return supply;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentBorrowInUSDC",
        "visibility": "public",
        "args": [],
        "func": "function getCurrentBorrowInUSDC() public returns (uint256 _amount) {\n    CERC20 market = CERC20(compoundTokenAddr);\n    uint256 borrow = __tokenToUSDC(compoundTokenAddr, market.borrowBalanceCurrent(address(this)));\n    return borrow;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentCashInUSDC",
        "visibility": "public",
        "args": [],
        "func": "function getCurrentCashInUSDC() public view returns (uint256 _amount) {\n    uint256 cash = getBalance(usdc, address(this));\n    return cash;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "executeOrder",
        "visibility": "public",
        "args": [
            {
                "name": "_minPrice",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            }
        ],
        "func": "function executeOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidToken(compoundTokenAddr)\n    isValidPrice(_minPrice, _maxPrice)\n  {\n    buyTime = now;\n\n    // Get funds in USDC from PeakDeFiFund\n    usdc.safeTransferFrom(owner(), address(this), collateralAmountInUSDC); // Transfer USDC from PeakDeFiFund\n    \n    // Enter Compound markets\n    CEther market = CEther(compoundTokenAddr);\n    address[] memory markets = new address[](2);\n    markets[0] = compoundTokenAddr;\n    markets[1] = address(CUSDC);\n    uint[] memory errors = COMPTROLLER.enterMarkets(markets);\n    require(errors[0] == 0 && errors[1] == 0);\n\n    // Get loan from Compound in tokenAddr\n    uint256 loanAmountInToken = __usdcToToken(compoundTokenAddr, loanAmountInUSDC);\n    usdc.safeApprove(address(CUSDC), 0); // Clear USDC allowance of Compound USDC market\n    usdc.safeApprove(address(CUSDC), collateralAmountInUSDC); // Approve USDC transfer to Compound USDC market\n    require(CUSDC.mint(collateralAmountInUSDC) == 0); // Transfer USDC into Compound as supply\n    usdc.safeApprove(address(CUSDC), 0);\n    require(market.borrow(loanAmountInToken) == 0);// Take out loan\n    (bool negLiquidity, ) = getCurrentLiquidityInUSDC();\n    require(!negLiquidity); // Ensure account liquidity is positive\n\n    // Convert loaned tokens to USDC\n    (uint256 actualUSDCAmount,) = __sellTokenForUSDC(loanAmountInToken);\n    loanAmountInUSDC = actualUSDCAmount; // Change loan amount to actual USDC received\n\n    // Repay leftover tokens to avoid complications\n    if (address(this).balance > 0) {\n      uint256 repayAmount = address(this).balance;\n      market.repayBorrow.value(repayAmount)();\n    }\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sellOrder",
        "visibility": "public",
        "args": [
            {
                "name": "_minPrice",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            }
        ],
        "func": "function sellOrder(uint256 _minPrice, uint256 _maxPrice)\n    public\n    onlyOwner\n    isValidPrice(_minPrice, _maxPrice)\n    returns (uint256 _inputAmount, uint256 _outputAmount)\n  {\n    require(buyTime > 0); // Ensure the order has been executed\n    require(isSold == false);\n    isSold = true;\n\n    // Siphon remaining collateral by repaying x USDC and getting back 1.5x USDC collateral\n    // Repeat to ensure debt is exhausted\n    for (uint256 i = 0; i < MAX_REPAY_STEPS; i = i++) {\n      uint256 currentDebt = getCurrentBorrowInUSDC();\n      if (currentDebt > NEGLIGIBLE_DEBT) {\n        // Determine amount to be repaid this step\n        uint256 currentBalance = getCurrentCashInUSDC();\n        uint256 repayAmount = 0; // amount to be repaid in USDC\n        if (currentDebt <= currentBalance) {\n          // Has enough money, repay all debt\n          repayAmount = currentDebt;\n        } else {\n          // Doesn't have enough money, repay whatever we can repay\n          repayAmount = currentBalance;\n        }\n\n        // Repay debt\n        repayLoan(repayAmount);\n      }\n\n      // Withdraw all available liquidity\n      (bool isNeg, uint256 liquidity) = getCurrentLiquidityInUSDC();\n      if (!isNeg) {\n        uint256 errorCode = CUSDC.redeemUnderlying(liquidity.mul(PRECISION.sub(DEFAULT_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n        if (errorCode != 0) {\n          // error\n          // try again with fallback slippage\n          errorCode = CUSDC.redeemUnderlying(liquidity.mul(PRECISION.sub(FALLBACK_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          if (errorCode != 0) {\n            // error\n            // try again with max slippage\n            CUSDC.redeemUnderlying(liquidity.mul(PRECISION.sub(MAX_LIQUIDITY_SLIPPAGE)).div(PRECISION));\n          }\n        }\n      }\n\n      if (currentDebt <= NEGLIGIBLE_DEBT) {\n        break;\n      }\n    }\n\n    // Send USDC back to PeakDeFiFund and return\n    _inputAmount = collateralAmountInUSDC;\n    _outputAmount = usdc.balanceOf(address(this));\n    outputAmount = _outputAmount;\n    usdc.safeTransfer(owner(), usdc.balanceOf(address(this)));\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repayLoan",
        "visibility": "public",
        "args": [
            {
                "name": "_repayAmountInUSDC",
                "type": "uint256"
            }
        ],
        "func": "function repayLoan(uint256 _repayAmountInUSDC) public onlyOwner {\n    require(buyTime > 0); // Ensure the order has been executed\n\n    // Convert USDC to shorting token\n    (,uint256 actualTokenAmount) = __sellUSDCForToken(_repayAmountInUSDC);\n\n    // Check if amount is greater than borrow balance\n    CEther market = CEther(compoundTokenAddr);\n    uint256 currentDebt = market.borrowBalanceCurrent(address(this));\n    if (actualTokenAmount > currentDebt) {\n      actualTokenAmount = currentDebt;\n    }\n\n    // Repay loan to Compound\n    market.repayBorrow.value(actualTokenAmount)();\n  }",
        "comments": [
            "",
            "  // Allows manager to repay loan to avoid liquidation",
            "  "
        ],
        "comt": "\n  // Allows manager to repay loan to avoid liquidation\n  ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMarketCollateralFactor",
        "visibility": "public",
        "args": [],
        "func": "function getMarketCollateralFactor() public view returns (uint256) {\n    (, uint256 ratio) = COMPTROLLER.markets(address(CUSDC));\n    return ratio;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentCollateralInUSDC",
        "visibility": "public",
        "args": [],
        "func": "function getCurrentCollateralInUSDC() public returns (uint256 _amount) {\n    uint256 supply = CUSDC.balanceOf(address(this)).mul(CUSDC.exchangeRateCurrent()).div(PRECISION);\n    return supply;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentBorrowInUSDC",
        "visibility": "public",
        "args": [],
        "func": "function getCurrentBorrowInUSDC() public returns (uint256 _amount) {\n    CEther market = CEther(compoundTokenAddr);\n    uint256 borrow = __tokenToUSDC(compoundTokenAddr, market.borrowBalanceCurrent(address(this)));\n    return borrow;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCurrentCashInUSDC",
        "visibility": "public",
        "args": [],
        "func": "function getCurrentCashInUSDC() public view returns (uint256 _amount) {\n    uint256 cash = getBalance(usdc, address(this));\n    return cash;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setCompleted",
        "visibility": "public",
        "args": [
            {
                "name": "completed",
                "type": "uint"
            }
        ],
        "func": "function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "upgrade",
        "visibility": "public",
        "args": [
            {
                "name": "new_address",
                "type": "address"
            }
        ],
        "func": "function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-totalSupply}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-totalSupply}.\n     */\n",
        "@dev": "See {IERC20-totalSupply}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-balanceOf}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-balanceOf}.\n     */\n",
        "@dev": "See {IERC20-balanceOf}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-transfer}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `recipient` cannot be the zero address.",
            "     * - the caller must have a balance of at least `amount`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n",
        "@dev": "See {IERC20-transfer}. * * Requirements: * * - `recipient` cannot be the zero address. * - the caller must have a balance of at least `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allowance",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            }
        ],
        "func": "function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-allowance}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-allowance}.\n     */\n",
        "@dev": "See {IERC20-allowance}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-approve}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n",
        "@dev": "See {IERC20-approve}. * * Requirements: * * - `spender` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {IERC20-transferFrom}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance. This is not",
            "     * required by the EIP. See the note at the beginning of {ERC20};",
            "     *",
            "     * Requirements:",
            "     * - `sender` and `recipient` cannot be the zero address.",
            "     * - `sender` must have a balance of at least `amount`.",
            "     * - the caller must have allowance for `sender`'s tokens of at least",
            "     * `amount`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n",
        "@dev": "See {IERC20-transferFrom}. * * Emits an {Approval} event indicating the updated allowance. This is not * required by the EIP. See the note at the beginning of {ERC20}; * * Requirements: * - `sender` and `recipient` cannot be the zero address. * - `sender` must have a balance of at least `amount`. * - the caller must have allowance for `sender`'s tokens of at least * `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "increaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "addedValue",
                "type": "uint256"
            }
        ],
        "func": "function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Atomically increases the allowance granted to `spender` by the caller.",
            "     *",
            "     * This is an alternative to {approve} that can be used as a mitigation for",
            "     * problems described in {IERC20-approve}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n",
        "@dev": "Atomically increases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decreaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "subtractedValue",
                "type": "uint256"
            }
        ],
        "func": "function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev Atomically decreases the allowance granted to `spender` by the caller.",
            "     *",
            "     * This is an alternative to {approve} that can be used as a mitigation for",
            "     * problems described in {IERC20-approve}.",
            "     *",
            "     * Emits an {Approval} event indicating the updated allowance.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `spender` cannot be the zero address.",
            "     * - `spender` must have allowance for the caller of at least",
            "     * `subtractedValue`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n",
        "@dev": "Atomically decreases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address. * - `spender` must have allowance for the caller of at least * `subtractedValue`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cap",
        "visibility": "public",
        "args": [],
        "func": "function cap() public view returns (uint256) {\n        return _cap;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the cap on the token's total supply.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the cap on the token's total supply.\n     */\n",
        "@dev": "Returns the cap on the token's total supply.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @dev See {ERC20-_mint}.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - the caller must have the {MinterRole}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the {MinterRole}.\n     */\n",
        "@dev": "See {ERC20-_mint}. * * Requirements: * * - the caller must have the {MinterRole}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isMinter",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addMinter",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "renounceMinter",
        "visibility": "public",
        "args": [],
        "func": "function renounceMinter() public {\n        _removeMinter(_msgSender());\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "public",
        "args": [
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function burn(uint256 amount) public {\n        _burn(_msgSender(), amount);\n    }",
        "comments": [
            "/**",
            "     * @dev Destroys `amount` tokens from the caller.",
            "     *",
            "     * See {ERC20-_burn}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n",
        "@dev": "Destroys `amount` tokens from the caller. * * See {ERC20-_burn}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burnFrom",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function burnFrom(address account, uint256 amount) public {\n        _burnFrom(account, amount);\n    }",
        "comments": [
            "/**",
            "     * @dev See {ERC20-_burnFrom}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev See {ERC20-_burnFrom}.\n     */\n",
        "@dev": "See {ERC20-_burnFrom}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "multiRefer",
        "visibility": "external",
        "args": [
            {
                "name": "users",
                "type": "address[] calldata"
            },
            {
                "name": "referrers",
                "type": "address[] calldata"
            }
        ],
        "func": "function multiRefer(address[] calldata users, address[] calldata referrers) external onlySigner {\n      require(users.length == referrers.length, \"PeakReward: arrays length are not equal\");\n      for (uint256 i = 0; i < users.length; i++) {\n        refer(users[i], referrers[i]);\n      }\n    }",
        "comments": [
            "/**",
            "        @notice Registers a group of referrals relationship.",
            "        @param users The array of users",
            "        @param referrers The group of referrers of `users`",
            "     */",
            ""
        ],
        "comt": "/**\n        @notice Registers a group of referrals relationship.\n        @param users The array of users\n        @param referrers The group of referrers of `users`\n     */\n",
        "@notice": "Registers a group of referrals relationship.",
        "@param1": "users The array of users",
        "@param2": "referrers The group of referrers of `users`",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "refer",
        "visibility": "public",
        "args": [
            {
                "name": "user",
                "type": "address"
            },
            {
                "name": "referrer",
                "type": "address"
            }
        ],
        "func": "function refer(address user, address referrer) public onlySigner {\n        require(!isUser[user], \"PeakReward: referred is already a user\");\n        require(user != referrer, \"PeakReward: can't refer self\");\n        require(\n            user != address(0) && referrer != address(0),\n            \"PeakReward: 0 address\"\n        );\n\n        isUser[user] = true;\n        isUser[referrer] = true;\n\n        referrerOf[user] = referrer;\n        downlineRanks[referrer][0] = downlineRanks[referrer][0].add(1);\n\n        emit Register(user, referrer);\n    }",
        "comments": [
            "/**",
            "        @notice Registers a referral relationship",
            "        @param user The user who is being referred",
            "        @param referrer The referrer of `user`",
            "     */",
            ""
        ],
        "comt": "/**\n        @notice Registers a referral relationship\n        @param user The user who is being referred\n        @param referrer The referrer of `user`\n     */\n",
        "@notice": "Registers a referral relationship",
        "@param1": "user The user who is being referred",
        "@param2": "referrer The referrer of `user`",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "canRefer",
        "visibility": "public",
        "args": [
            {
                "name": "user",
                "type": "address"
            },
            {
                "name": "referrer",
                "type": "address"
            }
        ],
        "func": "function canRefer(address user, address referrer)\n        public\n        view\n        returns (bool)\n    {\n        return\n            !isUser[user] &&\n            user != referrer &&\n            user != address(0) &&\n            referrer != address(0);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "payCommission",
        "visibility": "public",
        "args": [
            {
                "name": "referrer",
                "type": "address"
            },
            {
                "name": "commissionToken",
                "type": "address"
            },
            {
                "name": "rawCommission",
                "type": "uint256"
            },
            {
                "name": "returnLeftovers",
                "type": "bool"
            }
        ],
        "func": "function payCommission(\n        address referrer,\n        address commissionToken,\n        uint256 rawCommission,\n        bool returnLeftovers\n    ) public regUser(referrer) onlySigner returns (uint256 leftoverAmount) {\n        // transfer the raw commission from `msg.sender`\n        IERC20 token = IERC20(commissionToken);\n        token.safeTransferFrom(msg.sender, address(this), rawCommission);\n\n        // payout commissions to referrers of different levels\n        address ptr = referrer;\n        uint256 commissionLeft = rawCommission;\n        uint8 i = 0;\n        while (ptr != address(0) && i < COMMISSION_LEVELS) {\n            if (_peakStakeOf(ptr) >= commissionStakeRequirements[i]) {\n                // referrer has enough stake, give commission\n                uint256 com = rawCommission.mul(commissionPercentages[i]).div(\n                    COMMISSION_RATE\n                );\n                if (com > commissionLeft) {\n                    com = commissionLeft;\n                }\n                token.safeTransfer(ptr, com);\n                commissionLeft = commissionLeft.sub(com);\n                if (commissionToken == address(peakToken)) {\n                    incrementCareerValueInPeak(ptr, com);\n                } else if (commissionToken == stablecoin) {\n                    incrementCareerValueInUsdc(ptr, com);\n                }\n                emit PayCommission(referrer, ptr, commissionToken, com, i);\n            }\n\n            ptr = referrerOf[ptr];\n            i += 1;\n        }\n\n        // handle leftovers\n        if (returnLeftovers) {\n            // return leftovers to `msg.sender`\n            token.safeTransfer(msg.sender, commissionLeft);\n            return commissionLeft;\n        } else {\n            // give leftovers to MarketPeak wallet\n            token.safeTransfer(marketPeakWallet, commissionLeft);\n            return 0;\n        }\n    }",
        "comments": [
            "/**",
            "        @notice Distributes commissions to a referrer and their referrers",
            "        @param referrer The referrer who will receive commission",
            "        @param commissionToken The ERC20 token that the commission is paid in",
            "        @param rawCommission The raw commission that will be distributed amongst referrers",
            "        @param returnLeftovers If true, leftover commission is returned to the sender. If false, leftovers will be paid to MarketPeak.",
            "     */",
            ""
        ],
        "comt": "/**\n        @notice Distributes commissions to a referrer and their referrers\n        @param referrer The referrer who will receive commission\n        @param commissionToken The ERC20 token that the commission is paid in\n        @param rawCommission The raw commission that will be distributed amongst referrers\n        @param returnLeftovers If true, leftover commission is returned to the sender. If false, leftovers will be paid to MarketPeak.\n     */\n",
        "@notice": "Distributes commissions to a referrer and their referrers",
        "@param1": "referrer The referrer who will receive commission",
        "@param2": "commissionToken The ERC20 token that the commission is paid in",
        "@param3": "rawCommission The raw commission that will be distributed amongst referrers",
        "@param4": "returnLeftovers If true, leftover commission is returned to the sender. If false, leftovers will be paid to MarketPeak.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "incrementCareerValueInUsdc",
        "visibility": "public",
        "args": [
            {
                "name": "user",
                "type": "address"
            },
            {
                "name": "incCV",
                "type": "uint256"
            }
        ],
        "func": "function incrementCareerValueInUsdc(address user, uint256 incCV)\n        public\n        regUser(user)\n        onlySigner\n    {\n        careerValue[user] = careerValue[user].add(incCV);\n        emit ChangedCareerValue(user, incCV, true);\n    }",
        "comments": [
            "/**",
            "        @notice Increments a user's career value",
            "        @param user The user",
            "        @param incCV The CV increase amount, in Usdc",
            "     */",
            ""
        ],
        "comt": "/**\n        @notice Increments a user's career value\n        @param user The user\n        @param incCV The CV increase amount, in Usdc\n     */\n",
        "@notice": "Increments a user's career value",
        "@param1": "user The user",
        "@param2": "incCV The CV increase amount, in Usdc",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "incrementCareerValueInPeak",
        "visibility": "public",
        "args": [
            {
                "name": "user",
                "type": "address"
            },
            {
                "name": "incCVInPeak",
                "type": "uint256"
            }
        ],
        "func": "function incrementCareerValueInPeak(address user, uint256 incCVInPeak)\n        public\n        regUser(user)\n        onlySigner\n    {\n        uint256 peakPriceInUsdc = _getPeakPriceInUsdc();\n        uint256 incCVInUsdc = incCVInPeak.mul(peakPriceInUsdc).div(\n            PEAK_PRECISION\n        );\n        careerValue[user] = careerValue[user].add(incCVInUsdc);\n        emit ChangedCareerValue(user, incCVInUsdc, true);\n    }",
        "comments": [
            "/**",
            "        @notice Increments a user's career value",
            "        @param user The user",
            "        @param incCVInPeak The CV increase amount, in PEAK tokens",
            "     */",
            ""
        ],
        "comt": "/**\n        @notice Increments a user's career value\n        @param user The user\n        @param incCVInPeak The CV increase amount, in PEAK tokens\n     */\n",
        "@notice": "Increments a user's career value",
        "@param1": "user The user",
        "@param2": "incCVInPeak The CV increase amount, in PEAK tokens",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cvRankOf",
        "visibility": "public",
        "args": [
            {
                "name": "user",
                "type": "address"
            }
        ],
        "func": "function cvRankOf(address user) public view returns (uint256) {\n        uint256 cv = careerValue[user];\n        if (cv < USDC_PRECISION.mul(100)) {\n            return 0;\n        } else if (cv < USDC_PRECISION.mul(250)) {\n            return 1;\n        } else if (cv < USDC_PRECISION.mul(750)) {\n            return 2;\n        } else if (cv < USDC_PRECISION.mul(1500)) {\n            return 3;\n        } else if (cv < USDC_PRECISION.mul(3000)) {\n            return 4;\n        } else if (cv < USDC_PRECISION.mul(10000)) {\n            return 5;\n        } else if (cv < USDC_PRECISION.mul(50000)) {\n            return 6;\n        } else if (cv < USDC_PRECISION.mul(150000)) {\n            return 7;\n        } else {\n            return 8;\n        }\n    }",
        "comments": [
            "/**",
            "        @notice Returns a user's rank in the PeakDeFi system based only on career value",
            "        @param user The user whose rank will be queried",
            "     */",
            ""
        ],
        "comt": "/**\n        @notice Returns a user's rank in the PeakDeFi system based only on career value\n        @param user The user whose rank will be queried\n     */\n",
        "@notice": "Returns a user's rank in the PeakDeFi system based only on career value",
        "@param1": "user The user whose rank will be queried",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "rankUp",
        "visibility": "external",
        "args": [
            {
                "name": "user",
                "type": "address"
            }
        ],
        "func": "function rankUp(address user) external {\n        // verify rank up conditions\n        uint256 currentRank = rankOf[user];\n        uint256 cvRank = cvRankOf(user);\n        require(cvRank > currentRank, \"PeakReward: career value is not enough!\");\n        require(downlineRanks[user][currentRank] >= 2 || currentRank == 0, \"PeakReward: downlines count and requirement not passed!\");\n\n        // Target rank always should be +1 rank from current rank\n        uint256 targetRank = currentRank + 1;\n\n        // increase user rank\n        rankOf[user] = targetRank;\n        emit RankChange(user, currentRank, targetRank);\n\n        address referrer = referrerOf[user];\n        if (referrer != address(0)) {\n            downlineRanks[referrer][targetRank] = downlineRanks[referrer][targetRank]\n                .add(1);\n            downlineRanks[referrer][currentRank] = downlineRanks[referrer][currentRank]\n                .sub(1);\n        }\n\n        // give user rank reward\n        uint256 rewardInPeak = rankReward[currentRank][targetRank]\n            .mul(PEAK_PRECISION)\n            .div(_getPeakPriceInUsdc());\n        if (mintedPeakTokens.add(rewardInPeak) <= PEAK_MINT_CAP) {\n            // mint if under cap, do nothing if over cap\n            mintedPeakTokens = mintedPeakTokens.add(rewardInPeak);\n            peakToken.mint(user, rewardInPeak);\n            emit ReceiveRankReward(user, rewardInPeak);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "canRankUp",
        "visibility": "external",
        "args": [
            {
                "name": "user",
                "type": "address"
            }
        ],
        "func": "function canRankUp(address user) external view returns (bool) {\n        uint256 currentRank = rankOf[user];\n        uint256 cvRank = cvRankOf(user);\n        return\n            (cvRank > currentRank) &&\n            (downlineRanks[user][currentRank] >= 2 || currentRank == 0);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isSigner",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function isSigner(address account) public view returns (bool) {\n        return _signers.has(account);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "addSigner",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function addSigner(address account) public onlySigner {\n        _addSigner(account);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "renounceSigner",
        "visibility": "public",
        "args": [],
        "func": "function renounceSigner() public {\n        _removeSigner(_msgSender());\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "init",
        "visibility": "public",
        "args": [
            {
                "name": "_peakReward",
                "type": "address"
            }
        ],
        "func": "function init(address _peakReward) public {\n        require(!initialized, \"PeakStaking: Already initialized\");\n        initialized = true;\n\n        peakReward = PeakReward(_peakReward);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stake",
        "visibility": "public",
        "args": [
            {
                "name": "stakeAmount",
                "type": "uint256"
            },
            {
                "name": "stakeTimeInDays",
                "type": "uint256"
            },
            {
                "name": "referrer",
                "type": "address"
            }
        ],
        "func": "function stake(\n        uint256 stakeAmount,\n        uint256 stakeTimeInDays,\n        address referrer\n    ) public returns (uint256 stakeIdx) {\n        require(\n            stakeTimeInDays >= MIN_STAKE_PERIOD,\n            \"PeakStaking: stakeTimeInDays < MIN_STAKE_PERIOD\"\n        );\n        require(\n            stakeTimeInDays <= MAX_STAKE_PERIOD,\n            \"PeakStaking: stakeTimeInDays > MAX_STAKE_PERIOD\"\n        );\n\n        // record stake\n        uint256 interestAmount = getInterestAmount(\n            stakeAmount,\n            stakeTimeInDays\n        );\n        stakeIdx = stakeList.length;\n        stakeList.push(\n            Stake({\n                staker: msg.sender,\n                stakeAmount: stakeAmount,\n                interestAmount: interestAmount,\n                withdrawnInterestAmount: 0,\n                stakeTimestamp: now,\n                stakeTimeInDays: stakeTimeInDays,\n                active: true\n            })\n        );\n        mintedPeakTokens = mintedPeakTokens.add(interestAmount);\n        userStakeAmount[msg.sender] = userStakeAmount[msg.sender].add(\n            stakeAmount\n        );\n\n        // transfer PEAK from msg.sender\n        peakToken.safeTransferFrom(msg.sender, address(this), stakeAmount);\n\n        // mint PEAK interest\n        peakToken.mint(address(this), interestAmount);\n\n        // handle referral\n        if (peakReward.canRefer(msg.sender, referrer)) {\n            peakReward.refer(msg.sender, referrer);\n        }\n        address actualReferrer = peakReward.referrerOf(msg.sender);\n        if (actualReferrer != address(0)) {\n            // pay referral bonus to referrer\n            uint256 rawCommission = interestAmount.mul(COMMISSION_RATE).div(\n                PRECISION\n            );\n            peakToken.mint(address(this), rawCommission);\n            peakToken.safeApprove(address(peakReward), rawCommission);\n            uint256 leftoverAmount = peakReward.payCommission(\n                actualReferrer,\n                address(peakToken),\n                rawCommission,\n                true\n            );\n            peakToken.burn(leftoverAmount);\n\n            // pay referral bonus to staker\n            uint256 referralStakerBonus = interestAmount\n                .mul(REFERRAL_STAKER_BONUS)\n                .div(PRECISION);\n            peakToken.mint(msg.sender, referralStakerBonus);\n\n            mintedPeakTokens = mintedPeakTokens.add(\n                rawCommission.sub(leftoverAmount).add(referralStakerBonus)\n            );\n\n            emit ReceiveStakeReward(stakeIdx, msg.sender, referralStakerBonus);\n        }\n\n        require(mintedPeakTokens <= PEAK_MINT_CAP, \"PeakStaking: reached cap\");\n\n        emit CreateStake(\n            stakeIdx,\n            msg.sender,\n            actualReferrer,\n            stakeAmount,\n            stakeTimeInDays,\n            interestAmount\n        );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdraw",
        "visibility": "public",
        "args": [
            {
                "name": "stakeIdx",
                "type": "uint256"
            }
        ],
        "func": "function withdraw(uint256 stakeIdx) public {\n        Stake storage stakeObj = stakeList[stakeIdx];\n        require(\n            stakeObj.staker == msg.sender,\n            \"PeakStaking: Sender not staker\"\n        );\n        require(stakeObj.active, \"PeakStaking: Not active\");\n\n        // calculate amount that can be withdrawn\n        uint256 stakeTimeInSeconds = stakeObj.stakeTimeInDays.mul(\n            DAY_IN_SECONDS\n        );\n        uint256 withdrawAmount;\n        if (now >= stakeObj.stakeTimestamp.add(stakeTimeInSeconds)) {\n            // matured, withdraw all\n            withdrawAmount = stakeObj\n                .stakeAmount\n                .add(stakeObj.interestAmount)\n                .sub(stakeObj.withdrawnInterestAmount);\n            stakeObj.active = false;\n            stakeObj.withdrawnInterestAmount = stakeObj.interestAmount;\n            userStakeAmount[msg.sender] = userStakeAmount[msg.sender].sub(\n                stakeObj.stakeAmount\n            );\n\n            emit WithdrawReward(\n                stakeIdx,\n                msg.sender,\n                stakeObj.interestAmount.sub(stakeObj.withdrawnInterestAmount)\n            );\n            emit WithdrawStake(stakeIdx, msg.sender);\n        } else {\n            // not mature, partial withdraw\n            withdrawAmount = stakeObj\n                .interestAmount\n                .mul(uint256(now).sub(stakeObj.stakeTimestamp))\n                .div(stakeTimeInSeconds)\n                .sub(stakeObj.withdrawnInterestAmount);\n\n            // record withdrawal\n            stakeObj.withdrawnInterestAmount = stakeObj\n                .withdrawnInterestAmount\n                .add(withdrawAmount);\n\n            emit WithdrawReward(stakeIdx, msg.sender, withdrawAmount);\n        }\n\n        // withdraw interest to sender\n        peakToken.safeTransfer(msg.sender, withdrawAmount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getInterestAmount",
        "visibility": "public",
        "args": [
            {
                "name": "stakeAmount",
                "type": "uint256"
            },
            {
                "name": "stakeTimeInDays",
                "type": "uint256"
            }
        ],
        "func": "function getInterestAmount(uint256 stakeAmount, uint256 stakeTimeInDays)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 earlyFactor = _earlyFactor(mintedPeakTokens);\n        uint256 biggerBonus = stakeAmount.mul(PRECISION).div(\n            BIGGER_BONUS_DIVISOR\n        );\n        if (biggerBonus > MAX_BIGGER_BONUS) {\n            biggerBonus = MAX_BIGGER_BONUS;\n        }\n\n        // convert yearly bigger bonus to stake time\n        biggerBonus = biggerBonus.mul(stakeTimeInDays).div(YEAR_IN_DAYS);\n\n        uint256 longerBonus = _longerBonus(stakeTimeInDays);\n        uint256 interestRate = biggerBonus.add(longerBonus).mul(earlyFactor).div(\n            PRECISION\n        );\n        uint256 interestAmount = stakeAmount.mul(interestRate).div(PRECISION);\n        return interestAmount;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createFund",
        "visibility": "external",
        "args": [],
        "func": "function createFund() external returns (PeakDeFiFund) {\n        // create fund\n        PeakDeFiFund fund = PeakDeFiFund(createClone(peakdefiFund).toPayable());\n        fund.initOwner();\n\n        // give PeakReward signer rights to fund\n        PeakReward peakReward = PeakReward(peakRewardAddr);\n        peakReward.addSigner(address(fund));\n\n        fundCreator[address(fund)] = msg.sender;\n\n        emit CreateFund(address(fund));\n\n        return fund;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "initFund1",
        "visibility": "external",
        "args": [
            {
                "name": "fund",
                "type": "PeakDeFiFund"
            },
            {
                "name": "reptokenName",
                "type": "string calldata"
            },
            {
                "name": "reptokenSymbol",
                "type": "string calldata"
            },
            {
                "name": "sharesName",
                "type": "string calldata"
            },
            {
                "name": "sharesSymbol",
                "type": "string calldata"
            }
        ],
        "func": "function initFund1(\n        PeakDeFiFund fund,\n        string calldata reptokenName,\n        string calldata reptokenSymbol,\n        string calldata sharesName,\n        string calldata sharesSymbol\n    ) external {\n        require(\n            fundCreator[address(fund)] == msg.sender,\n            \"PeakDeFiFactory: not creator\"\n        );\n\n        // create tokens\n        MiniMeToken reptoken = minimeFactory.createCloneToken(\n            address(0),\n            0,\n            reptokenName,\n            18,\n            reptokenSymbol,\n            false\n        );\n        MiniMeToken shares = minimeFactory.createCloneToken(\n            address(0),\n            0,\n            sharesName,\n            18,\n            sharesSymbol,\n            true\n        );\n        MiniMeToken peakReferralToken = minimeFactory.createCloneToken(\n            address(0),\n            0,\n            \"Peak Referral Token\",\n            18,\n            \"PRT\",\n            false\n        );\n\n        // transfer token ownerships to fund\n        reptoken.transferOwnership(address(fund));\n        shares.transferOwnership(address(fund));\n        peakReferralToken.transferOwnership(address(fund));\n\n        fund.initInternalTokens(\n            address(reptoken),\n            address(shares),\n            address(peakReferralToken)\n        );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "initFund2",
        "visibility": "external",
        "args": [
            {
                "name": "fund",
                "type": "PeakDeFiFund"
            },
            {
                "name": "_devFundingAccount",
                "type": "address payable"
            },
            {
                "name": "_devFundingRate",
                "type": "uint256"
            },
            {
                "name": "_phaseLengths",
                "type": "uint256[2] calldata"
            },
            {
                "name": "_compoundFactoryAddr",
                "type": "address"
            }
        ],
        "func": "function initFund2(\n        PeakDeFiFund fund,\n        address payable _devFundingAccount,\n        uint256 _devFundingRate,\n        uint256[2] calldata _phaseLengths,\n        address _compoundFactoryAddr\n    ) external {\n        require(\n            fundCreator[address(fund)] == msg.sender,\n            \"PeakDeFiFactory: not creator\"\n        );\n        fund.initParams(\n            _devFundingAccount,\n            _phaseLengths,\n            _devFundingRate,\n            address(0),\n            usdcAddr,\n            kyberAddr,\n            _compoundFactoryAddr,\n            peakdefiLogic,\n            peakdefiLogic2,\n            peakdefiLogic3,\n            1,\n            oneInchAddr,\n            peakRewardAddr,\n            peakStakingAddr\n        );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "initFund3",
        "visibility": "external",
        "args": [
            {
                "name": "fund",
                "type": "PeakDeFiFund"
            },
            {
                "name": "_newManagerRepToken",
                "type": "uint256"
            },
            {
                "name": "_maxNewManagersPerCycle",
                "type": "uint256"
            },
            {
                "name": "_reptokenPrice",
                "type": "uint256"
            },
            {
                "name": "_peakManagerStakeRequired",
                "type": "uint256"
            },
            {
                "name": "_isPermissioned",
                "type": "bool"
            }
        ],
        "func": "function initFund3(\n        PeakDeFiFund fund,\n        uint256 _newManagerRepToken,\n        uint256 _maxNewManagersPerCycle,\n        uint256 _reptokenPrice,\n        uint256 _peakManagerStakeRequired,\n        bool _isPermissioned\n    ) external {\n        require(\n            fundCreator[address(fund)] == msg.sender,\n            \"PeakDeFiFactory: not creator\"\n        );\n        fund.initRegistration(\n            _newManagerRepToken,\n            _maxNewManagersPerCycle,\n            _reptokenPrice,\n            _peakManagerStakeRequired,\n            _isPermissioned\n        );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "initFund4",
        "visibility": "external",
        "args": [
            {
                "name": "fund",
                "type": "PeakDeFiFund"
            },
            {
                "name": "_kyberTokens",
                "type": "address[] calldata"
            },
            {
                "name": "_compoundTokens",
                "type": "address[] calldata"
            }
        ],
        "func": "function initFund4(\n        PeakDeFiFund fund,\n        address[] calldata _kyberTokens,\n        address[] calldata _compoundTokens\n    ) external {\n        require(\n            fundCreator[address(fund)] == msg.sender,\n            \"PeakDeFiFactory: not creator\"\n        );\n        fund.initTokenListings(_kyberTokens, _compoundTokens);\n\n        // deploy and set PeakDeFiProxy\n        PeakDeFiProxy proxy = new PeakDeFiProxy(address(fund));\n        fund.setProxy(address(proxy).toPayable());\n\n        // transfer fund ownership to msg.sender\n        fund.transferOwnership(msg.sender);\n\n        emit InitFund(address(fund), address(proxy));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "_to",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address _to, uint256 _amount) public returns (bool success) {\n    require(transfersEnabled);\n    doTransfer(msg.sender, _to, _amount);\n    return true;\n  }",
        "comments": [
            "",
            "",
            "///////////////////",
            "// ERC20 Methods",
            "///////////////////",
            "",
            "  /// @notice Send `_amount` tokens to `_to` from `msg.sender`",
            "  /// @param _to The address of the recipient",
            "  /// @param _amount The amount of tokens to be transferred",
            "  /// @return Whether the transfer was successful or not",
            "  "
        ],
        "comt": "\n\n///////////////////\n// ERC20 Methods\n///////////////////\n\n  /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n  /// @param _to The address of the recipient\n  /// @param _amount The amount of tokens to be transferred\n  /// @return Whether the transfer was successful or not\n  ",
        "@notice": "Send `_amount` tokens to `_to` from `msg.sender`",
        "@param1": "_to The address of the recipient",
        "@param2": "_amount The amount of tokens to be transferred",
        "@return1": "Whether the transfer was successful or not",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "_from",
                "type": "address"
            },
            {
                "name": "_to",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(address _from, address _to, uint256 _amount\n  ) public returns (bool success) {\n\n    // The owner of this contract can move tokens around at will,\n    //  this is important to recognize! Confirm that you trust the\n    //  owner of this contract, which in most situations should be\n    //  another open source smart contract or 0x0\n    if (msg.sender != owner()) {\n      require(transfersEnabled);\n\n      // The standard ERC 20 transferFrom functionality\n      require(allowed[_from][msg.sender] >= _amount);\n      allowed[_from][msg.sender] -= _amount;\n    }\n    doTransfer(_from, _to, _amount);\n    return true;\n  }",
        "comments": [
            "",
            "  /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it",
            "  ///  is approved by `_from`",
            "  /// @param _from The address holding the tokens being transferred",
            "  /// @param _to The address of the recipient",
            "  /// @param _amount The amount of tokens to be transferred",
            "  /// @return True if the transfer was successful",
            "  "
        ],
        "comt": "\n  /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n  ///  is approved by `_from`\n  /// @param _from The address holding the tokens being transferred\n  /// @param _to The address of the recipient\n  /// @param _amount The amount of tokens to be transferred\n  /// @return True if the transfer was successful\n  ",
        "@notice": "Send `_amount` tokens to `_to` from `_from` on the condition it /// is approved by `_from`",
        "@param1": "_from The address holding the tokens being transferred",
        "@param2": "_to The address of the recipient",
        "@param3": "_amount The amount of tokens to be transferred",
        "@return1": "True if the transfer was successful",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "_owner",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balanceOfAt(_owner, block.number);\n  }",
        "comments": [
            "",
            "  /// @param _owner The address that's balance is being requested",
            "  /// @return The balance of `_owner` at the current block",
            "  "
        ],
        "comt": "\n  /// @param _owner The address that's balance is being requested\n  /// @return The balance of `_owner` at the current block\n  ",
        "@param1": "_owner The address that's balance is being requested",
        "@return1": "The balance of `_owner` at the current block",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "_spender",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "func": "function approve(address _spender, uint256 _amount) public returns (bool success) {\n    require(transfersEnabled);\n\n    // To change the approve amount you first have to reduce the addresses`\n    //  allowance to zero by calling `approve(_spender,0)` if it is not\n    //  already 0 to mitigate the race condition described here:\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n    // Alerts the token owner of the approve function call\n    if (isContract(owner())) {\n      require(TokenController(owner()).onApprove(msg.sender, _spender, _amount));\n    }\n\n    allowed[msg.sender][_spender] = _amount;\n    emit Approval(msg.sender, _spender, _amount);\n    return true;\n  }",
        "comments": [
            "",
            "  /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on",
            "  ///  its behalf. This is a modified version of the ERC20 approve function",
            "  ///  to be a little bit safer",
            "  /// @param _spender The address of the account able to transfer the tokens",
            "  /// @param _amount The amount of tokens to be approved for transfer",
            "  /// @return True if the approval was successful",
            "  "
        ],
        "comt": "\n  /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n  ///  its behalf. This is a modified version of the ERC20 approve function\n  ///  to be a little bit safer\n  /// @param _spender The address of the account able to transfer the tokens\n  /// @param _amount The amount of tokens to be approved for transfer\n  /// @return True if the approval was successful\n  ",
        "@notice": "`msg.sender` approves `_spender` to spend `_amount` tokens on /// its behalf. This is a modified version of the ERC20 approve function /// to be a little bit safer",
        "@param1": "_spender The address of the account able to transfer the tokens",
        "@param2": "_amount The amount of tokens to be approved for transfer",
        "@return1": "True if the approval was successful",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allowance",
        "visibility": "public",
        "args": [
            {
                "name": "_owner",
                "type": "address"
            },
            {
                "name": "_spender",
                "type": "address"
            }
        ],
        "func": "function allowance(address _owner, address _spender\n  ) public view returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }",
        "comments": [
            "",
            "  /// @dev This function makes it easy to read the `allowed[]` map",
            "  /// @param _owner The address of the account that owns the token",
            "  /// @param _spender The address of the account able to transfer the tokens",
            "  /// @return Amount of remaining tokens of _owner that _spender is allowed",
            "  ///  to spend",
            "  "
        ],
        "comt": "\n  /// @dev This function makes it easy to read the `allowed[]` map\n  /// @param _owner The address of the account that owns the token\n  /// @param _spender The address of the account able to transfer the tokens\n  /// @return Amount of remaining tokens of _owner that _spender is allowed\n  ///  to spend\n  ",
        "@dev": "This function makes it easy to read the `allowed[]` map",
        "@param1": "_owner The address of the account that owns the token",
        "@param2": "_spender The address of the account able to transfer the tokens",
        "@return1": "Amount of remaining tokens of _owner that _spender is allowed /// to spend",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approveAndCall",
        "visibility": "public",
        "args": [
            {
                "name": "_spender",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint256"
            },
            {
                "name": "_extraData",
                "type": "bytes memory"
            }
        ],
        "func": "function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData\n  ) public returns (bool success) {\n    require(approve(_spender, _amount));\n\n    ApproveAndCallFallBack(_spender).receiveApproval(\n      msg.sender,\n      _amount,\n      address(this),\n      _extraData\n    );\n\n    return true;\n  }",
        "comments": [
            "",
            "  /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on",
            "  ///  its behalf, and then a function is triggered in the contract that is",
            "  ///  being approved, `_spender`. This allows users to use their tokens to",
            "  ///  interact with contracts in one function call instead of two",
            "  /// @param _spender The address of the contract able to transfer the tokens",
            "  /// @param _amount The amount of tokens to be approved for transfer",
            "  /// @return True if the function call was successful",
            "  "
        ],
        "comt": "\n  /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\n  ///  its behalf, and then a function is triggered in the contract that is\n  ///  being approved, `_spender`. This allows users to use their tokens to\n  ///  interact with contracts in one function call instead of two\n  /// @param _spender The address of the contract able to transfer the tokens\n  /// @param _amount The amount of tokens to be approved for transfer\n  /// @return True if the function call was successful\n  ",
        "@notice": "`msg.sender` approves `_spender` to send `_amount` tokens on /// its behalf, and then a function is triggered in the contract that is /// being approved, `_spender`. This allows users to use their tokens to /// interact with contracts in one function call instead of two",
        "@param1": "_spender The address of the contract able to transfer the tokens",
        "@param2": "_amount The amount of tokens to be approved for transfer",
        "@return1": "True if the function call was successful",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view returns (uint) {\n    return totalSupplyAt(block.number);\n  }",
        "comments": [
            "",
            "  /// @dev This function makes it easy to get the total number of tokens",
            "  /// @return The total number of tokens",
            "  "
        ],
        "comt": "\n  /// @dev This function makes it easy to get the total number of tokens\n  /// @return The total number of tokens\n  ",
        "@dev": "This function makes it easy to get the total number of tokens",
        "@return1": "The total number of tokens",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOfAt",
        "visibility": "public",
        "args": [
            {
                "name": "_owner",
                "type": "address"
            },
            {
                "name": "_blockNumber",
                "type": "uint"
            }
        ],
        "func": "function balanceOfAt(address _owner, uint _blockNumber) public view\n    returns (uint) {\n\n    // These next few lines are used when the balance of the token is\n    //  requested before a check point was ever created for this token, it\n    //  requires that the `parentToken.balanceOfAt` be queried at the\n    //  genesis block for that token as this contains initial balance of\n    //  this token\n    if ((balances[_owner].length == 0)\n        || (balances[_owner][0].fromBlock > _blockNumber)) {\n      if (address(parentToken) != address(0)) {\n        return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n      } else {\n          // Has no parent\n        return 0;\n      }\n\n    // This will return the expected balance during normal situations\n    } else {\n      return getValueAt(balances[_owner], _blockNumber);\n    }\n  }",
        "comments": [
            "",
            "",
            "////////////////",
            "// Query balance and totalSupply in History",
            "////////////////",
            "",
            "  /// @dev Queries the balance of `_owner` at a specific `_blockNumber`",
            "  /// @param _owner The address from which the balance will be retrieved",
            "  /// @param _blockNumber The block number when the balance is queried",
            "  /// @return The balance at `_blockNumber`",
            "  "
        ],
        "comt": "\n\n////////////////\n// Query balance and totalSupply in History\n////////////////\n\n  /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\n  /// @param _owner The address from which the balance will be retrieved\n  /// @param _blockNumber The block number when the balance is queried\n  /// @return The balance at `_blockNumber`\n  ",
        "@dev": "Queries the balance of `_owner` at a specific `_blockNumber`",
        "@param1": "_owner The address from which the balance will be retrieved",
        "@param2": "_blockNumber The block number when the balance is queried",
        "@return1": "The balance at `_blockNumber`",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalSupplyAt",
        "visibility": "public",
        "args": [
            {
                "name": "_blockNumber",
                "type": "uint"
            }
        ],
        "func": "function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n    // These next few lines are used when the totalSupply of the token is\n    //  requested before a check point was ever created for this token, it\n    //  requires that the `parentToken.totalSupplyAt` be queried at the\n    //  genesis block for this token as that contains totalSupply of this\n    //  token at this block number.\n    if ((totalSupplyHistory.length == 0)\n      || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n      if (address(parentToken) != address(0)) {\n        return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n      } else {\n        return 0;\n      }\n\n    // This will return the expected totalSupply during normal situations\n    } else {\n      return getValueAt(totalSupplyHistory, _blockNumber);\n    }\n  }",
        "comments": [
            "",
            "  /// @notice Total amount of tokens at a specific `_blockNumber`.",
            "  /// @param _blockNumber The block number when the totalSupply is queried",
            "  /// @return The total amount of tokens at `_blockNumber`",
            "  "
        ],
        "comt": "\n  /// @notice Total amount of tokens at a specific `_blockNumber`.\n  /// @param _blockNumber The block number when the totalSupply is queried\n  /// @return The total amount of tokens at `_blockNumber`\n  ",
        "@notice": "Total amount of tokens at a specific `_blockNumber`.",
        "@param1": "_blockNumber The block number when the totalSupply is queried",
        "@return1": "The total amount of tokens at `_blockNumber`",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createCloneToken",
        "visibility": "public",
        "args": [
            {
                "name": "_cloneTokenName",
                "type": "string memory"
            },
            {
                "name": "_cloneDecimalUnits",
                "type": "uint8"
            },
            {
                "name": "_cloneTokenSymbol",
                "type": "string memory"
            },
            {
                "name": "_snapshotBlock",
                "type": "uint"
            },
            {
                "name": "_transfersEnabled",
                "type": "bool"
            }
        ],
        "func": "function createCloneToken(\n    string memory _cloneTokenName,\n    uint8 _cloneDecimalUnits,\n    string memory _cloneTokenSymbol,\n    uint _snapshotBlock,\n    bool _transfersEnabled\n  ) public returns(address) {\n    uint snapshotBlock = _snapshotBlock;\n    if (snapshotBlock == 0) snapshotBlock = block.number;\n    MiniMeToken cloneToken = tokenFactory.createCloneToken(\n      address(this),\n      snapshotBlock,\n      _cloneTokenName,\n      _cloneDecimalUnits,\n      _cloneTokenSymbol,\n      _transfersEnabled\n    );\n\n    cloneToken.transferOwnership(msg.sender);\n\n    // An event to make the token easy to find on the blockchain\n    emit NewCloneToken(address(cloneToken), snapshotBlock);\n    return address(cloneToken);\n  }",
        "comments": [
            "  ///  if the block is zero than the actual block, the current block is used",
            "  /// @param _transfersEnabled True if transfers are allowed in the clone",
            "  /// @return The address of the new MiniMeToken Contract",
            "  "
        ],
        "comt": "  ///  if the block is zero than the actual block, the current block is used\n  /// @param _transfersEnabled True if transfers are allowed in the clone\n  /// @return The address of the new MiniMeToken Contract\n  ",
        "@param1": "_transfersEnabled True if transfers are allowed in the clone",
        "@return1": "The address of the new MiniMeToken Contract",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "generateTokens",
        "visibility": "public",
        "args": [
            {
                "name": "_owner",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            }
        ],
        "func": "function generateTokens(address _owner, uint _amount\n  ) public onlyOwner returns (bool) {\n    uint curTotalSupply = totalSupply();\n    require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n    uint previousBalanceTo = balanceOf(_owner);\n    require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n    updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n    updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n    emit Transfer(address(0), _owner, _amount);\n    return true;\n  }",
        "comments": [
            "",
            "////////////////",
            "// Generate and destroy tokens",
            "////////////////",
            "",
            "  /// @notice Generates `_amount` tokens that are assigned to `_owner`",
            "  /// @param _owner The address that will be assigned the new tokens",
            "  /// @param _amount The quantity of tokens generated",
            "  /// @return True if the tokens are generated correctly",
            "  "
        ],
        "comt": "\n////////////////\n// Generate and destroy tokens\n////////////////\n\n  /// @notice Generates `_amount` tokens that are assigned to `_owner`\n  /// @param _owner The address that will be assigned the new tokens\n  /// @param _amount The quantity of tokens generated\n  /// @return True if the tokens are generated correctly\n  ",
        "@notice": "Generates `_amount` tokens that are assigned to `_owner`",
        "@param1": "_owner The address that will be assigned the new tokens",
        "@param2": "_amount The quantity of tokens generated",
        "@return1": "True if the tokens are generated correctly",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "destroyTokens",
        "visibility": "public",
        "args": [
            {
                "name": "_owner",
                "type": "address"
            },
            {
                "name": "_amount",
                "type": "uint"
            }
        ],
        "func": "function destroyTokens(address _owner, uint _amount\n  ) onlyOwner public returns (bool) {\n    uint curTotalSupply = totalSupply();\n    require(curTotalSupply >= _amount);\n    uint previousBalanceFrom = balanceOf(_owner);\n    require(previousBalanceFrom >= _amount);\n    updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n    updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n    emit Transfer(_owner, address(0), _amount);\n    return true;\n  }",
        "comments": [
            "",
            "",
            "  /// @notice Burns `_amount` tokens from `_owner`",
            "  /// @param _owner The address that will lose the tokens",
            "  /// @param _amount The quantity of tokens to burn",
            "  /// @return True if the tokens are burned correctly",
            "  "
        ],
        "comt": "\n\n  /// @notice Burns `_amount` tokens from `_owner`\n  /// @param _owner The address that will lose the tokens\n  /// @param _amount The quantity of tokens to burn\n  /// @return True if the tokens are burned correctly\n  ",
        "@notice": "Burns `_amount` tokens from `_owner`",
        "@param1": "_owner The address that will lose the tokens",
        "@param2": "_amount The quantity of tokens to burn",
        "@return1": "True if the tokens are burned correctly",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "enableTransfers",
        "visibility": "public",
        "args": [
            {
                "name": "_transfersEnabled",
                "type": "bool"
            }
        ],
        "func": "function enableTransfers(bool _transfersEnabled) public onlyOwner {\n    transfersEnabled = _transfersEnabled;\n  }",
        "comments": [
            "",
            "////////////////",
            "// Enable tokens transfers",
            "////////////////",
            "",
            "",
            "  /// @notice Enables token holders to transfer their tokens freely if true",
            "  /// @param _transfersEnabled True if transfers are allowed in the clone",
            "  "
        ],
        "comt": "\n////////////////\n// Enable tokens transfers\n////////////////\n\n\n  /// @notice Enables token holders to transfer their tokens freely if true\n  /// @param _transfersEnabled True if transfers are allowed in the clone\n  ",
        "@notice": "Enables token holders to transfer their tokens freely if true",
        "@param1": "_transfersEnabled True if transfers are allowed in the clone",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "claimTokens",
        "visibility": "public",
        "args": [
            {
                "name": "_token",
                "type": "address payable"
            }
        ],
        "func": "function claimTokens(address payable _token) public onlyOwner {\n    if (_token == address(0)) {\n      address(uint160(owner())).transfer(address(this).balance);\n      return;\n    }\n\n    MiniMeToken token = MiniMeToken(_token);\n    uint balance = token.balanceOf(address(this));\n    require(token.transfer(owner(), balance));\n    emit ClaimedTokens(_token, owner(), balance);\n  }",
        "comments": [
            "",
            "//////////",
            "// Safety Methods",
            "//////////",
            "",
            "  /// @notice This method can be used by the owner to extract mistakenly",
            "  ///  sent tokens to this contract.",
            "  /// @param _token The address of the token contract that you want to recover",
            "  ///  set to 0 in case you want to extract ether.",
            "  "
        ],
        "comt": "\n//////////\n// Safety Methods\n//////////\n\n  /// @notice This method can be used by the owner to extract mistakenly\n  ///  sent tokens to this contract.\n  /// @param _token The address of the token contract that you want to recover\n  ///  set to 0 in case you want to extract ether.\n  ",
        "@notice": "This method can be used by the owner to extract mistakenly /// sent tokens to this contract.",
        "@param1": "_token The address of the token contract that you want to recover /// set to 0 in case you want to extract ether.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createCloneToken",
        "visibility": "public",
        "args": [
            {
                "name": "_parentToken",
                "type": "address payable"
            },
            {
                "name": "_snapshotBlock",
                "type": "uint"
            },
            {
                "name": "_tokenName",
                "type": "string memory"
            },
            {
                "name": "_decimalUnits",
                "type": "uint8"
            },
            {
                "name": "_tokenSymbol",
                "type": "string memory"
            },
            {
                "name": "_transfersEnabled",
                "type": "bool"
            }
        ],
        "func": "function createCloneToken(\n    address payable _parentToken,\n    uint _snapshotBlock,\n    string memory _tokenName,\n    uint8 _decimalUnits,\n    string memory _tokenSymbol,\n    bool _transfersEnabled\n  ) public returns (MiniMeToken) {\n    MiniMeToken newToken = new MiniMeToken(\n      address(this),\n      _parentToken,\n      _snapshotBlock,\n      _tokenName,\n      _decimalUnits,\n      _tokenSymbol,\n      _transfersEnabled\n    );\n\n    newToken.transferOwnership(msg.sender);\n    emit CreatedToken(_tokenSymbol, address(newToken));\n    return newToken;\n  }",
        "comments": [
            "",
            "  /// @notice Update the DApp by creating a new token with new functionalities",
            "  ///  the msg.sender becomes the owner of this clone token",
            "  /// @param _parentToken Address of the token being cloned",
            "  /// @param _snapshotBlock Block of the parent token that will",
            "  ///  determine the initial distribution of the clone token",
            "  /// @param _tokenName Name of the new token",
            "  /// @param _decimalUnits Number of decimals of the new token",
            "  /// @param _tokenSymbol Token Symbol for the new token",
            "  /// @param _transfersEnabled If true, tokens will be able to be transferred",
            "  /// @return The address of the new token contract",
            "  "
        ],
        "comt": "\n  /// @notice Update the DApp by creating a new token with new functionalities\n  ///  the msg.sender becomes the owner of this clone token\n  /// @param _parentToken Address of the token being cloned\n  /// @param _snapshotBlock Block of the parent token that will\n  ///  determine the initial distribution of the clone token\n  /// @param _tokenName Name of the new token\n  /// @param _decimalUnits Number of decimals of the new token\n  /// @param _tokenSymbol Token Symbol for the new token\n  /// @param _transfersEnabled If true, tokens will be able to be transferred\n  /// @return The address of the new token contract\n  ",
        "@notice": "Update the DApp by creating a new token with new functionalities /// the msg.sender becomes the owner of this clone token",
        "@param1": "_parentToken Address of the token being cloned",
        "@param2": "_snapshotBlock Block of the parent token that will /// determine the initial distribution of the clone token",
        "@param3": "_tokenName Name of the new token",
        "@param4": "_decimalUnits Number of decimals of the new token",
        "@param5": "_tokenSymbol Token Symbol for the new token",
        "@param6": "_transfersEnabled If true, tokens will be able to be transferred",
        "@return1": "The address of the new token contract",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "initParams",
        "visibility": "external",
        "args": [
            {
                "name": "_devFundingAccount",
                "type": "address payable"
            },
            {
                "name": "_phaseLengths",
                "type": "uint256[2] calldata"
            },
            {
                "name": "_devFundingRate",
                "type": "uint256"
            },
            {
                "name": "_previousVersion",
                "type": "address payable"
            },
            {
                "name": "_usdcAddr",
                "type": "address"
            },
            {
                "name": "_kyberAddr",
                "type": "address payable"
            },
            {
                "name": "_compoundFactoryAddr",
                "type": "address"
            },
            {
                "name": "_peakdefiLogic",
                "type": "address"
            },
            {
                "name": "_peakdefiLogic2",
                "type": "address"
            },
            {
                "name": "_peakdefiLogic3",
                "type": "address"
            },
            {
                "name": "_startCycleNumber",
                "type": "uint256"
            },
            {
                "name": "_oneInchAddr",
                "type": "address payable"
            },
            {
                "name": "_peakRewardAddr",
                "type": "address"
            },
            {
                "name": "_peakStakingAddr",
                "type": "address"
            }
        ],
        "func": "function initParams(\n        address payable _devFundingAccount,\n        uint256[2] calldata _phaseLengths,\n        uint256 _devFundingRate,\n        address payable _previousVersion,\n        address _usdcAddr,\n        address payable _kyberAddr,\n        address _compoundFactoryAddr,\n        address _peakdefiLogic,\n        address _peakdefiLogic2,\n        address _peakdefiLogic3,\n        uint256 _startCycleNumber,\n        address payable _oneInchAddr,\n        address _peakRewardAddr,\n        address _peakStakingAddr\n    ) external {\n        require(proxyAddr == address(0));\n        devFundingAccount = _devFundingAccount;\n        phaseLengths = _phaseLengths;\n        devFundingRate = _devFundingRate;\n        cyclePhase = CyclePhase.Intermission;\n        compoundFactoryAddr = _compoundFactoryAddr;\n        peakdefiLogic = _peakdefiLogic;\n        peakdefiLogic2 = _peakdefiLogic2;\n        peakdefiLogic3 = _peakdefiLogic3;\n        previousVersion = _previousVersion;\n        cycleNumber = _startCycleNumber;\n\n        peakReward = PeakReward(_peakRewardAddr);\n        peakStaking = PeakStaking(_peakStakingAddr);\n\n        USDC_ADDR = _usdcAddr;\n        KYBER_ADDR = _kyberAddr;\n        ONEINCH_ADDR = _oneInchAddr;\n\n        usdc = ERC20Detailed(_usdcAddr);\n        kyber = KyberNetwork(_kyberAddr);\n\n        __initReentrancyGuard();\n    }",
        "comments": [
            "/**",
            "     * Meta functions",
            "     */",
            ""
        ],
        "comt": "/**\n     * Meta functions\n     */\n",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "initOwner",
        "visibility": "external",
        "args": [],
        "func": "function initOwner() external {\n        require(proxyAddr == address(0));\n        _transferOwnership(msg.sender);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "initInternalTokens",
        "visibility": "external",
        "args": [
            {
                "name": "_repAddr",
                "type": "address payable"
            },
            {
                "name": "_sTokenAddr",
                "type": "address payable"
            },
            {
                "name": "_peakReferralTokenAddr",
                "type": "address payable"
            }
        ],
        "func": "function initInternalTokens(\n        address payable _repAddr,\n        address payable _sTokenAddr,\n        address payable _peakReferralTokenAddr\n    ) external onlyOwner {\n        require(controlTokenAddr == address(0));\n        require(_repAddr != address(0));\n        controlTokenAddr = _repAddr;\n        shareTokenAddr = _sTokenAddr;\n        cToken = IMiniMeToken(_repAddr);\n        sToken = IMiniMeToken(_sTokenAddr);\n        peakReferralToken = IMiniMeToken(_peakReferralTokenAddr);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "initRegistration",
        "visibility": "external",
        "args": [
            {
                "name": "_newManagerRepToken",
                "type": "uint256"
            },
            {
                "name": "_maxNewManagersPerCycle",
                "type": "uint256"
            },
            {
                "name": "_reptokenPrice",
                "type": "uint256"
            },
            {
                "name": "_peakManagerStakeRequired",
                "type": "uint256"
            },
            {
                "name": "_isPermissioned",
                "type": "bool"
            }
        ],
        "func": "function initRegistration(\n        uint256 _newManagerRepToken,\n        uint256 _maxNewManagersPerCycle,\n        uint256 _reptokenPrice,\n        uint256 _peakManagerStakeRequired,\n        bool _isPermissioned\n    ) external onlyOwner {\n        require(_newManagerRepToken > 0 && newManagerRepToken == 0);\n        newManagerRepToken = _newManagerRepToken;\n        maxNewManagersPerCycle = _maxNewManagersPerCycle;\n        reptokenPrice = _reptokenPrice;\n        peakManagerStakeRequired = _peakManagerStakeRequired;\n        isPermissioned = _isPermissioned;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "initTokenListings",
        "visibility": "external",
        "args": [
            {
                "name": "_kyberTokens",
                "type": "address[] calldata"
            },
            {
                "name": "_compoundTokens",
                "type": "address[] calldata"
            }
        ],
        "func": "function initTokenListings(\n        address[] calldata _kyberTokens,\n        address[] calldata _compoundTokens\n    ) external onlyOwner {\n        // May only initialize once\n        require(!hasInitializedTokenListings);\n        hasInitializedTokenListings = true;\n\n        uint256 i;\n        for (i = 0; i < _kyberTokens.length; i++) {\n            isKyberToken[_kyberTokens[i]] = true;\n        }\n        CompoundOrderFactory factory = CompoundOrderFactory(compoundFactoryAddr);\n        for (i = 0; i < _compoundTokens.length; i++) {\n            require(factory.tokenIsListed(_compoundTokens[i]));\n            isCompoundToken[_compoundTokens[i]] = true;\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setProxy",
        "visibility": "external",
        "args": [
            {
                "name": "_proxyAddr",
                "type": "address payable"
            }
        ],
        "func": "function setProxy(address payable _proxyAddr) external onlyOwner {\n        require(_proxyAddr != address(0));\n        require(proxyAddr == address(0));\n        proxyAddr = _proxyAddr;\n        proxy = PeakDeFiProxyInterface(_proxyAddr);\n    }",
        "comments": [
            "/**",
            "     * @notice Used during deployment to set the PeakDeFiProxy contract address.",
            "     * @param _proxyAddr the proxy's address",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Used during deployment to set the PeakDeFiProxy contract address.\n     * @param _proxyAddr the proxy's address\n     */\n",
        "@notice": "Used during deployment to set the PeakDeFiProxy contract address.",
        "@param1": "_proxyAddr the proxy's address",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "developerInitiateUpgrade",
        "visibility": "public",
        "args": [
            {
                "name": "_candidate",
                "type": "address payable"
            }
        ],
        "func": "function developerInitiateUpgrade(address payable _candidate)\n        public\n        returns (bool _success)\n    {\n        (bool success, bytes memory result) = peakdefiLogic3.delegatecall(\n            abi.encodeWithSelector(\n                this.developerInitiateUpgrade.selector,\n                _candidate\n            )\n        );\n        if (!success) {\n            return false;\n        }\n        return abi.decode(result, (bool));\n    }",
        "comments": [
            "/**",
            "     * @notice Allows the developer to propose a candidate smart contract for the fund to upgrade to.",
            "     *          The developer may change the candidate during the Intermission phase.",
            "     * @param _candidate the address of the candidate smart contract",
            "     * @return True if successfully changed candidate, false otherwise.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Allows the developer to propose a candidate smart contract for the fund to upgrade to.\n     *          The developer may change the candidate during the Intermission phase.\n     * @param _candidate the address of the candidate smart contract\n     * @return True if successfully changed candidate, false otherwise.\n     */\n",
        "@notice": "Allows the developer to propose a candidate smart contract for the fund to upgrade to. * The developer may change the candidate during the Intermission phase.",
        "@param1": "_candidate the address of the candidate smart contract",
        "@return1": "True if successfully changed candidate, false otherwise.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "migrateOwnedContractsToNextVersion",
        "visibility": "public",
        "args": [],
        "func": "function migrateOwnedContractsToNextVersion()\n        public\n        nonReentrant\n        readyForUpgradeMigration\n    {\n        cToken.transferOwnership(nextVersion);\n        sToken.transferOwnership(nextVersion);\n        peakReferralToken.transferOwnership(nextVersion);\n        proxy.updatePeakDeFiFundAddress();\n    }",
        "comments": [
            "/**",
            "     * @notice Transfers ownership of RepToken & Share token contracts to the next version. Also updates PeakDeFiFund's",
            "     *         address in PeakDeFiProxy.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfers ownership of RepToken & Share token contracts to the next version. Also updates PeakDeFiFund's\n     *         address in PeakDeFiProxy.\n     */\n",
        "@notice": "Transfers ownership of RepToken & Share token contracts to the next version. Also updates PeakDeFiFund's * address in PeakDeFiProxy.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferAssetToNextVersion",
        "visibility": "public",
        "args": [
            {
                "name": "_assetAddress",
                "type": "address"
            }
        ],
        "func": "function transferAssetToNextVersion(address _assetAddress)\n        public\n        nonReentrant\n        readyForUpgradeMigration\n        isValidToken(_assetAddress)\n    {\n        if (_assetAddress == address(ETH_TOKEN_ADDRESS)) {\n            nextVersion.transfer(address(this).balance);\n        } else {\n            ERC20Detailed token = ERC20Detailed(_assetAddress);\n            token.safeTransfer(nextVersion, token.balanceOf(address(this)));\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Transfers assets to the next version.",
            "     * @param _assetAddress the address of the asset to be transferred. Use ETH_TOKEN_ADDRESS to transfer Ether.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Transfers assets to the next version.\n     * @param _assetAddress the address of the asset to be transferred. Use ETH_TOKEN_ADDRESS to transfer Ether.\n     */\n",
        "@notice": "Transfers assets to the next version.",
        "@param1": "_assetAddress the address of the asset to be transferred. Use ETH_TOKEN_ADDRESS to transfer Ether.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "investmentsCount",
        "visibility": "public",
        "args": [
            {
                "name": "_userAddr",
                "type": "address"
            }
        ],
        "func": "function investmentsCount(address _userAddr)\n        public\n        view\n        returns (uint256 _count)\n    {\n        return userInvestments[_userAddr].length;\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the length of the user's investments array.",
            "     * @return length of the user's investments array",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the length of the user's investments array.\n     * @return length of the user's investments array\n     */\n",
        "@notice": "Returns the length of the user's investments array.",
        "@return1": "length of the user's investments array",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "compoundOrdersCount",
        "visibility": "public",
        "args": [
            {
                "name": "_userAddr",
                "type": "address"
            }
        ],
        "func": "function compoundOrdersCount(address _userAddr)\n        public\n        view\n        returns (uint256 _count)\n    {\n        return userCompoundOrders[_userAddr].length;\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the length of the user's compound orders array.",
            "     * @return length of the user's compound orders array",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the length of the user's compound orders array.\n     * @return length of the user's compound orders array\n     */\n",
        "@notice": "Returns the length of the user's compound orders array.",
        "@return1": "length of the user's compound orders array",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPhaseLengths",
        "visibility": "public",
        "args": [],
        "func": "function getPhaseLengths()\n        public\n        view\n        returns (uint256[2] memory _phaseLengths)\n    {\n        return phaseLengths;\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the phaseLengths array.",
            "     * @return the phaseLengths array",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the phaseLengths array.\n     * @return the phaseLengths array\n     */\n",
        "@notice": "Returns the phaseLengths array.",
        "@return1": "the phaseLengths array",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "commissionBalanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "_manager",
                "type": "address"
            }
        ],
        "func": "function commissionBalanceOf(address _manager)\n        public\n        returns (uint256 _commission, uint256 _penalty)\n    {\n        (bool success, bytes memory result) = peakdefiLogic3.delegatecall(\n            abi.encodeWithSelector(this.commissionBalanceOf.selector, _manager)\n        );\n        if (!success) {\n            return (0, 0);\n        }\n        return abi.decode(result, (uint256, uint256));\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the commission balance of `_manager`",
            "     * @return the commission balance and the received penalty, denoted in USDC",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the commission balance of `_manager`\n     * @return the commission balance and the received penalty, denoted in USDC\n     */\n",
        "@notice": "Returns the commission balance of `_manager`",
        "@return1": "the commission balance and the received penalty, denoted in USDC",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "commissionOfAt",
        "visibility": "public",
        "args": [
            {
                "name": "_manager",
                "type": "address"
            },
            {
                "name": "_cycle",
                "type": "uint256"
            }
        ],
        "func": "function commissionOfAt(address _manager, uint256 _cycle)\n        public\n        returns (uint256 _commission, uint256 _penalty)\n    {\n        (bool success, bytes memory result) = peakdefiLogic3.delegatecall(\n            abi.encodeWithSelector(\n                this.commissionOfAt.selector,\n                _manager,\n                _cycle\n            )\n        );\n        if (!success) {\n            return (0, 0);\n        }\n        return abi.decode(result, (uint256, uint256));\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the commission amount received by `_manager` in the `_cycle`th cycle",
            "     * @return the commission amount and the received penalty, denoted in USDC",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the commission amount received by `_manager` in the `_cycle`th cycle\n     * @return the commission amount and the received penalty, denoted in USDC\n     */\n",
        "@notice": "Returns the commission amount received by `_manager` in the `_cycle`th cycle",
        "@return1": "the commission amount and the received penalty, denoted in USDC",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeDeveloperFeeAccount",
        "visibility": "public",
        "args": [
            {
                "name": "_newAddr",
                "type": "address payable"
            }
        ],
        "func": "function changeDeveloperFeeAccount(address payable _newAddr)\n        public\n        onlyOwner\n    {\n        require(_newAddr != address(0) && _newAddr != address(this));\n        devFundingAccount = _newAddr;\n    }",
        "comments": [
            "/**",
            "     * @notice Changes the address to which the developer fees will be sent. Only callable by owner.",
            "     * @param _newAddr the new developer fee address",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Changes the address to which the developer fees will be sent. Only callable by owner.\n     * @param _newAddr the new developer fee address\n     */\n",
        "@notice": "Changes the address to which the developer fees will be sent. Only callable by owner.",
        "@param1": "_newAddr the new developer fee address",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "changeDeveloperFeeRate",
        "visibility": "public",
        "args": [
            {
                "name": "_newProp",
                "type": "uint256"
            }
        ],
        "func": "function changeDeveloperFeeRate(uint256 _newProp) public onlyOwner {\n        require(_newProp < PRECISION);\n        require(_newProp < devFundingRate);\n        devFundingRate = _newProp;\n    }",
        "comments": [
            "/**",
            "     * @notice Changes the proportion of fund balance sent to the developers each cycle. May only decrease. Only callable by owner.",
            "     * @param _newProp the new proportion, fixed point decimal",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Changes the proportion of fund balance sent to the developers each cycle. May only decrease. Only callable by owner.\n     * @param _newProp the new proportion, fixed point decimal\n     */\n",
        "@notice": "Changes the proportion of fund balance sent to the developers each cycle. May only decrease. Only callable by owner.",
        "@param1": "_newProp the new proportion, fixed point decimal",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "listKyberToken",
        "visibility": "public",
        "args": [
            {
                "name": "_token",
                "type": "address"
            }
        ],
        "func": "function listKyberToken(address _token) public onlyOwner {\n        isKyberToken[_token] = true;\n    }",
        "comments": [
            "/**",
            "     * @notice Allows managers to invest in a token. Only callable by owner.",
            "     * @param _token address of the token to be listed",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Allows managers to invest in a token. Only callable by owner.\n     * @param _token address of the token to be listed\n     */\n",
        "@notice": "Allows managers to invest in a token. Only callable by owner.",
        "@param1": "_token address of the token to be listed",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "listCompoundToken",
        "visibility": "public",
        "args": [
            {
                "name": "_token",
                "type": "address"
            }
        ],
        "func": "function listCompoundToken(address _token) public onlyOwner {\n        CompoundOrderFactory factory = CompoundOrderFactory(\n            compoundFactoryAddr\n        );\n        require(factory.tokenIsListed(_token));\n        isCompoundToken[_token] = true;\n    }",
        "comments": [
            "/**",
            "     * @notice Allows managers to invest in a Compound token. Only callable by owner.",
            "     * @param _token address of the Compound token to be listed",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Allows managers to invest in a Compound token. Only callable by owner.\n     * @param _token address of the Compound token to be listed\n     */\n",
        "@notice": "Allows managers to invest in a Compound token. Only callable by owner.",
        "@param1": "_token address of the Compound token to be listed",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "nextPhase",
        "visibility": "public",
        "args": [],
        "func": "function nextPhase() public {\n        (bool success, ) = peakdefiLogic3.delegatecall(\n            abi.encodeWithSelector(this.nextPhase.selector)\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Moves the fund to the next phase in the investment cycle.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Moves the fund to the next phase in the investment cycle.\n     */\n",
        "@notice": "Moves the fund to the next phase in the investment cycle.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "registerWithUSDC",
        "visibility": "public",
        "args": [],
        "func": "function registerWithUSDC() public {\n        (bool success, ) = peakdefiLogic2.delegatecall(\n            abi.encodeWithSelector(this.registerWithUSDC.selector)\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Registers `msg.sender` as a manager, using USDC as payment. The more one pays, the more RepToken one gets.",
            "     *         There's a max RepToken amount that can be bought, and excess payment will be sent back to sender.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Registers `msg.sender` as a manager, using USDC as payment. The more one pays, the more RepToken one gets.\n     *         There's a max RepToken amount that can be bought, and excess payment will be sent back to sender.\n     */\n",
        "@notice": "Registers `msg.sender` as a manager, using USDC as payment. The more one pays, the more RepToken one gets. * There's a max RepToken amount that can be bought, and excess payment will be sent back to sender.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "registerWithETH",
        "visibility": "public",
        "args": [],
        "func": "function registerWithETH() public payable {\n        (bool success, ) = peakdefiLogic2.delegatecall(\n            abi.encodeWithSelector(this.registerWithETH.selector)\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Registers `msg.sender` as a manager, using ETH as payment. The more one pays, the more RepToken one gets.",
            "     *         There's a max RepToken amount that can be bought, and excess payment will be sent back to sender.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Registers `msg.sender` as a manager, using ETH as payment. The more one pays, the more RepToken one gets.\n     *         There's a max RepToken amount that can be bought, and excess payment will be sent back to sender.\n     */\n",
        "@notice": "Registers `msg.sender` as a manager, using ETH as payment. The more one pays, the more RepToken one gets. * There's a max RepToken amount that can be bought, and excess payment will be sent back to sender.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "registerWithToken",
        "visibility": "public",
        "args": [
            {
                "name": "_token",
                "type": "address"
            },
            {
                "name": "_donationInTokens",
                "type": "uint256"
            }
        ],
        "func": "function registerWithToken(address _token, uint256 _donationInTokens)\n        public\n    {\n        (bool success, ) = peakdefiLogic2.delegatecall(\n            abi.encodeWithSelector(\n                this.registerWithToken.selector,\n                _token,\n                _donationInTokens\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Registers `msg.sender` as a manager, using tokens as payment. The more one pays, the more RepToken one gets.",
            "     *         There's a max RepToken amount that can be bought, and excess payment will be sent back to sender.",
            "     * @param _token the token to be used for payment",
            "     * @param _donationInTokens the amount of tokens to be used for registration, should use the token's native decimals",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Registers `msg.sender` as a manager, using tokens as payment. The more one pays, the more RepToken one gets.\n     *         There's a max RepToken amount that can be bought, and excess payment will be sent back to sender.\n     * @param _token the token to be used for payment\n     * @param _donationInTokens the amount of tokens to be used for registration, should use the token's native decimals\n     */\n",
        "@notice": "Registers `msg.sender` as a manager, using tokens as payment. The more one pays, the more RepToken one gets. * There's a max RepToken amount that can be bought, and excess payment will be sent back to sender.",
        "@param1": "_token the token to be used for payment",
        "@param2": "_donationInTokens the amount of tokens to be used for registration, should use the token's native decimals",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "depositEther",
        "visibility": "public",
        "args": [
            {
                "name": "_referrer",
                "type": "address"
            }
        ],
        "func": "function depositEther(address _referrer) public payable {\n        (bool success, ) = peakdefiLogic2.delegatecall(\n            abi.encodeWithSelector(this.depositEther.selector, _referrer)\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Deposit Ether into the fund. Ether will be converted into USDC.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Deposit Ether into the fund. Ether will be converted into USDC.\n     */\n",
        "@notice": "Deposit Ether into the fund. Ether will be converted into USDC.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "depositEtherAdvanced",
        "visibility": "external",
        "args": [
            {
                "name": "_useKyber",
                "type": "bool"
            },
            {
                "name": "_calldata",
                "type": "bytes calldata"
            },
            {
                "name": "_referrer",
                "type": "address"
            }
        ],
        "func": "function depositEtherAdvanced(\n        bool _useKyber,\n        bytes calldata _calldata,\n        address _referrer\n    ) external payable {\n        (bool success, ) = peakdefiLogic2.delegatecall(\n            abi.encodeWithSelector(\n                this.depositEtherAdvanced.selector,\n                _useKyber,\n                _calldata,\n                _referrer\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "depositUSDC",
        "visibility": "public",
        "args": [
            {
                "name": "_usdcAmount",
                "type": "uint256"
            },
            {
                "name": "_referrer",
                "type": "address"
            }
        ],
        "func": "function depositUSDC(uint256 _usdcAmount, address _referrer) public {\n        (bool success, ) = peakdefiLogic2.delegatecall(\n            abi.encodeWithSelector(\n                this.depositUSDC.selector,\n                _usdcAmount,\n                _referrer\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Deposit USDC Stablecoin into the fund.",
            "     * @param _usdcAmount The amount of USDC to be deposited. May be different from actual deposited amount.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Deposit USDC Stablecoin into the fund.\n     * @param _usdcAmount The amount of USDC to be deposited. May be different from actual deposited amount.\n     */\n",
        "@notice": "Deposit USDC Stablecoin into the fund.",
        "@param1": "_usdcAmount The amount of USDC to be deposited. May be different from actual deposited amount.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "depositToken",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_tokenAmount",
                "type": "uint256"
            },
            {
                "name": "_referrer",
                "type": "address"
            }
        ],
        "func": "function depositToken(\n        address _tokenAddr,\n        uint256 _tokenAmount,\n        address _referrer\n    ) public {\n        (bool success, ) = peakdefiLogic2.delegatecall(\n            abi.encodeWithSelector(\n                this.depositToken.selector,\n                _tokenAddr,\n                _tokenAmount,\n                _referrer\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Deposit ERC20 tokens into the fund. Tokens will be converted into USDC.",
            "     * @param _tokenAddr the address of the token to be deposited",
            "     * @param _tokenAmount The amount of tokens to be deposited. May be different from actual deposited amount.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Deposit ERC20 tokens into the fund. Tokens will be converted into USDC.\n     * @param _tokenAddr the address of the token to be deposited\n     * @param _tokenAmount The amount of tokens to be deposited. May be different from actual deposited amount.\n     */\n",
        "@notice": "Deposit ERC20 tokens into the fund. Tokens will be converted into USDC.",
        "@param1": "_tokenAddr the address of the token to be deposited",
        "@param2": "_tokenAmount The amount of tokens to be deposited. May be different from actual deposited amount.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "depositTokenAdvanced",
        "visibility": "external",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_tokenAmount",
                "type": "uint256"
            },
            {
                "name": "_useKyber",
                "type": "bool"
            },
            {
                "name": "_calldata",
                "type": "bytes calldata"
            },
            {
                "name": "_referrer",
                "type": "address"
            }
        ],
        "func": "function depositTokenAdvanced(\n        address _tokenAddr,\n        uint256 _tokenAmount,\n        bool _useKyber,\n        bytes calldata _calldata,\n        address _referrer\n    ) external {\n        (bool success, ) = peakdefiLogic2.delegatecall(\n            abi.encodeWithSelector(\n                this.depositTokenAdvanced.selector,\n                _tokenAddr,\n                _tokenAmount,\n                _useKyber,\n                _calldata,\n                _referrer\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawEther",
        "visibility": "external",
        "args": [
            {
                "name": "_amountInUSDC",
                "type": "uint256"
            }
        ],
        "func": "function withdrawEther(uint256 _amountInUSDC) external {\n        (bool success, ) = peakdefiLogic2.delegatecall(\n            abi.encodeWithSelector(this.withdrawEther.selector, _amountInUSDC)\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Withdraws Ether by burning Shares.",
            "     * @param _amountInUSDC Amount of funds to be withdrawn expressed in USDC. Fixed-point decimal. May be different from actual amount.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Withdraws Ether by burning Shares.\n     * @param _amountInUSDC Amount of funds to be withdrawn expressed in USDC. Fixed-point decimal. May be different from actual amount.\n     */\n",
        "@notice": "Withdraws Ether by burning Shares.",
        "@param1": "_amountInUSDC Amount of funds to be withdrawn expressed in USDC. Fixed-point decimal. May be different from actual amount.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawEtherAdvanced",
        "visibility": "external",
        "args": [
            {
                "name": "_amountInUSDC",
                "type": "uint256"
            },
            {
                "name": "_useKyber",
                "type": "bool"
            },
            {
                "name": "_calldata",
                "type": "bytes calldata"
            }
        ],
        "func": "function withdrawEtherAdvanced(\n        uint256 _amountInUSDC,\n        bool _useKyber,\n        bytes calldata _calldata\n    ) external {\n        (bool success, ) = peakdefiLogic2.delegatecall(\n            abi.encodeWithSelector(\n                this.withdrawEtherAdvanced.selector,\n                _amountInUSDC,\n                _useKyber,\n                _calldata\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawUSDC",
        "visibility": "public",
        "args": [
            {
                "name": "_amountInUSDC",
                "type": "uint256"
            }
        ],
        "func": "function withdrawUSDC(uint256 _amountInUSDC) public {\n        (bool success, ) = peakdefiLogic2.delegatecall(\n            abi.encodeWithSelector(this.withdrawUSDC.selector, _amountInUSDC)\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Withdraws Ether by burning Shares.",
            "     * @param _amountInUSDC Amount of funds to be withdrawn expressed in USDC. Fixed-point decimal. May be different from actual amount.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Withdraws Ether by burning Shares.\n     * @param _amountInUSDC Amount of funds to be withdrawn expressed in USDC. Fixed-point decimal. May be different from actual amount.\n     */\n",
        "@notice": "Withdraws Ether by burning Shares.",
        "@param1": "_amountInUSDC Amount of funds to be withdrawn expressed in USDC. Fixed-point decimal. May be different from actual amount.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawToken",
        "visibility": "external",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_amountInUSDC",
                "type": "uint256"
            }
        ],
        "func": "function withdrawToken(address _tokenAddr, uint256 _amountInUSDC) external {\n        (bool success, ) = peakdefiLogic2.delegatecall(\n            abi.encodeWithSelector(\n                this.withdrawToken.selector,\n                _tokenAddr,\n                _amountInUSDC\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Withdraws funds by burning Shares, and converts the funds into the specified token using Kyber Network.",
            "     * @param _tokenAddr the address of the token to be withdrawn into the caller's account",
            "     * @param _amountInUSDC The amount of funds to be withdrawn expressed in USDC. Fixed-point decimal. May be different from actual amount.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Withdraws funds by burning Shares, and converts the funds into the specified token using Kyber Network.\n     * @param _tokenAddr the address of the token to be withdrawn into the caller's account\n     * @param _amountInUSDC The amount of funds to be withdrawn expressed in USDC. Fixed-point decimal. May be different from actual amount.\n     */\n",
        "@notice": "Withdraws funds by burning Shares, and converts the funds into the specified token using Kyber Network.",
        "@param1": "_tokenAddr the address of the token to be withdrawn into the caller's account",
        "@param2": "_amountInUSDC The amount of funds to be withdrawn expressed in USDC. Fixed-point decimal. May be different from actual amount.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawTokenAdvanced",
        "visibility": "external",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_amountInUSDC",
                "type": "uint256"
            },
            {
                "name": "_useKyber",
                "type": "bool"
            },
            {
                "name": "_calldata",
                "type": "bytes calldata"
            }
        ],
        "func": "function withdrawTokenAdvanced(\n        address _tokenAddr,\n        uint256 _amountInUSDC,\n        bool _useKyber,\n        bytes calldata _calldata\n    ) external {\n        (bool success, ) = peakdefiLogic2.delegatecall(\n            abi.encodeWithSelector(\n                this.withdrawTokenAdvanced.selector,\n                _tokenAddr,\n                _amountInUSDC,\n                _useKyber,\n                _calldata\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "redeemCommission",
        "visibility": "public",
        "args": [
            {
                "name": "_inShares",
                "type": "bool"
            }
        ],
        "func": "function redeemCommission(bool _inShares) public {\n        (bool success, ) = peakdefiLogic3.delegatecall(\n            abi.encodeWithSelector(this.redeemCommission.selector, _inShares)\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Redeems commission.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Redeems commission.\n     */\n",
        "@notice": "Redeems commission.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "redeemCommissionForCycle",
        "visibility": "public",
        "args": [
            {
                "name": "_inShares",
                "type": "bool"
            },
            {
                "name": "_cycle",
                "type": "uint256"
            }
        ],
        "func": "function redeemCommissionForCycle(bool _inShares, uint256 _cycle) public {\n        (bool success, ) = peakdefiLogic3.delegatecall(\n            abi.encodeWithSelector(\n                this.redeemCommissionForCycle.selector,\n                _inShares,\n                _cycle\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Redeems commission for a particular cycle.",
            "     * @param _inShares true to redeem in PeakDeFi Shares, false to redeem in USDC",
            "     * @param _cycle the cycle for which the commission will be redeemed.",
            "     *        Commissions for a cycle will be redeemed during the Intermission phase of the next cycle, so _cycle must < cycleNumber.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Redeems commission for a particular cycle.\n     * @param _inShares true to redeem in PeakDeFi Shares, false to redeem in USDC\n     * @param _cycle the cycle for which the commission will be redeemed.\n     *        Commissions for a cycle will be redeemed during the Intermission phase of the next cycle, so _cycle must < cycleNumber.\n     */\n",
        "@notice": "Redeems commission for a particular cycle.",
        "@param1": "_inShares true to redeem in PeakDeFi Shares, false to redeem in USDC",
        "@param2": "_cycle the cycle for which the commission will be redeemed. * Commissions for a cycle will be redeemed during the Intermission phase of the next cycle, so _cycle must < cycleNumber.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sellLeftoverToken",
        "visibility": "external",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_calldata",
                "type": "bytes calldata"
            }
        ],
        "func": "function sellLeftoverToken(address _tokenAddr, bytes calldata _calldata)\n        external\n    {\n        (bool success, ) = peakdefiLogic2.delegatecall(\n            abi.encodeWithSelector(\n                this.sellLeftoverToken.selector,\n                _tokenAddr,\n                _calldata\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Sells tokens left over due to manager not selling or KyberNetwork not having enough volume. Callable by anyone. Money goes to developer.",
            "     * @param _tokenAddr address of the token to be sold",
            "     * @param _calldata the 1inch trade call data",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sells tokens left over due to manager not selling or KyberNetwork not having enough volume. Callable by anyone. Money goes to developer.\n     * @param _tokenAddr address of the token to be sold\n     * @param _calldata the 1inch trade call data\n     */\n",
        "@notice": "Sells tokens left over due to manager not selling or KyberNetwork not having enough volume. Callable by anyone. Money goes to developer.",
        "@param1": "_tokenAddr address of the token to be sold",
        "@param2": "_calldata the 1inch trade call data",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sellLeftoverCompoundOrder",
        "visibility": "public",
        "args": [
            {
                "name": "_orderAddress",
                "type": "address payable"
            }
        ],
        "func": "function sellLeftoverCompoundOrder(address payable _orderAddress) public {\n        (bool success, ) = peakdefiLogic2.delegatecall(\n            abi.encodeWithSelector(\n                this.sellLeftoverCompoundOrder.selector,\n                _orderAddress\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Sells CompoundOrder left over due to manager not selling or KyberNetwork not having enough volume. Callable by anyone. Money goes to developer.",
            "     * @param _orderAddress address of the CompoundOrder to be sold",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sells CompoundOrder left over due to manager not selling or KyberNetwork not having enough volume. Callable by anyone. Money goes to developer.\n     * @param _orderAddress address of the CompoundOrder to be sold\n     */\n",
        "@notice": "Sells CompoundOrder left over due to manager not selling or KyberNetwork not having enough volume. Callable by anyone. Money goes to developer.",
        "@param1": "_orderAddress address of the CompoundOrder to be sold",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burnDeadman",
        "visibility": "public",
        "args": [
            {
                "name": "_deadman",
                "type": "address"
            }
        ],
        "func": "function burnDeadman(address _deadman) public {\n        (bool success, ) = peakdefiLogic.delegatecall(\n            abi.encodeWithSelector(this.burnDeadman.selector, _deadman)\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Burns the RepToken balance of a manager who has been inactive for a certain number of cycles",
            "     * @param _deadman the manager whose RepToken balance will be burned",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Burns the RepToken balance of a manager who has been inactive for a certain number of cycles\n     * @param _deadman the manager whose RepToken balance will be burned\n     */\n",
        "@notice": "Burns the RepToken balance of a manager who has been inactive for a certain number of cycles",
        "@param1": "_deadman the manager whose RepToken balance will be burned",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createInvestmentWithSignature",
        "visibility": "external",
        "args": [
            {
                "name": "_tokenAddress",
                "type": "address"
            },
            {
                "name": "_stake",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            },
            {
                "name": "_calldata",
                "type": "bytes calldata"
            },
            {
                "name": "_useKyber",
                "type": "bool"
            },
            {
                "name": "_manager",
                "type": "address"
            },
            {
                "name": "_salt",
                "type": "uint256"
            },
            {
                "name": "_signature",
                "type": "bytes calldata"
            }
        ],
        "func": "function createInvestmentWithSignature(\n        address _tokenAddress,\n        uint256 _stake,\n        uint256 _maxPrice,\n        bytes calldata _calldata,\n        bool _useKyber,\n        address _manager,\n        uint256 _salt,\n        bytes calldata _signature\n    ) external {\n        (bool success, ) = peakdefiLogic.delegatecall(\n            abi.encodeWithSelector(\n                this.createInvestmentWithSignature.selector,\n                _tokenAddress,\n                _stake,\n                _maxPrice,\n                _calldata,\n                _useKyber,\n                _manager,\n                _salt,\n                _signature\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * Manage phase functions",
            "     */",
            ""
        ],
        "comt": "/**\n     * Manage phase functions\n     */\n",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sellInvestmentWithSignature",
        "visibility": "external",
        "args": [
            {
                "name": "_investmentId",
                "type": "uint256"
            },
            {
                "name": "_tokenAmount",
                "type": "uint256"
            },
            {
                "name": "_minPrice",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            },
            {
                "name": "_calldata",
                "type": "bytes calldata"
            },
            {
                "name": "_useKyber",
                "type": "bool"
            },
            {
                "name": "_manager",
                "type": "address"
            },
            {
                "name": "_salt",
                "type": "uint256"
            },
            {
                "name": "_signature",
                "type": "bytes calldata"
            }
        ],
        "func": "function sellInvestmentWithSignature(\n        uint256 _investmentId,\n        uint256 _tokenAmount,\n        uint256 _minPrice,\n        uint256 _maxPrice,\n        bytes calldata _calldata,\n        bool _useKyber,\n        address _manager,\n        uint256 _salt,\n        bytes calldata _signature\n    ) external {\n        (bool success, ) = peakdefiLogic.delegatecall(\n            abi.encodeWithSelector(\n                this.sellInvestmentWithSignature.selector,\n                _investmentId,\n                _tokenAmount,\n                _minPrice,\n                _maxPrice,\n                _calldata,\n                _useKyber,\n                _manager,\n                _salt,\n                _signature\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createCompoundOrderWithSignature",
        "visibility": "external",
        "args": [
            {
                "name": "_orderType",
                "type": "bool"
            },
            {
                "name": "_tokenAddress",
                "type": "address"
            },
            {
                "name": "_stake",
                "type": "uint256"
            },
            {
                "name": "_minPrice",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            },
            {
                "name": "_manager",
                "type": "address"
            },
            {
                "name": "_salt",
                "type": "uint256"
            },
            {
                "name": "_signature",
                "type": "bytes calldata"
            }
        ],
        "func": "function createCompoundOrderWithSignature(\n        bool _orderType,\n        address _tokenAddress,\n        uint256 _stake,\n        uint256 _minPrice,\n        uint256 _maxPrice,\n        address _manager,\n        uint256 _salt,\n        bytes calldata _signature\n    ) external {\n        (bool success, ) = peakdefiLogic.delegatecall(\n            abi.encodeWithSelector(\n                this.createCompoundOrderWithSignature.selector,\n                _orderType,\n                _tokenAddress,\n                _stake,\n                _minPrice,\n                _maxPrice,\n                _manager,\n                _salt,\n                _signature\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sellCompoundOrderWithSignature",
        "visibility": "external",
        "args": [
            {
                "name": "_orderId",
                "type": "uint256"
            },
            {
                "name": "_minPrice",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            },
            {
                "name": "_manager",
                "type": "address"
            },
            {
                "name": "_salt",
                "type": "uint256"
            },
            {
                "name": "_signature",
                "type": "bytes calldata"
            }
        ],
        "func": "function sellCompoundOrderWithSignature(\n        uint256 _orderId,\n        uint256 _minPrice,\n        uint256 _maxPrice,\n        address _manager,\n        uint256 _salt,\n        bytes calldata _signature\n    ) external {\n        (bool success, ) = peakdefiLogic.delegatecall(\n            abi.encodeWithSelector(\n                this.sellCompoundOrderWithSignature.selector,\n                _orderId,\n                _minPrice,\n                _maxPrice,\n                _manager,\n                _salt,\n                _signature\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repayCompoundOrderWithSignature",
        "visibility": "external",
        "args": [
            {
                "name": "_orderId",
                "type": "uint256"
            },
            {
                "name": "_repayAmountInUSDC",
                "type": "uint256"
            },
            {
                "name": "_manager",
                "type": "address"
            },
            {
                "name": "_salt",
                "type": "uint256"
            },
            {
                "name": "_signature",
                "type": "bytes calldata"
            }
        ],
        "func": "function repayCompoundOrderWithSignature(\n        uint256 _orderId,\n        uint256 _repayAmountInUSDC,\n        address _manager,\n        uint256 _salt,\n        bytes calldata _signature\n    ) external {\n        (bool success, ) = peakdefiLogic.delegatecall(\n            abi.encodeWithSelector(\n                this.repayCompoundOrderWithSignature.selector,\n                _orderId,\n                _repayAmountInUSDC,\n                _manager,\n                _salt,\n                _signature\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createInvestment",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddress",
                "type": "address"
            },
            {
                "name": "_stake",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            }
        ],
        "func": "function createInvestment(\n        address _tokenAddress,\n        uint256 _stake,\n        uint256 _maxPrice\n    ) public {\n        (bool success, ) = peakdefiLogic.delegatecall(\n            abi.encodeWithSelector(\n                this.createInvestment.selector,\n                _tokenAddress,\n                _stake,\n                _maxPrice\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Creates a new investment for an ERC20 token.",
            "     * @param _tokenAddress address of the ERC20 token contract",
            "     * @param _stake amount of RepTokens to be staked in support of the investment",
            "     * @param _maxPrice the maximum price for the trade",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Creates a new investment for an ERC20 token.\n     * @param _tokenAddress address of the ERC20 token contract\n     * @param _stake amount of RepTokens to be staked in support of the investment\n     * @param _maxPrice the maximum price for the trade\n     */\n",
        "@notice": "Creates a new investment for an ERC20 token.",
        "@param1": "_tokenAddress address of the ERC20 token contract",
        "@param2": "_stake amount of RepTokens to be staked in support of the investment",
        "@param3": "_maxPrice the maximum price for the trade",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createInvestmentV2",
        "visibility": "public",
        "args": [
            {
                "name": "_sender",
                "type": "address"
            },
            {
                "name": "_tokenAddress",
                "type": "address"
            },
            {
                "name": "_stake",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            },
            {
                "name": "_calldata",
                "type": "bytes memory"
            },
            {
                "name": "_useKyber",
                "type": "bool"
            }
        ],
        "func": "function createInvestmentV2(\n        address _sender,\n        address _tokenAddress,\n        uint256 _stake,\n        uint256 _maxPrice,\n        bytes memory _calldata,\n        bool _useKyber\n    ) public {\n        (bool success, ) = peakdefiLogic.delegatecall(\n            abi.encodeWithSelector(\n                this.createInvestmentV2.selector,\n                _sender,\n                _tokenAddress,\n                _stake,\n                _maxPrice,\n                _calldata,\n                _useKyber\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Creates a new investment for an ERC20 token.",
            "     * @param _tokenAddress address of the ERC20 token contract",
            "     * @param _stake amount of RepTokens to be staked in support of the investment",
            "     * @param _maxPrice the maximum price for the trade",
            "     * @param _calldata calldata for 1inch trading",
            "     * @param _useKyber true for Kyber Network, false for 1inch",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Creates a new investment for an ERC20 token.\n     * @param _tokenAddress address of the ERC20 token contract\n     * @param _stake amount of RepTokens to be staked in support of the investment\n     * @param _maxPrice the maximum price for the trade\n     * @param _calldata calldata for 1inch trading\n     * @param _useKyber true for Kyber Network, false for 1inch\n     */\n",
        "@notice": "Creates a new investment for an ERC20 token.",
        "@param1": "_tokenAddress address of the ERC20 token contract",
        "@param2": "_stake amount of RepTokens to be staked in support of the investment",
        "@param3": "_maxPrice the maximum price for the trade",
        "@param4": "_calldata calldata for 1inch trading",
        "@param5": "_useKyber true for Kyber Network, false for 1inch",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sellInvestmentAsset",
        "visibility": "public",
        "args": [
            {
                "name": "_investmentId",
                "type": "uint256"
            },
            {
                "name": "_tokenAmount",
                "type": "uint256"
            },
            {
                "name": "_minPrice",
                "type": "uint256"
            }
        ],
        "func": "function sellInvestmentAsset(\n        uint256 _investmentId,\n        uint256 _tokenAmount,\n        uint256 _minPrice\n    ) public {\n        (bool success, ) = peakdefiLogic.delegatecall(\n            abi.encodeWithSelector(\n                this.sellInvestmentAsset.selector,\n                _investmentId,\n                _tokenAmount,\n                _minPrice\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Called by user to sell the assets an investment invested in. Returns the staked RepToken plus rewards/penalties to the user.",
            "     *         The user can sell only part of the investment by changing _tokenAmount.",
            "     * @dev When selling only part of an investment, the old investment would be \"fully\" sold and a new investment would be created with",
            "     *   the original buy price and however much tokens that are not sold.",
            "     * @param _investmentId the ID of the investment",
            "     * @param _tokenAmount the amount of tokens to be sold.",
            "     * @param _minPrice the minimum price for the trade",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Called by user to sell the assets an investment invested in. Returns the staked RepToken plus rewards/penalties to the user.\n     *         The user can sell only part of the investment by changing _tokenAmount.\n     * @dev When selling only part of an investment, the old investment would be \"fully\" sold and a new investment would be created with\n     *   the original buy price and however much tokens that are not sold.\n     * @param _investmentId the ID of the investment\n     * @param _tokenAmount the amount of tokens to be sold.\n     * @param _minPrice the minimum price for the trade\n     */\n",
        "@notice": "Called by user to sell the assets an investment invested in. Returns the staked RepToken plus rewards/penalties to the user. * The user can sell only part of the investment by changing _tokenAmount.",
        "@dev": "When selling only part of an investment, the old investment would be \"fully\" sold and a new investment would be created with * the original buy price and however much tokens that are not sold.",
        "@param1": "_investmentId the ID of the investment",
        "@param2": "_tokenAmount the amount of tokens to be sold.",
        "@param3": "_minPrice the minimum price for the trade",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sellInvestmentAssetV2",
        "visibility": "public",
        "args": [
            {
                "name": "_sender",
                "type": "address"
            },
            {
                "name": "_investmentId",
                "type": "uint256"
            },
            {
                "name": "_tokenAmount",
                "type": "uint256"
            },
            {
                "name": "_minPrice",
                "type": "uint256"
            },
            {
                "name": "_calldata",
                "type": "bytes memory"
            },
            {
                "name": "_useKyber",
                "type": "bool"
            }
        ],
        "func": "function sellInvestmentAssetV2(\n        address _sender,\n        uint256 _investmentId,\n        uint256 _tokenAmount,\n        uint256 _minPrice,\n        bytes memory _calldata,\n        bool _useKyber\n    ) public {\n        (bool success, ) = peakdefiLogic.delegatecall(\n            abi.encodeWithSelector(\n                this.sellInvestmentAssetV2.selector,\n                _sender,\n                _investmentId,\n                _tokenAmount,\n                _minPrice,\n                _calldata,\n                _useKyber\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Called by user to sell the assets an investment invested in. Returns the staked RepToken plus rewards/penalties to the user.",
            "     *         The user can sell only part of the investment by changing _tokenAmount.",
            "     * @dev When selling only part of an investment, the old investment would be \"fully\" sold and a new investment would be created with",
            "     *   the original buy price and however much tokens that are not sold.",
            "     * @param _investmentId the ID of the investment",
            "     * @param _tokenAmount the amount of tokens to be sold.",
            "     * @param _minPrice the minimum price for the trade",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Called by user to sell the assets an investment invested in. Returns the staked RepToken plus rewards/penalties to the user.\n     *         The user can sell only part of the investment by changing _tokenAmount.\n     * @dev When selling only part of an investment, the old investment would be \"fully\" sold and a new investment would be created with\n     *   the original buy price and however much tokens that are not sold.\n     * @param _investmentId the ID of the investment\n     * @param _tokenAmount the amount of tokens to be sold.\n     * @param _minPrice the minimum price for the trade\n     */\n",
        "@notice": "Called by user to sell the assets an investment invested in. Returns the staked RepToken plus rewards/penalties to the user. * The user can sell only part of the investment by changing _tokenAmount.",
        "@dev": "When selling only part of an investment, the old investment would be \"fully\" sold and a new investment would be created with * the original buy price and however much tokens that are not sold.",
        "@param1": "_investmentId the ID of the investment",
        "@param2": "_tokenAmount the amount of tokens to be sold.",
        "@param3": "_minPrice the minimum price for the trade",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createCompoundOrder",
        "visibility": "public",
        "args": [
            {
                "name": "_sender",
                "type": "address"
            },
            {
                "name": "_orderType",
                "type": "bool"
            },
            {
                "name": "_tokenAddress",
                "type": "address"
            },
            {
                "name": "_stake",
                "type": "uint256"
            },
            {
                "name": "_minPrice",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            }
        ],
        "func": "function createCompoundOrder(\n        address _sender,\n        bool _orderType,\n        address _tokenAddress,\n        uint256 _stake,\n        uint256 _minPrice,\n        uint256 _maxPrice\n    ) public {\n        (bool success, ) = peakdefiLogic.delegatecall(\n            abi.encodeWithSelector(\n                this.createCompoundOrder.selector,\n                _sender,\n                _orderType,\n                _tokenAddress,\n                _stake,\n                _minPrice,\n                _maxPrice\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Creates a new Compound order to either short or leverage long a token.",
            "     * @param _orderType true for a short order, false for a levarage long order",
            "     * @param _tokenAddress address of the Compound token to be traded",
            "     * @param _stake amount of RepTokens to be staked",
            "     * @param _minPrice the minimum token price for the trade",
            "     * @param _maxPrice the maximum token price for the trade",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Creates a new Compound order to either short or leverage long a token.\n     * @param _orderType true for a short order, false for a levarage long order\n     * @param _tokenAddress address of the Compound token to be traded\n     * @param _stake amount of RepTokens to be staked\n     * @param _minPrice the minimum token price for the trade\n     * @param _maxPrice the maximum token price for the trade\n     */\n",
        "@notice": "Creates a new Compound order to either short or leverage long a token.",
        "@param1": "_orderType true for a short order, false for a levarage long order",
        "@param2": "_tokenAddress address of the Compound token to be traded",
        "@param3": "_stake amount of RepTokens to be staked",
        "@param4": "_minPrice the minimum token price for the trade",
        "@param5": "_maxPrice the maximum token price for the trade",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sellCompoundOrder",
        "visibility": "public",
        "args": [
            {
                "name": "_sender",
                "type": "address"
            },
            {
                "name": "_orderId",
                "type": "uint256"
            },
            {
                "name": "_minPrice",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            }
        ],
        "func": "function sellCompoundOrder(\n        address _sender,\n        uint256 _orderId,\n        uint256 _minPrice,\n        uint256 _maxPrice\n    ) public {\n        (bool success, ) = peakdefiLogic.delegatecall(\n            abi.encodeWithSelector(\n                this.sellCompoundOrder.selector,\n                _sender,\n                _orderId,\n                _minPrice,\n                _maxPrice\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Sells a compound order",
            "     * @param _orderId the ID of the order to be sold (index in userCompoundOrders[msg.sender])",
            "     * @param _minPrice the minimum token price for the trade",
            "     * @param _maxPrice the maximum token price for the trade",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sells a compound order\n     * @param _orderId the ID of the order to be sold (index in userCompoundOrders[msg.sender])\n     * @param _minPrice the minimum token price for the trade\n     * @param _maxPrice the maximum token price for the trade\n     */\n",
        "@notice": "Sells a compound order",
        "@param1": "_orderId the ID of the order to be sold (index in userCompoundOrders[msg.sender])",
        "@param2": "_minPrice the minimum token price for the trade",
        "@param3": "_maxPrice the maximum token price for the trade",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repayCompoundOrder",
        "visibility": "public",
        "args": [
            {
                "name": "_sender",
                "type": "address"
            },
            {
                "name": "_orderId",
                "type": "uint256"
            },
            {
                "name": "_repayAmountInUSDC",
                "type": "uint256"
            }
        ],
        "func": "function repayCompoundOrder(\n        address _sender,\n        uint256 _orderId,\n        uint256 _repayAmountInUSDC\n    ) public {\n        (bool success, ) = peakdefiLogic.delegatecall(\n            abi.encodeWithSelector(\n                this.repayCompoundOrder.selector,\n                _sender,\n                _orderId,\n                _repayAmountInUSDC\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Repys debt for a Compound order to prevent the collateral ratio from dropping below threshold.",
            "     * @param _orderId the ID of the Compound order",
            "     * @param _repayAmountInUSDC amount of USDC to use for repaying debt",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Repys debt for a Compound order to prevent the collateral ratio from dropping below threshold.\n     * @param _orderId the ID of the Compound order\n     * @param _repayAmountInUSDC amount of USDC to use for repaying debt\n     */\n",
        "@notice": "Repys debt for a Compound order to prevent the collateral ratio from dropping below threshold.",
        "@param1": "_orderId the ID of the Compound order",
        "@param2": "_repayAmountInUSDC amount of USDC to use for repaying debt",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "emergencyExitCompoundTokens",
        "visibility": "public",
        "args": [
            {
                "name": "_sender",
                "type": "address"
            },
            {
                "name": "_orderId",
                "type": "uint256"
            },
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_receiver",
                "type": "address"
            }
        ],
        "func": "function emergencyExitCompoundTokens(\n        address _sender,\n        uint256 _orderId,\n        address _tokenAddr,\n        address _receiver\n    ) public onlyOwner {\n        (bool success, ) = peakdefiLogic.delegatecall(\n            abi.encodeWithSelector(\n                this.emergencyExitCompoundTokens.selector,\n                _sender,\n                _orderId,\n                _tokenAddr,\n                _receiver\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Emergency exit the tokens from order contract during intermission stage",
            "     * @param _sender the address of trader, who created the order",
            "     * @param _orderId the ID of the Compound order",
            "     * @param _tokenAddr the address of token which should be transferred",
            "     * @param _receiver the address of receiver",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Emergency exit the tokens from order contract during intermission stage\n     * @param _sender the address of trader, who created the order\n     * @param _orderId the ID of the Compound order\n     * @param _tokenAddr the address of token which should be transferred\n     * @param _receiver the address of receiver\n     */\n",
        "@notice": "Emergency exit the tokens from order contract during intermission stage",
        "@param1": "_sender the address of trader, who created the order",
        "@param2": "_orderId the ID of the Compound order",
        "@param3": "_tokenAddr the address of token which should be transferred",
        "@param4": "_receiver the address of receiver",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "proxyPayment",
        "visibility": "public",
        "args": [
            {
                "name": "/*_owner*/",
                "type": "address"
            }
        ],
        "func": "function proxyPayment(\n        address /*_owner*/\n    ) public payable returns (bool) {\n        return false;\n    }",
        "comments": [
            "/**",
            "     * @notice Called when `_owner` sends ether to the MiniMe Token contract",
            "     * @return True if the ether is accepted, false if it throws",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Called when `_owner` sends ether to the MiniMe Token contract\n     * @return True if the ether is accepted, false if it throws\n     */\n",
        "@notice": "Called when `_owner` sends ether to the MiniMe Token contract",
        "@return1": "True if the ether is accepted, false if it throws",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "onTransfer",
        "visibility": "public",
        "args": [
            {
                "name": "address",
                "type": "address"
            },
            {
                "name": "address",
                "type": "/*_from*/\n       "
            },
            {
                "name": "/*_amount*/",
                "type": "/*_to*/\n        uint256"
            }
        ],
        "func": "function onTransfer(\n        address, /*_from*/\n        address, /*_to*/\n        uint256 /*_amount*/\n    ) public returns (bool) {\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @notice Notifies the controller about a token transfer allowing the",
            "     *  controller to react if desired",
            "     * @return False if the controller does not authorize the transfer",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Notifies the controller about a token transfer allowing the\n     *  controller to react if desired\n     * @return False if the controller does not authorize the transfer\n     */\n",
        "@notice": "Notifies the controller about a token transfer allowing the * controller to react if desired",
        "@return1": "False if the controller does not authorize the transfer",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "onApprove",
        "visibility": "public",
        "args": [
            {
                "name": "address",
                "type": "address"
            },
            {
                "name": "address",
                "type": "/*_owner*/\n       "
            },
            {
                "name": "/*_amount*/",
                "type": "/*_spender*/\n        uint256"
            }
        ],
        "func": "function onApprove(\n        address, /*_owner*/\n        address, /*_spender*/\n        uint256 /*_amount*/\n    ) public returns (bool) {\n        return true;\n    }",
        "comments": [
            "/**",
            "     * @notice Notifies the controller about an approval allowing the",
            "     *  controller to react if desired",
            "     * @return False if the controller does not authorize the approval",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Notifies the controller about an approval allowing the\n     *  controller to react if desired\n     * @return False if the controller does not authorize the approval\n     */\n",
        "@notice": "Notifies the controller about an approval allowing the * controller to react if desired",
        "@return1": "False if the controller does not authorize the approval",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "peakReferralCommissionBalanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "_referrer",
                "type": "address"
            }
        ],
        "func": "function peakReferralCommissionBalanceOf(address _referrer)\n        public\n        returns (uint256 _commission)\n    {\n        (bool success, bytes memory result) = peakdefiLogic3.delegatecall(\n            abi.encodeWithSelector(\n                this.peakReferralCommissionBalanceOf.selector,\n                _referrer\n            )\n        );\n        if (!success) {\n            return 0;\n        }\n        return abi.decode(result, (uint256));\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the commission balance of `_referrer`",
            "     * @return the commission balance and the received penalty, denoted in USDC",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the commission balance of `_referrer`\n     * @return the commission balance and the received penalty, denoted in USDC\n     */\n",
        "@notice": "Returns the commission balance of `_referrer`",
        "@return1": "the commission balance and the received penalty, denoted in USDC",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "peakReferralCommissionOfAt",
        "visibility": "public",
        "args": [
            {
                "name": "_referrer",
                "type": "address"
            },
            {
                "name": "_cycle",
                "type": "uint256"
            }
        ],
        "func": "function peakReferralCommissionOfAt(address _referrer, uint256 _cycle)\n        public\n        returns (uint256 _commission)\n    {\n        (bool success, bytes memory result) = peakdefiLogic3.delegatecall(\n            abi.encodeWithSelector(\n                this.peakReferralCommissionOfAt.selector,\n                _referrer,\n                _cycle\n            )\n        );\n        if (!success) {\n            return 0;\n        }\n        return abi.decode(result, (uint256));\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the commission amount received by `_referrer` in the `_cycle`th cycle",
            "     * @return the commission amount and the received penalty, denoted in USDC",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the commission amount received by `_referrer` in the `_cycle`th cycle\n     * @return the commission amount and the received penalty, denoted in USDC\n     */\n",
        "@notice": "Returns the commission amount received by `_referrer` in the `_cycle`th cycle",
        "@return1": "the commission amount and the received penalty, denoted in USDC",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "peakReferralRedeemCommission",
        "visibility": "public",
        "args": [],
        "func": "function peakReferralRedeemCommission() public {\n        (bool success, ) = peakdefiLogic3.delegatecall(\n            abi.encodeWithSelector(this.peakReferralRedeemCommission.selector)\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Redeems commission.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Redeems commission.\n     */\n",
        "@notice": "Redeems commission.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "peakReferralRedeemCommissionForCycle",
        "visibility": "public",
        "args": [
            {
                "name": "_cycle",
                "type": "uint256"
            }
        ],
        "func": "function peakReferralRedeemCommissionForCycle(uint256 _cycle) public {\n        (bool success, ) = peakdefiLogic3.delegatecall(\n            abi.encodeWithSelector(\n                this.peakReferralRedeemCommissionForCycle.selector,\n                _cycle\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Redeems commission for a particular cycle.",
            "     * @param _cycle the cycle for which the commission will be redeemed.",
            "     *        Commissions for a cycle will be redeemed during the Intermission phase of the next cycle, so _cycle must < cycleNumber.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Redeems commission for a particular cycle.\n     * @param _cycle the cycle for which the commission will be redeemed.\n     *        Commissions for a cycle will be redeemed during the Intermission phase of the next cycle, so _cycle must < cycleNumber.\n     */\n",
        "@notice": "Redeems commission for a particular cycle.",
        "@param1": "_cycle the cycle for which the commission will be redeemed. * Commissions for a cycle will be redeemed during the Intermission phase of the next cycle, so _cycle must < cycleNumber.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "peakChangeManagerStakeRequired",
        "visibility": "public",
        "args": [
            {
                "name": "_newValue",
                "type": "uint256"
            }
        ],
        "func": "function peakChangeManagerStakeRequired(uint256 _newValue)\n        public\n        onlyOwner\n    {\n        peakManagerStakeRequired = _newValue;\n    }",
        "comments": [
            "/**",
            "     * @notice Changes the required PEAK stake of a new manager. Only callable by owner.",
            "     * @param _newValue the new value",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Changes the required PEAK stake of a new manager. Only callable by owner.\n     * @param _newValue the new value\n     */\n",
        "@notice": "Changes the required PEAK stake of a new manager. Only callable by owner.",
        "@param1": "_newValue the new value",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lastCommissionRedemption",
        "visibility": "public",
        "args": [
            {
                "name": "_manager",
                "type": "address"
            }
        ],
        "func": "function lastCommissionRedemption(address _manager)\n        public\n        view\n        returns (uint256)\n    {\n        if (_lastCommissionRedemption[_manager] == 0) {\n            return\n                previousVersion == address(0)\n                    ? 0\n                    : PeakDeFiStorage(previousVersion).lastCommissionRedemption(\n                        _manager\n                    );\n        }\n        return _lastCommissionRedemption[_manager];\n    }",
        "comments": [
            "/*",
            "  Helper functions shared by both PeakDeFiLogic & PeakDeFiFund",
            "  */",
            ""
        ],
        "comt": "/*\n  Helper functions shared by both PeakDeFiLogic & PeakDeFiFund\n  */\n",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "hasRedeemedCommissionForCycle",
        "visibility": "public",
        "args": [
            {
                "name": "_manager",
                "type": "address"
            },
            {
                "name": "_cycle",
                "type": "uint256"
            }
        ],
        "func": "function hasRedeemedCommissionForCycle(address _manager, uint256 _cycle)\n        public\n        view\n        returns (bool)\n    {\n        if (_hasRedeemedCommissionForCycle[_manager][_cycle] == false) {\n            return\n                previousVersion == address(0)\n                    ? false\n                    : PeakDeFiStorage(previousVersion)\n                        .hasRedeemedCommissionForCycle(_manager, _cycle);\n        }\n        return _hasRedeemedCommissionForCycle[_manager][_cycle];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "riskTakenInCycle",
        "visibility": "public",
        "args": [
            {
                "name": "_manager",
                "type": "address"
            },
            {
                "name": "_cycle",
                "type": "uint256"
            }
        ],
        "func": "function riskTakenInCycle(address _manager, uint256 _cycle)\n        public\n        view\n        returns (uint256)\n    {\n        if (_riskTakenInCycle[_manager][_cycle] == 0) {\n            return\n                previousVersion == address(0)\n                    ? 0\n                    : PeakDeFiStorage(previousVersion).riskTakenInCycle(\n                        _manager,\n                        _cycle\n                    );\n        }\n        return _riskTakenInCycle[_manager][_cycle];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "baseRiskStakeFallback",
        "visibility": "public",
        "args": [
            {
                "name": "_manager",
                "type": "address"
            }
        ],
        "func": "function baseRiskStakeFallback(address _manager)\n        public\n        view\n        returns (uint256)\n    {\n        if (_baseRiskStakeFallback[_manager] == 0) {\n            return\n                previousVersion == address(0)\n                    ? 0\n                    : PeakDeFiStorage(previousVersion).baseRiskStakeFallback(\n                        _manager\n                    );\n        }\n        return _baseRiskStakeFallback[_manager];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "totalCommissionOfCycle",
        "visibility": "public",
        "args": [
            {
                "name": "_cycle",
                "type": "uint256"
            }
        ],
        "func": "function totalCommissionOfCycle(uint256 _cycle)\n        public\n        view\n        returns (uint256)\n    {\n        if (_totalCommissionOfCycle[_cycle] == 0) {\n            return\n                previousVersion == address(0)\n                    ? 0\n                    : PeakDeFiStorage(previousVersion).totalCommissionOfCycle(\n                        _cycle\n                    );\n        }\n        return _totalCommissionOfCycle[_cycle];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "managePhaseEndBlock",
        "visibility": "public",
        "args": [
            {
                "name": "_cycle",
                "type": "uint256"
            }
        ],
        "func": "function managePhaseEndBlock(uint256 _cycle) public view returns (uint256) {\n        if (_managePhaseEndBlock[_cycle] == 0) {\n            return\n                previousVersion == address(0)\n                    ? 0\n                    : PeakDeFiStorage(previousVersion).managePhaseEndBlock(\n                        _cycle\n                    );\n        }\n        return _managePhaseEndBlock[_cycle];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "lastActiveCycle",
        "visibility": "public",
        "args": [
            {
                "name": "_manager",
                "type": "address"
            }
        ],
        "func": "function lastActiveCycle(address _manager) public view returns (uint256) {\n        if (_lastActiveCycle[_manager] == 0) {\n            return\n                previousVersion == address(0)\n                    ? 0\n                    : PeakDeFiStorage(previousVersion).lastActiveCycle(_manager);\n        }\n        return _lastActiveCycle[_manager];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "peakReferralLastCommissionRedemption",
        "visibility": "public",
        "args": [
            {
                "name": "_manager",
                "type": "address"
            }
        ],
        "func": "function peakReferralLastCommissionRedemption(address _manager)\n        public\n        view\n        returns (uint256)\n    {\n        if (_peakReferralLastCommissionRedemption[_manager] == 0) {\n            return\n                previousVersion == address(0)\n                    ? 0\n                    : PeakDeFiStorage(previousVersion)\n                        .peakReferralLastCommissionRedemption(_manager);\n        }\n        return _peakReferralLastCommissionRedemption[_manager];\n    }",
        "comments": [
            "/**",
            "    PeakDeFi",
            "   */",
            ""
        ],
        "comt": "/**\n    PeakDeFi\n   */\n",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "peakReferralHasRedeemedCommissionForCycle",
        "visibility": "public",
        "args": [
            {
                "name": "_manager",
                "type": "address"
            },
            {
                "name": "_cycle",
                "type": "uint256"
            }
        ],
        "func": "function peakReferralHasRedeemedCommissionForCycle(\n        address _manager,\n        uint256 _cycle\n    ) public view returns (bool) {\n        if (\n            _peakReferralHasRedeemedCommissionForCycle[_manager][_cycle] ==\n            false\n        ) {\n            return\n                previousVersion == address(0)\n                    ? false\n                    : PeakDeFiStorage(previousVersion)\n                        .peakReferralHasRedeemedCommissionForCycle(\n                        _manager,\n                        _cycle\n                    );\n        }\n        return _peakReferralHasRedeemedCommissionForCycle[_manager][_cycle];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "peakReferralTotalCommissionOfCycle",
        "visibility": "public",
        "args": [
            {
                "name": "_cycle",
                "type": "uint256"
            }
        ],
        "func": "function peakReferralTotalCommissionOfCycle(uint256 _cycle)\n        public\n        view\n        returns (uint256)\n    {\n        if (_peakReferralTotalCommissionOfCycle[_cycle] == 0) {\n            return\n                previousVersion == address(0)\n                    ? 0\n                    : PeakDeFiStorage(previousVersion)\n                        .peakReferralTotalCommissionOfCycle(_cycle);\n        }\n        return _peakReferralTotalCommissionOfCycle[_cycle];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updatePeakDeFiFundAddress",
        "visibility": "public",
        "args": [],
        "func": "function updatePeakDeFiFundAddress() public {\n        require(msg.sender == peakdefiFundAddress, \"Sender not PeakDeFiFund\");\n        address payable nextVersion = PeakDeFiFund(peakdefiFundAddress)\n            .nextVersion();\n        require(nextVersion != address(0), \"Next version can't be empty\");\n        peakdefiFundAddress = nextVersion;\n        emit UpdatedFundAddress(peakdefiFundAddress);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "investmentsCount",
        "visibility": "public",
        "args": [
            {
                "name": "_userAddr",
                "type": "address"
            }
        ],
        "func": "function investmentsCount(address _userAddr)\n        public\n        view\n        returns (uint256 _count)\n    {\n        return userInvestments[_userAddr].length;\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the length of the user's investments array.",
            "     * @return length of the user's investments array",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the length of the user's investments array.\n     * @return length of the user's investments array\n     */\n",
        "@notice": "Returns the length of the user's investments array.",
        "@return1": "length of the user's investments array",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burnDeadman",
        "visibility": "public",
        "args": [
            {
                "name": "_deadman",
                "type": "address"
            }
        ],
        "func": "function burnDeadman(address _deadman)\n        public\n        nonReentrant\n        during(CyclePhase.Intermission)\n    {\n        require(_deadman != address(this));\n        require(\n            cycleNumber.sub(lastActiveCycle(_deadman)) > INACTIVE_THRESHOLD\n        );\n        uint256 balance = cToken.balanceOf(_deadman);\n        require(cToken.destroyTokens(_deadman, balance));\n        emit BurnDeadman(_deadman, balance);\n    }",
        "comments": [
            "/**",
            "     * @notice Burns the RepToken balance of a manager who has been inactive for a certain number of cycles",
            "     * @param _deadman the manager whose RepToken balance will be burned",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Burns the RepToken balance of a manager who has been inactive for a certain number of cycles\n     * @param _deadman the manager whose RepToken balance will be burned\n     */\n",
        "@notice": "Burns the RepToken balance of a manager who has been inactive for a certain number of cycles",
        "@param1": "_deadman the manager whose RepToken balance will be burned",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createInvestment",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddress",
                "type": "address"
            },
            {
                "name": "_stake",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            }
        ],
        "func": "function createInvestment(\n        address _tokenAddress,\n        uint256 _stake,\n        uint256 _maxPrice\n    ) public {\n        bytes memory nil;\n        createInvestmentV2(\n            msg.sender,\n            _tokenAddress,\n            _stake,\n            _maxPrice,\n            nil,\n            true\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Creates a new investment for an ERC20 token. Backwards compatible.",
            "     * @param _tokenAddress address of the ERC20 token contract",
            "     * @param _stake amount of RepTokens to be staked in support of the investment",
            "     * @param _maxPrice the maximum price for the trade",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Creates a new investment for an ERC20 token. Backwards compatible.\n     * @param _tokenAddress address of the ERC20 token contract\n     * @param _stake amount of RepTokens to be staked in support of the investment\n     * @param _maxPrice the maximum price for the trade\n     */\n",
        "@notice": "Creates a new investment for an ERC20 token. Backwards compatible.",
        "@param1": "_tokenAddress address of the ERC20 token contract",
        "@param2": "_stake amount of RepTokens to be staked in support of the investment",
        "@param3": "_maxPrice the maximum price for the trade",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createInvestmentWithSignature",
        "visibility": "external",
        "args": [
            {
                "name": "_tokenAddress",
                "type": "address"
            },
            {
                "name": "_stake",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            },
            {
                "name": "_calldata",
                "type": "bytes calldata"
            },
            {
                "name": "_useKyber",
                "type": "bool"
            },
            {
                "name": "_manager",
                "type": "address"
            },
            {
                "name": "_salt",
                "type": "uint256"
            },
            {
                "name": "_signature",
                "type": "bytes calldata"
            }
        ],
        "func": "function createInvestmentWithSignature(\n        address _tokenAddress,\n        uint256 _stake,\n        uint256 _maxPrice,\n        bytes calldata _calldata,\n        bool _useKyber,\n        address _manager,\n        uint256 _salt,\n        bytes calldata _signature\n    ) external {\n        require(!hasUsedSalt[_manager][_salt]);\n        bytes32 naiveHash = keccak256(\n            abi.encodeWithSelector(\n                this.createInvestmentWithSignature.selector,\n                abi.encode(\n                    _tokenAddress,\n                    _stake,\n                    _maxPrice,\n                    _calldata,\n                    _useKyber\n                ),\n                \"|END|\",\n                _salt,\n                address(this)\n            )\n        );\n        bytes32 msgHash = ECDSA.toEthSignedMessageHash(naiveHash);\n        address recoveredAddress = ECDSA.recover(msgHash, _signature);\n        require(recoveredAddress == _manager);\n\n        // Signature valid, record use of salt\n        hasUsedSalt[_manager][_salt] = true;\n\n        this.createInvestmentV2(\n            _manager,\n            _tokenAddress,\n            _stake,\n            _maxPrice,\n            _calldata,\n            _useKyber\n        );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sellInvestmentAsset",
        "visibility": "public",
        "args": [
            {
                "name": "_investmentId",
                "type": "uint256"
            },
            {
                "name": "_tokenAmount",
                "type": "uint256"
            },
            {
                "name": "_minPrice",
                "type": "uint256"
            }
        ],
        "func": "function sellInvestmentAsset(\n        uint256 _investmentId,\n        uint256 _tokenAmount,\n        uint256 _minPrice\n    ) public {\n        bytes memory nil;\n        sellInvestmentAssetV2(\n            msg.sender,\n            _investmentId,\n            _tokenAmount,\n            _minPrice,\n            nil,\n            true\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Called by user to sell the assets an investment invested in. Returns the staked RepToken plus rewards/penalties to the user.",
            "     *         The user can sell only part of the investment by changing _tokenAmount. Backwards compatible.",
            "     * @dev When selling only part of an investment, the old investment would be \"fully\" sold and a new investment would be created with",
            "     *   the original buy price and however much tokens that are not sold.",
            "     * @param _investmentId the ID of the investment",
            "     * @param _tokenAmount the amount of tokens to be sold.",
            "     * @param _minPrice the minimum price for the trade",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Called by user to sell the assets an investment invested in. Returns the staked RepToken plus rewards/penalties to the user.\n     *         The user can sell only part of the investment by changing _tokenAmount. Backwards compatible.\n     * @dev When selling only part of an investment, the old investment would be \"fully\" sold and a new investment would be created with\n     *   the original buy price and however much tokens that are not sold.\n     * @param _investmentId the ID of the investment\n     * @param _tokenAmount the amount of tokens to be sold.\n     * @param _minPrice the minimum price for the trade\n     */\n",
        "@notice": "Called by user to sell the assets an investment invested in. Returns the staked RepToken plus rewards/penalties to the user. * The user can sell only part of the investment by changing _tokenAmount. Backwards compatible.",
        "@dev": "When selling only part of an investment, the old investment would be \"fully\" sold and a new investment would be created with * the original buy price and however much tokens that are not sold.",
        "@param1": "_investmentId the ID of the investment",
        "@param2": "_tokenAmount the amount of tokens to be sold.",
        "@param3": "_minPrice the minimum price for the trade",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sellInvestmentWithSignature",
        "visibility": "external",
        "args": [
            {
                "name": "_investmentId",
                "type": "uint256"
            },
            {
                "name": "_tokenAmount",
                "type": "uint256"
            },
            {
                "name": "_minPrice",
                "type": "uint256"
            },
            {
                "name": "_calldata",
                "type": "bytes calldata"
            },
            {
                "name": "_useKyber",
                "type": "bool"
            },
            {
                "name": "_manager",
                "type": "address"
            },
            {
                "name": "_salt",
                "type": "uint256"
            },
            {
                "name": "_signature",
                "type": "bytes calldata"
            }
        ],
        "func": "function sellInvestmentWithSignature(\n        uint256 _investmentId,\n        uint256 _tokenAmount,\n        uint256 _minPrice,\n        bytes calldata _calldata,\n        bool _useKyber,\n        address _manager,\n        uint256 _salt,\n        bytes calldata _signature\n    ) external {\n        require(!hasUsedSalt[_manager][_salt]);\n        bytes32 naiveHash = keccak256(\n            abi.encodeWithSelector(\n                this.sellInvestmentWithSignature.selector,\n                abi.encode(\n                    _investmentId,\n                    _tokenAmount,\n                    _minPrice,\n                    _calldata,\n                    _useKyber\n                ),\n                \"|END|\",\n                _salt,\n                address(this)\n            )\n        );\n        bytes32 msgHash = ECDSA.toEthSignedMessageHash(naiveHash);\n        address recoveredAddress = ECDSA.recover(msgHash, _signature);\n        require(recoveredAddress == _manager);\n\n        // Signature valid, record use of salt\n        hasUsedSalt[_manager][_salt] = true;\n\n        this.sellInvestmentAssetV2(\n            _manager,\n            _investmentId,\n            _tokenAmount,\n            _minPrice,\n            _calldata,\n            _useKyber\n        );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createInvestmentV2",
        "visibility": "public",
        "args": [
            {
                "name": "_sender",
                "type": "address"
            },
            {
                "name": "_tokenAddress",
                "type": "address"
            },
            {
                "name": "_stake",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            },
            {
                "name": "_calldata",
                "type": "bytes memory"
            },
            {
                "name": "_useKyber",
                "type": "bool"
            }
        ],
        "func": "function createInvestmentV2(\n        address _sender,\n        address _tokenAddress,\n        uint256 _stake,\n        uint256 _maxPrice,\n        bytes memory _calldata,\n        bool _useKyber\n    )\n        public\n        during(CyclePhase.Manage)\n        nonReentrant\n        isValidToken(_tokenAddress)\n    {\n        require(msg.sender == _sender || msg.sender == address(this));\n        require(_stake > 0);\n        require(isKyberToken[_tokenAddress]);\n\n        // Verify user peak stake\n        uint256 peakStake = peakStaking.userStakeAmount(_sender);\n        require(peakStake >= peakManagerStakeRequired);\n\n        // Collect stake\n        require(cToken.generateTokens(address(this), _stake));\n        require(cToken.destroyTokens(_sender, _stake));\n\n        // Add investment to list\n        userInvestments[_sender].push(\n            Investment({\n                tokenAddress: _tokenAddress,\n                cycleNumber: cycleNumber,\n                stake: _stake,\n                tokenAmount: 0,\n                buyPrice: 0,\n                sellPrice: 0,\n                buyTime: now,\n                buyCostInUSDC: 0,\n                isSold: false\n            })\n        );\n\n        // Invest\n        uint256 investmentId = investmentsCount(_sender).sub(1);\n        __handleInvestment(\n            _sender,\n            investmentId,\n            0,\n            _maxPrice,\n            true,\n            _calldata,\n            _useKyber\n        );\n\n        // Update last active cycle\n        _lastActiveCycle[_sender] = cycleNumber;\n\n        // Emit event\n        __emitCreatedInvestmentEvent(_sender, investmentId);\n    }",
        "comments": [
            "/**",
            "     * @notice Creates a new investment for an ERC20 token.",
            "     * @param _tokenAddress address of the ERC20 token contract",
            "     * @param _stake amount of RepTokens to be staked in support of the investment",
            "     * @param _maxPrice the maximum price for the trade",
            "     * @param _calldata calldata for 1inch trading",
            "     * @param _useKyber true for Kyber Network, false for 1inch",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Creates a new investment for an ERC20 token.\n     * @param _tokenAddress address of the ERC20 token contract\n     * @param _stake amount of RepTokens to be staked in support of the investment\n     * @param _maxPrice the maximum price for the trade\n     * @param _calldata calldata for 1inch trading\n     * @param _useKyber true for Kyber Network, false for 1inch\n     */\n",
        "@notice": "Creates a new investment for an ERC20 token.",
        "@param1": "_tokenAddress address of the ERC20 token contract",
        "@param2": "_stake amount of RepTokens to be staked in support of the investment",
        "@param3": "_maxPrice the maximum price for the trade",
        "@param4": "_calldata calldata for 1inch trading",
        "@param5": "_useKyber true for Kyber Network, false for 1inch",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sellInvestmentAssetV2",
        "visibility": "public",
        "args": [
            {
                "name": "_sender",
                "type": "address"
            },
            {
                "name": "_investmentId",
                "type": "uint256"
            },
            {
                "name": "_tokenAmount",
                "type": "uint256"
            },
            {
                "name": "_minPrice",
                "type": "uint256"
            },
            {
                "name": "_calldata",
                "type": "bytes memory"
            },
            {
                "name": "_useKyber",
                "type": "bool"
            }
        ],
        "func": "function sellInvestmentAssetV2(\n        address _sender,\n        uint256 _investmentId,\n        uint256 _tokenAmount,\n        uint256 _minPrice,\n        bytes memory _calldata,\n        bool _useKyber\n    ) public nonReentrant during(CyclePhase.Manage) {\n        require(msg.sender == _sender || msg.sender == address(this));\n        Investment storage investment = userInvestments[_sender][_investmentId];\n        require(\n            investment.buyPrice > 0 &&\n                investment.cycleNumber == cycleNumber &&\n                !investment.isSold\n        );\n        require(_tokenAmount > 0 && _tokenAmount <= investment.tokenAmount);\n\n        // Create new investment for leftover tokens\n        bool isPartialSell = false;\n        uint256 stakeOfSoldTokens = investment.stake.mul(_tokenAmount).div(\n            investment.tokenAmount\n        );\n        if (_tokenAmount != investment.tokenAmount) {\n            isPartialSell = true;\n\n            __createInvestmentForLeftovers(\n                _sender,\n                _investmentId,\n                _tokenAmount\n            );\n\n            __emitCreatedInvestmentEvent(\n                _sender,\n                investmentsCount(_sender).sub(1)\n            );\n        }\n\n        // Update investment info\n        investment.isSold = true;\n\n        // Sell asset\n        (\n            uint256 actualDestAmount,\n            uint256 actualSrcAmount\n        ) = __handleInvestment(\n            _sender,\n            _investmentId,\n            _minPrice,\n            uint256(-1),\n            false,\n            _calldata,\n            _useKyber\n        );\n\n        __sellInvestmentUpdate(\n            _sender,\n            _investmentId,\n            stakeOfSoldTokens,\n            actualDestAmount\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Called by user to sell the assets an investment invested in. Returns the staked RepToken plus rewards/penalties to the user.",
            "     *         The user can sell only part of the investment by changing _tokenAmount.",
            "     * @dev When selling only part of an investment, the old investment would be \"fully\" sold and a new investment would be created with",
            "     *   the original buy price and however much tokens that are not sold.",
            "     * @param _investmentId the ID of the investment",
            "     * @param _tokenAmount the amount of tokens to be sold.",
            "     * @param _minPrice the minimum price for the trade",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Called by user to sell the assets an investment invested in. Returns the staked RepToken plus rewards/penalties to the user.\n     *         The user can sell only part of the investment by changing _tokenAmount.\n     * @dev When selling only part of an investment, the old investment would be \"fully\" sold and a new investment would be created with\n     *   the original buy price and however much tokens that are not sold.\n     * @param _investmentId the ID of the investment\n     * @param _tokenAmount the amount of tokens to be sold.\n     * @param _minPrice the minimum price for the trade\n     */\n",
        "@notice": "Called by user to sell the assets an investment invested in. Returns the staked RepToken plus rewards/penalties to the user. * The user can sell only part of the investment by changing _tokenAmount.",
        "@dev": "When selling only part of an investment, the old investment would be \"fully\" sold and a new investment would be created with * the original buy price and however much tokens that are not sold.",
        "@param1": "_investmentId the ID of the investment",
        "@param2": "_tokenAmount the amount of tokens to be sold.",
        "@param3": "_minPrice the minimum price for the trade",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createCompoundOrderWithSignature",
        "visibility": "external",
        "args": [
            {
                "name": "_orderType",
                "type": "bool"
            },
            {
                "name": "_tokenAddress",
                "type": "address"
            },
            {
                "name": "_stake",
                "type": "uint256"
            },
            {
                "name": "_minPrice",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            },
            {
                "name": "_manager",
                "type": "address"
            },
            {
                "name": "_salt",
                "type": "uint256"
            },
            {
                "name": "_signature",
                "type": "bytes calldata"
            }
        ],
        "func": "function createCompoundOrderWithSignature(\n        bool _orderType,\n        address _tokenAddress,\n        uint256 _stake,\n        uint256 _minPrice,\n        uint256 _maxPrice,\n        address _manager,\n        uint256 _salt,\n        bytes calldata _signature\n    ) external {\n        require(!hasUsedSalt[_manager][_salt]);\n        bytes32 naiveHash = keccak256(\n            abi.encodeWithSelector(\n                this.createCompoundOrderWithSignature.selector,\n                abi.encode(\n                    _orderType,\n                    _tokenAddress,\n                    _stake,\n                    _minPrice,\n                    _maxPrice\n                ),\n                \"|END|\",\n                _salt,\n                address(this)\n            )\n        );\n        bytes32 msgHash = ECDSA.toEthSignedMessageHash(naiveHash);\n        address recoveredAddress = ECDSA.recover(msgHash, _signature);\n        require(recoveredAddress == _manager);\n\n        // Signature valid, record use of salt\n        hasUsedSalt[_manager][_salt] = true;\n\n        this.createCompoundOrder(\n            _manager,\n            _orderType,\n            _tokenAddress,\n            _stake,\n            _minPrice,\n            _maxPrice\n        );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sellCompoundOrderWithSignature",
        "visibility": "external",
        "args": [
            {
                "name": "_orderId",
                "type": "uint256"
            },
            {
                "name": "_minPrice",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            },
            {
                "name": "_manager",
                "type": "address"
            },
            {
                "name": "_salt",
                "type": "uint256"
            },
            {
                "name": "_signature",
                "type": "bytes calldata"
            }
        ],
        "func": "function sellCompoundOrderWithSignature(\n        uint256 _orderId,\n        uint256 _minPrice,\n        uint256 _maxPrice,\n        address _manager,\n        uint256 _salt,\n        bytes calldata _signature\n    ) external {\n        require(!hasUsedSalt[_manager][_salt]);\n        bytes32 naiveHash = keccak256(\n            abi.encodeWithSelector(\n                this.sellCompoundOrderWithSignature.selector,\n                abi.encode(_orderId, _minPrice, _maxPrice),\n                \"|END|\",\n                _salt,\n                address(this)\n            )\n        );\n        bytes32 msgHash = ECDSA.toEthSignedMessageHash(naiveHash);\n        address recoveredAddress = ECDSA.recover(msgHash, _signature);\n        require(recoveredAddress == _manager);\n\n        // Signature valid, record use of salt\n        hasUsedSalt[_manager][_salt] = true;\n\n        this.sellCompoundOrder(_manager, _orderId, _minPrice, _maxPrice);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repayCompoundOrderWithSignature",
        "visibility": "external",
        "args": [
            {
                "name": "_orderId",
                "type": "uint256"
            },
            {
                "name": "_repayAmountInUSDC",
                "type": "uint256"
            },
            {
                "name": "_manager",
                "type": "address"
            },
            {
                "name": "_salt",
                "type": "uint256"
            },
            {
                "name": "_signature",
                "type": "bytes calldata"
            }
        ],
        "func": "function repayCompoundOrderWithSignature(\n        uint256 _orderId,\n        uint256 _repayAmountInUSDC,\n        address _manager,\n        uint256 _salt,\n        bytes calldata _signature\n    ) external {\n        require(!hasUsedSalt[_manager][_salt]);\n        bytes32 naiveHash = keccak256(\n            abi.encodeWithSelector(\n                this.repayCompoundOrderWithSignature.selector,\n                abi.encode(_orderId, _repayAmountInUSDC),\n                \"|END|\",\n                _salt,\n                address(this)\n            )\n        );\n        bytes32 msgHash = ECDSA.toEthSignedMessageHash(naiveHash);\n        address recoveredAddress = ECDSA.recover(msgHash, _signature);\n        require(recoveredAddress == _manager);\n\n        // Signature valid, record use of salt\n        hasUsedSalt[_manager][_salt] = true;\n\n        this.repayCompoundOrder(_manager, _orderId, _repayAmountInUSDC);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "createCompoundOrder",
        "visibility": "public",
        "args": [
            {
                "name": "_sender",
                "type": "address"
            },
            {
                "name": "_orderType",
                "type": "bool"
            },
            {
                "name": "_tokenAddress",
                "type": "address"
            },
            {
                "name": "_stake",
                "type": "uint256"
            },
            {
                "name": "_minPrice",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            }
        ],
        "func": "function createCompoundOrder(\n        address _sender,\n        bool _orderType,\n        address _tokenAddress,\n        uint256 _stake,\n        uint256 _minPrice,\n        uint256 _maxPrice\n    )\n        public\n        during(CyclePhase.Manage)\n        nonReentrant\n        isValidToken(_tokenAddress)\n    {\n        require(msg.sender == _sender || msg.sender == address(this));\n        require(_minPrice <= _maxPrice);\n        require(_stake > 0);\n        require(isCompoundToken[_tokenAddress]);\n\n        // Verify user peak stake\n        uint256 peakStake = peakStaking.userStakeAmount(_sender);\n        require(peakStake >= peakManagerStakeRequired);\n\n        // Collect stake\n        require(cToken.generateTokens(address(this), _stake));\n        require(cToken.destroyTokens(_sender, _stake));\n\n        // Create compound order and execute\n        uint256 collateralAmountInUSDC = totalFundsInUSDC.mul(_stake).div(\n            cToken.totalSupply()\n        );\n        CompoundOrder order = __createCompoundOrder(\n            _orderType,\n            _tokenAddress,\n            _stake,\n            collateralAmountInUSDC\n        );\n        usdc.safeApprove(address(order), 0);\n        usdc.safeApprove(address(order), collateralAmountInUSDC);\n        order.executeOrder(_minPrice, _maxPrice);\n\n        // Add order to list\n        userCompoundOrders[_sender].push(address(order));\n\n        // Update last active cycle\n        _lastActiveCycle[_sender] = cycleNumber;\n\n        __emitCreatedCompoundOrderEvent(\n            _sender,\n            address(order),\n            _orderType,\n            _tokenAddress,\n            _stake,\n            collateralAmountInUSDC\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Creates a new Compound order to either short or leverage long a token.",
            "     * @param _orderType true for a short order, false for a levarage long order",
            "     * @param _tokenAddress address of the Compound token to be traded",
            "     * @param _stake amount of RepTokens to be staked",
            "     * @param _minPrice the minimum token price for the trade",
            "     * @param _maxPrice the maximum token price for the trade",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Creates a new Compound order to either short or leverage long a token.\n     * @param _orderType true for a short order, false for a levarage long order\n     * @param _tokenAddress address of the Compound token to be traded\n     * @param _stake amount of RepTokens to be staked\n     * @param _minPrice the minimum token price for the trade\n     * @param _maxPrice the maximum token price for the trade\n     */\n",
        "@notice": "Creates a new Compound order to either short or leverage long a token.",
        "@param1": "_orderType true for a short order, false for a levarage long order",
        "@param2": "_tokenAddress address of the Compound token to be traded",
        "@param3": "_stake amount of RepTokens to be staked",
        "@param4": "_minPrice the minimum token price for the trade",
        "@param5": "_maxPrice the maximum token price for the trade",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sellCompoundOrder",
        "visibility": "public",
        "args": [
            {
                "name": "_sender",
                "type": "address"
            },
            {
                "name": "_orderId",
                "type": "uint256"
            },
            {
                "name": "_minPrice",
                "type": "uint256"
            },
            {
                "name": "_maxPrice",
                "type": "uint256"
            }
        ],
        "func": "function sellCompoundOrder(\n        address _sender,\n        uint256 _orderId,\n        uint256 _minPrice,\n        uint256 _maxPrice\n    ) public during(CyclePhase.Manage) nonReentrant {\n        require(msg.sender == _sender || msg.sender == address(this));\n        // Load order info\n        require(userCompoundOrders[_sender][_orderId] != address(0));\n        CompoundOrder order = CompoundOrder(\n            userCompoundOrders[_sender][_orderId]\n        );\n        require(order.isSold() == false && order.cycleNumber() == cycleNumber);\n\n        // Sell order\n        (uint256 inputAmount, uint256 outputAmount) = order.sellOrder(\n            _minPrice,\n            _maxPrice\n        );\n\n        // Return staked RepToken\n        uint256 stake = order.stake();\n        uint256 receiveRepTokenAmount = getReceiveRepTokenAmount(\n            stake,\n            outputAmount,\n            inputAmount\n        );\n        __returnStake(receiveRepTokenAmount, stake);\n\n        // Record risk taken\n        __recordRisk(_sender, stake, order.buyTime());\n\n        // Update total funds\n        totalFundsInUSDC = totalFundsInUSDC.sub(inputAmount).add(outputAmount);\n\n        // Emit event\n        emit SoldCompoundOrder(\n            cycleNumber,\n            _sender,\n            userCompoundOrders[_sender].length - 1,\n            address(order),\n            order.orderType(),\n            order.compoundTokenAddr(),\n            receiveRepTokenAmount,\n            outputAmount\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Sells a compound order",
            "     * @param _orderId the ID of the order to be sold (index in userCompoundOrders[msg.sender])",
            "     * @param _minPrice the minimum token price for the trade",
            "     * @param _maxPrice the maximum token price for the trade",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sells a compound order\n     * @param _orderId the ID of the order to be sold (index in userCompoundOrders[msg.sender])\n     * @param _minPrice the minimum token price for the trade\n     * @param _maxPrice the maximum token price for the trade\n     */\n",
        "@notice": "Sells a compound order",
        "@param1": "_orderId the ID of the order to be sold (index in userCompoundOrders[msg.sender])",
        "@param2": "_minPrice the minimum token price for the trade",
        "@param3": "_maxPrice the maximum token price for the trade",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repayCompoundOrder",
        "visibility": "public",
        "args": [
            {
                "name": "_sender",
                "type": "address"
            },
            {
                "name": "_orderId",
                "type": "uint256"
            },
            {
                "name": "_repayAmountInUSDC",
                "type": "uint256"
            }
        ],
        "func": "function repayCompoundOrder(\n        address _sender,\n        uint256 _orderId,\n        uint256 _repayAmountInUSDC\n    ) public during(CyclePhase.Manage) nonReentrant {\n        require(msg.sender == _sender || msg.sender == address(this));\n        // Load order info\n        require(userCompoundOrders[_sender][_orderId] != address(0));\n        CompoundOrder order = CompoundOrder(\n            userCompoundOrders[_sender][_orderId]\n        );\n        require(order.isSold() == false && order.cycleNumber() == cycleNumber);\n\n        // Repay loan\n        order.repayLoan(_repayAmountInUSDC);\n\n        // Emit event\n        emit RepaidCompoundOrder(\n            cycleNumber,\n            _sender,\n            userCompoundOrders[_sender].length - 1,\n            address(order),\n            _repayAmountInUSDC\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Repys debt for a Compound order to prevent the collateral ratio from dropping below threshold.",
            "     * @param _orderId the ID of the Compound order",
            "     * @param _repayAmountInUSDC amount of USDC to use for repaying debt",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Repys debt for a Compound order to prevent the collateral ratio from dropping below threshold.\n     * @param _orderId the ID of the Compound order\n     * @param _repayAmountInUSDC amount of USDC to use for repaying debt\n     */\n",
        "@notice": "Repys debt for a Compound order to prevent the collateral ratio from dropping below threshold.",
        "@param1": "_orderId the ID of the Compound order",
        "@param2": "_repayAmountInUSDC amount of USDC to use for repaying debt",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "emergencyExitCompoundTokens",
        "visibility": "public",
        "args": [
            {
                "name": "_sender",
                "type": "address"
            },
            {
                "name": "_orderId",
                "type": "uint256"
            },
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_receiver",
                "type": "address"
            }
        ],
        "func": "function emergencyExitCompoundTokens(\n        address _sender,\n        uint256 _orderId,\n        address _tokenAddr,\n        address _receiver\n    ) public during(CyclePhase.Intermission) nonReentrant {\n        CompoundOrder order = CompoundOrder(userCompoundOrders[_sender][_orderId]);\n        order.emergencyExitTokens(_tokenAddr, _receiver);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getReceiveRepTokenAmount",
        "visibility": "public",
        "args": [
            {
                "name": "stake",
                "type": "uint256"
            },
            {
                "name": "output",
                "type": "uint256"
            },
            {
                "name": "input",
                "type": "uint256"
            }
        ],
        "func": "function getReceiveRepTokenAmount(\n        uint256 stake,\n        uint256 output,\n        uint256 input\n    ) public pure returns (uint256 _amount) {\n        if (output >= input) {\n            // positive ROI, simply return stake * (1 + ROI)\n            return stake.mul(output).div(input);\n        } else {\n            // negative ROI\n            uint256 absROI = input.sub(output).mul(PRECISION).div(input);\n            if (absROI <= ROI_PUNISH_THRESHOLD) {\n                // ROI better than -10%, no punishment\n                return stake.mul(output).div(input);\n            } else if (\n                absROI > ROI_PUNISH_THRESHOLD && absROI < ROI_BURN_THRESHOLD\n            ) {\n                // ROI between -10% and -25%, punish\n                // return stake * (1 + roiWithPunishment) = stake * (1 + (-(6 * absROI - 0.5)))\n                return\n                    stake\n                        .mul(\n                        PRECISION.sub(\n                            ROI_PUNISH_SLOPE.mul(absROI).sub(\n                                ROI_PUNISH_NEG_BIAS\n                            )\n                        )\n                    )\n                        .div(PRECISION);\n            } else {\n                // ROI greater than 25%, burn all stake\n                return 0;\n            }\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "depositEther",
        "visibility": "public",
        "args": [
            {
                "name": "_referrer",
                "type": "address"
            }
        ],
        "func": "function depositEther(address _referrer) public payable {\n        bytes memory nil;\n        depositEtherAdvanced(true, nil, _referrer);\n    }",
        "comments": [
            "/**",
            "     * Deposit & Withdraw",
            "     */",
            ""
        ],
        "comt": "/**\n     * Deposit & Withdraw\n     */\n",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "depositEtherAdvanced",
        "visibility": "public",
        "args": [
            {
                "name": "_useKyber",
                "type": "bool"
            },
            {
                "name": "_calldata",
                "type": "bytes memory"
            },
            {
                "name": "_referrer",
                "type": "address"
            }
        ],
        "func": "function depositEtherAdvanced(\n        bool _useKyber,\n        bytes memory _calldata,\n        address _referrer\n    ) public payable nonReentrant notReadyForUpgrade {\n        // Buy USDC with ETH\n        uint256 actualUSDCDeposited;\n        uint256 actualETHDeposited;\n        if (_useKyber) {\n            (, , actualUSDCDeposited, actualETHDeposited) = __kyberTrade(\n                ETH_TOKEN_ADDRESS,\n                msg.value,\n                usdc\n            );\n        } else {\n            (, , actualUSDCDeposited, actualETHDeposited) = __oneInchTrade(\n                ETH_TOKEN_ADDRESS,\n                msg.value,\n                usdc,\n                _calldata\n            );\n        }\n\n        // Send back leftover ETH\n        uint256 leftOverETH = msg.value.sub(actualETHDeposited);\n        if (leftOverETH > 0) {\n            msg.sender.transfer(leftOverETH);\n        }\n\n        // Register investment\n        __deposit(actualUSDCDeposited, _referrer);\n\n        // Emit event\n        emit Deposit(\n            cycleNumber,\n            msg.sender,\n            address(ETH_TOKEN_ADDRESS),\n            actualETHDeposited,\n            actualUSDCDeposited,\n            now\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Deposit Ether into the fund. Ether will be converted into USDC.",
            "     * @param _useKyber true for Kyber Network, false for 1inch",
            "     * @param _calldata calldata for 1inch trading",
            "     * @param _referrer the referrer's address",
            "",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Deposit Ether into the fund. Ether will be converted into USDC.\n     * @param _useKyber true for Kyber Network, false for 1inch\n     * @param _calldata calldata for 1inch trading\n     * @param _referrer the referrer's address\n\n     */\n",
        "@notice": "Deposit Ether into the fund. Ether will be converted into USDC.",
        "@param1": "_useKyber true for Kyber Network, false for 1inch",
        "@param2": "_calldata calldata for 1inch trading",
        "@param3": "_referrer the referrer's address",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "depositUSDC",
        "visibility": "public",
        "args": [
            {
                "name": "_usdcAmount",
                "type": "uint256"
            },
            {
                "name": "_referrer",
                "type": "address"
            }
        ],
        "func": "function depositUSDC(uint256 _usdcAmount, address _referrer)\n        public\n        nonReentrant\n        notReadyForUpgrade\n    {\n        usdc.safeTransferFrom(msg.sender, address(this), _usdcAmount);\n\n        // Register investment\n        __deposit(_usdcAmount, _referrer);\n\n        // Emit event\n        emit Deposit(\n            cycleNumber,\n            msg.sender,\n            USDC_ADDR,\n            _usdcAmount,\n            _usdcAmount,\n            now\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Deposit USDC Stablecoin into the fund.",
            "     * @param _usdcAmount The amount of USDC to be deposited. May be different from actual deposited amount.",
            "     * @param _referrer the referrer's address",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Deposit USDC Stablecoin into the fund.\n     * @param _usdcAmount The amount of USDC to be deposited. May be different from actual deposited amount.\n     * @param _referrer the referrer's address\n     */\n",
        "@notice": "Deposit USDC Stablecoin into the fund.",
        "@param1": "_usdcAmount The amount of USDC to be deposited. May be different from actual deposited amount.",
        "@param2": "_referrer the referrer's address",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "depositToken",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_tokenAmount",
                "type": "uint256"
            },
            {
                "name": "_referrer",
                "type": "address"
            }
        ],
        "func": "function depositToken(\n        address _tokenAddr,\n        uint256 _tokenAmount,\n        address _referrer\n    ) public {\n        bytes memory nil;\n        depositTokenAdvanced(_tokenAddr, _tokenAmount, true, nil, _referrer);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "depositTokenAdvanced",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_tokenAmount",
                "type": "uint256"
            },
            {
                "name": "_useKyber",
                "type": "bool"
            },
            {
                "name": "_calldata",
                "type": "bytes memory"
            },
            {
                "name": "_referrer",
                "type": "address"
            }
        ],
        "func": "function depositTokenAdvanced(\n        address _tokenAddr,\n        uint256 _tokenAmount,\n        bool _useKyber,\n        bytes memory _calldata,\n        address _referrer\n    ) public nonReentrant notReadyForUpgrade isValidToken(_tokenAddr) {\n        require(\n            _tokenAddr != USDC_ADDR && _tokenAddr != address(ETH_TOKEN_ADDRESS)\n        );\n\n        ERC20Detailed token = ERC20Detailed(_tokenAddr);\n\n        token.safeTransferFrom(msg.sender, address(this), _tokenAmount);\n        // Convert token into USDC\n        uint256 actualUSDCDeposited;\n        uint256 actualTokenDeposited;\n        if (_useKyber) {\n            (, , actualUSDCDeposited, actualTokenDeposited) = __kyberTrade(\n                token,\n                _tokenAmount,\n                usdc\n            );\n        } else {\n            (, , actualUSDCDeposited, actualTokenDeposited) = __oneInchTrade(\n                token,\n                _tokenAmount,\n                usdc,\n                _calldata\n            );\n        }\n        // Give back leftover tokens\n        uint256 leftOverTokens = _tokenAmount.sub(actualTokenDeposited);\n        if (leftOverTokens > 0) {\n            token.safeTransfer(msg.sender, leftOverTokens);\n        }\n\n        // Register investment\n        __deposit(actualUSDCDeposited, _referrer);\n\n        // Emit event\n        emit Deposit(\n            cycleNumber,\n            msg.sender,\n            _tokenAddr,\n            actualTokenDeposited,\n            actualUSDCDeposited,\n            now\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Deposit ERC20 tokens into the fund. Tokens will be converted into USDC.",
            "     * @param _tokenAddr the address of the token to be deposited",
            "     * @param _tokenAmount The amount of tokens to be deposited. May be different from actual deposited amount.",
            "     * @param _useKyber true for Kyber Network, false for 1inch",
            "     * @param _calldata calldata for 1inch trading",
            "     * @param _referrer the referrer's address",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Deposit ERC20 tokens into the fund. Tokens will be converted into USDC.\n     * @param _tokenAddr the address of the token to be deposited\n     * @param _tokenAmount The amount of tokens to be deposited. May be different from actual deposited amount.\n     * @param _useKyber true for Kyber Network, false for 1inch\n     * @param _calldata calldata for 1inch trading\n     * @param _referrer the referrer's address\n     */\n",
        "@notice": "Deposit ERC20 tokens into the fund. Tokens will be converted into USDC.",
        "@param1": "_tokenAddr the address of the token to be deposited",
        "@param2": "_tokenAmount The amount of tokens to be deposited. May be different from actual deposited amount.",
        "@param3": "_useKyber true for Kyber Network, false for 1inch",
        "@param4": "_calldata calldata for 1inch trading",
        "@param5": "_referrer the referrer's address",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawEther",
        "visibility": "external",
        "args": [
            {
                "name": "_amountInUSDC",
                "type": "uint256"
            }
        ],
        "func": "function withdrawEther(uint256 _amountInUSDC) external {\n        bytes memory nil;\n        withdrawEtherAdvanced(_amountInUSDC, true, nil);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawEtherAdvanced",
        "visibility": "public",
        "args": [
            {
                "name": "_amountInUSDC",
                "type": "uint256"
            },
            {
                "name": "_useKyber",
                "type": "bool"
            },
            {
                "name": "_calldata",
                "type": "bytes memory"
            }
        ],
        "func": "function withdrawEtherAdvanced(\n        uint256 _amountInUSDC,\n        bool _useKyber,\n        bytes memory _calldata\n    ) public nonReentrant during(CyclePhase.Intermission) {\n        // Buy ETH\n        uint256 actualETHWithdrawn;\n        uint256 actualUSDCWithdrawn;\n        if (_useKyber) {\n            (, , actualETHWithdrawn, actualUSDCWithdrawn) = __kyberTrade(\n                usdc,\n                _amountInUSDC,\n                ETH_TOKEN_ADDRESS\n            );\n        } else {\n            (, , actualETHWithdrawn, actualUSDCWithdrawn) = __oneInchTrade(\n                usdc,\n                _amountInUSDC,\n                ETH_TOKEN_ADDRESS,\n                _calldata\n            );\n        }\n\n        __withdraw(actualUSDCWithdrawn);\n\n        // Transfer Ether to user\n        msg.sender.transfer(actualETHWithdrawn);\n\n        // Emit event\n        emit Withdraw(\n            cycleNumber,\n            msg.sender,\n            address(ETH_TOKEN_ADDRESS),\n            actualETHWithdrawn,\n            actualUSDCWithdrawn,\n            now\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Withdraws Ether by burning Shares.",
            "     * @param _amountInUSDC Amount of funds to be withdrawn expressed in USDC. Fixed-point decimal. May be different from actual amount.",
            "     * @param _useKyber true for Kyber Network, false for 1inch",
            "     * @param _calldata calldata for 1inch trading",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Withdraws Ether by burning Shares.\n     * @param _amountInUSDC Amount of funds to be withdrawn expressed in USDC. Fixed-point decimal. May be different from actual amount.\n     * @param _useKyber true for Kyber Network, false for 1inch\n     * @param _calldata calldata for 1inch trading\n     */\n",
        "@notice": "Withdraws Ether by burning Shares.",
        "@param1": "_amountInUSDC Amount of funds to be withdrawn expressed in USDC. Fixed-point decimal. May be different from actual amount.",
        "@param2": "_useKyber true for Kyber Network, false for 1inch",
        "@param3": "_calldata calldata for 1inch trading",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawUSDC",
        "visibility": "external",
        "args": [
            {
                "name": "_amountInUSDC",
                "type": "uint256"
            }
        ],
        "func": "function withdrawUSDC(uint256 _amountInUSDC)\n        external\n        nonReentrant\n        during(CyclePhase.Intermission)\n    {\n        __withdraw(_amountInUSDC);\n\n        // Transfer USDC to user\n        usdc.safeTransfer(msg.sender, _amountInUSDC);\n\n        // Emit event\n        emit Withdraw(\n            cycleNumber,\n            msg.sender,\n            USDC_ADDR,\n            _amountInUSDC,\n            _amountInUSDC,\n            now\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Withdraws Ether by burning Shares.",
            "     * @param _amountInUSDC Amount of funds to be withdrawn expressed in USDC. Fixed-point decimal. May be different from actual amount.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Withdraws Ether by burning Shares.\n     * @param _amountInUSDC Amount of funds to be withdrawn expressed in USDC. Fixed-point decimal. May be different from actual amount.\n     */\n",
        "@notice": "Withdraws Ether by burning Shares.",
        "@param1": "_amountInUSDC Amount of funds to be withdrawn expressed in USDC. Fixed-point decimal. May be different from actual amount.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawToken",
        "visibility": "external",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_amountInUSDC",
                "type": "uint256"
            }
        ],
        "func": "function withdrawToken(address _tokenAddr, uint256 _amountInUSDC) external {\n        bytes memory nil;\n        withdrawTokenAdvanced(_tokenAddr, _amountInUSDC, true, nil);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "withdrawTokenAdvanced",
        "visibility": "public",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_amountInUSDC",
                "type": "uint256"
            },
            {
                "name": "_useKyber",
                "type": "bool"
            },
            {
                "name": "_calldata",
                "type": "bytes memory"
            }
        ],
        "func": "function withdrawTokenAdvanced(\n        address _tokenAddr,\n        uint256 _amountInUSDC,\n        bool _useKyber,\n        bytes memory _calldata\n    )\n        public\n        during(CyclePhase.Intermission)\n        nonReentrant\n        isValidToken(_tokenAddr)\n    {\n        require(\n            _tokenAddr != USDC_ADDR && _tokenAddr != address(ETH_TOKEN_ADDRESS)\n        );\n\n        ERC20Detailed token = ERC20Detailed(_tokenAddr);\n\n        // Convert USDC into desired tokens\n        uint256 actualTokenWithdrawn;\n        uint256 actualUSDCWithdrawn;\n        if (_useKyber) {\n            (, , actualTokenWithdrawn, actualUSDCWithdrawn) = __kyberTrade(\n                usdc,\n                _amountInUSDC,\n                token\n            );\n        } else {\n            (, , actualTokenWithdrawn, actualUSDCWithdrawn) = __oneInchTrade(\n                usdc,\n                _amountInUSDC,\n                token,\n                _calldata\n            );\n        }\n\n        __withdraw(actualUSDCWithdrawn);\n\n        // Transfer tokens to user\n        token.safeTransfer(msg.sender, actualTokenWithdrawn);\n\n        // Emit event\n        emit Withdraw(\n            cycleNumber,\n            msg.sender,\n            _tokenAddr,\n            actualTokenWithdrawn,\n            actualUSDCWithdrawn,\n            now\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Withdraws funds by burning Shares, and converts the funds into the specified token using Kyber Network.",
            "     * @param _tokenAddr the address of the token to be withdrawn into the caller's account",
            "     * @param _amountInUSDC The amount of funds to be withdrawn expressed in USDC. Fixed-point decimal. May be different from actual amount.",
            "     * @param _useKyber true for Kyber Network, false for 1inch",
            "     * @param _calldata calldata for 1inch trading",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Withdraws funds by burning Shares, and converts the funds into the specified token using Kyber Network.\n     * @param _tokenAddr the address of the token to be withdrawn into the caller's account\n     * @param _amountInUSDC The amount of funds to be withdrawn expressed in USDC. Fixed-point decimal. May be different from actual amount.\n     * @param _useKyber true for Kyber Network, false for 1inch\n     * @param _calldata calldata for 1inch trading\n     */\n",
        "@notice": "Withdraws funds by burning Shares, and converts the funds into the specified token using Kyber Network.",
        "@param1": "_tokenAddr the address of the token to be withdrawn into the caller's account",
        "@param2": "_amountInUSDC The amount of funds to be withdrawn expressed in USDC. Fixed-point decimal. May be different from actual amount.",
        "@param3": "_useKyber true for Kyber Network, false for 1inch",
        "@param4": "_calldata calldata for 1inch trading",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "registerWithUSDC",
        "visibility": "public",
        "args": [],
        "func": "function registerWithUSDC()\n        public\n        during(CyclePhase.Intermission)\n        nonReentrant\n    {\n        require(!isPermissioned);\n        require(managersOnboardedThisCycle < maxNewManagersPerCycle);\n        managersOnboardedThisCycle = managersOnboardedThisCycle.add(1);\n\n        uint256 peakStake = peakStaking.userStakeAmount(msg.sender);\n        require(peakStake >= peakManagerStakeRequired);\n\n        uint256 donationInUSDC = newManagerRepToken.mul(reptokenPrice).div(PRECISION);\n        usdc.safeTransferFrom(msg.sender, address(this), donationInUSDC);\n        __register(donationInUSDC);\n    }",
        "comments": [
            "/**",
            "     * @notice Registers `msg.sender` as a manager, using USDC as payment. The more one pays, the more RepToken one gets.",
            "     *         There's a max RepToken amount that can be bought, and excess payment will be sent back to sender.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Registers `msg.sender` as a manager, using USDC as payment. The more one pays, the more RepToken one gets.\n     *         There's a max RepToken amount that can be bought, and excess payment will be sent back to sender.\n     */\n",
        "@notice": "Registers `msg.sender` as a manager, using USDC as payment. The more one pays, the more RepToken one gets. * There's a max RepToken amount that can be bought, and excess payment will be sent back to sender.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "registerWithETH",
        "visibility": "public",
        "args": [],
        "func": "function registerWithETH()\n        public\n        payable\n        during(CyclePhase.Intermission)\n        nonReentrant\n    {\n        require(!isPermissioned);\n        require(managersOnboardedThisCycle < maxNewManagersPerCycle);\n        managersOnboardedThisCycle = managersOnboardedThisCycle.add(1);\n\n        uint256 peakStake = peakStaking.userStakeAmount(msg.sender);\n        require(peakStake >= peakManagerStakeRequired);\n\n        uint256 receivedUSDC;\n\n        // trade ETH for USDC\n        (, , receivedUSDC, ) = __kyberTrade(ETH_TOKEN_ADDRESS, msg.value, usdc);\n\n        // if USDC value is greater than the amount required, return excess USDC to msg.sender\n        uint256 donationInUSDC = newManagerRepToken.mul(reptokenPrice).div(PRECISION);\n        if (receivedUSDC > donationInUSDC) {\n            usdc.safeTransfer(msg.sender, receivedUSDC.sub(donationInUSDC));\n            receivedUSDC = donationInUSDC;\n        }\n\n        // register new manager\n        __register(receivedUSDC);\n    }",
        "comments": [
            "/**",
            "     * @notice Registers `msg.sender` as a manager, using ETH as payment. The more one pays, the more RepToken one gets.",
            "     *         There's a max RepToken amount that can be bought, and excess payment will be sent back to sender.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Registers `msg.sender` as a manager, using ETH as payment. The more one pays, the more RepToken one gets.\n     *         There's a max RepToken amount that can be bought, and excess payment will be sent back to sender.\n     */\n",
        "@notice": "Registers `msg.sender` as a manager, using ETH as payment. The more one pays, the more RepToken one gets. * There's a max RepToken amount that can be bought, and excess payment will be sent back to sender.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "registerWithToken",
        "visibility": "public",
        "args": [
            {
                "name": "_token",
                "type": "address"
            },
            {
                "name": "_donationInTokens",
                "type": "uint256"
            }
        ],
        "func": "function registerWithToken(address _token, uint256 _donationInTokens)\n        public\n        during(CyclePhase.Intermission)\n        nonReentrant\n    {\n        require(!isPermissioned);\n        require(managersOnboardedThisCycle < maxNewManagersPerCycle);\n        managersOnboardedThisCycle = managersOnboardedThisCycle.add(1);\n\n        uint256 peakStake = peakStaking.userStakeAmount(msg.sender);\n        require(peakStake >= peakManagerStakeRequired);\n\n        require(\n            _token != address(0) &&\n                _token != address(ETH_TOKEN_ADDRESS) &&\n                _token != USDC_ADDR\n        );\n        ERC20Detailed token = ERC20Detailed(_token);\n        require(token.totalSupply() > 0);\n\n        token.safeTransferFrom(msg.sender, address(this), _donationInTokens);\n\n        uint256 receivedUSDC;\n\n        (, , receivedUSDC, ) = __kyberTrade(token, _donationInTokens, usdc);\n\n        // if USDC value is greater than the amount required, return excess USDC to msg.sender\n        uint256 donationInUSDC = newManagerRepToken.mul(reptokenPrice).div(PRECISION);\n        if (receivedUSDC > donationInUSDC) {\n            usdc.safeTransfer(msg.sender, receivedUSDC.sub(donationInUSDC));\n            receivedUSDC = donationInUSDC;\n        }\n\n        // register new manager\n        __register(receivedUSDC);\n    }",
        "comments": [
            "/**",
            "     * @notice Registers `msg.sender` as a manager, using tokens as payment. The more one pays, the more RepToken one gets.",
            "     *         There's a max RepToken amount that can be bought, and excess payment will be sent back to sender.",
            "     * @param _token the token to be used for payment",
            "     * @param _donationInTokens the amount of tokens to be used for registration, should use the token's native decimals",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Registers `msg.sender` as a manager, using tokens as payment. The more one pays, the more RepToken one gets.\n     *         There's a max RepToken amount that can be bought, and excess payment will be sent back to sender.\n     * @param _token the token to be used for payment\n     * @param _donationInTokens the amount of tokens to be used for registration, should use the token's native decimals\n     */\n",
        "@notice": "Registers `msg.sender` as a manager, using tokens as payment. The more one pays, the more RepToken one gets. * There's a max RepToken amount that can be bought, and excess payment will be sent back to sender.",
        "@param1": "_token the token to be used for payment",
        "@param2": "_donationInTokens the amount of tokens to be used for registration, should use the token's native decimals",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "peakAdminRegisterManager",
        "visibility": "public",
        "args": [
            {
                "name": "_manager",
                "type": "address"
            },
            {
                "name": "_reptokenAmount",
                "type": "uint256"
            }
        ],
        "func": "function peakAdminRegisterManager(address _manager, uint256 _reptokenAmount)\n        public\n        during(CyclePhase.Intermission)\n        nonReentrant\n        onlyOwner\n    {\n        require(isPermissioned);\n\n        // mint REP for msg.sender\n        require(cToken.generateTokens(_manager, _reptokenAmount));\n\n        // Set risk fallback base stake\n        _baseRiskStakeFallback[_manager] = _baseRiskStakeFallback[_manager].add(\n            _reptokenAmount\n        );\n\n        // Set last active cycle for msg.sender to be the current cycle\n        _lastActiveCycle[_manager] = cycleNumber;\n\n        // emit events\n        emit Register(_manager, 0, _reptokenAmount);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sellLeftoverToken",
        "visibility": "external",
        "args": [
            {
                "name": "_tokenAddr",
                "type": "address"
            },
            {
                "name": "_calldata",
                "type": "bytes calldata"
            }
        ],
        "func": "function sellLeftoverToken(address _tokenAddr, bytes calldata _calldata)\n        external\n        during(CyclePhase.Intermission)\n        nonReentrant\n        isValidToken(_tokenAddr)\n    {\n        ERC20Detailed token = ERC20Detailed(_tokenAddr);\n        (, , uint256 actualUSDCReceived, ) = __oneInchTrade(\n            token,\n            getBalance(token, address(this)),\n            usdc,\n            _calldata\n        );\n        totalFundsInUSDC = totalFundsInUSDC.add(actualUSDCReceived);\n    }",
        "comments": [
            "/**",
            "     * @notice Sells tokens left over due to manager not selling or KyberNetwork not having enough volume. Callable by anyone. Money goes to developer.",
            "     * @param _tokenAddr address of the token to be sold",
            "     * @param _calldata the 1inch trade call data",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sells tokens left over due to manager not selling or KyberNetwork not having enough volume. Callable by anyone. Money goes to developer.\n     * @param _tokenAddr address of the token to be sold\n     * @param _calldata the 1inch trade call data\n     */\n",
        "@notice": "Sells tokens left over due to manager not selling or KyberNetwork not having enough volume. Callable by anyone. Money goes to developer.",
        "@param1": "_tokenAddr address of the token to be sold",
        "@param2": "_calldata the 1inch trade call data",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "sellLeftoverCompoundOrder",
        "visibility": "public",
        "args": [
            {
                "name": "_orderAddress",
                "type": "address payable"
            }
        ],
        "func": "function sellLeftoverCompoundOrder(address payable _orderAddress)\n        public\n        during(CyclePhase.Intermission)\n        nonReentrant\n    {\n        // Load order info\n        require(_orderAddress != address(0));\n        CompoundOrder order = CompoundOrder(_orderAddress);\n        require(order.isSold() == false && order.cycleNumber() < cycleNumber);\n\n        // Sell short order\n        // Not using outputAmount returned by order.sellOrder() because _orderAddress could point to a malicious contract\n        uint256 beforeUSDCBalance = usdc.balanceOf(address(this));\n        order.sellOrder(0, MAX_QTY);\n        uint256 actualUSDCReceived = usdc.balanceOf(address(this)).sub(\n            beforeUSDCBalance\n        );\n\n        totalFundsInUSDC = totalFundsInUSDC.add(actualUSDCReceived);\n    }",
        "comments": [
            "/**",
            "     * @notice Sells CompoundOrder left over due to manager not selling or KyberNetwork not having enough volume. Callable by anyone. Money goes to developer.",
            "     * @param _orderAddress address of the CompoundOrder to be sold",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sells CompoundOrder left over due to manager not selling or KyberNetwork not having enough volume. Callable by anyone. Money goes to developer.\n     * @param _orderAddress address of the CompoundOrder to be sold\n     */\n",
        "@notice": "Sells CompoundOrder left over due to manager not selling or KyberNetwork not having enough volume. Callable by anyone. Money goes to developer.",
        "@param1": "_orderAddress address of the CompoundOrder to be sold",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "nextPhase",
        "visibility": "public",
        "args": [],
        "func": "function nextPhase() public nonReentrant {\n        require(\n            now >= startTimeOfCyclePhase.add(phaseLengths[uint256(cyclePhase)])\n        );\n\n        if (isInitialized == false) {\n            // first cycle of this smart contract deployment\n            // check whether ready for starting cycle\n            isInitialized = true;\n            require(proxyAddr != address(0)); // has initialized proxy\n            require(proxy.peakdefiFundAddress() == address(this)); // upgrade complete\n            require(hasInitializedTokenListings); // has initialized token listings\n\n            // execute initialization function\n            __init();\n\n            require(\n                previousVersion == address(0) ||\n                    (previousVersion != address(0) &&\n                        getBalance(usdc, address(this)) > 0)\n            ); // has transfered assets from previous version\n        } else {\n            // normal phase changing\n            if (cyclePhase == CyclePhase.Intermission) {\n                require(hasFinalizedNextVersion == false); // Shouldn't progress to next phase if upgrading\n\n                // Update total funds at management phase's beginning\n                totalFundsAtManagePhaseStart = totalFundsInUSDC;\n\n                // reset number of managers onboarded\n                managersOnboardedThisCycle = 0;\n            } else if (cyclePhase == CyclePhase.Manage) {\n                // Burn any RepToken left in PeakDeFiFund's account\n                require(\n                    cToken.destroyTokens(\n                        address(this),\n                        cToken.balanceOf(address(this))\n                    )\n                );\n\n                // Pay out commissions and fees\n                uint256 profit = 0;\n\n\n                    uint256 usdcBalanceAtManagePhaseStart\n                 = totalFundsAtManagePhaseStart.add(totalCommissionLeft);\n                if (\n                    getBalance(usdc, address(this)) >\n                    usdcBalanceAtManagePhaseStart\n                ) {\n                    profit = getBalance(usdc, address(this)).sub(\n                        usdcBalanceAtManagePhaseStart\n                    );\n                }\n\n                totalFundsInUSDC = getBalance(usdc, address(this))\n                    .sub(totalCommissionLeft)\n                    .sub(peakReferralTotalCommissionLeft);\n\n                // Calculate manager commissions\n                uint256 commissionThisCycle = COMMISSION_RATE\n                    .mul(profit)\n                    .add(ASSET_FEE_RATE.mul(totalFundsInUSDC))\n                    .div(PRECISION);\n                _totalCommissionOfCycle[cycleNumber] = totalCommissionOfCycle(\n                    cycleNumber\n                )\n                    .add(commissionThisCycle); // account for penalties\n                totalCommissionLeft = totalCommissionLeft.add(\n                    commissionThisCycle\n                );\n\n                // Calculate referrer commissions\n                uint256 peakReferralCommissionThisCycle = PEAK_COMMISSION_RATE\n                    .mul(profit)\n                    .mul(peakReferralToken.totalSupply())\n                    .div(sToken.totalSupply())\n                    .div(PRECISION);\n                _peakReferralTotalCommissionOfCycle[cycleNumber] = peakReferralTotalCommissionOfCycle(\n                    cycleNumber\n                )\n                    .add(peakReferralCommissionThisCycle);\n                peakReferralTotalCommissionLeft = peakReferralTotalCommissionLeft\n                    .add(peakReferralCommissionThisCycle);\n\n                totalFundsInUSDC = getBalance(usdc, address(this))\n                    .sub(totalCommissionLeft)\n                    .sub(peakReferralTotalCommissionLeft);\n\n                // Give the developer PeakDeFi shares inflation funding\n                uint256 devFunding = devFundingRate\n                    .mul(sToken.totalSupply())\n                    .div(PRECISION);\n                require(sToken.generateTokens(devFundingAccount, devFunding));\n\n                // Emit event\n                emit TotalCommissionPaid(\n                    cycleNumber,\n                    totalCommissionOfCycle(cycleNumber)\n                );\n                emit PeakReferralTotalCommissionPaid(\n                    cycleNumber,\n                    peakReferralTotalCommissionOfCycle(cycleNumber)\n                );\n\n                _managePhaseEndBlock[cycleNumber] = block.number;\n\n                // Clear/update upgrade related data\n                if (nextVersion == address(this)) {\n                    // The developer proposed a candidate, but the managers decide to not upgrade at all\n                    // Reset upgrade process\n                    delete nextVersion;\n                    delete hasFinalizedNextVersion;\n                }\n                if (nextVersion != address(0)) {\n                    hasFinalizedNextVersion = true;\n                    emit FinalizedNextVersion(cycleNumber, nextVersion);\n                }\n\n                // Start new cycle\n                cycleNumber = cycleNumber.add(1);\n            }\n\n            cyclePhase = CyclePhase(addmod(uint256(cyclePhase), 1, 2));\n        }\n\n        startTimeOfCyclePhase = now;\n\n        // Reward caller if they're a manager\n        if (cToken.balanceOf(msg.sender) > 0) {\n            require(cToken.generateTokens(msg.sender, NEXT_PHASE_REWARD));\n        }\n\n        emit ChangedPhase(\n            cycleNumber,\n            uint256(cyclePhase),\n            now,\n            totalFundsInUSDC\n        );\n    }",
        "comments": [
            "/**",
            "     * Next phase transition handler",
            "     * @notice Moves the fund to the next phase in the investment cycle.",
            "     */",
            ""
        ],
        "comt": "/**\n     * Next phase transition handler\n     * @notice Moves the fund to the next phase in the investment cycle.\n     */\n",
        "@notice": "Moves the fund to the next phase in the investment cycle.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "developerInitiateUpgrade",
        "visibility": "public",
        "args": [
            {
                "name": "_candidate",
                "type": "address payable"
            }
        ],
        "func": "function developerInitiateUpgrade(address payable _candidate)\n        public\n        onlyOwner\n        notReadyForUpgrade\n        during(CyclePhase.Intermission)\n        nonReentrant\n        returns (bool _success)\n    {\n        if (_candidate == address(0) || _candidate == address(this)) {\n            return false;\n        }\n        nextVersion = _candidate;\n        emit DeveloperInitiatedUpgrade(cycleNumber, _candidate);\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "commissionBalanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "_manager",
                "type": "address"
            }
        ],
        "func": "function commissionBalanceOf(address _manager)\n        public\n        view\n        returns (uint256 _commission, uint256 _penalty)\n    {\n        if (lastCommissionRedemption(_manager) >= cycleNumber) {\n            return (0, 0);\n        }\n        uint256 cycle = lastCommissionRedemption(_manager) > 0\n            ? lastCommissionRedemption(_manager)\n            : 1;\n        uint256 cycleCommission;\n        uint256 cyclePenalty;\n        for (; cycle < cycleNumber; cycle++) {\n            (cycleCommission, cyclePenalty) = commissionOfAt(_manager, cycle);\n            _commission = _commission.add(cycleCommission);\n            _penalty = _penalty.add(cyclePenalty);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "commissionOfAt",
        "visibility": "public",
        "args": [
            {
                "name": "_manager",
                "type": "address"
            },
            {
                "name": "_cycle",
                "type": "uint256"
            }
        ],
        "func": "function commissionOfAt(address _manager, uint256 _cycle)\n        public\n        view\n        returns (uint256 _commission, uint256 _penalty)\n    {\n        if (hasRedeemedCommissionForCycle(_manager, _cycle)) {\n            return (0, 0);\n        }\n        // take risk into account\n        uint256 baseRepTokenBalance = cToken.balanceOfAt(\n            _manager,\n            managePhaseEndBlock(_cycle.sub(1))\n        );\n        uint256 baseStake = baseRepTokenBalance == 0\n            ? baseRiskStakeFallback(_manager)\n            : baseRepTokenBalance;\n        if (baseRepTokenBalance == 0 && baseRiskStakeFallback(_manager) == 0) {\n            return (0, 0);\n        }\n        uint256 riskTakenProportion = riskTakenInCycle(_manager, _cycle)\n            .mul(PRECISION)\n            .div(baseStake.mul(MIN_RISK_TIME)); // risk / threshold\n        riskTakenProportion = riskTakenProportion > PRECISION\n            ? PRECISION\n            : riskTakenProportion; // max proportion is 1\n\n        uint256 fullCommission = totalCommissionOfCycle(_cycle)\n            .mul(cToken.balanceOfAt(_manager, managePhaseEndBlock(_cycle)))\n            .div(cToken.totalSupplyAt(managePhaseEndBlock(_cycle)));\n\n        _commission = fullCommission.mul(riskTakenProportion).div(PRECISION);\n        _penalty = fullCommission.sub(_commission);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "redeemCommission",
        "visibility": "public",
        "args": [
            {
                "name": "_inShares",
                "type": "bool"
            }
        ],
        "func": "function redeemCommission(bool _inShares)\n        public\n        during(CyclePhase.Intermission)\n        nonReentrant\n    {\n        uint256 commission = __redeemCommission();\n\n        if (_inShares) {\n            // Deposit commission into fund\n            __deposit(commission);\n\n            // Emit deposit event\n            emit Deposit(\n                cycleNumber,\n                msg.sender,\n                USDC_ADDR,\n                commission,\n                commission,\n                now\n            );\n        } else {\n            // Transfer the commission in USDC\n            usdc.safeTransfer(msg.sender, commission);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "redeemCommissionForCycle",
        "visibility": "public",
        "args": [
            {
                "name": "_inShares",
                "type": "bool"
            },
            {
                "name": "_cycle",
                "type": "uint256"
            }
        ],
        "func": "function redeemCommissionForCycle(bool _inShares, uint256 _cycle)\n        public\n        during(CyclePhase.Intermission)\n        nonReentrant\n    {\n        require(_cycle < cycleNumber);\n\n        uint256 commission = __redeemCommissionForCycle(_cycle);\n\n        if (_inShares) {\n            // Deposit commission into fund\n            __deposit(commission);\n\n            // Emit deposit event\n            emit Deposit(\n                cycleNumber,\n                msg.sender,\n                USDC_ADDR,\n                commission,\n                commission,\n                now\n            );\n        } else {\n            // Transfer the commission in USDC\n            usdc.safeTransfer(msg.sender, commission);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "peakReferralCommissionBalanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "_referrer",
                "type": "address"
            }
        ],
        "func": "function peakReferralCommissionBalanceOf(address _referrer)\n        public\n        view\n        returns (uint256 _commission)\n    {\n        if (peakReferralLastCommissionRedemption(_referrer) >= cycleNumber) {\n            return (0);\n        }\n        uint256 cycle = peakReferralLastCommissionRedemption(_referrer) > 0\n            ? peakReferralLastCommissionRedemption(_referrer)\n            : 1;\n        uint256 cycleCommission;\n        for (; cycle < cycleNumber; cycle++) {\n            (cycleCommission) = peakReferralCommissionOfAt(_referrer, cycle);\n            _commission = _commission.add(cycleCommission);\n        }\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "peakReferralCommissionOfAt",
        "visibility": "public",
        "args": [
            {
                "name": "_referrer",
                "type": "address"
            },
            {
                "name": "_cycle",
                "type": "uint256"
            }
        ],
        "func": "function peakReferralCommissionOfAt(address _referrer, uint256 _cycle)\n        public\n        view\n        returns (uint256 _commission)\n    {\n        _commission = peakReferralTotalCommissionOfCycle(_cycle)\n            .mul(\n            peakReferralToken.balanceOfAt(\n                _referrer,\n                managePhaseEndBlock(_cycle)\n            )\n        )\n            .div(peakReferralToken.totalSupplyAt(managePhaseEndBlock(_cycle)));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "peakReferralRedeemCommission",
        "visibility": "public",
        "args": [],
        "func": "function peakReferralRedeemCommission()\n        public\n        during(CyclePhase.Intermission)\n        nonReentrant\n    {\n        uint256 commission = __peakReferralRedeemCommission();\n\n        // Transfer the commission in USDC\n        usdc.safeApprove(address(peakReward), commission);\n        peakReward.payCommission(msg.sender, address(usdc), commission, false);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "peakReferralRedeemCommissionForCycle",
        "visibility": "public",
        "args": [
            {
                "name": "_cycle",
                "type": "uint256"
            }
        ],
        "func": "function peakReferralRedeemCommissionForCycle(uint256 _cycle)\n        public\n        during(CyclePhase.Intermission)\n        nonReentrant\n    {\n        require(_cycle < cycleNumber);\n\n        uint256 commission = __peakReferralRedeemCommissionForCycle(_cycle);\n\n        // Transfer the commission in USDC\n        usdc.safeApprove(address(peakReward), commission);\n        peakReward.payCommission(msg.sender, address(usdc), commission, false);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "external",
        "args": [
            {
                "name": "mintAmount",
                "type": "uint"
            }
        ],
        "func": "function mint(uint mintAmount) external returns (uint) {\n    ERC20Detailed token = ERC20Detailed(_underlying);\n    require(token.transferFrom(msg.sender, address(this), mintAmount));\n\n    _balanceOf[msg.sender] = _balanceOf[msg.sender].add(mintAmount.mul(10 ** this.decimals()).div(PRECISION));\n    \n    return 0;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "redeemUnderlying",
        "visibility": "external",
        "args": [
            {
                "name": "redeemAmount",
                "type": "uint"
            }
        ],
        "func": "function redeemUnderlying(uint redeemAmount) external returns (uint) {\n    _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(redeemAmount.mul(10 ** this.decimals()).div(PRECISION));\n\n    ERC20Detailed token = ERC20Detailed(_underlying);\n    require(token.transfer(msg.sender, redeemAmount));\n\n    return 0;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "borrow",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function borrow(uint amount) external returns (uint) {\n    // add to borrow balance\n    _borrowBalanceCurrent[msg.sender] = _borrowBalanceCurrent[msg.sender].add(amount);\n\n    // transfer asset\n    ERC20Detailed token = ERC20Detailed(_underlying);\n    require(token.transfer(msg.sender, amount));\n\n    return 0;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repayBorrow",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function repayBorrow(uint amount) external returns (uint) {\n    // accept repayment\n    ERC20Detailed token = ERC20Detailed(_underlying);\n    uint256 repayAmount = amount == MAX_UINT ? _borrowBalanceCurrent[msg.sender] : amount;\n    require(token.transferFrom(msg.sender, address(this), repayAmount));\n\n    // subtract from borrow balance\n    _borrowBalanceCurrent[msg.sender] = _borrowBalanceCurrent[msg.sender].sub(repayAmount);\n\n    return 0;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address account) external view returns (uint) { return _balanceOf[account]; }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "borrowBalanceCurrent",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function borrowBalanceCurrent(address account) external returns (uint) { return _borrowBalanceCurrent[account]; }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "underlying",
        "visibility": "external",
        "args": [],
        "func": "function underlying() external view returns (address) { return _underlying; }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "exchangeRateCurrent",
        "visibility": "external",
        "args": [],
        "func": "function exchangeRateCurrent() external returns (uint) { return _exchangeRateCurrent; }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decimals",
        "visibility": "external",
        "args": [],
        "func": "function decimals() external view returns (uint) { return 8; }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "newToken",
        "visibility": "public",
        "args": [
            {
                "name": "underlying",
                "type": "address"
            },
            {
                "name": "comptroller",
                "type": "address"
            }
        ],
        "func": "function newToken(address underlying, address comptroller) public returns(address) {\n    require(createdTokens[underlying] == address(0));\n    \n    TestCERC20 token = new TestCERC20(underlying, comptroller);\n    createdTokens[underlying] = address(token);\n    emit CreatedToken(underlying, address(token));\n    return address(token);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "external",
        "args": [],
        "func": "function mint() external payable {\n    _balanceOf[msg.sender] = _balanceOf[msg.sender].add(msg.value.mul(10 ** this.decimals()).div(PRECISION));\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "redeemUnderlying",
        "visibility": "external",
        "args": [
            {
                "name": "redeemAmount",
                "type": "uint"
            }
        ],
        "func": "function redeemUnderlying(uint redeemAmount) external returns (uint) {\n    _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(redeemAmount.mul(10 ** this.decimals()).div(PRECISION));\n\n    msg.sender.transfer(redeemAmount);\n\n    return 0;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "borrow",
        "visibility": "external",
        "args": [
            {
                "name": "amount",
                "type": "uint"
            }
        ],
        "func": "function borrow(uint amount) external returns (uint) {\n    // add to borrow balance\n    _borrowBalanceCurrent[msg.sender] = _borrowBalanceCurrent[msg.sender].add(amount);\n\n    // transfer asset\n    msg.sender.transfer(amount);\n\n    return 0;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "repayBorrow",
        "visibility": "external",
        "args": [],
        "func": "function repayBorrow() external payable {\n    _borrowBalanceCurrent[msg.sender] = _borrowBalanceCurrent[msg.sender].sub(msg.value);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address account) external view returns (uint) { return _balanceOf[account]; }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "borrowBalanceCurrent",
        "visibility": "external",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function borrowBalanceCurrent(address account) external returns (uint) { return _borrowBalanceCurrent[account]; }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "exchangeRateCurrent",
        "visibility": "external",
        "args": [],
        "func": "function exchangeRateCurrent() external returns (uint) { return _exchangeRateCurrent; }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decimals",
        "visibility": "external",
        "args": [],
        "func": "function decimals() external view returns (uint) { return 8; }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "enterMarkets",
        "visibility": "external",
        "args": [
            {
                "name": "cTokens",
                "type": "address[] calldata"
            }
        ],
        "func": "function enterMarkets(address[] calldata cTokens) external returns (uint[] memory) {\n    uint[] memory errors = new uint[](cTokens.length);\n    for (uint256 i = 0; i < cTokens.length; i = i.add(1)) {\n      getAssetsIn[msg.sender].push(cTokens[i]);\n      errors[i] = 0;\n    }\n    return errors;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "markets",
        "visibility": "external",
        "args": [
            {
                "name": "/*cToken*/",
                "type": "address"
            }
        ],
        "func": "function markets(address /*cToken*/) external view returns (bool isListed, uint256 collateralFactorMantissa) {\n    return (true, collateralFactor);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setTokenPrice",
        "visibility": "public",
        "args": [
            {
                "name": "_token",
                "type": "address"
            },
            {
                "name": "_priceInUSDC",
                "type": "uint256"
            }
        ],
        "func": "function setTokenPrice(address _token, uint256 _priceInUSDC) public onlyOwner {\n    priceInUSDC[_token] = _priceInUSDC;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setAllTokenPrices",
        "visibility": "public",
        "args": [
            {
                "name": "_tokens",
                "type": "address[] memory"
            },
            {
                "name": "_pricesInUSDC",
                "type": "uint256[] memory"
            }
        ],
        "func": "function setAllTokenPrices(address[] memory _tokens, uint256[] memory _pricesInUSDC) public onlyOwner {\n    for (uint256 i = 0; i < _tokens.length; i = i.add(1)) {\n      priceInUSDC[_tokens[i]] = _pricesInUSDC[i];\n    }\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getExpectedRate",
        "visibility": "external",
        "args": [
            {
                "name": "src",
                "type": "ERC20Detailed"
            },
            {
                "name": "dest",
                "type": "ERC20Detailed"
            },
            {
                "name": "/*srcQty*/",
                "type": "uint"
            }
        ],
        "func": "function getExpectedRate(ERC20Detailed src, ERC20Detailed dest, uint /*srcQty*/) external view returns (uint expectedRate, uint slippageRate) \n  {\n    uint256 result = priceInUSDC[address(src)].mul(10**getDecimals(dest)).mul(PRECISION).div(priceInUSDC[address(dest)].mul(10**getDecimals(src)));\n    return (result, result);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "tradeWithHint",
        "visibility": "external",
        "args": [
            {
                "name": "src",
                "type": "ERC20Detailed"
            },
            {
                "name": "srcAmount",
                "type": "uint"
            },
            {
                "name": "dest",
                "type": "ERC20Detailed"
            },
            {
                "name": "destAddress",
                "type": "address payable"
            },
            {
                "name": "maxDestAmount",
                "type": "uint"
            },
            {
                "name": "/*minConversionRate*/",
                "type": "uint"
            },
            {
                "name": "/*walletId*/",
                "type": "address"
            },
            {
                "name": "/*hint*/",
                "type": "bytes calldata"
            }
        ],
        "func": "function tradeWithHint(\n    ERC20Detailed src,\n    uint srcAmount,\n    ERC20Detailed dest,\n    address payable destAddress,\n    uint maxDestAmount,\n    uint /*minConversionRate*/,\n    address /*walletId*/,\n    bytes calldata /*hint*/\n  )\n    external\n    payable\n    returns(uint)\n  {\n    require(calcDestAmount(src, srcAmount, dest) <= maxDestAmount);\n\n    if (address(src) == address(ETH_TOKEN_ADDRESS)) {\n      require(srcAmount == msg.value);\n    } else {\n      require(src.transferFrom(msg.sender, address(this), srcAmount));\n    }\n\n    if (address(dest) == address(ETH_TOKEN_ADDRESS)) {\n      destAddress.transfer(calcDestAmount(src, srcAmount, dest));\n    } else {\n      require(dest.transfer(destAddress, calcDestAmount(src, srcAmount, dest)));\n    }\n    return calcDestAmount(src, srcAmount, dest);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setTokenPrice",
        "visibility": "public",
        "args": [
            {
                "name": "_token",
                "type": "address"
            },
            {
                "name": "_priceInUSD",
                "type": "uint256"
            }
        ],
        "func": "function setTokenPrice(address _token, uint256 _priceInUSD) public onlyOwner {\n    priceInUSD[_token] = _priceInUSD;\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getUnderlyingPrice",
        "visibility": "external",
        "args": [
            {
                "name": "_cToken",
                "type": "address"
            }
        ],
        "func": "function getUnderlyingPrice(address _cToken) external view returns (uint) {\n    if (_cToken == CETH_ADDR) {\n      return priceInUSD[_cToken];\n    }\n    CERC20 cToken = CERC20(_cToken);\n    ERC20Detailed underlying = ERC20Detailed(cToken.underlying());\n    return priceInUSD[_cToken].mul(PRECISION).div(10 ** uint256(underlying.decimals()));\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "newToken",
        "visibility": "public",
        "args": [
            {
                "name": "name",
                "type": "string memory"
            },
            {
                "name": "symbol",
                "type": "string memory"
            },
            {
                "name": "decimals",
                "type": "uint8"
            }
        ],
        "func": "function newToken(string memory name, string memory symbol, uint8 decimals) public returns(address) {\n    bytes32 symbolHash = keccak256(abi.encodePacked(symbol));\n    require(createdTokens[symbolHash] == address(0));\n    \n    TestToken token = new TestToken(name, symbol, decimals);\n    token.addMinter(msg.sender);\n    token.renounceMinter();\n    createdTokens[symbolHash] = address(token);\n    emit CreatedToken(symbol, address(token));\n    return address(token);\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getToken",
        "visibility": "public",
        "args": [
            {
                "name": "symbol",
                "type": "string memory"
            }
        ],
        "func": "function getToken(string memory symbol) public view returns(address) {\n    return createdTokens[keccak256(abi.encodePacked(symbol))];\n  }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "update",
        "visibility": "external",
        "args": [],
        "func": "function update() external returns (bool success) {\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "consult",
        "visibility": "external",
        "args": [
            {
                "name": "token",
                "type": "address"
            },
            {
                "name": "amountIn",
                "type": "uint256"
            }
        ],
        "func": "function consult(address token, uint256 amountIn)\n        external\n        view\n        returns (uint256 amountOut)\n    {\n        return 3 * 10**5; // 1 PEAK = 0.30 USDC\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    }
]