[
    {
        "transactions": 6285,
        "function_num": 151
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view virtual override returns (uint256) {\n        // Counter underflow is impossible as _burnCounter cannot be incremented\n        // more than `_currentIndex - _startTokenId()` times.\n        unchecked {\n            return _currentIndex - _burnCounter - _startTokenId();\n        }\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the total number of tokens in existence.",
            "     * Burned tokens will reduce the count.",
            "     * To get the total number of tokens minted, please see {_totalMinted}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n",
        "@dev": "Returns the total number of tokens in existence. * Burned tokens will reduce the count. * To get the total number of tokens minted, please see {_totalMinted}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address owner) public view virtual override returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\n    }",
        "comments": [
            "",
            "    // =============================================================",
            "    //                    ADDRESS DATA OPERATIONS",
            "    // =============================================================",
            "",
            "    /**",
            "     * @dev Returns the number of tokens in `owner`'s account.",
            "     */",
            "    "
        ],
        "comt": "\n    // =============================================================\n    //                    ADDRESS DATA OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the number of tokens in `owner`'s account.\n     */\n    ",
        "@dev": "Returns the number of tokens in `owner`'s account.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "supportsInterface",
        "visibility": "public",
        "args": [
            {
                "name": "interfaceId",
                "type": "bytes4"
            }
        ],
        "func": "function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        // The interface IDs are constants representing the first 4 bytes\n        // of the XOR of all function selectors in the interface.\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\n    }",
        "comments": [
            "",
            "    // =============================================================",
            "    //                            IERC165",
            "    // =============================================================",
            "",
            "    /**",
            "     * @dev Returns true if this contract implements the interface defined by",
            "     * `interfaceId`. See the corresponding",
            "     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)",
            "     * to learn more about how these ids are created.",
            "     *",
            "     * This function call must use less than 30000 gas.",
            "     */",
            "    "
        ],
        "comt": "\n    // =============================================================\n    //                            IERC165\n    // =============================================================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    ",
        "@dev": "Returns true if this contract implements the interface defined by * `interfaceId`. See the corresponding * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified) * to learn more about how these ids are created. * * This function call must use less than 30000 gas.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "name",
        "visibility": "public",
        "args": [],
        "func": "function name() public view virtual override returns (string memory) {\n        return _name;\n    }",
        "comments": [
            "",
            "    // =============================================================",
            "    //                        IERC721Metadata",
            "    // =============================================================",
            "",
            "    /**",
            "     * @dev Returns the token collection name.",
            "     */",
            "    "
        ],
        "comt": "\n    // =============================================================\n    //                        IERC721Metadata\n    // =============================================================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    ",
        "@dev": "Returns the token collection name.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "symbol",
        "visibility": "public",
        "args": [],
        "func": "function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the token collection symbol.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the token collection symbol.\n     */\n",
        "@dev": "Returns the token collection symbol.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "tokenURI",
        "visibility": "public",
        "args": [
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n",
        "@dev": "Returns the Uniform Resource Identifier (URI) for `tokenId` token.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "ownerOf",
        "visibility": "public",
        "args": [
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return address(uint160(_packedOwnershipOf(tokenId)));\n    }",
        "comments": [
            "",
            "    // =============================================================",
            "    //                     OWNERSHIPS OPERATIONS",
            "    // =============================================================",
            "",
            "    /**",
            "     * @dev Returns the owner of the `tokenId` token.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `tokenId` must exist.",
            "     */",
            "    "
        ],
        "comt": "\n    // =============================================================\n    //                     OWNERSHIPS OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    ",
        "@dev": "Returns the owner of the `tokenId` token. * * Requirements: * * - `tokenId` must exist.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ownerOf(tokenId);\n\n        if (_msgSenderERC721A() != owner)\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\n                revert ApprovalCallerNotOwnerNorApproved();\n            }\n\n        _tokenApprovals[tokenId].value = to;\n        emit Approval(owner, to, tokenId);\n    }",
        "comments": [
            "/**",
            "     * @dev Gives permission to `to` to transfer `tokenId` token to another account.",
            "     * The approval is cleared when the token is transferred.",
            "     *",
            "     * Only a single account can be approved at a time, so approving the",
            "     * zero address clears previous approvals.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - The caller must own the token or be an approved operator.",
            "     * - `tokenId` must exist.",
            "     *",
            "     * Emits an {Approval} event.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n",
        "@dev": "Gives permission to `to` to transfer `tokenId` token to another account. * The approval is cleared when the token is transferred. * * Only a single account can be approved at a time, so approving the * zero address clears previous approvals. * * Requirements: * * - The caller must own the token or be an approved operator. * - `tokenId` must exist. * * Emits an {Approval} event.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getApproved",
        "visibility": "public",
        "args": [
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\n\n        return _tokenApprovals[tokenId].value;\n    }",
        "comments": [
            "/**",
            "     * @dev Returns the account approved for `tokenId` token.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `tokenId` must exist.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n",
        "@dev": "Returns the account approved for `tokenId` token. * * Requirements: * * - `tokenId` must exist.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setApprovalForAll",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "approved",
                "type": "bool"
            }
        ],
        "func": "function setApprovalForAll(address operator, bool approved) public virtual override {\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }",
        "comments": [
            "/**",
            "     * @dev Approve or remove `operator` as an operator for the caller.",
            "     * Operators can call {transferFrom} or {safeTransferFrom}",
            "     * for any token owned by the caller.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - The `operator` cannot be the caller.",
            "     *",
            "     * Emits an {ApprovalForAll} event.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n",
        "@dev": "Approve or remove `operator` as an operator for the caller. * Operators can call {transferFrom} or {safeTransferFrom} * for any token owned by the caller. * * Requirements: * * - The `operator` cannot be the caller. * * Emits an {ApprovalForAll} event.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "isApprovedForAll",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "operator",
                "type": "address"
            }
        ],
        "func": "function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }",
        "comments": [
            "/**",
            "     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.",
            "     *",
            "     * See {setApprovalForAll}.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}.\n     */\n",
        "@dev": "Returns if the `operator` is allowed to manage all of the assets of `owner`. * * See {setApprovalForAll}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\n\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\n\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\n\n        // The nested ifs save around 20+ gas over a compound boolean condition.\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\n\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        _beforeTokenTransfers(from, to, tokenId, 1);\n\n        // Clear approvals from the previous owner.\n        assembly {\n            if approvedAddress {\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\n                sstore(approvedAddressSlot, 0)\n            }\n        }\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\n        unchecked {\n            // We can directly increment and decrement the balances.\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\n\n            // Updates:\n            // - `address` to the next owner.\n            // - `startTimestamp` to the timestamp of transfering.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `true`.\n            _packedOwnerships[tokenId] = _packOwnershipData(\n                to,\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\n            );\n\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\n                if (_packedOwnerships[nextTokenId] == 0) {\n                    // If the next slot is within bounds.\n                    if (nextTokenId != _currentIndex) {\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfers(from, to, tokenId, 1);\n    }",
        "comments": [
            "/**",
            "     * @dev Transfers `tokenId` from `from` to `to`.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `from` cannot be the zero address.",
            "     * - `to` cannot be the zero address.",
            "     * - `tokenId` token must be owned by `from`.",
            "     * - If the caller is not `from`, it must be approved to move this token",
            "     * by either {approve} or {setApprovalForAll}.",
            "     *",
            "     * Emits a {Transfer} event.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n",
        "@dev": "Transfers `tokenId` from `from` to `to`. * * Requirements: * * - `from` cannot be the zero address. * - `to` cannot be the zero address. * - `tokenId` token must be owned by `from`. * - If the caller is not `from`, it must be approved to move this token * by either {approve} or {setApprovalForAll}. * * Emits a {Transfer} event.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "safeTransferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, '');\n    }",
        "comments": [
            "/**",
            "     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n     */\n",
        "@dev": "Equivalent to `safeTransferFrom(from, to, tokenId, '')`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "safeTransferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "name": "_data",
                "type": "bytes memory"
            }
        ],
        "func": "function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        transferFrom(from, to, tokenId);\n        if (to.code.length != 0)\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\n                revert TransferToNonERC721ReceiverImplementer();\n            }\n    }",
        "comments": [
            "/**",
            "     * @dev Safely transfers `tokenId` token from `from` to `to`.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `from` cannot be the zero address.",
            "     * - `to` cannot be the zero address.",
            "     * - `tokenId` token must exist and be owned by `from`.",
            "     * - If the caller is not `from`, it must be approved to move this token",
            "     * by either {approve} or {setApprovalForAll}.",
            "     * - If `to` refers to a smart contract, it must implement",
            "     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.",
            "     *",
            "     * Emits a {Transfer} event.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n",
        "@dev": "Safely transfers `tokenId` token from `from` to `to`. * * Requirements: * * - `from` cannot be the zero address. * - `to` cannot be the zero address. * - `tokenId` token must exist and be owned by `from`. * - If the caller is not `from`, it must be approved to move this token * by either {approve} or {setApprovalForAll}. * - If `to` refers to a smart contract, it must implement * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. * * Emits a {Transfer} event.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }",
        "comments": [
            "/*/",
            ""
        ],
        "comt": "/*/\n",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "permit",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "value",
                "type": "uint256"
            },
            {
                "name": "deadline",
                "type": "uint256"
            },
            {
                "name": "v",
                "type": "uint8"
            },
            {
                "name": "r",
                "type": "bytes32"
            },
            {
                "name": "s",
                "type": "bytes32"
            }
        ],
        "func": "function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }",
        "comments": [
            "/*/",
            ""
        ],
        "comt": "/*/\n",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "DOMAIN_SEPARATOR",
        "visibility": "public",
        "args": [],
        "func": "function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "ownerOf",
        "visibility": "public",
        "args": [
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }",
        "comments": [
            "/*/",
            ""
        ],
        "comt": "/*/\n",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setApprovalForAll",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "approved",
                "type": "bool"
            }
        ],
        "func": "function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "safeTransferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            }
        ],
        "func": "function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "safeTransferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "id",
                "type": "uint256"
            },
            {
                "name": "data",
                "type": "bytes calldata"
            }
        ],
        "func": "function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "supportsInterface",
        "visibility": "public",
        "args": [
            {
                "name": "interfaceId",
                "type": "bytes4"
            }
        ],
        "func": "function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }",
        "comments": [
            "/*/",
            ""
        ],
        "comt": "/*/\n",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "onERC721Received",
        "visibility": "external",
        "args": [
            {
                "name": "address",
                "type": "address"
            },
            {
                "name": "address",
                "type": "address"
            },
            {
                "name": "uint256",
                "type": "uint256"
            },
            {
                "name": "calldata",
                "type": "bytes"
            }
        ],
        "func": "function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }",
        "comments": [
            "",
            "/// @notice A generic interface for a contract which properly accepts ERC721 tokens.",
            "/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)",
            "abstract contract ERC721TokenReceiver {",
            "    "
        ],
        "comt": "\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    ",
        "@notice": "A generic interface for a contract which properly accepts ERC721 tokens.",
        "@author": "Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)abstract contract ERC721TokenReceiver {",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferAdministration",
        "visibility": "public",
        "args": [
            {
                "name": "newAdministrator",
                "type": "address"
            }
        ],
        "func": "function transferAdministration(address newAdministrator)\n        public\n        virtual\n        onlyAdministrator\n    {\n        if (newAdministrator == address(0)) {\n            revert NewAdministratorIsZeroAddress();\n        }\n        potentialAdministrator = newAdministrator;\n        emit PotentialAdministratorUpdated(newAdministrator);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "acceptAdministration",
        "visibility": "public",
        "args": [],
        "func": "function acceptAdministration() public virtual {\n        address _potentialAdministrator = potentialAdministrator;\n        if (msg.sender != _potentialAdministrator) {\n            revert NotNextAdministrator();\n        }\n        _transferAdministration(_potentialAdministrator);\n        delete potentialAdministrator;\n    }",
        "comments": [
            "",
            "    ///@notice Acept administration of smart contract, after the current administrator has initiated the process with transferAdministration",
            "    "
        ],
        "comt": "\n    ///@notice Acept administration of smart contract, after the current administrator has initiated the process with transferAdministration\n    ",
        "@notice": "Acept administration of smart contract, after the current administrator has initiated the process with transferAdministration",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cancelAdministrationTransfer",
        "visibility": "public",
        "args": [],
        "func": "function cancelAdministrationTransfer() public virtual onlyAdministrator {\n        delete potentialAdministrator;\n        emit PotentialAdministratorUpdated(address(0));\n    }",
        "comments": [
            "",
            "    ///@notice cancel administration transfer",
            "    "
        ],
        "comt": "\n    ///@notice cancel administration transfer\n    ",
        "@notice": "cancel administration transfer",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "renounceAdministration",
        "visibility": "public",
        "args": [],
        "func": "function renounceAdministration() public virtual onlyAdministrator {\n        delete administrator;\n        emit AdministratorUpdated(msg.sender, address(0));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferOwnership",
        "visibility": "public",
        "args": [
            {
                "name": "newPotentialOwner",
                "type": "address"
            }
        ],
        "func": "function transferOwnership(address newPotentialOwner)\n        public\n        virtual\n        onlyOwner\n    {\n        if (newPotentialOwner == address(0)) {\n            revert NewOwnerIsZeroAddress();\n        }\n        potentialOwner = newPotentialOwner;\n        emit PotentialOwnerUpdated(newPotentialOwner);\n    }",
        "comments": [
            "",
            "    ///@notice Initiate ownership transfer to newPotentialOwner. Note: new owner will have to manually acceptOwnership",
            "    ///@param newPotentialOwner address of potential new owner",
            "    "
        ],
        "comt": "\n    ///@notice Initiate ownership transfer to newPotentialOwner. Note: new owner will have to manually acceptOwnership\n    ///@param newPotentialOwner address of potential new owner\n    ",
        "@notice": "Initiate ownership transfer to newPotentialOwner. Note: new owner will have to manually acceptOwnership",
        "@param1": "newPotentialOwner address of potential new owner",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "acceptOwnership",
        "visibility": "public",
        "args": [],
        "func": "function acceptOwnership() public virtual {\n        address _potentialOwner = potentialOwner;\n        if (msg.sender != _potentialOwner) {\n            revert NotNextOwner();\n        }\n        delete potentialOwner;\n        emit PotentialOwnerUpdated(address(0));\n        _transferOwnership(_potentialOwner);\n    }",
        "comments": [
            "",
            "    ///@notice Claim ownership of smart contract, after the current owner has initiated the process with transferOwnership",
            "    "
        ],
        "comt": "\n    ///@notice Claim ownership of smart contract, after the current owner has initiated the process with transferOwnership\n    ",
        "@notice": "Claim ownership of smart contract, after the current owner has initiated the process with transferOwnership",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "cancelOwnershipTransfer",
        "visibility": "public",
        "args": [],
        "func": "function cancelOwnershipTransfer() public virtual onlyOwner {\n        delete potentialOwner;\n        emit PotentialOwnerUpdated(address(0));\n    }",
        "comments": [
            "",
            "    ///@notice cancel ownership transfer",
            "    "
        ],
        "comt": "\n    ///@notice cancel ownership transfer\n    ",
        "@notice": "cancel ownership transfer",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "owner",
        "visibility": "public",
        "args": [],
        "func": "function owner() public view virtual returns (address) {\n        return _owner;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "renounceOwnership",
        "visibility": "public",
        "args": [],
        "func": "function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }",
        "comments": [
            "/**",
            "     * @dev Leaves the contract without owner. It will not be possible to call",
            "     * `onlyOwner` functions anymore. Can only be called by the current owner.",
            "     *",
            "     * NOTE: Renouncing ownership will leave the contract without an owner,",
            "     * thereby removing any functionality that is only available to the owner.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n",
        "@dev": "Leaves the contract without owner. It will not be possible to call * `onlyOwner` functions anymore. Can only be called by the current owner. * * NOTE: Renouncing ownership will leave the contract without an owner, * thereby removing any functionality that is only available to the owner.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setBaseURI",
        "visibility": "external",
        "args": [
            {
                "name": "newBaseURI",
                "type": "string calldata"
            }
        ],
        "func": "function setBaseURI(string calldata newBaseURI) external override {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Set the new base URI.\n        _tokenBaseURI = newBaseURI;\n\n        // Emit an event with the update.\n        if (totalSupply() != 0) {\n            emit BatchMetadataUpdate(1, _nextTokenId() - 1);\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Sets the base URI for the token metadata and emits an event.",
            "     *",
            "     * @param newBaseURI The new base URI to set.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sets the base URI for the token metadata and emits an event.\n     *\n     * @param newBaseURI The new base URI to set.\n     */\n",
        "@notice": "Sets the base URI for the token metadata and emits an event.",
        "@param1": "newBaseURI The new base URI to set.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setContractURI",
        "visibility": "external",
        "args": [
            {
                "name": "newContractURI",
                "type": "string calldata"
            }
        ],
        "func": "function setContractURI(string calldata newContractURI) external override {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Set the new contract URI.\n        _contractURI = newContractURI;\n\n        // Emit an event with the update.\n        emit ContractURIUpdated(newContractURI);\n    }",
        "comments": [
            "/**",
            "     * @notice Sets the contract URI for contract metadata.",
            "     *",
            "     * @param newContractURI The new contract URI.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sets the contract URI for contract metadata.\n     *\n     * @param newContractURI The new contract URI.\n     */\n",
        "@notice": "Sets the contract URI for contract metadata.",
        "@param1": "newContractURI The new contract URI.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "emitBatchMetadataUpdate",
        "visibility": "external",
        "args": [
            {
                "name": "fromTokenId",
                "type": "uint256"
            },
            {
                "name": "toTokenId",
                "type": "uint256"
            }
        ],
        "func": "function emitBatchMetadataUpdate(uint256 fromTokenId, uint256 toTokenId)\n        external\n    {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Emit an event with the update.\n        emit BatchMetadataUpdate(fromTokenId, toTokenId);\n    }",
        "comments": [
            "/**",
            "     * @notice Emit an event notifying metadata updates for",
            "     *         a range of token ids, according to EIP-4906.",
            "     *",
            "     * @param fromTokenId The start token id.",
            "     * @param toTokenId   The end token id.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Emit an event notifying metadata updates for\n     *         a range of token ids, according to EIP-4906.\n     *\n     * @param fromTokenId The start token id.\n     * @param toTokenId   The end token id.\n     */\n",
        "@notice": "Emit an event notifying metadata updates for * a range of token ids, according to EIP-4906.",
        "@param1": "fromTokenId The start token id.",
        "@param2": "toTokenId The end token id.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setMaxSupply",
        "visibility": "external",
        "args": [
            {
                "name": "newMaxSupply",
                "type": "uint256"
            }
        ],
        "func": "function setMaxSupply(uint256 newMaxSupply) external {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Ensure the max supply does not exceed the maximum value of uint64.\n        if (newMaxSupply > 2**64 - 1) {\n            revert CannotExceedMaxSupplyOfUint64(newMaxSupply);\n        }\n\n        // Set the new max supply.\n        _maxSupply = newMaxSupply;\n\n        // Emit an event with the update.\n        emit MaxSupplyUpdated(newMaxSupply);\n    }",
        "comments": [
            "/**",
            "     * @notice Sets the max token supply and emits an event.",
            "     *",
            "     * @param newMaxSupply The new max supply to set.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sets the max token supply and emits an event.\n     *\n     * @param newMaxSupply The new max supply to set.\n     */\n",
        "@notice": "Sets the max token supply and emits an event.",
        "@param1": "newMaxSupply The new max supply to set.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setProvenanceHash",
        "visibility": "external",
        "args": [
            {
                "name": "newProvenanceHash",
                "type": "bytes32"
            }
        ],
        "func": "function setProvenanceHash(bytes32 newProvenanceHash) external {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Revert if any items have been minted.\n        if (_totalMinted() > 0) {\n            revert ProvenanceHashCannotBeSetAfterMintStarted();\n        }\n\n        // Keep track of the old provenance hash for emitting with the event.\n        bytes32 oldProvenanceHash = _provenanceHash;\n\n        // Set the new provenance hash.\n        _provenanceHash = newProvenanceHash;\n\n        // Emit an event with the update.\n        emit ProvenanceHashUpdated(oldProvenanceHash, newProvenanceHash);\n    }",
        "comments": [
            "/**",
            "     * @notice Sets the provenance hash and emits an event.",
            "     *",
            "     *         The provenance hash is used for random reveals, which",
            "     *         is a hash of the ordered metadata to show it has not been",
            "     *         modified after mint started.",
            "     *",
            "     *         This function will revert after the first item has been minted.",
            "     *",
            "     * @param newProvenanceHash The new provenance hash to set.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sets the provenance hash and emits an event.\n     *\n     *         The provenance hash is used for random reveals, which\n     *         is a hash of the ordered metadata to show it has not been\n     *         modified after mint started.\n     *\n     *         This function will revert after the first item has been minted.\n     *\n     * @param newProvenanceHash The new provenance hash to set.\n     */\n",
        "@notice": "Sets the provenance hash and emits an event. * * The provenance hash is used for random reveals, which * is a hash of the ordered metadata to show it has not been * modified after mint started. * * This function will revert after the first item has been minted.",
        "@param1": "newProvenanceHash The new provenance hash to set.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "setRoyaltyInfo",
        "visibility": "external",
        "args": [
            {
                "name": "newInfo",
                "type": "RoyaltyInfo calldata"
            }
        ],
        "func": "function setRoyaltyInfo(RoyaltyInfo calldata newInfo) external {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Revert if the new royalty address is the zero address.\n        if (newInfo.royaltyAddress == address(0)) {\n            revert RoyaltyAddressCannotBeZeroAddress();\n        }\n\n        // Revert if the new basis points is greater than 10_000.\n        if (newInfo.royaltyBps > 10_000) {\n            revert InvalidRoyaltyBasisPoints(newInfo.royaltyBps);\n        }\n\n        // Set the new royalty info.\n        _royaltyInfo = newInfo;\n\n        // Emit an event with the updated params.\n        emit RoyaltyInfoUpdated(newInfo.royaltyAddress, newInfo.royaltyBps);\n    }",
        "comments": [
            "/**",
            "     * @notice Sets the address and basis points for royalties.",
            "     *",
            "     * @param newInfo The struct to configure royalties.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Sets the address and basis points for royalties.\n     *\n     * @param newInfo The struct to configure royalties.\n     */\n",
        "@notice": "Sets the address and basis points for royalties.",
        "@param1": "newInfo The struct to configure royalties.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "baseURI",
        "visibility": "external",
        "args": [],
        "func": "function baseURI() external view override returns (string memory) {\n        return _baseURI();\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the base URI for token metadata.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the base URI for token metadata.\n     */\n",
        "@notice": "Returns the base URI for token metadata.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "contractURI",
        "visibility": "external",
        "args": [],
        "func": "function contractURI() external view override returns (string memory) {\n        return _contractURI;\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the contract URI for contract metadata.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the contract URI for contract metadata.\n     */\n",
        "@notice": "Returns the contract URI for contract metadata.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "maxSupply",
        "visibility": "public",
        "args": [],
        "func": "function maxSupply() public view returns (uint256) {\n        return _maxSupply;\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the max token supply.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the max token supply.\n     */\n",
        "@notice": "Returns the max token supply.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "provenanceHash",
        "visibility": "external",
        "args": [],
        "func": "function provenanceHash() external view override returns (bytes32) {\n        return _provenanceHash;\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the provenance hash.",
            "     *         The provenance hash is used for random reveals, which",
            "     *         is a hash of the ordered metadata to show it is unmodified",
            "     *         after mint has started.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the provenance hash.\n     *         The provenance hash is used for random reveals, which\n     *         is a hash of the ordered metadata to show it is unmodified\n     *         after mint has started.\n     */\n",
        "@notice": "Returns the provenance hash. * The provenance hash is used for random reveals, which * is a hash of the ordered metadata to show it is unmodified * after mint has started.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "royaltyAddress",
        "visibility": "external",
        "args": [],
        "func": "function royaltyAddress() external view returns (address) {\n        return _royaltyInfo.royaltyAddress;\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the address that receives royalties.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the address that receives royalties.\n     */\n",
        "@notice": "Returns the address that receives royalties.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "royaltyBasisPoints",
        "visibility": "external",
        "args": [],
        "func": "function royaltyBasisPoints() external view returns (uint256) {\n        return _royaltyInfo.royaltyBps;\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the royalty basis points out of 10_000.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the royalty basis points out of 10_000.\n     */\n",
        "@notice": "Returns the royalty basis points out of 10_000.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "royaltyInfo",
        "visibility": "external",
        "args": [
            {
                "name": "uint256",
                "type": "uint256"
            },
            {
                "name": "_salePrice",
                "type": "/* _tokenId */\n        uint256"
            }
        ],
        "func": "function royaltyInfo(\n        uint256, /* _tokenId */\n        uint256 _salePrice\n    ) external view returns (address receiver, uint256 royaltyAmount) {\n        // Put the royalty info on the stack for more efficient access.\n        RoyaltyInfo storage info = _royaltyInfo;\n\n        // Set the royalty amount to the sale price times the royalty basis\n        // points divided by 10_000.\n        royaltyAmount = (_salePrice * info.royaltyBps) / 10_000;\n\n        // Set the receiver of the royalty.\n        receiver = info.royaltyAddress;\n    }",
        "comments": [
            "/**",
            "     * @notice Called with the sale price to determine how much royalty",
            "     *         is owed and to whom.",
            "     *",
            "     * @ param  _tokenId     The NFT asset queried for royalty information.",
            "     * @param  _salePrice    The sale price of the NFT asset specified by",
            "     *                       _tokenId.",
            "     *",
            "     * @return receiver      Address of who should be sent the royalty payment.",
            "     * @return royaltyAmount The royalty payment amount for _salePrice.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Called with the sale price to determine how much royalty\n     *         is owed and to whom.\n     *\n     * @ param  _tokenId     The NFT asset queried for royalty information.\n     * @param  _salePrice    The sale price of the NFT asset specified by\n     *                       _tokenId.\n     *\n     * @return receiver      Address of who should be sent the royalty payment.\n     * @return royaltyAmount The royalty payment amount for _salePrice.\n     */\n",
        "@notice": "Called with the sale price to determine how much royalty * is owed and to whom.",
        "@": "param _tokenId The NFT asset queried for royalty information.",
        "@param1": "_salePrice The sale price of the NFT asset specified by * _tokenId.",
        "@return1": "receiver Address of who should be sent the royalty payment.",
        "@return2": "royaltyAmount The royalty payment amount for _salePrice.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "supportsInterface",
        "visibility": "public",
        "args": [
            {
                "name": "interfaceId",
                "type": "bytes4"
            }
        ],
        "func": "function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(IERC165, ERC721A)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC2981).interfaceId ||\n            interfaceId == 0x49064906 || // ERC-4906\n            super.supportsInterface(interfaceId);\n    }",
        "comments": [
            "/**",
            "     * @notice Returns whether the interface is supported.",
            "     *",
            "     * @param interfaceId The interface id to check against.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns whether the interface is supported.\n     *\n     * @param interfaceId The interface id to check against.\n     */\n",
        "@notice": "Returns whether the interface is supported.",
        "@param1": "interfaceId The interface id to check against.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mintSeaDrop",
        "visibility": "external",
        "args": [
            {
                "name": "minter",
                "type": "address"
            },
            {
                "name": "quantity",
                "type": "uint256"
            }
        ],
        "func": "function mintSeaDrop(address minter, uint256 quantity)\n        external\n        virtual\n        override\n    {\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(msg.sender);\n\n        // Extra safety check to ensure the max supply is not exceeded.\n        if (_totalMinted() + quantity > maxSupply()) {\n            revert MintQuantityExceedsMaxSupply(\n                _totalMinted() + quantity,\n                maxSupply()\n            );\n        }\n\n        // Mint the quantity of tokens to the minter.\n        _mint(minter, quantity);\n    }",
        "comments": [
            "/**",
            "     * @notice Mint tokens, restricted to the SeaDrop contract.",
            "     *",
            "     * @param minter   The address to mint to.",
            "     * @param quantity The number of tokens to mint.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Mint tokens, restricted to the SeaDrop contract.\n     *\n     * @param minter   The address to mint to.\n     * @param quantity The number of tokens to mint.\n     */\n",
        "@notice": "Mint tokens, restricted to the SeaDrop contract.",
        "@param1": "minter The address to mint to.",
        "@param2": "quantity The number of tokens to mint.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateAllowedSeaDrop",
        "visibility": "external",
        "args": [
            {
                "name": "allowedSeaDrop",
                "type": "address[] calldata"
            }
        ],
        "func": "function updateAllowedSeaDrop(address[] calldata allowedSeaDrop)\n        external\n        override\n        onlyOwnerOrAdministrator\n    {\n        _updateAllowedSeaDrop(allowedSeaDrop);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the allowed SeaDrop contracts.",
            "     *         Only the owner or administrator can use this function.",
            "     *",
            "     * @param allowedSeaDrop The allowed SeaDrop addresses.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the allowed SeaDrop contracts.\n     *         Only the owner or administrator can use this function.\n     *\n     * @param allowedSeaDrop The allowed SeaDrop addresses.\n     */\n",
        "@notice": "Update the allowed SeaDrop contracts. * Only the owner or administrator can use this function.",
        "@param1": "allowedSeaDrop The allowed SeaDrop addresses.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updatePublicDrop",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "publicDrop",
                "type": "PublicDrop calldata"
            }
        ],
        "func": "function updatePublicDrop(\n        address seaDropImpl,\n        PublicDrop calldata publicDrop\n    ) external virtual override onlyOwnerOrAdministrator {\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Track the previous public drop data.\n        PublicDrop memory retrieved = ISeaDrop(seaDropImpl).getPublicDrop(\n            address(this)\n        );\n\n        // Track the newly supplied drop data.\n        PublicDrop memory supplied = publicDrop;\n\n        // Only the administrator (OpenSea) can set feeBps.\n        if (msg.sender != administrator) {\n            // Administrator must first set fee.\n            if (retrieved.maxTotalMintableByWallet == 0) {\n                revert AdministratorMustInitializeWithFee();\n            }\n            supplied.feeBps = retrieved.feeBps;\n            supplied.restrictFeeRecipients = true;\n        } else {\n            // Administrator can only initialize\n            // (maxTotalMintableByWallet > 0) and set\n            // feeBps/restrictFeeRecipients.\n            uint16 maxTotalMintableByWallet = retrieved\n                .maxTotalMintableByWallet;\n            retrieved.maxTotalMintableByWallet = maxTotalMintableByWallet > 0\n                ? maxTotalMintableByWallet\n                : 1;\n            retrieved.feeBps = supplied.feeBps;\n            retrieved.restrictFeeRecipients = true;\n            supplied = retrieved;\n        }\n\n        // Update the public drop data on SeaDrop.\n        ISeaDrop(seaDropImpl).updatePublicDrop(supplied);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the public drop data for this nft contract on SeaDrop.",
            "     *         Only the owner or administrator can use this function.",
            "     *",
            "     *         The administrator can only update `feeBps`.",
            "     *",
            "     * @param seaDropImpl The allowed SeaDrop contract.",
            "     * @param publicDrop  The public drop data.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the public drop data for this nft contract on SeaDrop.\n     *         Only the owner or administrator can use this function.\n     *\n     *         The administrator can only update `feeBps`.\n     *\n     * @param seaDropImpl The allowed SeaDrop contract.\n     * @param publicDrop  The public drop data.\n     */\n",
        "@notice": "Update the public drop data for this nft contract on SeaDrop. * Only the owner or administrator can use this function. * * The administrator can only update `feeBps`.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "publicDrop The public drop data.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateAllowList",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "allowListData",
                "type": "AllowListData calldata"
            }
        ],
        "func": "function updateAllowList(\n        address seaDropImpl,\n        AllowListData calldata allowListData\n    ) external virtual override onlyOwnerOrAdministrator {\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Update the allow list on SeaDrop.\n        ISeaDrop(seaDropImpl).updateAllowList(allowListData);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the allow list data for this nft contract on SeaDrop.",
            "     *         Only the owner or administrator can use this function.",
            "     *",
            "     * @param seaDropImpl   The allowed SeaDrop contract.",
            "     * @param allowListData The allow list data.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the allow list data for this nft contract on SeaDrop.\n     *         Only the owner or administrator can use this function.\n     *\n     * @param seaDropImpl   The allowed SeaDrop contract.\n     * @param allowListData The allow list data.\n     */\n",
        "@notice": "Update the allow list data for this nft contract on SeaDrop. * Only the owner or administrator can use this function.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "allowListData The allow list data.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateTokenGatedDrop",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "allowedNftToken",
                "type": "address"
            },
            {
                "name": "dropStage",
                "type": "TokenGatedDropStage calldata"
            }
        ],
        "func": "function updateTokenGatedDrop(\n        address seaDropImpl,\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external virtual override onlyOwnerOrAdministrator {\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Track the previous drop stage data.\n        TokenGatedDropStage memory retrieved = ISeaDrop(seaDropImpl)\n            .getTokenGatedDrop(address(this), allowedNftToken);\n\n        // Track the newly supplied drop data.\n        TokenGatedDropStage memory supplied = dropStage;\n\n        // Only the administrator (OpenSea) can set feeBps on Partner\n        // contracts.\n        if (msg.sender != administrator) {\n            // Administrator must first set fee.\n            if (retrieved.maxTotalMintableByWallet == 0) {\n                revert AdministratorMustInitializeWithFee();\n            }\n            supplied.feeBps = retrieved.feeBps;\n            supplied.restrictFeeRecipients = true;\n        } else {\n            // Administrator can only initialize\n            // (maxTotalMintableByWallet > 0) and set\n            // feeBps/restrictFeeRecipients.\n            uint16 maxTotalMintableByWallet = retrieved\n                .maxTotalMintableByWallet;\n            retrieved.maxTotalMintableByWallet = maxTotalMintableByWallet > 0\n                ? maxTotalMintableByWallet\n                : 1;\n            retrieved.feeBps = supplied.feeBps;\n            retrieved.restrictFeeRecipients = true;\n            supplied = retrieved;\n        }\n\n        // Update the token gated drop stage.\n        ISeaDrop(seaDropImpl).updateTokenGatedDrop(allowedNftToken, supplied);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the token gated drop stage data for this nft contract",
            "     *         on SeaDrop.",
            "     *         Only the owner or administrator can use this function.",
            "     *",
            "     *         The administrator must first set `feeBps`.",
            "     *",
            "     *         Note: If two INonFungibleSeaDropToken tokens are doing",
            "     *         simultaneous token gated drop promotions for each other,",
            "     *         they can be minted by the same actor until",
            "     *         `maxTokenSupplyForStage` is reached. Please ensure the",
            "     *         `allowedNftToken` is not running an active drop during the",
            "     *         `dropStage` time period.",
            "     *",
            "     * @param seaDropImpl     The allowed SeaDrop contract.",
            "     * @param allowedNftToken The allowed nft token.",
            "     * @param dropStage       The token gated drop stage data.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the token gated drop stage data for this nft contract\n     *         on SeaDrop.\n     *         Only the owner or administrator can use this function.\n     *\n     *         The administrator must first set `feeBps`.\n     *\n     *         Note: If two INonFungibleSeaDropToken tokens are doing\n     *         simultaneous token gated drop promotions for each other,\n     *         they can be minted by the same actor until\n     *         `maxTokenSupplyForStage` is reached. Please ensure the\n     *         `allowedNftToken` is not running an active drop during the\n     *         `dropStage` time period.\n     *\n     * @param seaDropImpl     The allowed SeaDrop contract.\n     * @param allowedNftToken The allowed nft token.\n     * @param dropStage       The token gated drop stage data.\n     */\n",
        "@notice": "Update the token gated drop stage data for this nft contract * on SeaDrop. * Only the owner or administrator can use this function. * * The administrator must first set `feeBps`. * * Note: If two INonFungibleSeaDropToken tokens are doing * simultaneous token gated drop promotions for each other, * they can be minted by the same actor until * `maxTokenSupplyForStage` is reached. Please ensure the * `allowedNftToken` is not running an active drop during the * `dropStage` time period.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "allowedNftToken The allowed nft token.",
        "@param3": "dropStage The token gated drop stage data.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "updateDropURI",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "dropURI",
                "type": "string calldata"
            }
        ],
        "func": "function updateDropURI(address seaDropImpl, string calldata dropURI)\n        external\n        virtual\n        override\n        onlyOwnerOrAdministrator\n    {\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Update the drop URI.\n        ISeaDrop(seaDropImpl).updateDropURI(dropURI);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the drop URI for this nft contract on SeaDrop.",
            "     *         Only the owner or administrator can use this function.",
            "     *",
            "     * @param seaDropImpl The allowed SeaDrop contract.",
            "     * @param dropURI     The new drop URI.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the drop URI for this nft contract on SeaDrop.\n     *         Only the owner or administrator can use this function.\n     *\n     * @param seaDropImpl The allowed SeaDrop contract.\n     * @param dropURI     The new drop URI.\n     */\n",
        "@notice": "Update the drop URI for this nft contract on SeaDrop. * Only the owner or administrator can use this function.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "dropURI The new drop URI.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateAllowedFeeRecipient",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "feeRecipient",
                "type": "address"
            },
            {
                "name": "allowed",
                "type": "bool"
            }
        ],
        "func": "function updateAllowedFeeRecipient(\n        address seaDropImpl,\n        address feeRecipient,\n        bool allowed\n    ) external override onlyAdministrator {\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Update the allowed fee recipient.\n        ISeaDrop(seaDropImpl).updateAllowedFeeRecipient(feeRecipient, allowed);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the allowed fee recipient for this nft contract",
            "     *         on SeaDrop.",
            "     *         Only the administrator can set the allowed fee recipient.",
            "     *",
            "     * @param seaDropImpl  The allowed SeaDrop contract.",
            "     * @param feeRecipient The new fee recipient.",
            "     * @param allowed      If the fee recipient is allowed.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the allowed fee recipient for this nft contract\n     *         on SeaDrop.\n     *         Only the administrator can set the allowed fee recipient.\n     *\n     * @param seaDropImpl  The allowed SeaDrop contract.\n     * @param feeRecipient The new fee recipient.\n     * @param allowed      If the fee recipient is allowed.\n     */\n",
        "@notice": "Update the allowed fee recipient for this nft contract * on SeaDrop. * Only the administrator can set the allowed fee recipient.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "feeRecipient The new fee recipient.",
        "@param3": "allowed If the fee recipient is allowed.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateSignedMintValidationParams",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "signer",
                "type": "address"
            },
            {
                "name": "signedMintValidationParams",
                "type": "SignedMintValidationParams memory"
            }
        ],
        "func": "function updateSignedMintValidationParams(\n        address seaDropImpl,\n        address signer,\n        SignedMintValidationParams memory signedMintValidationParams\n    ) external virtual override onlyOwnerOrAdministrator {\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Track the previous signed mint validation params.\n        SignedMintValidationParams memory retrieved = ISeaDrop(seaDropImpl)\n            .getSignedMintValidationParams(address(this), signer);\n\n        // Track the newly supplied params.\n        SignedMintValidationParams memory supplied = signedMintValidationParams;\n\n        // Only the administrator (OpenSea) can set feeBps on Partner\n        // contracts.\n        if (msg.sender != administrator) {\n            // Administrator must first set fee.\n            if (retrieved.maxMaxTotalMintableByWallet == 0) {\n                revert AdministratorMustInitializeWithFee();\n            }\n            supplied.minFeeBps = retrieved.minFeeBps;\n            supplied.maxFeeBps = retrieved.maxFeeBps;\n        } else {\n            // Administrator can only initialize\n            // (maxTotalMintableByWallet > 0) and set\n            // feeBps/restrictFeeRecipients.\n            uint24 maxMaxTotalMintableByWallet = retrieved\n                .maxMaxTotalMintableByWallet;\n            retrieved\n                .maxMaxTotalMintableByWallet = maxMaxTotalMintableByWallet > 0\n                ? maxMaxTotalMintableByWallet\n                : 1;\n            retrieved.minFeeBps = supplied.minFeeBps;\n            retrieved.maxFeeBps = supplied.maxFeeBps;\n            supplied = retrieved;\n        }\n\n        // Update the signed mint validation params.\n        ISeaDrop(seaDropImpl).updateSignedMintValidationParams(\n            signer,\n            supplied\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Update the server-side signers for this nft contract",
            "     *         on SeaDrop.",
            "     *         Only the owner or administrator can use this function.",
            "     *",
            "     * @param seaDropImpl                The allowed SeaDrop contract.",
            "     * @param signer                     The signer to update.",
            "     * @param signedMintValidationParams Minimum and maximum parameters to",
            "     *                                   enforce for signed mints.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the server-side signers for this nft contract\n     *         on SeaDrop.\n     *         Only the owner or administrator can use this function.\n     *\n     * @param seaDropImpl                The allowed SeaDrop contract.\n     * @param signer                     The signer to update.\n     * @param signedMintValidationParams Minimum and maximum parameters to\n     *                                   enforce for signed mints.\n     */\n",
        "@notice": "Update the server-side signers for this nft contract * on SeaDrop. * Only the owner or administrator can use this function.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "signer The signer to update.",
        "@param3": "signedMintValidationParams Minimum and maximum parameters to * enforce for signed mints.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updatePayer",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "payer",
                "type": "address"
            },
            {
                "name": "allowed",
                "type": "bool"
            }
        ],
        "func": "function updatePayer(\n        address seaDropImpl,\n        address payer,\n        bool allowed\n    ) external virtual override onlyOwnerOrAdministrator {\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Update the payer.\n        ISeaDrop(seaDropImpl).updatePayer(payer, allowed);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the allowed payers for this nft contract on SeaDrop.",
            "     *         Only the owner or administrator can use this function.",
            "     *",
            "     * @param seaDropImpl The allowed SeaDrop contract.",
            "     * @param payer       The payer to update.",
            "     * @param allowed     Whether the payer is allowed.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the allowed payers for this nft contract on SeaDrop.\n     *         Only the owner or administrator can use this function.\n     *\n     * @param seaDropImpl The allowed SeaDrop contract.\n     * @param payer       The payer to update.\n     * @param allowed     Whether the payer is allowed.\n     */\n",
        "@notice": "Update the allowed payers for this nft contract on SeaDrop. * Only the owner or administrator can use this function.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "payer The payer to update.",
        "@param3": "allowed Whether the payer is allowed.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateAllowedSeaDrop",
        "visibility": "external",
        "args": [
            {
                "name": "allowedSeaDrop",
                "type": "address[] calldata"
            }
        ],
        "func": "function updateAllowedSeaDrop(address[] calldata allowedSeaDrop)\n        external\n        virtual\n        override\n        onlyOwner\n    {\n        _updateAllowedSeaDrop(allowedSeaDrop);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the allowed SeaDrop contracts.",
            "     *         Only the owner or administrator can use this function.",
            "     *",
            "     * @param allowedSeaDrop The allowed SeaDrop addresses.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the allowed SeaDrop contracts.\n     *         Only the owner or administrator can use this function.\n     *\n     * @param allowedSeaDrop The allowed SeaDrop addresses.\n     */\n",
        "@notice": "Update the allowed SeaDrop contracts. * Only the owner or administrator can use this function.",
        "@param1": "allowedSeaDrop The allowed SeaDrop addresses.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mintSeaDrop",
        "visibility": "external",
        "args": [
            {
                "name": "minter",
                "type": "address"
            },
            {
                "name": "quantity",
                "type": "uint256"
            }
        ],
        "func": "function mintSeaDrop(address minter, uint256 quantity)\n        external\n        virtual\n        override\n        nonReentrant\n    {\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(msg.sender);\n\n        // Extra safety check to ensure the max supply is not exceeded.\n        if (_totalMinted() + quantity > maxSupply()) {\n            revert MintQuantityExceedsMaxSupply(\n                _totalMinted() + quantity,\n                maxSupply()\n            );\n        }\n\n        // Mint the quantity of tokens to the minter.\n        _safeMint(minter, quantity);\n    }",
        "comments": [
            "/**",
            "     * @notice Mint tokens, restricted to the SeaDrop contract.",
            "     *",
            "     * @dev    NOTE: If a token registers itself with multiple SeaDrop",
            "     *         contracts, the implementation of this function should guard",
            "     *         against reentrancy. If the implementing token uses",
            "     *         _safeMint(), or a feeRecipient with a malicious receive() hook",
            "     *         is specified, the token or fee recipients may be able to execute",
            "     *         another mint in the same transaction via a separate SeaDrop",
            "     *         contract.",
            "     *         This is dangerous if an implementing token does not correctly",
            "     *         update the minterNumMinted and currentTotalSupply values before",
            "     *         transferring minted tokens, as SeaDrop references these values",
            "     *         to enforce token limits on a per-wallet and per-stage basis.",
            "     *",
            "     *         ERC721A tracks these values automatically, but this note and",
            "     *         nonReentrant modifier are left here to encourage best-practices",
            "     *         when referencing this contract.",
            "     *",
            "     * @param minter   The address to mint to.",
            "     * @param quantity The number of tokens to mint.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Mint tokens, restricted to the SeaDrop contract.\n     *\n     * @dev    NOTE: If a token registers itself with multiple SeaDrop\n     *         contracts, the implementation of this function should guard\n     *         against reentrancy. If the implementing token uses\n     *         _safeMint(), or a feeRecipient with a malicious receive() hook\n     *         is specified, the token or fee recipients may be able to execute\n     *         another mint in the same transaction via a separate SeaDrop\n     *         contract.\n     *         This is dangerous if an implementing token does not correctly\n     *         update the minterNumMinted and currentTotalSupply values before\n     *         transferring minted tokens, as SeaDrop references these values\n     *         to enforce token limits on a per-wallet and per-stage basis.\n     *\n     *         ERC721A tracks these values automatically, but this note and\n     *         nonReentrant modifier are left here to encourage best-practices\n     *         when referencing this contract.\n     *\n     * @param minter   The address to mint to.\n     * @param quantity The number of tokens to mint.\n     */\n",
        "@notice": "Mint tokens, restricted to the SeaDrop contract.",
        "@dev": "NOTE: If a token registers itself with multiple SeaDrop * contracts, the implementation of this function should guard * against reentrancy. If the implementing token uses * _safeMint(), or a feeRecipient with a malicious receive() hook * is specified, the token or fee recipients may be able to execute * another mint in the same transaction via a separate SeaDrop * contract. * This is dangerous if an implementing token does not correctly * update the minterNumMinted and currentTotalSupply values before * transferring minted tokens, as SeaDrop references these values * to enforce token limits on a per-wallet and per-stage basis. * * ERC721A tracks these values automatically, but this note and * nonReentrant modifier are left here to encourage best-practices * when referencing this contract.",
        "@param1": "minter The address to mint to.",
        "@param2": "quantity The number of tokens to mint.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updatePublicDrop",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "publicDrop",
                "type": "PublicDrop calldata"
            }
        ],
        "func": "function updatePublicDrop(\n        address seaDropImpl,\n        PublicDrop calldata publicDrop\n    ) external virtual override {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Update the public drop data on SeaDrop.\n        ISeaDrop(seaDropImpl).updatePublicDrop(publicDrop);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the public drop data for this nft contract on SeaDrop.",
            "     *         Only the owner can use this function.",
            "     *",
            "     * @param seaDropImpl The allowed SeaDrop contract.",
            "     * @param publicDrop  The public drop data.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the public drop data for this nft contract on SeaDrop.\n     *         Only the owner can use this function.\n     *\n     * @param seaDropImpl The allowed SeaDrop contract.\n     * @param publicDrop  The public drop data.\n     */\n",
        "@notice": "Update the public drop data for this nft contract on SeaDrop. * Only the owner can use this function.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "publicDrop The public drop data.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateAllowList",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "allowListData",
                "type": "AllowListData calldata"
            }
        ],
        "func": "function updateAllowList(\n        address seaDropImpl,\n        AllowListData calldata allowListData\n    ) external virtual override {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Update the allow list on SeaDrop.\n        ISeaDrop(seaDropImpl).updateAllowList(allowListData);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the allow list data for this nft contract on SeaDrop.",
            "     *         Only the owner can use this function.",
            "     *",
            "     * @param seaDropImpl   The allowed SeaDrop contract.",
            "     * @param allowListData The allow list data.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the allow list data for this nft contract on SeaDrop.\n     *         Only the owner can use this function.\n     *\n     * @param seaDropImpl   The allowed SeaDrop contract.\n     * @param allowListData The allow list data.\n     */\n",
        "@notice": "Update the allow list data for this nft contract on SeaDrop. * Only the owner can use this function.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "allowListData The allow list data.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateTokenGatedDrop",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "allowedNftToken",
                "type": "address"
            },
            {
                "name": "dropStage",
                "type": "TokenGatedDropStage calldata"
            }
        ],
        "func": "function updateTokenGatedDrop(\n        address seaDropImpl,\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external virtual override {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Update the token gated drop stage.\n        ISeaDrop(seaDropImpl).updateTokenGatedDrop(allowedNftToken, dropStage);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the token gated drop stage data for this nft contract",
            "     *         on SeaDrop.",
            "     *         Only the owner can use this function.",
            "     *",
            "     *         Note: If two INonFungibleSeaDropToken tokens are doing",
            "     *         simultaneous token gated drop promotions for each other,",
            "     *         they can be minted by the same actor until",
            "     *         `maxTokenSupplyForStage` is reached. Please ensure the",
            "     *         `allowedNftToken` is not running an active drop during the",
            "     *         `dropStage` time period.",
            "     *",
            "     * @param seaDropImpl     The allowed SeaDrop contract.",
            "     * @param allowedNftToken The allowed nft token.",
            "     * @param dropStage       The token gated drop stage data.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the token gated drop stage data for this nft contract\n     *         on SeaDrop.\n     *         Only the owner can use this function.\n     *\n     *         Note: If two INonFungibleSeaDropToken tokens are doing\n     *         simultaneous token gated drop promotions for each other,\n     *         they can be minted by the same actor until\n     *         `maxTokenSupplyForStage` is reached. Please ensure the\n     *         `allowedNftToken` is not running an active drop during the\n     *         `dropStage` time period.\n     *\n     * @param seaDropImpl     The allowed SeaDrop contract.\n     * @param allowedNftToken The allowed nft token.\n     * @param dropStage       The token gated drop stage data.\n     */\n",
        "@notice": "Update the token gated drop stage data for this nft contract * on SeaDrop. * Only the owner can use this function. * * Note: If two INonFungibleSeaDropToken tokens are doing * simultaneous token gated drop promotions for each other, * they can be minted by the same actor until * `maxTokenSupplyForStage` is reached. Please ensure the * `allowedNftToken` is not running an active drop during the * `dropStage` time period.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "allowedNftToken The allowed nft token.",
        "@param3": "dropStage The token gated drop stage data.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "updateDropURI",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "dropURI",
                "type": "string calldata"
            }
        ],
        "func": "function updateDropURI(address seaDropImpl, string calldata dropURI)\n        external\n        virtual\n        override\n    {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Update the drop URI.\n        ISeaDrop(seaDropImpl).updateDropURI(dropURI);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the drop URI for this nft contract on SeaDrop.",
            "     *         Only the owner can use this function.",
            "     *",
            "     * @param seaDropImpl The allowed SeaDrop contract.",
            "     * @param dropURI     The new drop URI.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the drop URI for this nft contract on SeaDrop.\n     *         Only the owner can use this function.\n     *\n     * @param seaDropImpl The allowed SeaDrop contract.\n     * @param dropURI     The new drop URI.\n     */\n",
        "@notice": "Update the drop URI for this nft contract on SeaDrop. * Only the owner can use this function.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "dropURI The new drop URI.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateCreatorPayoutAddress",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "payoutAddress",
                "type": "address"
            }
        ],
        "func": "function updateCreatorPayoutAddress(\n        address seaDropImpl,\n        address payoutAddress\n    ) external {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Update the creator payout address.\n        ISeaDrop(seaDropImpl).updateCreatorPayoutAddress(payoutAddress);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the creator payout address for this nft contract on",
            "     *         SeaDrop.",
            "     *         Only the owner can set the creator payout address.",
            "     *",
            "     * @param seaDropImpl   The allowed SeaDrop contract.",
            "     * @param payoutAddress The new payout address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the creator payout address for this nft contract on\n     *         SeaDrop.\n     *         Only the owner can set the creator payout address.\n     *\n     * @param seaDropImpl   The allowed SeaDrop contract.\n     * @param payoutAddress The new payout address.\n     */\n",
        "@notice": "Update the creator payout address for this nft contract on * SeaDrop. * Only the owner can set the creator payout address.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "payoutAddress The new payout address.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateAllowedFeeRecipient",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "feeRecipient",
                "type": "address"
            },
            {
                "name": "allowed",
                "type": "bool"
            }
        ],
        "func": "function updateAllowedFeeRecipient(\n        address seaDropImpl,\n        address feeRecipient,\n        bool allowed\n    ) external virtual {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Update the allowed fee recipient.\n        ISeaDrop(seaDropImpl).updateAllowedFeeRecipient(feeRecipient, allowed);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the allowed fee recipient for this nft contract",
            "     *         on SeaDrop.",
            "     *         Only the owner can set the allowed fee recipient.",
            "     *",
            "     * @param seaDropImpl  The allowed SeaDrop contract.",
            "     * @param feeRecipient The new fee recipient.",
            "     * @param allowed      If the fee recipient is allowed.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the allowed fee recipient for this nft contract\n     *         on SeaDrop.\n     *         Only the owner can set the allowed fee recipient.\n     *\n     * @param seaDropImpl  The allowed SeaDrop contract.\n     * @param feeRecipient The new fee recipient.\n     * @param allowed      If the fee recipient is allowed.\n     */\n",
        "@notice": "Update the allowed fee recipient for this nft contract * on SeaDrop. * Only the owner can set the allowed fee recipient.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "feeRecipient The new fee recipient.",
        "@param3": "allowed If the fee recipient is allowed.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateSignedMintValidationParams",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "signer",
                "type": "address"
            },
            {
                "name": "signedMintValidationParams",
                "type": "SignedMintValidationParams memory"
            }
        ],
        "func": "function updateSignedMintValidationParams(\n        address seaDropImpl,\n        address signer,\n        SignedMintValidationParams memory signedMintValidationParams\n    ) external virtual override {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Update the signer.\n        ISeaDrop(seaDropImpl).updateSignedMintValidationParams(\n            signer,\n            signedMintValidationParams\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Update the server-side signers for this nft contract",
            "     *         on SeaDrop.",
            "     *         Only the owner can use this function.",
            "     *",
            "     * @param seaDropImpl                The allowed SeaDrop contract.",
            "     * @param signer                     The signer to update.",
            "     * @param signedMintValidationParams Minimum and maximum parameters to",
            "     *                                   enforce for signed mints.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the server-side signers for this nft contract\n     *         on SeaDrop.\n     *         Only the owner can use this function.\n     *\n     * @param seaDropImpl                The allowed SeaDrop contract.\n     * @param signer                     The signer to update.\n     * @param signedMintValidationParams Minimum and maximum parameters to\n     *                                   enforce for signed mints.\n     */\n",
        "@notice": "Update the server-side signers for this nft contract * on SeaDrop. * Only the owner can use this function.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "signer The signer to update.",
        "@param3": "signedMintValidationParams Minimum and maximum parameters to * enforce for signed mints.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updatePayer",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "payer",
                "type": "address"
            },
            {
                "name": "allowed",
                "type": "bool"
            }
        ],
        "func": "function updatePayer(\n        address seaDropImpl,\n        address payer,\n        bool allowed\n    ) external virtual override {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Update the payer.\n        ISeaDrop(seaDropImpl).updatePayer(payer, allowed);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the allowed payers for this nft contract on SeaDrop.",
            "     *         Only the owner can use this function.",
            "     *",
            "     * @param seaDropImpl The allowed SeaDrop contract.",
            "     * @param payer       The payer to update.",
            "     * @param allowed     Whether the payer is allowed.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the allowed payers for this nft contract on SeaDrop.\n     *         Only the owner can use this function.\n     *\n     * @param seaDropImpl The allowed SeaDrop contract.\n     * @param payer       The payer to update.\n     * @param allowed     Whether the payer is allowed.\n     */\n",
        "@notice": "Update the allowed payers for this nft contract on SeaDrop. * Only the owner can use this function.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "payer The payer to update.",
        "@param3": "allowed Whether the payer is allowed.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMintStats",
        "visibility": "external",
        "args": [
            {
                "name": "minter",
                "type": "address"
            }
        ],
        "func": "function getMintStats(address minter)\n        external\n        view\n        override\n        returns (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        )\n    {\n        minterNumMinted = _numberMinted(minter);\n        currentTotalSupply = _totalMinted();\n        maxSupply = _maxSupply;\n    }",
        "comments": [
            "/**",
            "     * @notice Returns a set of mint stats for the address.",
            "     *         This assists SeaDrop in enforcing maxSupply,",
            "     *         maxTotalMintableByWallet, and maxTokenSupplyForStage checks.",
            "     *",
            "     * @dev    NOTE: Implementing contracts should always update these numbers",
            "     *         before transferring any tokens with _safeMint() to mitigate",
            "     *         consequences of malicious onERC721Received() hooks.",
            "     *",
            "     * @param minter The minter address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns a set of mint stats for the address.\n     *         This assists SeaDrop in enforcing maxSupply,\n     *         maxTotalMintableByWallet, and maxTokenSupplyForStage checks.\n     *\n     * @dev    NOTE: Implementing contracts should always update these numbers\n     *         before transferring any tokens with _safeMint() to mitigate\n     *         consequences of malicious onERC721Received() hooks.\n     *\n     * @param minter The minter address.\n     */\n",
        "@notice": "Returns a set of mint stats for the address. * This assists SeaDrop in enforcing maxSupply, * maxTotalMintableByWallet, and maxTokenSupplyForStage checks.",
        "@dev": "NOTE: Implementing contracts should always update these numbers * before transferring any tokens with _safeMint() to mitigate * consequences of malicious onERC721Received() hooks.",
        "@param1": "minter The minter address.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "supportsInterface",
        "visibility": "public",
        "args": [
            {
                "name": "interfaceId",
                "type": "bytes4"
            }
        ],
        "func": "function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(IERC165, ERC721ContractMetadata)\n        returns (bool)\n    {\n        return\n            interfaceId == type(INonFungibleSeaDropToken).interfaceId ||\n            interfaceId == type(ISeaDropTokenContractMetadata).interfaceId ||\n            // ERC721ContractMetadata returns supportsInterface true for\n            //     EIP-2981\n            // ERC721A returns supportsInterface true for\n            //     ERC165, ERC721, ERC721Metadata\n            super.supportsInterface(interfaceId);\n    }",
        "comments": [
            "/**",
            "     * @notice Returns whether the interface is supported.",
            "     *",
            "     * @param interfaceId The interface id to check against.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns whether the interface is supported.\n     *\n     * @param interfaceId The interface id to check against.\n     */\n",
        "@notice": "Returns whether the interface is supported.",
        "@param1": "interfaceId The interface id to check against.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setApprovalForAll",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "approved",
                "type": "bool"
            }
        ],
        "func": "function setApprovalForAll(address operator, bool approved)\n        public\n        override\n        onlyAllowedOperatorApproval(operator)\n    {\n        super.setApprovalForAll(operator, approved);\n    }",
        "comments": [
            "/**",
            "     * @dev Approve or remove `operator` as an operator for the caller.",
            "     * Operators can call {transferFrom} or {safeTransferFrom}",
            "     * for any token owned by the caller.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - The `operator` cannot be the caller.",
            "     * - The `operator` must be allowed.",
            "     *",
            "     * Emits an {ApprovalForAll} event.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     * - The `operator` must be allowed.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n",
        "@dev": "Approve or remove `operator` as an operator for the caller. * Operators can call {transferFrom} or {safeTransferFrom} * for any token owned by the caller. * * Requirements: * * - The `operator` cannot be the caller. * - The `operator` must be allowed. * * Emits an {ApprovalForAll} event.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function approve(address operator, uint256 tokenId)\n        public\n        override\n        onlyAllowedOperatorApproval(operator)\n    {\n        super.approve(operator, tokenId);\n    }",
        "comments": [
            "/**",
            "     * @dev Gives permission to `to` to transfer `tokenId` token to another account.",
            "     * The approval is cleared when the token is transferred.",
            "     *",
            "     * Only a single account can be approved at a time, so approving the",
            "     * zero address clears previous approvals.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - The caller must own the token or be an approved operator.",
            "     * - `tokenId` must exist.",
            "     * - The `operator` mut be allowed.",
            "     *",
            "     * Emits an {Approval} event.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     * - The `operator` mut be allowed.\n     *\n     * Emits an {Approval} event.\n     */\n",
        "@dev": "Gives permission to `to` to transfer `tokenId` token to another account. * The approval is cleared when the token is transferred. * * Only a single account can be approved at a time, so approving the * zero address clears previous approvals. * * Requirements: * * - The caller must own the token or be an approved operator. * - `tokenId` must exist. * - The `operator` mut be allowed. * * Emits an {Approval} event.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override onlyAllowedOperator(from) {\n        super.transferFrom(from, to, tokenId);\n    }",
        "comments": [
            "/**",
            "     * @dev Transfers `tokenId` from `from` to `to`.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `from` cannot be the zero address.",
            "     * - `to` cannot be the zero address.",
            "     * - `tokenId` token must be owned by `from`.",
            "     * - If the caller is not `from`, it must be approved to move this token",
            "     * by either {approve} or {setApprovalForAll}.",
            "     * - The operator must be allowed.",
            "     *",
            "     * Emits a {Transfer} event.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     * - The operator must be allowed.\n     *\n     * Emits a {Transfer} event.\n     */\n",
        "@dev": "Transfers `tokenId` from `from` to `to`. * * Requirements: * * - `from` cannot be the zero address. * - `to` cannot be the zero address. * - `tokenId` token must be owned by `from`. * - If the caller is not `from`, it must be approved to move this token * by either {approve} or {setApprovalForAll}. * - The operator must be allowed. * * Emits a {Transfer} event.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "safeTransferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override onlyAllowedOperator(from) {\n        super.safeTransferFrom(from, to, tokenId);\n    }",
        "comments": [
            "/**",
            "     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n     */\n",
        "@dev": "Equivalent to `safeTransferFrom(from, to, tokenId, '')`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "safeTransferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "name": "data",
                "type": "bytes memory"
            }
        ],
        "func": "function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public override onlyAllowedOperator(from) {\n        super.safeTransferFrom(from, to, tokenId, data);\n    }",
        "comments": [
            "/**",
            "     * @dev Safely transfers `tokenId` token from `from` to `to`.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `from` cannot be the zero address.",
            "     * - `to` cannot be the zero address.",
            "     * - `tokenId` token must exist and be owned by `from`.",
            "     * - If the caller is not `from`, it must be approved to move this token",
            "     * by either {approve} or {setApprovalForAll}.",
            "     * - If `to` refers to a smart contract, it must implement",
            "     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.",
            "     * - The operator must be allowed.",
            "     *",
            "     * Emits a {Transfer} event.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     * - The operator must be allowed.\n     *\n     * Emits a {Transfer} event.\n     */\n",
        "@dev": "Safely transfers `tokenId` token from `from` to `to`. * * Requirements: * * - `from` cannot be the zero address. * - `to` cannot be the zero address. * - `tokenId` token must exist and be owned by `from`. * - If the caller is not `from`, it must be approved to move this token * by either {approve} or {setApprovalForAll}. * - If `to` refers to a smart contract, it must implement * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. * - The operator must be allowed. * * Emits a {Transfer} event.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "multiConfigure",
        "visibility": "external",
        "args": [
            {
                "name": "config",
                "type": "MultiConfigureStruct calldata"
            }
        ],
        "func": "function multiConfigure(MultiConfigureStruct calldata config)\n        external\n        onlyOwner\n    {\n        if (config.maxSupply > 0) {\n            this.setMaxSupply(config.maxSupply);\n        }\n        if (bytes(config.baseURI).length != 0) {\n            this.setBaseURI(config.baseURI);\n        }\n        if (bytes(config.contractURI).length != 0) {\n            this.setContractURI(config.contractURI);\n        }\n        if (\n            _cast(config.publicDrop.startTime != 0) |\n                _cast(config.publicDrop.endTime != 0) ==\n            1\n        ) {\n            this.updatePublicDrop(config.seaDropImpl, config.publicDrop);\n        }\n        if (bytes(config.dropURI).length != 0) {\n            this.updateDropURI(config.seaDropImpl, config.dropURI);\n        }\n        if (config.allowListData.merkleRoot != bytes32(0)) {\n            this.updateAllowList(config.seaDropImpl, config.allowListData);\n        }\n        if (config.creatorPayoutAddress != address(0)) {\n            this.updateCreatorPayoutAddress(\n                config.seaDropImpl,\n                config.creatorPayoutAddress\n            );\n        }\n        if (config.provenanceHash != bytes32(0)) {\n            this.setProvenanceHash(config.provenanceHash);\n        }\n        if (config.allowedFeeRecipients.length > 0) {\n            for (uint256 i = 0; i < config.allowedFeeRecipients.length; ) {\n                this.updateAllowedFeeRecipient(\n                    config.seaDropImpl,\n                    config.allowedFeeRecipients[i],\n                    true\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        if (config.disallowedFeeRecipients.length > 0) {\n            for (uint256 i = 0; i < config.disallowedFeeRecipients.length; ) {\n                this.updateAllowedFeeRecipient(\n                    config.seaDropImpl,\n                    config.disallowedFeeRecipients[i],\n                    false\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        if (config.allowedPayers.length > 0) {\n            for (uint256 i = 0; i < config.allowedPayers.length; ) {\n                this.updatePayer(\n                    config.seaDropImpl,\n                    config.allowedPayers[i],\n                    true\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        if (config.disallowedPayers.length > 0) {\n            for (uint256 i = 0; i < config.disallowedPayers.length; ) {\n                this.updatePayer(\n                    config.seaDropImpl,\n                    config.disallowedPayers[i],\n                    false\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        if (config.tokenGatedDropStages.length > 0) {\n            if (\n                config.tokenGatedDropStages.length !=\n                config.tokenGatedAllowedNftTokens.length\n            ) {\n                revert TokenGatedMismatch();\n            }\n            for (uint256 i = 0; i < config.tokenGatedDropStages.length; ) {\n                this.updateTokenGatedDrop(\n                    config.seaDropImpl,\n                    config.tokenGatedAllowedNftTokens[i],\n                    config.tokenGatedDropStages[i]\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        if (config.disallowedTokenGatedAllowedNftTokens.length > 0) {\n            for (\n                uint256 i = 0;\n                i < config.disallowedTokenGatedAllowedNftTokens.length;\n\n            ) {\n                TokenGatedDropStage memory emptyStage;\n                this.updateTokenGatedDrop(\n                    config.seaDropImpl,\n                    config.disallowedTokenGatedAllowedNftTokens[i],\n                    emptyStage\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        if (config.signedMintValidationParams.length > 0) {\n            if (\n                config.signedMintValidationParams.length !=\n                config.signers.length\n            ) {\n                revert SignersMismatch();\n            }\n            for (\n                uint256 i = 0;\n                i < config.signedMintValidationParams.length;\n\n            ) {\n                this.updateSignedMintValidationParams(\n                    config.seaDropImpl,\n                    config.signers[i],\n                    config.signedMintValidationParams[i]\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        if (config.disallowedSigners.length > 0) {\n            for (uint256 i = 0; i < config.disallowedSigners.length; ) {\n                SignedMintValidationParams memory emptyParams;\n                this.updateSignedMintValidationParams(\n                    config.seaDropImpl,\n                    config.disallowedSigners[i],\n                    emptyParams\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Configure multiple properties at a time.",
            "     *",
            "     *         Note: The individual configure methods should be used",
            "     *         to unset or reset any properties to zero, as this method",
            "     *         will ignore zero-value properties in the config struct.",
            "     *",
            "     * @param config The configuration struct.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Configure multiple properties at a time.\n     *\n     *         Note: The individual configure methods should be used\n     *         to unset or reset any properties to zero, as this method\n     *         will ignore zero-value properties in the config struct.\n     *\n     * @param config The configuration struct.\n     */\n",
        "@notice": "Configure multiple properties at a time. * * Note: The individual configure methods should be used * to unset or reset any properties to zero, as this method * will ignore zero-value properties in the config struct.",
        "@param1": "config The configuration struct.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "external",
        "args": [
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function burn(uint256 tokenId) external {\n        _burn(tokenId, true);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setRandomOffset",
        "visibility": "external",
        "args": [],
        "func": "function setRandomOffset() external onlyOwner {\n        // Revert setting the offset if already revealed.\n        if (revealed == _REVEALED_TRUE) {\n            revert AlreadyRevealed();\n        }\n\n        // Put maxSupply on the stack, since reading a state variable\n        // costs more gas than reading a local variable.\n        uint256 maxSupply = _maxSupply;\n\n        // Revert if the collection is not yet fully minted.\n        if (_totalMinted() != maxSupply) {\n            revert NotFullyMinted();\n        }\n\n        // block.difficulty returns PREVRANDAO on Ethereum post-merge\n        // NOTE: do not use this on other chains\n        // randomOffset returns between 1 and MAX_SUPPLY\n        randomOffset =\n            (uint256(keccak256(abi.encode(block.difficulty))) %\n                (maxSupply - 1)) +\n            1;\n\n        // Set revealed to true.\n        revealed = _REVEALED_TRUE;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "tokenURI",
        "visibility": "public",
        "args": [
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function tokenURI(uint256 tokenId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        if (!_exists(tokenId)) {\n            revert URIQueryForNonexistentToken();\n        }\n\n        string memory base = _baseURI();\n        if (bytes(base).length == 0) {\n            // If there is no baseURI set, return an empty string.\n            return \"\";\n        } else if (revealed == _REVEALED_FALSE) {\n            // If the baseURI is set but the collection is not revealed yet,\n            // return just the baseURI.\n            return base;\n        } else {\n            // If the baseURI is set and the collection is revealed,\n            // return the tokenURI offset by the randomOffset.\n            return\n                string.concat(\n                    base,\n                    _toString(\n                        ((tokenId + randomOffset) % _maxSupply) +\n                            _startTokenId()\n                    )\n                );\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice The token URI, offset by randomOffset, to enable fair metadata",
            "     *         reveals.",
            "     *",
            "     * @param tokenId The token id",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice The token URI, offset by randomOffset, to enable fair metadata\n     *         reveals.\n     *\n     * @param tokenId The token id\n     */\n",
        "@notice": "The token URI, offset by randomOffset, to enable fair metadata * reveals.",
        "@param1": "tokenId The token id",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "burn",
        "visibility": "external",
        "args": [
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function burn(uint256 tokenId) external {\n        _burn(tokenId, true);\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setRandomOffset",
        "visibility": "external",
        "args": [],
        "func": "function setRandomOffset() external onlyOwner {\n        // Revert setting the offset if already revealed.\n        if (revealed == _REVEALED_TRUE) {\n            revert AlreadyRevealed();\n        }\n\n        // Put maxSupply on the stack, since reading a state variable\n        // costs more gas than reading a local variable.\n        uint256 maxSupply = _maxSupply;\n\n        // Revert if the collection is not yet fully minted.\n        if (_totalMinted() != maxSupply) {\n            revert NotFullyMinted();\n        }\n\n        // block.difficulty returns PREVRANDAO on Ethereum post-merge\n        // NOTE: do not use this on other chains\n        // randomOffset returns between 1 and MAX_SUPPLY\n        randomOffset =\n            (uint256(keccak256(abi.encode(block.difficulty))) %\n                (maxSupply - 1)) +\n            1;\n\n        // Set revealed to true.\n        revealed = _REVEALED_TRUE;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "tokenURI",
        "visibility": "public",
        "args": [
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function tokenURI(uint256 tokenId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        if (!_exists(tokenId)) {\n            revert URIQueryForNonexistentToken();\n        }\n\n        string memory base = _baseURI();\n        if (bytes(base).length == 0) {\n            // If there is no baseURI set, return an empty string.\n            return \"\";\n        } else if (revealed == _REVEALED_FALSE) {\n            // If the baseURI is set but the collection is not revealed yet,\n            // return just the baseURI.\n            return base;\n        } else {\n            // If the baseURI is set and the collection is revealed,\n            // return the tokenURI offset by the randomOffset.\n            return\n                string.concat(\n                    base,\n                    _toString(\n                        ((tokenId + randomOffset) % _maxSupply) +\n                            _startTokenId()\n                    )\n                );\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice The token URI, offset by randomOffset, to enable fair metadata",
            "     *         reveals.",
            "     *",
            "     * @param tokenId The token id",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice The token URI, offset by randomOffset, to enable fair metadata\n     *         reveals.\n     *\n     * @param tokenId The token id\n     */\n",
        "@notice": "The token URI, offset by randomOffset, to enable fair metadata * reveals.",
        "@param1": "tokenId The token id",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setWhitelistMintFee",
        "visibility": "external",
        "args": [
            {
                "name": "_whitelistMintFee",
                "type": "uint256"
            }
        ],
        "func": "function setWhitelistMintFee(uint256 _whitelistMintFee) external onlyOwner {\n        whitelistMintFee = _whitelistMintFee;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setPublicMintFee",
        "visibility": "external",
        "args": [
            {
                "name": "_publicMintFee",
                "type": "uint256"
            }
        ],
        "func": "function setPublicMintFee(uint256 _publicMintFee) external onlyOwner {\n        publicMintFee = _publicMintFee;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setMintFeeReceiver",
        "visibility": "external",
        "args": [
            {
                "name": "mintFeeReceiver_",
                "type": "address"
            }
        ],
        "func": "function setMintFeeReceiver(address mintFeeReceiver_) external onlyOwner {\n        mintFeeReceiver = mintFeeReceiver_;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setWhitelistMerkleRoot",
        "visibility": "external",
        "args": [
            {
                "name": "merkleRoot",
                "type": "bytes32"
            }
        ],
        "func": "function setWhitelistMerkleRoot(bytes32 merkleRoot) external onlyOwner {\n        whitelistMerkleRoot = merkleRoot;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setMintActive",
        "visibility": "external",
        "args": [
            {
                "name": "_whitelistMintActive",
                "type": "bool"
            },
            {
                "name": "_publicMintActive",
                "type": "bool"
            }
        ],
        "func": "function setMintActive(bool _whitelistMintActive, bool _publicMintActive)\n        external\n        nonReentrant\n        onlyOwner\n    {\n        whitelistMintActive = _whitelistMintActive;\n        publicMintActive = _publicMintActive;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setWhitelistMintLimitPerTx",
        "visibility": "external",
        "args": [
            {
                "name": "_whitelistMintLimitPerTx",
                "type": "uint8"
            }
        ],
        "func": "function setWhitelistMintLimitPerTx(uint8 _whitelistMintLimitPerTx)\n        external\n        onlyOwner\n    {\n        whitelistMintLimitPerTx = _whitelistMintLimitPerTx;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setWhitelistMintMaxLimit",
        "visibility": "external",
        "args": [
            {
                "name": "_whitelistMintMaxLimit",
                "type": "uint8"
            }
        ],
        "func": "function setWhitelistMintMaxLimit(uint8 _whitelistMintMaxLimit)\n        external\n        onlyOwner\n    {\n        whitelistMintMaxLimit = _whitelistMintMaxLimit;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setPublicMintLimitPerTx",
        "visibility": "external",
        "args": [
            {
                "name": "_publicMintLimitPerTx",
                "type": "uint8"
            }
        ],
        "func": "function setPublicMintLimitPerTx(uint8 _publicMintLimitPerTx)\n        external\n        onlyOwner\n    {\n        publicMintLimitPerTx = _publicMintLimitPerTx;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setPublicMintMaxLimit",
        "visibility": "external",
        "args": [
            {
                "name": "_publicMintMaxLimit",
                "type": "uint8"
            }
        ],
        "func": "function setPublicMintMaxLimit(uint8 _publicMintMaxLimit)\n        external\n        onlyOwner\n    {\n        publicMintMaxLimit = _publicMintMaxLimit;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mintWhitelist",
        "visibility": "external",
        "args": [
            {
                "name": "whitelistMerkleProof",
                "type": "bytes32[] calldata"
            },
            {
                "name": "quantity",
                "type": "uint8"
            }
        ],
        "func": "function mintWhitelist(\n        bytes32[] calldata whitelistMerkleProof,\n        uint8 quantity\n    ) external payable nonReentrant {\n        _canMint(quantity);\n        require(whitelistMintActive, \"WHITELIST_MINT_INACTIVE\");\n        require(\n            MerkleProof.verify(\n                whitelistMerkleProof,\n                whitelistMerkleRoot,\n                keccak256(abi.encodePacked(msg.sender))\n            ),\n            \"INVALID_MERKLE_PROOF\"\n        );\n        require(\n            quantity <= whitelistMintLimitPerTx,\n            \"REACHED_WHITELIST_MINT_CAP_PER_TX\"\n        );\n        require(\n            whitelistMinted[msg.sender] + quantity <= whitelistMintMaxLimit,\n            \"REACHED_WHITELIST_MINT_CAP\"\n        );\n\n        uint256 fee = whitelistMintFee * quantity;\n\n        _transferInETH(fee);\n        _transferOutETH(mintFeeReceiver, fee);\n\n        _safeMint(msg.sender, quantity);\n\n        whitelistMinted[msg.sender] += quantity;\n    }",
        "comments": [
            "",
            "    // Custom mints",
            "    "
        ],
        "comt": "\n    // Custom mints\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mintPublic",
        "visibility": "external",
        "args": [
            {
                "name": "quantity",
                "type": "uint8"
            }
        ],
        "func": "function mintPublic(uint8 quantity) external payable nonReentrant {\n        _canMint(quantity);\n        require(publicMintActive, \"PUBLIC_MINT_INACTIVE\");\n        require(\n            quantity <= publicMintLimitPerTx,\n            \"REACHED_PUBLIC_MINT_CAP_PER_TX\"\n        );\n        require(\n            publicMinted[msg.sender] + quantity <= publicMintMaxLimit,\n            \"REACHED_PUBLIC_MINT_CAP\"\n        );\n\n        uint256 fee = publicMintFee * quantity;\n\n        _transferInETH(fee);\n        _transferOutETH(mintFeeReceiver, fee);\n\n        _safeMint(msg.sender, quantity);\n\n        publicMinted[msg.sender] += quantity;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setMintFee",
        "visibility": "external",
        "args": [
            {
                "name": "_whitelistMintFee",
                "type": "uint256"
            },
            {
                "name": "_publicMintFee",
                "type": "uint256"
            }
        ],
        "func": "function setMintFee(uint256 _whitelistMintFee, uint256 _publicMintFee)\n        external\n        onlyOwner\n    {\n        whitelistMintFee = _whitelistMintFee;\n        publicMintFee = _publicMintFee;\n    }",
        "comments": [
            "",
            "    // Custom configs",
            "    "
        ],
        "comt": "\n    // Custom configs\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setMintFeeReceiver",
        "visibility": "external",
        "args": [
            {
                "name": "mintFeeReceiver_",
                "type": "address"
            }
        ],
        "func": "function setMintFeeReceiver(address mintFeeReceiver_) external onlyOwner {\n        mintFeeReceiver = mintFeeReceiver_;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setWhitelistMerkleRoot",
        "visibility": "external",
        "args": [
            {
                "name": "merkleRoot",
                "type": "bytes32"
            }
        ],
        "func": "function setWhitelistMerkleRoot(bytes32 merkleRoot) external onlyOwner {\n        whitelistMerkleRoot = merkleRoot;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setMintActive",
        "visibility": "external",
        "args": [
            {
                "name": "_whitelistMintActive",
                "type": "bool"
            },
            {
                "name": "_publicMintActive",
                "type": "bool"
            }
        ],
        "func": "function setMintActive(bool _whitelistMintActive, bool _publicMintActive)\n        external\n        nonReentrant\n        onlyOwner\n    {\n        whitelistMintActive = _whitelistMintActive;\n        publicMintActive = _publicMintActive;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setWhitelistMintLimitPerTx",
        "visibility": "external",
        "args": [
            {
                "name": "_whitelistMintLimitPerTx",
                "type": "uint8"
            }
        ],
        "func": "function setWhitelistMintLimitPerTx(uint8 _whitelistMintLimitPerTx)\n        external\n        onlyOwner\n    {\n        whitelistMintLimitPerTx = _whitelistMintLimitPerTx;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setWhitelistMintMaxLimit",
        "visibility": "external",
        "args": [
            {
                "name": "_whitelistMintMaxLimit",
                "type": "uint8"
            }
        ],
        "func": "function setWhitelistMintMaxLimit(uint8 _whitelistMintMaxLimit)\n        external\n        onlyOwner\n    {\n        whitelistMintMaxLimit = _whitelistMintMaxLimit;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setPublicMintLimitPerTx",
        "visibility": "external",
        "args": [
            {
                "name": "_publicMintLimitPerTx",
                "type": "uint8"
            }
        ],
        "func": "function setPublicMintLimitPerTx(uint8 _publicMintLimitPerTx)\n        external\n        onlyOwner\n    {\n        publicMintLimitPerTx = _publicMintLimitPerTx;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setPublicMintMaxLimit",
        "visibility": "external",
        "args": [
            {
                "name": "_publicMintMaxLimit",
                "type": "uint8"
            }
        ],
        "func": "function setPublicMintMaxLimit(uint8 _publicMintMaxLimit)\n        external\n        onlyOwner\n    {\n        publicMintMaxLimit = _publicMintMaxLimit;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mintWhitelist",
        "visibility": "external",
        "args": [
            {
                "name": "whitelistMerkleProof",
                "type": "bytes32[] calldata"
            },
            {
                "name": "quantity",
                "type": "uint8"
            }
        ],
        "func": "function mintWhitelist(\n        bytes32[] calldata whitelistMerkleProof,\n        uint8 quantity\n    ) external payable nonReentrant {\n        _canMint(quantity);\n        require(whitelistMintActive, \"WHITELIST_MINT_INACTIVE\");\n        require(\n            MerkleProof.verify(\n                whitelistMerkleProof,\n                whitelistMerkleRoot,\n                keccak256(abi.encodePacked(msg.sender))\n            ),\n            \"INVALID_MERKLE_PROOF\"\n        );\n        require(\n            quantity <= whitelistMintLimitPerTx,\n            \"REACHED_WHITELIST_MINT_CAP_PER_TX\"\n        );\n        require(\n            whitelistMinted[msg.sender] + quantity <= whitelistMintMaxLimit,\n            \"REACHED_WHITELIST_MINT_CAP\"\n        );\n\n        uint256 fee = whitelistMintFee * quantity;\n\n        _transferInETH(fee);\n        _transferOutETH(mintFeeReceiver, fee);\n\n        _safeMint(msg.sender, quantity);\n\n        whitelistMinted[msg.sender] += quantity;\n    }",
        "comments": [
            "",
            "    // Custom mints",
            "    "
        ],
        "comt": "\n    // Custom mints\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mintPublic",
        "visibility": "external",
        "args": [
            {
                "name": "quantity",
                "type": "uint8"
            }
        ],
        "func": "function mintPublic(uint8 quantity) external payable nonReentrant {\n        _canMint(quantity);\n        require(publicMintActive, \"PUBLIC_MINT_INACTIVE\");\n        require(\n            quantity <= publicMintLimitPerTx,\n            \"REACHED_PUBLIC_MINT_CAP_PER_TX\"\n        );\n        require(\n            publicMinted[msg.sender] + quantity <= publicMintMaxLimit,\n            \"REACHED_PUBLIC_MINT_CAP\"\n        );\n\n        uint256 fee = publicMintFee * quantity;\n\n        _transferInETH(fee);\n        _transferOutETH(mintFeeReceiver, fee);\n\n        _safeMint(msg.sender, quantity);\n\n        publicMinted[msg.sender] += quantity;\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateAllowedSeaDrop",
        "visibility": "external",
        "args": [
            {
                "name": "allowedSeaDrop",
                "type": "address[] calldata"
            }
        ],
        "func": "function updateAllowedSeaDrop(address[] calldata allowedSeaDrop)\n        external\n        virtual\n        override\n        onlyOwner\n    {\n        _updateAllowedSeaDrop(allowedSeaDrop);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the allowed SeaDrop contracts.",
            "     *         Only the owner or administrator can use this function.",
            "     *",
            "     * @param allowedSeaDrop The allowed SeaDrop addresses.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the allowed SeaDrop contracts.\n     *         Only the owner or administrator can use this function.\n     *\n     * @param allowedSeaDrop The allowed SeaDrop addresses.\n     */\n",
        "@notice": "Update the allowed SeaDrop contracts. * Only the owner or administrator can use this function.",
        "@param1": "allowedSeaDrop The allowed SeaDrop addresses.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mintSeaDrop",
        "visibility": "external",
        "args": [
            {
                "name": "minter",
                "type": "address"
            },
            {
                "name": "quantity",
                "type": "uint256"
            }
        ],
        "func": "function mintSeaDrop(address minter, uint256 quantity)\n        external\n        virtual\n        override\n        nonReentrant\n    {\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(msg.sender);\n\n        // Extra safety check to ensure the max supply is not exceeded.\n        if (_totalMinted() + quantity > maxSupply()) {\n            revert MintQuantityExceedsMaxSupply(\n                _totalMinted() + quantity,\n                maxSupply()\n            );\n        }\n\n        // Mint the quantity of tokens to the minter.\n        _safeMint(minter, quantity);\n    }",
        "comments": [
            "/**",
            "     * @notice Mint tokens, restricted to the SeaDrop contract.",
            "     *",
            "     * @dev    NOTE: If a token registers itself with multiple SeaDrop",
            "     *         contracts, the implementation of this function should guard",
            "     *         against reentrancy. If the implementing token uses",
            "     *         _safeMint(), or a feeRecipient with a malicious receive() hook",
            "     *         is specified, the token or fee recipients may be able to execute",
            "     *         another mint in the same transaction via a separate SeaDrop",
            "     *         contract.",
            "     *         This is dangerous if an implementing token does not correctly",
            "     *         update the minterNumMinted and currentTotalSupply values before",
            "     *         transferring minted tokens, as SeaDrop references these values",
            "     *         to enforce token limits on a per-wallet and per-stage basis.",
            "     *",
            "     *         ERC721A tracks these values automatically, but this note and",
            "     *         nonReentrant modifier are left here to encourage best-practices",
            "     *         when referencing this contract.",
            "     *",
            "     * @param minter   The address to mint to.",
            "     * @param quantity The number of tokens to mint.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Mint tokens, restricted to the SeaDrop contract.\n     *\n     * @dev    NOTE: If a token registers itself with multiple SeaDrop\n     *         contracts, the implementation of this function should guard\n     *         against reentrancy. If the implementing token uses\n     *         _safeMint(), or a feeRecipient with a malicious receive() hook\n     *         is specified, the token or fee recipients may be able to execute\n     *         another mint in the same transaction via a separate SeaDrop\n     *         contract.\n     *         This is dangerous if an implementing token does not correctly\n     *         update the minterNumMinted and currentTotalSupply values before\n     *         transferring minted tokens, as SeaDrop references these values\n     *         to enforce token limits on a per-wallet and per-stage basis.\n     *\n     *         ERC721A tracks these values automatically, but this note and\n     *         nonReentrant modifier are left here to encourage best-practices\n     *         when referencing this contract.\n     *\n     * @param minter   The address to mint to.\n     * @param quantity The number of tokens to mint.\n     */\n",
        "@notice": "Mint tokens, restricted to the SeaDrop contract.",
        "@dev": "NOTE: If a token registers itself with multiple SeaDrop * contracts, the implementation of this function should guard * against reentrancy. If the implementing token uses * _safeMint(), or a feeRecipient with a malicious receive() hook * is specified, the token or fee recipients may be able to execute * another mint in the same transaction via a separate SeaDrop * contract. * This is dangerous if an implementing token does not correctly * update the minterNumMinted and currentTotalSupply values before * transferring minted tokens, as SeaDrop references these values * to enforce token limits on a per-wallet and per-stage basis. * * ERC721A tracks these values automatically, but this note and * nonReentrant modifier are left here to encourage best-practices * when referencing this contract.",
        "@param1": "minter The address to mint to.",
        "@param2": "quantity The number of tokens to mint.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updatePublicDrop",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "publicDrop",
                "type": "PublicDrop calldata"
            }
        ],
        "func": "function updatePublicDrop(\n        address seaDropImpl,\n        PublicDrop calldata publicDrop\n    ) external virtual override {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Update the public drop data on SeaDrop.\n        ISeaDrop(seaDropImpl).updatePublicDrop(publicDrop);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the public drop data for this nft contract on SeaDrop.",
            "     *         Only the owner can use this function.",
            "     *",
            "     * @param seaDropImpl The allowed SeaDrop contract.",
            "     * @param publicDrop  The public drop data.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the public drop data for this nft contract on SeaDrop.\n     *         Only the owner can use this function.\n     *\n     * @param seaDropImpl The allowed SeaDrop contract.\n     * @param publicDrop  The public drop data.\n     */\n",
        "@notice": "Update the public drop data for this nft contract on SeaDrop. * Only the owner can use this function.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "publicDrop The public drop data.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateAllowList",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "allowListData",
                "type": "AllowListData calldata"
            }
        ],
        "func": "function updateAllowList(\n        address seaDropImpl,\n        AllowListData calldata allowListData\n    ) external virtual override {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Update the allow list on SeaDrop.\n        ISeaDrop(seaDropImpl).updateAllowList(allowListData);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the allow list data for this nft contract on SeaDrop.",
            "     *         Only the owner can use this function.",
            "     *",
            "     * @param seaDropImpl   The allowed SeaDrop contract.",
            "     * @param allowListData The allow list data.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the allow list data for this nft contract on SeaDrop.\n     *         Only the owner can use this function.\n     *\n     * @param seaDropImpl   The allowed SeaDrop contract.\n     * @param allowListData The allow list data.\n     */\n",
        "@notice": "Update the allow list data for this nft contract on SeaDrop. * Only the owner can use this function.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "allowListData The allow list data.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateTokenGatedDrop",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "allowedNftToken",
                "type": "address"
            },
            {
                "name": "dropStage",
                "type": "TokenGatedDropStage calldata"
            }
        ],
        "func": "function updateTokenGatedDrop(\n        address seaDropImpl,\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external virtual override {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Update the token gated drop stage.\n        ISeaDrop(seaDropImpl).updateTokenGatedDrop(allowedNftToken, dropStage);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the token gated drop stage data for this nft contract",
            "     *         on SeaDrop.",
            "     *         Only the owner can use this function.",
            "     *",
            "     *         Note: If two INonFungibleSeaDropToken tokens are doing",
            "     *         simultaneous token gated drop promotions for each other,",
            "     *         they can be minted by the same actor until",
            "     *         `maxTokenSupplyForStage` is reached. Please ensure the",
            "     *         `allowedNftToken` is not running an active drop during the",
            "     *         `dropStage` time period.",
            "     *",
            "     * @param seaDropImpl     The allowed SeaDrop contract.",
            "     * @param allowedNftToken The allowed nft token.",
            "     * @param dropStage       The token gated drop stage data.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the token gated drop stage data for this nft contract\n     *         on SeaDrop.\n     *         Only the owner can use this function.\n     *\n     *         Note: If two INonFungibleSeaDropToken tokens are doing\n     *         simultaneous token gated drop promotions for each other,\n     *         they can be minted by the same actor until\n     *         `maxTokenSupplyForStage` is reached. Please ensure the\n     *         `allowedNftToken` is not running an active drop during the\n     *         `dropStage` time period.\n     *\n     * @param seaDropImpl     The allowed SeaDrop contract.\n     * @param allowedNftToken The allowed nft token.\n     * @param dropStage       The token gated drop stage data.\n     */\n",
        "@notice": "Update the token gated drop stage data for this nft contract * on SeaDrop. * Only the owner can use this function. * * Note: If two INonFungibleSeaDropToken tokens are doing * simultaneous token gated drop promotions for each other, * they can be minted by the same actor until * `maxTokenSupplyForStage` is reached. Please ensure the * `allowedNftToken` is not running an active drop during the * `dropStage` time period.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "allowedNftToken The allowed nft token.",
        "@param3": "dropStage The token gated drop stage data.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "updateDropURI",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "dropURI",
                "type": "string calldata"
            }
        ],
        "func": "function updateDropURI(address seaDropImpl, string calldata dropURI)\n        external\n        virtual\n        override\n    {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Update the drop URI.\n        ISeaDrop(seaDropImpl).updateDropURI(dropURI);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the drop URI for this nft contract on SeaDrop.",
            "     *         Only the owner can use this function.",
            "     *",
            "     * @param seaDropImpl The allowed SeaDrop contract.",
            "     * @param dropURI     The new drop URI.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the drop URI for this nft contract on SeaDrop.\n     *         Only the owner can use this function.\n     *\n     * @param seaDropImpl The allowed SeaDrop contract.\n     * @param dropURI     The new drop URI.\n     */\n",
        "@notice": "Update the drop URI for this nft contract on SeaDrop. * Only the owner can use this function.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "dropURI The new drop URI.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateCreatorPayoutAddress",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "payoutAddress",
                "type": "address"
            }
        ],
        "func": "function updateCreatorPayoutAddress(\n        address seaDropImpl,\n        address payoutAddress\n    ) external {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Update the creator payout address.\n        ISeaDrop(seaDropImpl).updateCreatorPayoutAddress(payoutAddress);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the creator payout address for this nft contract on",
            "     *         SeaDrop.",
            "     *         Only the owner can set the creator payout address.",
            "     *",
            "     * @param seaDropImpl   The allowed SeaDrop contract.",
            "     * @param payoutAddress The new payout address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the creator payout address for this nft contract on\n     *         SeaDrop.\n     *         Only the owner can set the creator payout address.\n     *\n     * @param seaDropImpl   The allowed SeaDrop contract.\n     * @param payoutAddress The new payout address.\n     */\n",
        "@notice": "Update the creator payout address for this nft contract on * SeaDrop. * Only the owner can set the creator payout address.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "payoutAddress The new payout address.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateAllowedFeeRecipient",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "feeRecipient",
                "type": "address"
            },
            {
                "name": "allowed",
                "type": "bool"
            }
        ],
        "func": "function updateAllowedFeeRecipient(\n        address seaDropImpl,\n        address feeRecipient,\n        bool allowed\n    ) external virtual {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Update the allowed fee recipient.\n        ISeaDrop(seaDropImpl).updateAllowedFeeRecipient(feeRecipient, allowed);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the allowed fee recipient for this nft contract",
            "     *         on SeaDrop.",
            "     *         Only the owner can set the allowed fee recipient.",
            "     *",
            "     * @param seaDropImpl  The allowed SeaDrop contract.",
            "     * @param feeRecipient The new fee recipient.",
            "     * @param allowed      If the fee recipient is allowed.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the allowed fee recipient for this nft contract\n     *         on SeaDrop.\n     *         Only the owner can set the allowed fee recipient.\n     *\n     * @param seaDropImpl  The allowed SeaDrop contract.\n     * @param feeRecipient The new fee recipient.\n     * @param allowed      If the fee recipient is allowed.\n     */\n",
        "@notice": "Update the allowed fee recipient for this nft contract * on SeaDrop. * Only the owner can set the allowed fee recipient.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "feeRecipient The new fee recipient.",
        "@param3": "allowed If the fee recipient is allowed.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateSignedMintValidationParams",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "signer",
                "type": "address"
            },
            {
                "name": "signedMintValidationParams",
                "type": "SignedMintValidationParams memory"
            }
        ],
        "func": "function updateSignedMintValidationParams(\n        address seaDropImpl,\n        address signer,\n        SignedMintValidationParams memory signedMintValidationParams\n    ) external virtual override {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Update the signer.\n        ISeaDrop(seaDropImpl).updateSignedMintValidationParams(\n            signer,\n            signedMintValidationParams\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Update the server-side signers for this nft contract",
            "     *         on SeaDrop.",
            "     *         Only the owner can use this function.",
            "     *",
            "     * @param seaDropImpl                The allowed SeaDrop contract.",
            "     * @param signer                     The signer to update.",
            "     * @param signedMintValidationParams Minimum and maximum parameters to",
            "     *                                   enforce for signed mints.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the server-side signers for this nft contract\n     *         on SeaDrop.\n     *         Only the owner can use this function.\n     *\n     * @param seaDropImpl                The allowed SeaDrop contract.\n     * @param signer                     The signer to update.\n     * @param signedMintValidationParams Minimum and maximum parameters to\n     *                                   enforce for signed mints.\n     */\n",
        "@notice": "Update the server-side signers for this nft contract * on SeaDrop. * Only the owner can use this function.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "signer The signer to update.",
        "@param3": "signedMintValidationParams Minimum and maximum parameters to * enforce for signed mints.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updatePayer",
        "visibility": "external",
        "args": [
            {
                "name": "seaDropImpl",
                "type": "address"
            },
            {
                "name": "payer",
                "type": "address"
            },
            {
                "name": "allowed",
                "type": "bool"
            }
        ],
        "func": "function updatePayer(\n        address seaDropImpl,\n        address payer,\n        bool allowed\n    ) external virtual override {\n        // Ensure the sender is only the owner or contract itself.\n        _onlyOwnerOrSelf();\n\n        // Ensure the SeaDrop is allowed.\n        _onlyAllowedSeaDrop(seaDropImpl);\n\n        // Update the payer.\n        ISeaDrop(seaDropImpl).updatePayer(payer, allowed);\n    }",
        "comments": [
            "/**",
            "     * @notice Update the allowed payers for this nft contract on SeaDrop.",
            "     *         Only the owner can use this function.",
            "     *",
            "     * @param seaDropImpl The allowed SeaDrop contract.",
            "     * @param payer       The payer to update.",
            "     * @param allowed     Whether the payer is allowed.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Update the allowed payers for this nft contract on SeaDrop.\n     *         Only the owner can use this function.\n     *\n     * @param seaDropImpl The allowed SeaDrop contract.\n     * @param payer       The payer to update.\n     * @param allowed     Whether the payer is allowed.\n     */\n",
        "@notice": "Update the allowed payers for this nft contract on SeaDrop. * Only the owner can use this function.",
        "@param1": "seaDropImpl The allowed SeaDrop contract.",
        "@param2": "payer The payer to update.",
        "@param3": "allowed Whether the payer is allowed.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getMintStats",
        "visibility": "external",
        "args": [
            {
                "name": "minter",
                "type": "address"
            }
        ],
        "func": "function getMintStats(address minter)\n        external\n        view\n        override\n        returns (\n            uint256 minterNumMinted,\n            uint256 currentTotalSupply,\n            uint256 maxSupply\n        )\n    {\n        minterNumMinted = _numberMinted(minter);\n        currentTotalSupply = _totalMinted();\n        maxSupply = _maxSupply;\n    }",
        "comments": [
            "/**",
            "     * @notice Returns a set of mint stats for the address.",
            "     *         This assists SeaDrop in enforcing maxSupply,",
            "     *         maxTotalMintableByWallet, and maxTokenSupplyForStage checks.",
            "     *",
            "     * @dev    NOTE: Implementing contracts should always update these numbers",
            "     *         before transferring any tokens with _safeMint() to mitigate",
            "     *         consequences of malicious onERC721Received() hooks.",
            "     *",
            "     * @param minter The minter address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns a set of mint stats for the address.\n     *         This assists SeaDrop in enforcing maxSupply,\n     *         maxTotalMintableByWallet, and maxTokenSupplyForStage checks.\n     *\n     * @dev    NOTE: Implementing contracts should always update these numbers\n     *         before transferring any tokens with _safeMint() to mitigate\n     *         consequences of malicious onERC721Received() hooks.\n     *\n     * @param minter The minter address.\n     */\n",
        "@notice": "Returns a set of mint stats for the address. * This assists SeaDrop in enforcing maxSupply, * maxTotalMintableByWallet, and maxTokenSupplyForStage checks.",
        "@dev": "NOTE: Implementing contracts should always update these numbers * before transferring any tokens with _safeMint() to mitigate * consequences of malicious onERC721Received() hooks.",
        "@param1": "minter The minter address.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "supportsInterface",
        "visibility": "public",
        "args": [
            {
                "name": "interfaceId",
                "type": "bytes4"
            }
        ],
        "func": "function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(IERC165, ERC721ContractMetadata)\n        returns (bool)\n    {\n        return\n            interfaceId == type(INonFungibleSeaDropToken).interfaceId ||\n            interfaceId == type(ISeaDropTokenContractMetadata).interfaceId ||\n            // ERC721ContractMetadata returns supportsInterface true for\n            //     EIP-2981\n            // ERC721A returns supportsInterface true for\n            //     ERC165, ERC721, ERC721Metadata\n            super.supportsInterface(interfaceId);\n    }",
        "comments": [
            "/**",
            "     * @notice Returns whether the interface is supported.",
            "     *",
            "     * @param interfaceId The interface id to check against.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns whether the interface is supported.\n     *\n     * @param interfaceId The interface id to check against.\n     */\n",
        "@notice": "Returns whether the interface is supported.",
        "@param1": "interfaceId The interface id to check against.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "setApprovalForAll",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "approved",
                "type": "bool"
            }
        ],
        "func": "function setApprovalForAll(address operator, bool approved)\n        public\n        override\n        onlyAllowedOperatorApproval(operator)\n    {\n        super.setApprovalForAll(operator, approved);\n    }",
        "comments": [
            "/**",
            "     * @dev Approve or remove `operator` as an operator for the caller.",
            "     * Operators can call {transferFrom} or {safeTransferFrom}",
            "     * for any token owned by the caller.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - The `operator` cannot be the caller.",
            "     * - The `operator` must be allowed.",
            "     *",
            "     * Emits an {ApprovalForAll} event.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     * - The `operator` must be allowed.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n",
        "@dev": "Approve or remove `operator` as an operator for the caller. * Operators can call {transferFrom} or {safeTransferFrom} * for any token owned by the caller. * * Requirements: * * - The `operator` cannot be the caller. * - The `operator` must be allowed. * * Emits an {ApprovalForAll} event.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "operator",
                "type": "address"
            },
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function approve(address operator, uint256 tokenId)\n        public\n        override\n        onlyAllowedOperatorApproval(operator)\n    {\n        super.approve(operator, tokenId);\n    }",
        "comments": [
            "/**",
            "     * @dev Gives permission to `to` to transfer `tokenId` token to another account.",
            "     * The approval is cleared when the token is transferred.",
            "     *",
            "     * Only a single account can be approved at a time, so approving the",
            "     * zero address clears previous approvals.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - The caller must own the token or be an approved operator.",
            "     * - `tokenId` must exist.",
            "     * - The `operator` mut be allowed.",
            "     *",
            "     * Emits an {Approval} event.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     * - The `operator` mut be allowed.\n     *\n     * Emits an {Approval} event.\n     */\n",
        "@dev": "Gives permission to `to` to transfer `tokenId` token to another account. * The approval is cleared when the token is transferred. * * Only a single account can be approved at a time, so approving the * zero address clears previous approvals. * * Requirements: * * - The caller must own the token or be an approved operator. * - `tokenId` must exist. * - The `operator` mut be allowed. * * Emits an {Approval} event.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override onlyAllowedOperator(from) {\n        super.transferFrom(from, to, tokenId);\n    }",
        "comments": [
            "/**",
            "     * @dev Transfers `tokenId` from `from` to `to`.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `from` cannot be the zero address.",
            "     * - `to` cannot be the zero address.",
            "     * - `tokenId` token must be owned by `from`.",
            "     * - If the caller is not `from`, it must be approved to move this token",
            "     * by either {approve} or {setApprovalForAll}.",
            "     * - The operator must be allowed.",
            "     *",
            "     * Emits a {Transfer} event.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     * - The operator must be allowed.\n     *\n     * Emits a {Transfer} event.\n     */\n",
        "@dev": "Transfers `tokenId` from `from` to `to`. * * Requirements: * * - `from` cannot be the zero address. * - `to` cannot be the zero address. * - `tokenId` token must be owned by `from`. * - If the caller is not `from`, it must be approved to move this token * by either {approve} or {setApprovalForAll}. * - The operator must be allowed. * * Emits a {Transfer} event.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "safeTransferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override onlyAllowedOperator(from) {\n        super.safeTransferFrom(from, to, tokenId);\n    }",
        "comments": [
            "/**",
            "     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n     */\n",
        "@dev": "Equivalent to `safeTransferFrom(from, to, tokenId, '')`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "safeTransferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "from",
                "type": "address"
            },
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "name": "data",
                "type": "bytes memory"
            }
        ],
        "func": "function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public override onlyAllowedOperator(from) {\n        super.safeTransferFrom(from, to, tokenId, data);\n    }",
        "comments": [
            "/**",
            "     * @dev Safely transfers `tokenId` token from `from` to `to`.",
            "     *",
            "     * Requirements:",
            "     *",
            "     * - `from` cannot be the zero address.",
            "     * - `to` cannot be the zero address.",
            "     * - `tokenId` token must exist and be owned by `from`.",
            "     * - If the caller is not `from`, it must be approved to move this token",
            "     * by either {approve} or {setApprovalForAll}.",
            "     * - If `to` refers to a smart contract, it must implement",
            "     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.",
            "     * - The operator must be allowed.",
            "     *",
            "     * Emits a {Transfer} event.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     * - The operator must be allowed.\n     *\n     * Emits a {Transfer} event.\n     */\n",
        "@dev": "Safely transfers `tokenId` token from `from` to `to`. * * Requirements: * * - `from` cannot be the zero address. * - `to` cannot be the zero address. * - `tokenId` token must exist and be owned by `from`. * - If the caller is not `from`, it must be approved to move this token * by either {approve} or {setApprovalForAll}. * - If `to` refers to a smart contract, it must implement * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. * - The operator must be allowed. * * Emits a {Transfer} event.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "multiConfigure",
        "visibility": "external",
        "args": [
            {
                "name": "config",
                "type": "MultiConfigureStruct calldata"
            }
        ],
        "func": "function multiConfigure(MultiConfigureStruct calldata config)\n        external\n        onlyOwner\n    {\n        if (config.maxSupply > 0) {\n            this.setMaxSupply(config.maxSupply);\n        }\n        if (bytes(config.baseURI).length != 0) {\n            this.setBaseURI(config.baseURI);\n        }\n        if (bytes(config.contractURI).length != 0) {\n            this.setContractURI(config.contractURI);\n        }\n        if (\n            _cast(config.publicDrop.startTime != 0) |\n                _cast(config.publicDrop.endTime != 0) ==\n            1\n        ) {\n            this.updatePublicDrop(config.seaDropImpl, config.publicDrop);\n        }\n        if (bytes(config.dropURI).length != 0) {\n            this.updateDropURI(config.seaDropImpl, config.dropURI);\n        }\n        if (config.allowListData.merkleRoot != bytes32(0)) {\n            this.updateAllowList(config.seaDropImpl, config.allowListData);\n        }\n        if (config.creatorPayoutAddress != address(0)) {\n            this.updateCreatorPayoutAddress(\n                config.seaDropImpl,\n                config.creatorPayoutAddress\n            );\n        }\n        if (config.provenanceHash != bytes32(0)) {\n            this.setProvenanceHash(config.provenanceHash);\n        }\n        if (config.allowedFeeRecipients.length > 0) {\n            for (uint256 i = 0; i < config.allowedFeeRecipients.length; ) {\n                this.updateAllowedFeeRecipient(\n                    config.seaDropImpl,\n                    config.allowedFeeRecipients[i],\n                    true\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        if (config.disallowedFeeRecipients.length > 0) {\n            for (uint256 i = 0; i < config.disallowedFeeRecipients.length; ) {\n                this.updateAllowedFeeRecipient(\n                    config.seaDropImpl,\n                    config.disallowedFeeRecipients[i],\n                    false\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        if (config.allowedPayers.length > 0) {\n            for (uint256 i = 0; i < config.allowedPayers.length; ) {\n                this.updatePayer(\n                    config.seaDropImpl,\n                    config.allowedPayers[i],\n                    true\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        if (config.disallowedPayers.length > 0) {\n            for (uint256 i = 0; i < config.disallowedPayers.length; ) {\n                this.updatePayer(\n                    config.seaDropImpl,\n                    config.disallowedPayers[i],\n                    false\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        if (config.tokenGatedDropStages.length > 0) {\n            if (\n                config.tokenGatedDropStages.length !=\n                config.tokenGatedAllowedNftTokens.length\n            ) {\n                revert TokenGatedMismatch();\n            }\n            for (uint256 i = 0; i < config.tokenGatedDropStages.length; ) {\n                this.updateTokenGatedDrop(\n                    config.seaDropImpl,\n                    config.tokenGatedAllowedNftTokens[i],\n                    config.tokenGatedDropStages[i]\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        if (config.disallowedTokenGatedAllowedNftTokens.length > 0) {\n            for (\n                uint256 i = 0;\n                i < config.disallowedTokenGatedAllowedNftTokens.length;\n\n            ) {\n                TokenGatedDropStage memory emptyStage;\n                this.updateTokenGatedDrop(\n                    config.seaDropImpl,\n                    config.disallowedTokenGatedAllowedNftTokens[i],\n                    emptyStage\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        if (config.signedMintValidationParams.length > 0) {\n            if (\n                config.signedMintValidationParams.length !=\n                config.signers.length\n            ) {\n                revert SignersMismatch();\n            }\n            for (\n                uint256 i = 0;\n                i < config.signedMintValidationParams.length;\n\n            ) {\n                this.updateSignedMintValidationParams(\n                    config.seaDropImpl,\n                    config.signers[i],\n                    config.signedMintValidationParams[i]\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        if (config.disallowedSigners.length > 0) {\n            for (uint256 i = 0; i < config.disallowedSigners.length; ) {\n                SignedMintValidationParams memory emptyParams;\n                this.updateSignedMintValidationParams(\n                    config.seaDropImpl,\n                    config.disallowedSigners[i],\n                    emptyParams\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }",
        "comments": [
            "/**",
            "     * @notice Configure multiple properties at a time.",
            "     *",
            "     *         Note: The individual configure methods should be used",
            "     *         to unset or reset any properties to zero, as this method",
            "     *         will ignore zero-value properties in the config struct.",
            "     *",
            "     * @param config The configuration struct.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Configure multiple properties at a time.\n     *\n     *         Note: The individual configure methods should be used\n     *         to unset or reset any properties to zero, as this method\n     *         will ignore zero-value properties in the config struct.\n     *\n     * @param config The configuration struct.\n     */\n",
        "@notice": "Configure multiple properties at a time. * * Note: The individual configure methods should be used * to unset or reset any properties to zero, as this method * will ignore zero-value properties in the config struct.",
        "@param1": "config The configuration struct.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "mintPublic",
        "visibility": "external",
        "args": [
            {
                "name": "nftContract",
                "type": "address"
            },
            {
                "name": "feeRecipient",
                "type": "address"
            },
            {
                "name": "minterIfNotPayer",
                "type": "address"
            },
            {
                "name": "quantity",
                "type": "uint256"
            }
        ],
        "func": "function mintPublic(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity\n    ) external payable override {\n        // Get the public drop data.\n        PublicDrop memory publicDrop = _publicDrops[nftContract];\n\n        // Ensure that the drop has started.\n        _checkActive(publicDrop.startTime, publicDrop.endTime);\n\n        // Put the mint price on the stack.\n        uint256 mintPrice = publicDrop.mintPrice;\n\n        // Validate payment is correct for number minted.\n        _checkCorrectPayment(quantity, mintPrice);\n\n        // Get the minter address.\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n\n        // Ensure the payer is allowed if not the minter.\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n\n        // Check that the minter is allowed to mint the desired quantity.\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            publicDrop.maxTotalMintableByWallet,\n            _UNLIMITED_MAX_TOKEN_SUPPLY_FOR_STAGE\n        );\n\n        // Check that the fee recipient is allowed if restricted.\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            publicDrop.restrictFeeRecipients\n        );\n\n        // Mint the token(s), split the payout, emit an event.\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            _PUBLIC_DROP_STAGE_INDEX,\n            publicDrop.feeBps,\n            feeRecipient\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Mint a public drop.",
            "     *",
            "     * @param nftContract      The nft contract to mint.",
            "     * @param feeRecipient     The fee recipient.",
            "     * @param minterIfNotPayer The mint recipient if different than the payer.",
            "     * @param quantity         The number of tokens to mint.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Mint a public drop.\n     *\n     * @param nftContract      The nft contract to mint.\n     * @param feeRecipient     The fee recipient.\n     * @param minterIfNotPayer The mint recipient if different than the payer.\n     * @param quantity         The number of tokens to mint.\n     */\n",
        "@notice": "Mint a public drop.",
        "@param1": "nftContract The nft contract to mint.",
        "@param2": "feeRecipient The fee recipient.",
        "@param3": "minterIfNotPayer The mint recipient if different than the payer.",
        "@param4": "quantity The number of tokens to mint.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mintAllowList",
        "visibility": "external",
        "args": [
            {
                "name": "nftContract",
                "type": "address"
            },
            {
                "name": "feeRecipient",
                "type": "address"
            },
            {
                "name": "minterIfNotPayer",
                "type": "address"
            },
            {
                "name": "quantity",
                "type": "uint256"
            },
            {
                "name": "mintParams",
                "type": "MintParams calldata"
            },
            {
                "name": "proof",
                "type": "bytes32[] calldata"
            }
        ],
        "func": "function mintAllowList(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        bytes32[] calldata proof\n    ) external payable override {\n        // Check that the drop stage is active.\n        _checkActive(mintParams.startTime, mintParams.endTime);\n\n        // Put the mint price on the stack.\n        uint256 mintPrice = mintParams.mintPrice;\n\n        // Validate payment is correct for number minted.\n        _checkCorrectPayment(quantity, mintPrice);\n\n        // Get the minter address.\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n\n        // Ensure the payer is allowed if not the minter.\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n\n        // Check that the minter is allowed to mint the desired quantity.\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n\n        // Check that the fee recipient is allowed if restricted.\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n\n        // Verify the proof.\n        if (\n            !MerkleProof.verify(\n                proof,\n                _allowListMerkleRoots[nftContract],\n                keccak256(abi.encode(minter, mintParams))\n            )\n        ) {\n            revert InvalidProof();\n        }\n\n        // Mint the token(s), split the payout, emit an event.\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Mint from an allow list.",
            "     *",
            "     * @param nftContract      The nft contract to mint.",
            "     * @param feeRecipient     The fee recipient.",
            "     * @param minterIfNotPayer The mint recipient if different than the payer.",
            "     * @param quantity         The number of tokens to mint.",
            "     * @param mintParams       The mint parameters.",
            "     * @param proof            The proof for the leaf of the allow list.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Mint from an allow list.\n     *\n     * @param nftContract      The nft contract to mint.\n     * @param feeRecipient     The fee recipient.\n     * @param minterIfNotPayer The mint recipient if different than the payer.\n     * @param quantity         The number of tokens to mint.\n     * @param mintParams       The mint parameters.\n     * @param proof            The proof for the leaf of the allow list.\n     */\n",
        "@notice": "Mint from an allow list.",
        "@param1": "nftContract The nft contract to mint.",
        "@param2": "feeRecipient The fee recipient.",
        "@param3": "minterIfNotPayer The mint recipient if different than the payer.",
        "@param4": "quantity The number of tokens to mint.",
        "@param5": "mintParams The mint parameters.",
        "@param6": "proof The proof for the leaf of the allow list.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mintSigned",
        "visibility": "external",
        "args": [
            {
                "name": "nftContract",
                "type": "address"
            },
            {
                "name": "feeRecipient",
                "type": "address"
            },
            {
                "name": "minterIfNotPayer",
                "type": "address"
            },
            {
                "name": "quantity",
                "type": "uint256"
            },
            {
                "name": "mintParams",
                "type": "MintParams calldata"
            },
            {
                "name": "salt",
                "type": "uint256"
            },
            {
                "name": "signature",
                "type": "bytes calldata"
            }
        ],
        "func": "function mintSigned(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        uint256 quantity,\n        MintParams calldata mintParams,\n        uint256 salt,\n        bytes calldata signature\n    ) external payable override {\n        // Check that the drop stage is active.\n        _checkActive(mintParams.startTime, mintParams.endTime);\n\n        // Validate payment is correct for number minted.\n        _checkCorrectPayment(quantity, mintParams.mintPrice);\n\n        // Get the minter address.\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n\n        // Ensure the payer is allowed if not the minter.\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n\n        // Check that the minter is allowed to mint the desired quantity.\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.maxTotalMintableByWallet,\n            mintParams.maxTokenSupplyForStage\n        );\n\n        // Check that the fee recipient is allowed if restricted.\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            mintParams.restrictFeeRecipients\n        );\n\n        // Validate the signature in a block scope to avoid \"stack too deep\".\n        {\n            // Get the digest to verify the EIP-712 signature.\n            bytes32 digest = _getDigest(\n                nftContract,\n                minter,\n                feeRecipient,\n                mintParams,\n                salt\n            );\n\n            // Ensure the digest has not already been used.\n            if (_usedDigests[digest]) {\n                revert SignatureAlreadyUsed();\n            }\n\n            // Mark the digest as used.\n            _usedDigests[digest] = true;\n\n            // Use the recover method to see what address was used to create\n            // the signature on this data.\n            // Note that if the digest doesn't exactly match what was signed we'll\n            // get a random recovered address.\n            address recoveredAddress = digest.recover(signature);\n            _validateSignerAndParams(nftContract, mintParams, recoveredAddress);\n        }\n\n        // Mint the token(s), split the payout, emit an event.\n        _mintAndPay(\n            nftContract,\n            minter,\n            quantity,\n            mintParams.mintPrice,\n            mintParams.dropStageIndex,\n            mintParams.feeBps,\n            feeRecipient\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Mint with a server-side signature.",
            "     *         Note that a signature can only be used once.",
            "     *",
            "     * @param nftContract      The nft contract to mint.",
            "     * @param feeRecipient     The fee recipient.",
            "     * @param minterIfNotPayer The mint recipient if different than the payer.",
            "     * @param quantity         The number of tokens to mint.",
            "     * @param mintParams       The mint parameters.",
            "     * @param salt             The salt for the signed mint.",
            "     * @param signature        The server-side signature, must be an allowed",
            "     *                         signer.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Mint with a server-side signature.\n     *         Note that a signature can only be used once.\n     *\n     * @param nftContract      The nft contract to mint.\n     * @param feeRecipient     The fee recipient.\n     * @param minterIfNotPayer The mint recipient if different than the payer.\n     * @param quantity         The number of tokens to mint.\n     * @param mintParams       The mint parameters.\n     * @param salt             The salt for the signed mint.\n     * @param signature        The server-side signature, must be an allowed\n     *                         signer.\n     */\n",
        "@notice": "Mint with a server-side signature. * Note that a signature can only be used once.",
        "@param1": "nftContract The nft contract to mint.",
        "@param2": "feeRecipient The fee recipient.",
        "@param3": "minterIfNotPayer The mint recipient if different than the payer.",
        "@param4": "quantity The number of tokens to mint.",
        "@param5": "mintParams The mint parameters.",
        "@param6": "salt The salt for the signed mint.",
        "@param7": "signature The server-side signature, must be an allowed * signer.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mintAllowedTokenHolder",
        "visibility": "external",
        "args": [
            {
                "name": "nftContract",
                "type": "address"
            },
            {
                "name": "feeRecipient",
                "type": "address"
            },
            {
                "name": "minterIfNotPayer",
                "type": "address"
            },
            {
                "name": "mintParams",
                "type": "TokenGatedMintParams calldata"
            }
        ],
        "func": "function mintAllowedTokenHolder(\n        address nftContract,\n        address feeRecipient,\n        address minterIfNotPayer,\n        TokenGatedMintParams calldata mintParams\n    ) external payable override {\n        // Get the minter address.\n        address minter = minterIfNotPayer != address(0)\n            ? minterIfNotPayer\n            : msg.sender;\n\n        // Ensure the payer is allowed if not the minter.\n        if (minter != msg.sender) {\n            if (!_allowedPayers[nftContract][msg.sender]) {\n                revert PayerNotAllowed();\n            }\n        }\n\n        // Put the allowedNftToken on the stack for more efficient access.\n        address allowedNftToken = mintParams.allowedNftToken;\n\n        // Set the dropStage to a variable.\n        TokenGatedDropStage memory dropStage = _tokenGatedDrops[nftContract][\n            allowedNftToken\n        ];\n\n        // Validate that the dropStage is active.\n        _checkActive(dropStage.startTime, dropStage.endTime);\n\n        // Check that the fee recipient is allowed if restricted.\n        _checkFeeRecipientIsAllowed(\n            nftContract,\n            feeRecipient,\n            dropStage.restrictFeeRecipients\n        );\n\n        // Put the mint quantity on the stack for more efficient access.\n        uint256 mintQuantity = mintParams.allowedNftTokenIds.length;\n\n        // Validate payment is correct for number minted.\n        _checkCorrectPayment(mintQuantity, dropStage.mintPrice);\n\n        // Check that the minter is allowed to mint the desired quantity.\n        _checkMintQuantity(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.maxTotalMintableByWallet,\n            dropStage.maxTokenSupplyForStage\n        );\n\n        // Iterate through each allowedNftTokenId\n        // to ensure it is not already redeemed.\n        for (uint256 i = 0; i < mintQuantity; ) {\n            // Put the tokenId on the stack.\n            uint256 tokenId = mintParams.allowedNftTokenIds[i];\n\n            // Check that the minter is the owner of the allowedNftTokenId.\n            if (IERC721(allowedNftToken).ownerOf(tokenId) != minter) {\n                revert TokenGatedNotTokenOwner(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n\n            // Cache the storage pointer for cheaper access.\n            mapping(uint256 => bool)\n                storage redeemedTokenIds = _tokenGatedRedeemed[nftContract][\n                    allowedNftToken\n                ];\n\n            // Check that the token id has not already been redeemed.\n            if (redeemedTokenIds[tokenId]) {\n                revert TokenGatedTokenIdAlreadyRedeemed(\n                    nftContract,\n                    allowedNftToken,\n                    tokenId\n                );\n            }\n\n            // Mark the token id as redeemed.\n            redeemedTokenIds[tokenId] = true;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Mint the token(s), split the payout, emit an event.\n        _mintAndPay(\n            nftContract,\n            minter,\n            mintQuantity,\n            dropStage.mintPrice,\n            dropStage.dropStageIndex,\n            dropStage.feeBps,\n            feeRecipient\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Mint as an allowed token holder.",
            "     *         This will mark the token ids as redeemed and will revert if the",
            "     *         same token id is attempted to be redeemed twice.",
            "     *",
            "     * @param nftContract      The nft contract to mint.",
            "     * @param feeRecipient     The fee recipient.",
            "     * @param minterIfNotPayer The mint recipient if different than the payer.",
            "     * @param mintParams       The token gated mint params.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Mint as an allowed token holder.\n     *         This will mark the token ids as redeemed and will revert if the\n     *         same token id is attempted to be redeemed twice.\n     *\n     * @param nftContract      The nft contract to mint.\n     * @param feeRecipient     The fee recipient.\n     * @param minterIfNotPayer The mint recipient if different than the payer.\n     * @param mintParams       The token gated mint params.\n     */\n",
        "@notice": "Mint as an allowed token holder. * This will mark the token ids as redeemed and will revert if the * same token id is attempted to be redeemed twice.",
        "@param1": "nftContract The nft contract to mint.",
        "@param2": "feeRecipient The fee recipient.",
        "@param3": "minterIfNotPayer The mint recipient if different than the payer.",
        "@param4": "mintParams The token gated mint params.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPublicDrop",
        "visibility": "external",
        "args": [
            {
                "name": "nftContract",
                "type": "address"
            }
        ],
        "func": "function getPublicDrop(address nftContract)\n        external\n        view\n        returns (PublicDrop memory)\n    {\n        return _publicDrops[nftContract];\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the public drop data for the nft contract.",
            "     *",
            "     * @param nftContract The nft contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the public drop data for the nft contract.\n     *\n     * @param nftContract The nft contract.\n     */\n",
        "@notice": "Returns the public drop data for the nft contract.",
        "@param1": "nftContract The nft contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getCreatorPayoutAddress",
        "visibility": "external",
        "args": [
            {
                "name": "nftContract",
                "type": "address"
            }
        ],
        "func": "function getCreatorPayoutAddress(address nftContract)\n        external\n        view\n        returns (address)\n    {\n        return _creatorPayoutAddresses[nftContract];\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the creator payout address for the nft contract.",
            "     *",
            "     * @param nftContract The nft contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the creator payout address for the nft contract.\n     *\n     * @param nftContract The nft contract.\n     */\n",
        "@notice": "Returns the creator payout address for the nft contract.",
        "@param1": "nftContract The nft contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAllowListMerkleRoot",
        "visibility": "external",
        "args": [
            {
                "name": "nftContract",
                "type": "address"
            }
        ],
        "func": "function getAllowListMerkleRoot(address nftContract)\n        external\n        view\n        returns (bytes32)\n    {\n        return _allowListMerkleRoots[nftContract];\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the allow list merkle root for the nft contract.",
            "     *",
            "     * @param nftContract The nft contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the allow list merkle root for the nft contract.\n     *\n     * @param nftContract The nft contract.\n     */\n",
        "@notice": "Returns the allow list merkle root for the nft contract.",
        "@param1": "nftContract The nft contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getFeeRecipientIsAllowed",
        "visibility": "external",
        "args": [
            {
                "name": "nftContract",
                "type": "address"
            },
            {
                "name": "feeRecipient",
                "type": "address"
            }
        ],
        "func": "function getFeeRecipientIsAllowed(address nftContract, address feeRecipient)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedFeeRecipients[nftContract][feeRecipient];\n    }",
        "comments": [
            "/**",
            "     * @notice Returns if the specified fee recipient is allowed",
            "     *         for the nft contract.",
            "     *",
            "     * @param nftContract The nft contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns if the specified fee recipient is allowed\n     *         for the nft contract.\n     *\n     * @param nftContract The nft contract.\n     */\n",
        "@notice": "Returns if the specified fee recipient is allowed * for the nft contract.",
        "@param1": "nftContract The nft contract.",
        "notice_missing": 0,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAllowedFeeRecipients",
        "visibility": "external",
        "args": [
            {
                "name": "nftContract",
                "type": "address"
            }
        ],
        "func": "function getAllowedFeeRecipients(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedFeeRecipients[nftContract];\n    }",
        "comments": [
            "/**",
            "     * @notice Returns an enumeration of allowed fee recipients for an",
            "     *         nft contract when fee recipients are enforced.",
            "     *",
            "     * @param nftContract The nft contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns an enumeration of allowed fee recipients for an\n     *         nft contract when fee recipients are enforced.\n     *\n     * @param nftContract The nft contract.\n     */\n",
        "@notice": "Returns an enumeration of allowed fee recipients for an * nft contract when fee recipients are enforced.",
        "@param1": "nftContract The nft contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getSigners",
        "visibility": "external",
        "args": [
            {
                "name": "nftContract",
                "type": "address"
            }
        ],
        "func": "function getSigners(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedSigners[nftContract];\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the server-side signers for the nft contract.",
            "     *",
            "     * @param nftContract The nft contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the server-side signers for the nft contract.\n     *\n     * @param nftContract The nft contract.\n     */\n",
        "@notice": "Returns the server-side signers for the nft contract.",
        "@param1": "nftContract The nft contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getSignedMintValidationParams",
        "visibility": "external",
        "args": [
            {
                "name": "nftContract",
                "type": "address"
            },
            {
                "name": "signer",
                "type": "address"
            }
        ],
        "func": "function getSignedMintValidationParams(address nftContract, address signer)\n        external\n        view\n        returns (SignedMintValidationParams memory)\n    {\n        return _signedMintValidationParams[nftContract][signer];\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the struct of SignedMintValidationParams for a signer.",
            "     *",
            "     * @param nftContract The nft contract.",
            "     * @param signer      The signer.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the struct of SignedMintValidationParams for a signer.\n     *\n     * @param nftContract The nft contract.\n     * @param signer      The signer.\n     */\n",
        "@notice": "Returns the struct of SignedMintValidationParams for a signer.",
        "@param1": "nftContract The nft contract.",
        "@param2": "signer The signer.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPayers",
        "visibility": "external",
        "args": [
            {
                "name": "nftContract",
                "type": "address"
            }
        ],
        "func": "function getPayers(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedPayers[nftContract];\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the payers for the nft contract.",
            "     *",
            "     * @param nftContract The nft contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the payers for the nft contract.\n     *\n     * @param nftContract The nft contract.\n     */\n",
        "@notice": "Returns the payers for the nft contract.",
        "@param1": "nftContract The nft contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getPayerIsAllowed",
        "visibility": "external",
        "args": [
            {
                "name": "nftContract",
                "type": "address"
            },
            {
                "name": "payer",
                "type": "address"
            }
        ],
        "func": "function getPayerIsAllowed(address nftContract, address payer)\n        external\n        view\n        returns (bool)\n    {\n        return _allowedPayers[nftContract][payer];\n    }",
        "comments": [
            "/**",
            "     * @notice Returns if the specified payer is allowed",
            "     *         for the nft contract.",
            "     *",
            "     * @param nftContract The nft contract.",
            "     * @param payer       The payer.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns if the specified payer is allowed\n     *         for the nft contract.\n     *\n     * @param nftContract The nft contract.\n     * @param payer       The payer.\n     */\n",
        "@notice": "Returns if the specified payer is allowed * for the nft contract.",
        "@param1": "nftContract The nft contract.",
        "@param2": "payer The payer.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getTokenGatedAllowedTokens",
        "visibility": "external",
        "args": [
            {
                "name": "nftContract",
                "type": "address"
            }
        ],
        "func": "function getTokenGatedAllowedTokens(address nftContract)\n        external\n        view\n        returns (address[] memory)\n    {\n        return _enumeratedTokenGatedTokens[nftContract];\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the allowed token gated drop tokens for the nft contract.",
            "     *",
            "     * @param nftContract The nft contract.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the allowed token gated drop tokens for the nft contract.\n     *\n     * @param nftContract The nft contract.\n     */\n",
        "@notice": "Returns the allowed token gated drop tokens for the nft contract.",
        "@param1": "nftContract The nft contract.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getTokenGatedDrop",
        "visibility": "external",
        "args": [
            {
                "name": "nftContract",
                "type": "address"
            },
            {
                "name": "allowedNftToken",
                "type": "address"
            }
        ],
        "func": "function getTokenGatedDrop(address nftContract, address allowedNftToken)\n        external\n        view\n        returns (TokenGatedDropStage memory)\n    {\n        return _tokenGatedDrops[nftContract][allowedNftToken];\n    }",
        "comments": [
            "/**",
            "     * @notice Returns the token gated drop data for the nft contract",
            "     *         and token gated nft.",
            "     *",
            "     * @param nftContract     The nft contract.",
            "     * @param allowedNftToken The token gated nft token.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns the token gated drop data for the nft contract\n     *         and token gated nft.\n     *\n     * @param nftContract     The nft contract.\n     * @param allowedNftToken The token gated nft token.\n     */\n",
        "@notice": "Returns the token gated drop data for the nft contract * and token gated nft.",
        "@param1": "nftContract The nft contract.",
        "@param2": "allowedNftToken The token gated nft token.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "getAllowedNftTokenIdIsRedeemed",
        "visibility": "external",
        "args": [
            {
                "name": "nftContract",
                "type": "address"
            },
            {
                "name": "allowedNftToken",
                "type": "address"
            },
            {
                "name": "allowedNftTokenId",
                "type": "uint256"
            }
        ],
        "func": "function getAllowedNftTokenIdIsRedeemed(\n        address nftContract,\n        address allowedNftToken,\n        uint256 allowedNftTokenId\n    ) external view returns (bool) {\n        return\n            _tokenGatedRedeemed[nftContract][allowedNftToken][\n                allowedNftTokenId\n            ];\n    }",
        "comments": [
            "/**",
            "     * @notice Returns whether the token id for a token gated drop has been",
            "     *         redeemed.",
            "     *",
            "     * @param nftContract       The nft contract.",
            "     * @param allowedNftToken   The token gated nft token.",
            "     * @param allowedNftTokenId The token gated nft token id to check.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Returns whether the token id for a token gated drop has been\n     *         redeemed.\n     *\n     * @param nftContract       The nft contract.\n     * @param allowedNftToken   The token gated nft token.\n     * @param allowedNftTokenId The token gated nft token id to check.\n     */\n",
        "@notice": "Returns whether the token id for a token gated drop has been * redeemed.",
        "@param1": "nftContract The nft contract.",
        "@param2": "allowedNftToken The token gated nft token.",
        "@param3": "allowedNftTokenId The token gated nft token id to check.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "updateDropURI",
        "visibility": "external",
        "args": [
            {
                "name": "dropURI",
                "type": "string calldata"
            }
        ],
        "func": "function updateDropURI(string calldata dropURI)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        // Emit an event with the update.\n        emit DropURIUpdated(msg.sender, dropURI);\n    }",
        "comments": [
            "/**",
            "     * @notice Emits an event to notify update of the drop URI.",
            "     *",
            "     *         This method assume msg.sender is an nft contract and its",
            "     *         ERC165 interface id matches INonFungibleSeaDropToken.",
            "     *",
            "     *         Note: Be sure only authorized users can call this from",
            "     *         token contracts that implement INonFungibleSeaDropToken.",
            "     *",
            "     * @param dropURI The new drop URI.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Emits an event to notify update of the drop URI.\n     *\n     *         This method assume msg.sender is an nft contract and its\n     *         ERC165 interface id matches INonFungibleSeaDropToken.\n     *\n     *         Note: Be sure only authorized users can call this from\n     *         token contracts that implement INonFungibleSeaDropToken.\n     *\n     * @param dropURI The new drop URI.\n     */\n",
        "@notice": "Emits an event to notify update of the drop URI. * * This method assume msg.sender is an nft contract and its * ERC165 interface id matches INonFungibleSeaDropToken. * * Note: Be sure only authorized users can call this from * token contracts that implement INonFungibleSeaDropToken.",
        "@param1": "dropURI The new drop URI.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "updatePublicDrop",
        "visibility": "external",
        "args": [
            {
                "name": "publicDrop",
                "type": "PublicDrop calldata"
            }
        ],
        "func": "function updatePublicDrop(PublicDrop calldata publicDrop)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        // Revert if the fee basis points is greater than 10_000.\n        if (publicDrop.feeBps > 10_000) {\n            revert InvalidFeeBps(publicDrop.feeBps);\n        }\n\n        // Set the public drop data.\n        _publicDrops[msg.sender] = publicDrop;\n\n        // Emit an event with the update.\n        emit PublicDropUpdated(msg.sender, publicDrop);\n    }",
        "comments": [
            "/**",
            "     * @notice Updates the public drop data for the nft contract",
            "     *         and emits an event.",
            "     *",
            "     *         This method assume msg.sender is an nft contract and its",
            "     *         ERC165 interface id matches INonFungibleSeaDropToken.",
            "     *",
            "     *         Note: Be sure only authorized users can call this from",
            "     *         token contracts that implement INonFungibleSeaDropToken.",
            "     *",
            "     * @param publicDrop The public drop data.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Updates the public drop data for the nft contract\n     *         and emits an event.\n     *\n     *         This method assume msg.sender is an nft contract and its\n     *         ERC165 interface id matches INonFungibleSeaDropToken.\n     *\n     *         Note: Be sure only authorized users can call this from\n     *         token contracts that implement INonFungibleSeaDropToken.\n     *\n     * @param publicDrop The public drop data.\n     */\n",
        "@notice": "Updates the public drop data for the nft contract * and emits an event. * * This method assume msg.sender is an nft contract and its * ERC165 interface id matches INonFungibleSeaDropToken. * * Note: Be sure only authorized users can call this from * token contracts that implement INonFungibleSeaDropToken.",
        "@param1": "publicDrop The public drop data.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "updateAllowList",
        "visibility": "external",
        "args": [
            {
                "name": "allowListData",
                "type": "AllowListData calldata"
            }
        ],
        "func": "function updateAllowList(AllowListData calldata allowListData)\n        external\n        override\n        onlyINonFungibleSeaDropToken\n    {\n        // Track the previous root.\n        bytes32 prevRoot = _allowListMerkleRoots[msg.sender];\n\n        // Update the merkle root.\n        _allowListMerkleRoots[msg.sender] = allowListData.merkleRoot;\n\n        // Emit an event with the update.\n        emit AllowListUpdated(\n            msg.sender,\n            prevRoot,\n            allowListData.merkleRoot,\n            allowListData.publicKeyURIs,\n            allowListData.allowListURI\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Updates the allow list merkle root for the nft contract",
            "     *         and emits an event.",
            "     *",
            "     *         This method assume msg.sender is an nft contract and its",
            "     *         ERC165 interface id matches INonFungibleSeaDropToken.",
            "     *",
            "     *         Note: Be sure only authorized users can call this from",
            "     *         token contracts that implement INonFungibleSeaDropToken.",
            "     *",
            "     * @param allowListData The allow list data.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Updates the allow list merkle root for the nft contract\n     *         and emits an event.\n     *\n     *         This method assume msg.sender is an nft contract and its\n     *         ERC165 interface id matches INonFungibleSeaDropToken.\n     *\n     *         Note: Be sure only authorized users can call this from\n     *         token contracts that implement INonFungibleSeaDropToken.\n     *\n     * @param allowListData The allow list data.\n     */\n",
        "@notice": "Updates the allow list merkle root for the nft contract * and emits an event. * * This method assume msg.sender is an nft contract and its * ERC165 interface id matches INonFungibleSeaDropToken. * * Note: Be sure only authorized users can call this from * token contracts that implement INonFungibleSeaDropToken.",
        "@param1": "allowListData The allow list data.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "updateTokenGatedDrop",
        "visibility": "external",
        "args": [
            {
                "name": "allowedNftToken",
                "type": "address"
            },
            {
                "name": "dropStage",
                "type": "TokenGatedDropStage calldata"
            }
        ],
        "func": "function updateTokenGatedDrop(\n        address allowedNftToken,\n        TokenGatedDropStage calldata dropStage\n    ) external override onlyINonFungibleSeaDropToken {\n        // Ensure the allowedNftToken is not the zero address.\n        if (allowedNftToken == address(0)) {\n            revert TokenGatedDropAllowedNftTokenCannotBeZeroAddress();\n        }\n\n        // Ensure the allowedNftToken cannot be the drop token itself.\n        if (allowedNftToken == msg.sender) {\n            revert TokenGatedDropAllowedNftTokenCannotBeDropToken();\n        }\n\n        // Revert if the fee basis points is greater than 10_000.\n        if (dropStage.feeBps > 10_000) {\n            revert InvalidFeeBps(dropStage.feeBps);\n        }\n\n        // Use maxTotalMintableByWallet != 0 as a signal that this update should\n        // add or update the drop stage, otherwise we will be removing.\n        bool addOrUpdateDropStage = dropStage.maxTotalMintableByWallet != 0;\n\n        // Get pointers to the token gated drop data and enumerated addresses.\n        TokenGatedDropStage storage existingDropStageData = _tokenGatedDrops[\n            msg.sender\n        ][allowedNftToken];\n        address[] storage enumeratedTokens = _enumeratedTokenGatedTokens[\n            msg.sender\n        ];\n\n        // Stage struct packs to a single slot, so load it\n        // as a uint256; if it is 0, it is empty.\n        bool dropStageDoesNotExist;\n        assembly {\n            dropStageDoesNotExist := iszero(sload(existingDropStageData.slot))\n        }\n\n        if (addOrUpdateDropStage) {\n            _tokenGatedDrops[msg.sender][allowedNftToken] = dropStage;\n            // Add to enumeration if it does not exist already.\n            if (dropStageDoesNotExist) {\n                enumeratedTokens.push(allowedNftToken);\n            }\n        } else {\n            // Check we are not deleting a drop stage that does not exist.\n            if (dropStageDoesNotExist) {\n                revert TokenGatedDropStageNotPresent();\n            }\n            // Clear storage slot and remove from enumeration.\n            delete _tokenGatedDrops[msg.sender][allowedNftToken];\n            _removeFromEnumeration(allowedNftToken, enumeratedTokens);\n        }\n\n        // Emit an event with the update.\n        emit TokenGatedDropStageUpdated(msg.sender, allowedNftToken, dropStage);\n    }",
        "comments": [
            "/**",
            "     * @notice Updates the token gated drop stage for the nft contract",
            "     *         and emits an event.",
            "     *",
            "     *         This method assume msg.sender is an nft contract and its",
            "     *         ERC165 interface id matches INonFungibleSeaDropToken.",
            "     *",
            "     *         Note: Be sure only authorized users can call this from",
            "     *         token contracts that implement INonFungibleSeaDropToken.",
            "     *",
            "     *         Note: If two INonFungibleSeaDropToken tokens are doing",
            "     *         simultaneous token gated drop promotions for each other,",
            "     *         they can be minted by the same actor until",
            "     *         `maxTokenSupplyForStage` is reached. Please ensure the",
            "     *         `allowedNftToken` is not running an active drop during",
            "     *         the `dropStage` time period.",
            "     *",
            "     * @param allowedNftToken The token gated nft token.",
            "     * @param dropStage       The token gated drop stage data.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Updates the token gated drop stage for the nft contract\n     *         and emits an event.\n     *\n     *         This method assume msg.sender is an nft contract and its\n     *         ERC165 interface id matches INonFungibleSeaDropToken.\n     *\n     *         Note: Be sure only authorized users can call this from\n     *         token contracts that implement INonFungibleSeaDropToken.\n     *\n     *         Note: If two INonFungibleSeaDropToken tokens are doing\n     *         simultaneous token gated drop promotions for each other,\n     *         they can be minted by the same actor until\n     *         `maxTokenSupplyForStage` is reached. Please ensure the\n     *         `allowedNftToken` is not running an active drop during\n     *         the `dropStage` time period.\n     *\n     * @param allowedNftToken The token gated nft token.\n     * @param dropStage       The token gated drop stage data.\n     */\n",
        "@notice": "Updates the token gated drop stage for the nft contract * and emits an event. * * This method assume msg.sender is an nft contract and its * ERC165 interface id matches INonFungibleSeaDropToken. * * Note: Be sure only authorized users can call this from * token contracts that implement INonFungibleSeaDropToken. * * Note: If two INonFungibleSeaDropToken tokens are doing * simultaneous token gated drop promotions for each other, * they can be minted by the same actor until * `maxTokenSupplyForStage` is reached. Please ensure the * `allowedNftToken` is not running an active drop during * the `dropStage` time period.",
        "@param1": "allowedNftToken The token gated nft token.",
        "@param2": "dropStage The token gated drop stage data.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "updateCreatorPayoutAddress",
        "visibility": "external",
        "args": [
            {
                "name": "payoutAddress",
                "type": "address"
            }
        ],
        "func": "function updateCreatorPayoutAddress(address payoutAddress)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payoutAddress == address(0)) {\n            revert CreatorPayoutAddressCannotBeZeroAddress();\n        }\n        // Set the creator payout address.\n        _creatorPayoutAddresses[msg.sender] = payoutAddress;\n\n        // Emit an event with the update.\n        emit CreatorPayoutAddressUpdated(msg.sender, payoutAddress);\n    }",
        "comments": [
            "/**",
            "     * @notice Updates the creator payout address and emits an event.",
            "     *",
            "     *         This method assume msg.sender is an nft contract and its",
            "     *         ERC165 interface id matches INonFungibleSeaDropToken.",
            "     *",
            "     *         Note: Be sure only authorized users can call this from",
            "     *         token contracts that implement INonFungibleSeaDropToken.",
            "     *",
            "     * @param payoutAddress The creator payout address.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Updates the creator payout address and emits an event.\n     *\n     *         This method assume msg.sender is an nft contract and its\n     *         ERC165 interface id matches INonFungibleSeaDropToken.\n     *\n     *         Note: Be sure only authorized users can call this from\n     *         token contracts that implement INonFungibleSeaDropToken.\n     *\n     * @param payoutAddress The creator payout address.\n     */\n",
        "@notice": "Updates the creator payout address and emits an event. * * This method assume msg.sender is an nft contract and its * ERC165 interface id matches INonFungibleSeaDropToken. * * Note: Be sure only authorized users can call this from * token contracts that implement INonFungibleSeaDropToken.",
        "@param1": "payoutAddress The creator payout address.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "updateAllowedFeeRecipient",
        "visibility": "external",
        "args": [
            {
                "name": "feeRecipient",
                "type": "address"
            },
            {
                "name": "allowed",
                "type": "bool"
            }
        ],
        "func": "function updateAllowedFeeRecipient(address feeRecipient, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (feeRecipient == address(0)) {\n            revert FeeRecipientCannotBeZeroAddress();\n        }\n\n        // Track the enumerated storage.\n        address[] storage enumeratedStorage = _enumeratedFeeRecipients[\n            msg.sender\n        ];\n        mapping(address => bool)\n            storage feeRecipientsMap = _allowedFeeRecipients[msg.sender];\n\n        if (allowed) {\n            if (feeRecipientsMap[feeRecipient]) {\n                revert DuplicateFeeRecipient();\n            }\n            feeRecipientsMap[feeRecipient] = true;\n            enumeratedStorage.push(feeRecipient);\n        } else {\n            if (!feeRecipientsMap[feeRecipient]) {\n                revert FeeRecipientNotPresent();\n            }\n            delete _allowedFeeRecipients[msg.sender][feeRecipient];\n            _removeFromEnumeration(feeRecipient, enumeratedStorage);\n        }\n\n        // Emit an event with the update.\n        emit AllowedFeeRecipientUpdated(msg.sender, feeRecipient, allowed);\n    }",
        "comments": [
            "/**",
            "     * @notice Updates the allowed fee recipient and emits an event.",
            "     *",
            "     *         This method assume msg.sender is an nft contract and its",
            "     *         ERC165 interface id matches INonFungibleSeaDropToken.",
            "     *",
            "     *         Note: Be sure only authorized users can call this from",
            "     *         token contracts that implement INonFungibleSeaDropToken.",
            "     *",
            "     * @param feeRecipient The fee recipient.",
            "     * @param allowed      If the fee recipient is allowed.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Updates the allowed fee recipient and emits an event.\n     *\n     *         This method assume msg.sender is an nft contract and its\n     *         ERC165 interface id matches INonFungibleSeaDropToken.\n     *\n     *         Note: Be sure only authorized users can call this from\n     *         token contracts that implement INonFungibleSeaDropToken.\n     *\n     * @param feeRecipient The fee recipient.\n     * @param allowed      If the fee recipient is allowed.\n     */\n",
        "@notice": "Updates the allowed fee recipient and emits an event. * * This method assume msg.sender is an nft contract and its * ERC165 interface id matches INonFungibleSeaDropToken. * * Note: Be sure only authorized users can call this from * token contracts that implement INonFungibleSeaDropToken.",
        "@param1": "feeRecipient The fee recipient.",
        "@param2": "allowed If the fee recipient is allowed.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "updateSignedMintValidationParams",
        "visibility": "external",
        "args": [
            {
                "name": "signer",
                "type": "address"
            },
            {
                "name": "signedMintValidationParams",
                "type": "SignedMintValidationParams calldata"
            }
        ],
        "func": "function updateSignedMintValidationParams(\n        address signer,\n        SignedMintValidationParams calldata signedMintValidationParams\n    ) external onlyINonFungibleSeaDropToken {\n        if (signer == address(0)) {\n            revert SignerCannotBeZeroAddress();\n        }\n\n        if (signedMintValidationParams.minFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.minFeeBps);\n        }\n        if (signedMintValidationParams.maxFeeBps > 10_000) {\n            revert InvalidFeeBps(signedMintValidationParams.maxFeeBps);\n        }\n\n        // Track the enumerated storage.\n        address[] storage enumeratedStorage = _enumeratedSigners[msg.sender];\n        mapping(address => SignedMintValidationParams)\n            storage signedMintValidationParamsMap = _signedMintValidationParams[\n                msg.sender\n            ];\n\n        SignedMintValidationParams\n            storage existingSignedMintValidationParams = signedMintValidationParamsMap[\n                signer\n            ];\n\n        bool signedMintValidationParamsDoNotExist;\n        assembly {\n            signedMintValidationParamsDoNotExist := iszero(\n                sload(existingSignedMintValidationParams.slot)\n            )\n        }\n        // Use maxMaxTotalMintableByWallet as sentry for add/update or delete.\n        bool addOrUpdate = signedMintValidationParams\n            .maxMaxTotalMintableByWallet > 0;\n\n        if (addOrUpdate) {\n            signedMintValidationParamsMap[signer] = signedMintValidationParams;\n            if (signedMintValidationParamsDoNotExist) {\n                enumeratedStorage.push(signer);\n            }\n        } else {\n            if (\n                existingSignedMintValidationParams\n                    .maxMaxTotalMintableByWallet == 0\n            ) {\n                revert SignerNotPresent();\n            }\n            delete _signedMintValidationParams[msg.sender][signer];\n            _removeFromEnumeration(signer, enumeratedStorage);\n        }\n\n        // Emit an event with the update.\n        emit SignedMintValidationParamsUpdated(\n            msg.sender,\n            signer,\n            signedMintValidationParams\n        );\n    }",
        "comments": [
            "/**",
            "     * @notice Updates the allowed server-side signers and emits an event.",
            "     *",
            "     *         This method assume msg.sender is an nft contract and its",
            "     *         ERC165 interface id matches INonFungibleSeaDropToken.",
            "     *",
            "     *         Note: Be sure only authorized users can call this from",
            "     *         token contracts that implement INonFungibleSeaDropToken.",
            "     *",
            "     * @param signer                     The signer to update.",
            "     * @param signedMintValidationParams Minimum and maximum parameters",
            "     *                                   to enforce for signed mints.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Updates the allowed server-side signers and emits an event.\n     *\n     *         This method assume msg.sender is an nft contract and its\n     *         ERC165 interface id matches INonFungibleSeaDropToken.\n     *\n     *         Note: Be sure only authorized users can call this from\n     *         token contracts that implement INonFungibleSeaDropToken.\n     *\n     * @param signer                     The signer to update.\n     * @param signedMintValidationParams Minimum and maximum parameters\n     *                                   to enforce for signed mints.\n     */\n",
        "@notice": "Updates the allowed server-side signers and emits an event. * * This method assume msg.sender is an nft contract and its * ERC165 interface id matches INonFungibleSeaDropToken. * * Note: Be sure only authorized users can call this from * token contracts that implement INonFungibleSeaDropToken.",
        "@param1": "signer The signer to update.",
        "@param2": "signedMintValidationParams Minimum and maximum parameters * to enforce for signed mints.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "updatePayer",
        "visibility": "external",
        "args": [
            {
                "name": "payer",
                "type": "address"
            },
            {
                "name": "allowed",
                "type": "bool"
            }
        ],
        "func": "function updatePayer(address payer, bool allowed)\n        external\n        onlyINonFungibleSeaDropToken\n    {\n        if (payer == address(0)) {\n            revert PayerCannotBeZeroAddress();\n        }\n\n        // Track the enumerated storage.\n        address[] storage enumeratedStorage = _enumeratedPayers[msg.sender];\n        mapping(address => bool) storage payersMap = _allowedPayers[msg.sender];\n\n        if (allowed) {\n            if (payersMap[payer]) {\n                revert DuplicatePayer();\n            }\n            payersMap[payer] = true;\n            enumeratedStorage.push(payer);\n        } else {\n            if (!payersMap[payer]) {\n                revert PayerNotPresent();\n            }\n            delete _allowedPayers[msg.sender][payer];\n            _removeFromEnumeration(payer, enumeratedStorage);\n        }\n\n        // Emit an event with the update.\n        emit PayerUpdated(msg.sender, payer, allowed);\n    }",
        "comments": [
            "/**",
            "     * @notice Updates the allowed payer and emits an event.",
            "     *",
            "     *         This method assume msg.sender is an nft contract and its",
            "     *         ERC165 interface id matches INonFungibleSeaDropToken.",
            "     *",
            "     *         Note: Be sure only authorized users can call this from",
            "     *         token contracts that implement INonFungibleSeaDropToken.",
            "     *",
            "     * @param payer   The payer to add or remove.",
            "     * @param allowed Whether to add or remove the payer.",
            "     */",
            ""
        ],
        "comt": "/**\n     * @notice Updates the allowed payer and emits an event.\n     *\n     *         This method assume msg.sender is an nft contract and its\n     *         ERC165 interface id matches INonFungibleSeaDropToken.\n     *\n     *         Note: Be sure only authorized users can call this from\n     *         token contracts that implement INonFungibleSeaDropToken.\n     *\n     * @param payer   The payer to add or remove.\n     * @param allowed Whether to add or remove the payer.\n     */\n",
        "@notice": "Updates the allowed payer and emits an event. * * This method assume msg.sender is an nft contract and its * ERC165 interface id matches INonFungibleSeaDropToken. * * Note: Be sure only authorized users can call this from * token contracts that implement INonFungibleSeaDropToken.",
        "@param1": "payer The payer to add or remove.",
        "@param2": "allowed Whether to add or remove the payer.",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 1,
        "low_quality": 0
    },
    {
        "name": "setStartAttack",
        "visibility": "public",
        "args": [],
        "func": "function setStartAttack() public payable {\n        startAttack = true;\n    }",
        "comments": [
            "",
            "    // Also receive some eth in the process",
            "    "
        ],
        "comt": "\n    // Also receive some eth in the process\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "attack",
        "visibility": "external",
        "args": [
            {
                "name": "_seaDrop",
                "type": "SeaDrop"
            },
            {
                "name": "_token",
                "type": "address"
            }
        ],
        "func": "function attack(SeaDrop _seaDrop, address _token) external payable {\n        token = _token;\n        seaDrop = _seaDrop;\n\n        _seaDrop.mintPublic{ value: 1 ether }({\n            nftContract: _token,\n            feeRecipient: address(this),\n            minterIfNotPayer: address(this),\n            quantity: 1\n        });\n\n        token = address(0);\n        seaDrop = SeaDrop(address(0));\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "mint",
        "visibility": "public",
        "args": [
            {
                "name": "to",
                "type": "address"
            },
            {
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "func": "function mint(address to, uint256 tokenId) public returns (bool) {\n        _mint(to, tokenId);\n        return true;\n    }",
        "comments": [
            "",
            "// Used for minting test ERC721s in our tests",
            "contract TestERC721 is ERC721(\"Test721\", \"TST721\") {",
            "    "
        ],
        "comt": "\n// Used for minting test ERC721s in our tests\ncontract TestERC721 is ERC721(\"Test721\", \"TST721\") {\n    ",
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "tokenURI",
        "visibility": "public",
        "args": [
            {
                "name": "uint256",
                "type": "uint256"
            }
        ],
        "func": "function tokenURI(uint256) public pure override returns (string memory) {\n        return \"tokenURI\";\n    }",
        "comments": [],
        "notice_missing": 0,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 1,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    }
]