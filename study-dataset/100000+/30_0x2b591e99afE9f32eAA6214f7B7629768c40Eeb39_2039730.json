[
    {
        "transactions": 2039730,
        "function_num": 30
    },
    {
        "name": "totalSupply",
        "visibility": "public",
        "args": [],
        "func": "function totalSupply() public view returns (uint256) {\n return _totalSupply;\n }",
        "comments": [
            "/**",
            " * @dev See {IERC20-totalSupply}.",
            " */",
            ""
        ],
        "comt": "/**\n * @dev See {IERC20-totalSupply}.\n */\n",
        "@dev": "See {IERC20-totalSupply}.",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "balanceOf",
        "visibility": "public",
        "args": [
            {
                "name": "account",
                "type": "address"
            }
        ],
        "func": "function balanceOf(address account) public view returns (uint256) {\n return _balances[account];\n }",
        "comments": [
            "/**",
            " * @dev See {IERC20-balanceOf}.",
            " */",
            ""
        ],
        "comt": "/**\n * @dev See {IERC20-balanceOf}.\n */\n",
        "@dev": "See {IERC20-balanceOf}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transfer",
        "visibility": "public",
        "args": [
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transfer(address recipient, uint256 amount) public returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }",
        "comments": [
            "/**",
            " * @dev See {IERC20-transfer}.",
            " *",
            " * Requirements:",
            "  *",
            " * - `recipient` cannot be the zero address.",
            " * - the caller must have a balance of at least `amount`.",
            " */",
            ""
        ],
        "comt": "/**\n * @dev See {IERC20-transfer}.\n *\n * Requirements:\n  *\n * - `recipient` cannot be the zero address.\n * - the caller must have a balance of at least `amount`.\n */\n",
        "@dev": "See {IERC20-transfer}. * * Requirements: * * - `recipient` cannot be the zero address. * - the caller must have a balance of at least `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allowance",
        "visibility": "public",
        "args": [
            {
                "name": "owner",
                "type": "address"
            },
            {
                "name": "spender",
                "type": "address"
            }
        ],
        "func": "function allowance(address owner, address spender) public view returns (uint256) {\n return _allowances[owner][spender];\n }",
        "comments": [
            "/**",
            " * @dev See {IERC20-allowance}.",
            " */",
            ""
        ],
        "comt": "/**\n * @dev See {IERC20-allowance}.\n */\n",
        "@dev": "See {IERC20-allowance}.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "approve",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function approve(address spender, uint256 amount) public returns (bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }",
        "comments": [
            "/**",
            " * @dev See {IERC20-approve}.",
            " *",
            " * Requirements:",
            " *",
            " * - `spender` cannot be the zero address.",
            " */",
            ""
        ],
        "comt": "/**\n * @dev See {IERC20-approve}.\n *\n * Requirements:\n *\n * - `spender` cannot be the zero address.\n */\n",
        "@dev": "See {IERC20-approve}. * * Requirements: * * - `spender` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "transferFrom",
        "visibility": "public",
        "args": [
            {
                "name": "sender",
                "type": "address"
            },
            {
                "name": "recipient",
                "type": "address"
            },
            {
                "name": "amount",
                "type": "uint256"
            }
        ],
        "func": "function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n _transfer(sender, recipient, amount);\n _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n return true;\n }",
        "comments": [
            "/**",
            " * @dev See {IERC20-transferFrom}.",
            " *",
            " * Emits an {Approval} event indicating the updated allowance. This is not",
            " * required by the EIP. See the note at the beginning of {ERC20};",
            " *",
            " * Requirements:",
            " * - `sender` and `recipient` cannot be the zero address.",
            " * - `sender` must have a balance of at least `amount`.",
            " * - the caller must have allowance for `sender`'s tokens of at least",
            " * `amount`.",
            " */",
            ""
        ],
        "comt": "/**\n * @dev See {IERC20-transferFrom}.\n *\n * Emits an {Approval} event indicating the updated allowance. This is not\n * required by the EIP. See the note at the beginning of {ERC20};\n *\n * Requirements:\n * - `sender` and `recipient` cannot be the zero address.\n * - `sender` must have a balance of at least `amount`.\n * - the caller must have allowance for `sender`'s tokens of at least\n * `amount`.\n */\n",
        "@dev": "See {IERC20-transferFrom}. * * Emits an {Approval} event indicating the updated allowance. This is not * required by the EIP. See the note at the beginning of {ERC20}; * * Requirements: * - `sender` and `recipient` cannot be the zero address. * - `sender` must have a balance of at least `amount`. * - the caller must have allowance for `sender`'s tokens of at least * `amount`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 0,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "increaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "addedValue",
                "type": "uint256"
            }
        ],
        "func": "function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n return true;\n }",
        "comments": [
            "/**",
            " * @dev Atomically increases the allowance granted to `spender` by the caller.",
            " *",
            " * This is an alternative to {approve} that can be used as a mitigation for",
            " * problems described in {IERC20-approve}.",
            " *",
            " * Emits an {Approval} event indicating the updated allowance.",
            " *",
            " * Requirements:",
            " *",
            " * - `spender` cannot be the zero address.",
            " */",
            ""
        ],
        "comt": "/**\n * @dev Atomically increases the allowance granted to `spender` by the caller.\n *\n * This is an alternative to {approve} that can be used as a mitigation for\n * problems described in {IERC20-approve}.\n *\n * Emits an {Approval} event indicating the updated allowance.\n *\n * Requirements:\n *\n * - `spender` cannot be the zero address.\n */\n",
        "@dev": "Atomically increases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "decreaseAllowance",
        "visibility": "public",
        "args": [
            {
                "name": "spender",
                "type": "address"
            },
            {
                "name": "subtractedValue",
                "type": "uint256"
            }
        ],
        "func": "function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n return true;\n }",
        "comments": [
            "/**",
            " * @dev Atomically decreases the allowance granted to `spender` by the caller.",
            " *",
            " * This is an alternative to {approve} that can be used as a mitigation for",
            " * problems described in {IERC20-approve}.",
            " *",
            " * Emits an {Approval} event indicating the updated allowance.",
            " *",
            " * Requirements:",
            " *",
            " * - `spender` cannot be the zero address.",
            " * - `spender` must have allowance for the caller of at least",
            " * `subtractedValue`.",
            " */",
            ""
        ],
        "comt": "/**\n * @dev Atomically decreases the allowance granted to `spender` by the caller.\n *\n * This is an alternative to {approve} that can be used as a mitigation for\n * problems described in {IERC20-approve}.\n *\n * Emits an {Approval} event indicating the updated allowance.\n *\n * Requirements:\n *\n * - `spender` cannot be the zero address.\n * - `spender` must have allowance for the caller of at least\n * `subtractedValue`.\n */\n",
        "@dev": "Atomically decreases the allowance granted to `spender` by the caller. * * This is an alternative to {approve} that can be used as a mitigation for * problems described in {IERC20-approve}. * * Emits an {Approval} event indicating the updated allowance. * * Requirements: * * - `spender` cannot be the zero address. * - `spender` must have allowance for the caller of at least * `subtractedValue`.",
        "notice_missing": 1,
        "param_missing": 1,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "dailyDataUpdate",
        "visibility": "external",
        "args": [
            {
                "name": "beforeDay",
                "type": "uint256"
            }
        ],
        "func": "function dailyDataUpdate(uint256 beforeDay)\n external\n {\n GlobalsCache memory g;\n GlobalsCache memory gSnapshot;\n _globalsLoad(g, gSnapshot);\n\n /* Skip pre-claim period */\n require(g._currentDay > CLAIM_PHASE_START_DAY, \"HEX: Too early\");\n\n if (beforeDay != 0) {\n require(beforeDay <= g._currentDay, \"HEX: beforeDay cannot be in the future\");\n\n _dailyDataUpdate(g, beforeDay, false);\n } else {\n /* Default to updating before current day */\n _dailyDataUpdate(g, g._currentDay, false);\n }\n\n _globalsSync(g, gSnapshot);\n }",
        "comments": [
            "/**",
            " * @dev PUBLIC FACING: Optionally update daily data for a smaller",
            " * range to reduce gas cost for a subsequent operation",
            " * @param beforeDay Only update days before this day number (optional; 0 for current day)",
            " */",
            ""
        ],
        "comt": "/**\n * @dev PUBLIC FACING: Optionally update daily data for a smaller\n * range to reduce gas cost for a subsequent operation\n * @param beforeDay Only update days before this day number (optional; 0 for current day)\n */\n",
        "@dev": "PUBLIC FACING: Optionally update daily data for a smaller * range to reduce gas cost for a subsequent operation",
        "@param1": "beforeDay Only update days before this day number (optional; 0 for current day)",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "dailyDataRange",
        "visibility": "external",
        "args": [
            {
                "name": "beginDay",
                "type": "uint256"
            },
            {
                "name": "endDay",
                "type": "uint256"
            }
        ],
        "func": "function dailyDataRange(uint256 beginDay, uint256 endDay)\n external\n view\n returns (uint256[] memory list)\n {\n require(beginDay < endDay && endDay <= globals.dailyDataCount, \"HEX: range invalid\");\n\n list = new uint256[](endDay - beginDay);\n\n uint256 src = beginDay;\n uint256 dst = 0;\n uint256 v;\n do {\n v = uint256(dailyData[src].dayUnclaimedSatoshisTotal) << (HEART_UINT_SIZE * 2);\n v |= uint256(dailyData[src].dayStakeSharesTotal) << HEART_UINT_SIZE;\n v |= uint256(dailyData[src].dayPayoutTotal);\n\n list[dst++] = v;\n } while (++src < endDay);\n\n return list;\n }",
        "comments": [
            "/**",
            " * @dev PUBLIC FACING: External helper to return multiple values of daily data with",
            " * a single call. Ugly implementation due to limitations of the standard ABI encoder.",
            " * @param beginDay First day of data range",
            " * @param endDay Last day (non-inclusive) of data range",
            " * @return Fixed array of packed values",
            " */",
            ""
        ],
        "comt": "/**\n * @dev PUBLIC FACING: External helper to return multiple values of daily data with\n * a single call. Ugly implementation due to limitations of the standard ABI encoder.\n * @param beginDay First day of data range\n * @param endDay Last day (non-inclusive) of data range\n * @return Fixed array of packed values\n */\n",
        "@dev": "PUBLIC FACING: External helper to return multiple values of daily data with * a single call. Ugly implementation due to limitations of the standard ABI encoder.",
        "@param1": "beginDay First day of data range",
        "@param2": "endDay Last day (non-inclusive) of data range",
        "@return1": "Fixed array of packed values",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "globalInfo",
        "visibility": "external",
        "args": [],
        "func": "function globalInfo()\n external\n view\n returns (uint256[13] memory)\n {\n uint256 _claimedBtcAddrCount;\n uint256 _claimedSatoshisTotal;\n uint256 _unclaimedSatoshisTotal;\n\n  (_claimedBtcAddrCount, _claimedSatoshisTotal, _unclaimedSatoshisTotal) = _claimStatsDecode(\n globals.claimStats\n );\n\n return [\n // 1\n globals.lockedHeartsTotal,\n globals.nextStakeSharesTotal,\n globals.shareRate,\n globals.stakePenaltyTotal,\n // 2\n globals.dailyDataCount,\n globals.stakeSharesTotal,\n globals.latestStakeId,\n _unclaimedSatoshisTotal,\n _claimedSatoshisTotal,\n _claimedBtcAddrCount,\n //\n block.timestamp,\n totalSupply(),\n xfLobby[_currentDay()]\n ];\n }",
        "comments": [
            "/**",
            " * @dev PUBLIC FACING: External helper to return most global info with a single call.",
            " * Ugly implementation due to limitations of the standard ABI encoder.",
            " * @return Fixed array of values",
            " */",
            ""
        ],
        "comt": "/**\n * @dev PUBLIC FACING: External helper to return most global info with a single call.\n * Ugly implementation due to limitations of the standard ABI encoder.\n * @return Fixed array of values\n */\n",
        "@dev": "PUBLIC FACING: External helper to return most global info with a single call. * Ugly implementation due to limitations of the standard ABI encoder.",
        "@return1": "Fixed array of values",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "allocatedSupply",
        "visibility": "external",
        "args": [],
        "func": "function allocatedSupply()\n external\n view\n returns (uint256)\n {\n return totalSupply() + globals.lockedHeartsTotal;\n }",
        "comments": [
            "/**",
            " * @dev PUBLIC FACING: ERC20 totalSupply() is the circulating supply and does not include any",
            " * staked Hearts. allocatedSupply() includes both.",
            " * @return Allocated Supply in Hearts",
            " */",
            ""
        ],
        "comt": "/**\n * @dev PUBLIC FACING: ERC20 totalSupply() is the circulating supply and does not include any\n * staked Hearts. allocatedSupply() includes both.\n * @return Allocated Supply in Hearts\n */\n",
        "@dev": "PUBLIC FACING: ERC20 totalSupply() is the circulating supply and does not include any * staked Hearts. allocatedSupply() includes both.",
        "@return1": "Allocated Supply in Hearts",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "currentDay",
        "visibility": "external",
        "args": [],
        "func": "function currentDay()\n external\n view\n returns (uint256)\n {\n return _currentDay();\n }",
        "comments": [
            "/**",
            " * @dev PUBLIC FACING: External helper for the current day number since launch time",
            " * @return Current day number (zero-based)",
            " */",
            ""
        ],
        "comt": "/**\n * @dev PUBLIC FACING: External helper for the current day number since launch time\n * @return Current day number (zero-based)\n */\n",
        "@dev": "PUBLIC FACING: External helper for the current day number since launch time",
        "@return1": "Current day number (zero-based)",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stakeStart",
        "visibility": "external",
        "args": [
            {
                "name": "newStakedHearts",
                "type": "uint256"
            },
            {
                "name": "newStakedDays",
                "type": "uint256"
            }
        ],
        "func": "function stakeStart(uint256 newStakedHearts, uint256 newStakedDays)\n external\n {\n GlobalsCache memory g;\n GlobalsCache memory gSnapshot;\n _globalsLoad(g, gSnapshot);\n\n /* Enforce the minimum stake time */\n require(newStakedDays >= MIN_STAKE_DAYS, \"HEX: newStakedDays lower than minimum\");\n\n /* Check if log data needs to be updated */\n _dailyDataUpdateAuto(g);\n\n _stakeStart(g, newStakedHearts, newStakedDays, false);\n\n /* Remove staked Hearts from balance of staker */\n _burn(msg.sender, newStakedHearts);\n\n _globalsSync(g, gSnapshot);\n }",
        "comments": [
            "/**",
            " * @dev PUBLIC FACING: Open a stake.",
            " * @param newStakedHearts Number of Hearts to stake",
            " * @param newStakedDays Number of days to stake",
            " */",
            ""
        ],
        "comt": "/**\n * @dev PUBLIC FACING: Open a stake.\n * @param newStakedHearts Number of Hearts to stake\n * @param newStakedDays Number of days to stake\n */\n",
        "@dev": "PUBLIC FACING: Open a stake.",
        "@param1": "newStakedHearts Number of Hearts to stake",
        "@param2": "newStakedDays Number of days to stake",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stakeGoodAccounting",
        "visibility": "external",
        "args": [
            {
                "name": "stakerAddr",
                "type": "address"
            },
            {
                "name": "stakeIndex",
                "type": "uint256"
            },
            {
                "name": "stakeIdParam",
                "type": "uint40"
            }
        ],
        "func": "function stakeGoodAccounting(address stakerAddr, uint256 stakeIndex, uint40 stakeIdParam)\n external\n {\n GlobalsCache memory g;\n GlobalsCache memory gSnapshot;\n _globalsLoad(g, gSnapshot);\n\n /* require() is more informative than the default assert() */\n require(stakeLists[stakerAddr].length != 0, \"HEX: Empty stake list\");\n require(stakeIndex < stakeLists[stakerAddr].length, \"HEX: stakeIndex invalid\");\n\n StakeStore storage stRef = stakeLists[stakerAddr][stakeIndex];\n\n /* Get stake copy */\n StakeCache memory st;\n _stakeLoad(stRef, stakeIdParam, st);\n\n /* Stake must have served full term */\n require(g._currentDay >= st._lockedDay + st._stakedDays, \"HEX: Stake not fully served\");\n\n /* Stake must still be locked */\n require(st._unlockedDay == 0, \"HEX: Stake already unlocked\");\n\n /* Check if log data needs to be updated */\n _dailyDataUpdateAuto(g);\n\n /* Unlock the completed stake */\n _stakeUnlock(g, st);\n\n /* stakeReturn value is unused here */\n (, uint256 payout, uint256 penalty, uint256 cappedPenalty) = _stakePerformance(\n g,\n st,\n st._stakedDays\n );\n\n _emitStakeGoodAccounting(\n stakerAddr,\n stakeIdParam,\n st._stakedHearts,\n st._stakeShares,\n payout,\n penalty\n );\n\n if (cappedPenalty != 0) {\n _splitPenaltyProceeds(g, cappedPenalty);\n }\n\n /* st._unlockedDay has changed */\n _stakeUpdate(stRef, st);\n\n _globalsSync(g, gSnapshot);\n }",
        "comments": [
            "/**",
            " * @dev PUBLIC FACING: Unlocks a completed stake, distributing the proceeds of any penalty",
            " * immediately. The staker must still call stakeEnd() to retrieve their stake return (if any).",
            " * @param stakerAddr Address of staker",
            " * @param stakeIndex Index of stake within stake list",
            " * @param stakeIdParam The stake's id",
            " */",
            ""
        ],
        "comt": "/**\n * @dev PUBLIC FACING: Unlocks a completed stake, distributing the proceeds of any penalty\n * immediately. The staker must still call stakeEnd() to retrieve their stake return (if any).\n * @param stakerAddr Address of staker\n * @param stakeIndex Index of stake within stake list\n * @param stakeIdParam The stake's id\n */\n",
        "@dev": "PUBLIC FACING: Unlocks a completed stake, distributing the proceeds of any penalty * immediately. The staker must still call stakeEnd() to retrieve their stake return (if any).",
        "@param1": "stakerAddr Address of staker",
        "@param2": "stakeIndex Index of stake within stake list",
        "@param3": "stakeIdParam The stake's id",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stakeEnd",
        "visibility": "external",
        "args": [
            {
                "name": "stakeIndex",
                "type": "uint256"
            },
            {
                "name": "stakeIdParam",
                "type": "uint40"
            }
        ],
        "func": "function stakeEnd(uint256 stakeIndex, uint40 stakeIdParam)\n external\n {\n GlobalsCache memory g;\n GlobalsCache memory gSnapshot;\n _globalsLoad(g, gSnapshot);\n\n StakeStore[] storage stakeListRef = stakeLists[msg.sender];\n\n /* require() is more informative than the default assert() */\n require(stakeListRef.length != 0, \"HEX: Empty stake list\");\n require(stakeIndex < stakeListRef.length, \"HEX: stakeIndex invalid\");\n\n /* Get stake copy */\n StakeCache memory st;\n _stakeLoad(stakeListRef[stakeIndex], stakeIdParam, st);\n\n /* Check if log data needs to be updated */\n _dailyDataUpdateAuto(g);\n\n uint256 servedDays = 0;\n\n bool prevUnlocked = (st._unlockedDay != 0);\n uint256 stakeReturn;\n uint256 payout = 0;\n uint256 penalty = 0;\n uint256 cappedPenalty = 0;\n\n if (g._currentDay >= st._lockedDay) {\n if (prevUnlocked) {\n /* Previously unlocked in stakeGoodAccounting(), so must have served full term */\n servedDays = st._stakedDays;\n } else {\n _stakeUnlock(g, st);\n\n  servedDays = g._currentDay - st._lockedDay;\n if (servedDays > st._stakedDays) {\n servedDays = st._stakedDays;\n } else {\n /* Deny early-unstake before an auto-stake minimum has been served */\n if (servedDays < MIN_AUTO_STAKE_DAYS) {\n require(!st._isAutoStake, \"HEX: Auto-stake still locked\");\n }\n }\n }\n\n (stakeReturn, payout, penalty, cappedPenalty) = _stakePerformance(g, st, servedDays);\n } else {\n /* Deny early-unstake before an auto-stake minimum has been served */\n require(!st._isAutoStake, \"HEX: Auto-stake still locked\");\n\n /* Stake hasn't been added to the total yet, so no penalties or rewards apply */\n g._nextStakeSharesTotal -= st._stakeShares;\n\n stakeReturn = st._stakedHearts;\n }\n\n _emitStakeEnd(\n stakeIdParam,\n st._stakedHearts,\n st._stakeShares,\n payout,\n penalty,\n servedDays,\n prevUnlocked\n );\n\n if (cappedPenalty != 0 && !prevUnlocked) {\n /* Split penalty proceeds only if not previously unlocked by stakeGoodAccounting() */\n _splitPenaltyProceeds(g, cappedPenalty);\n }\n\n /* Pay the stake return, if any, to the staker */\n if (stakeReturn != 0) {\n _mint(msg.sender, stakeReturn);\n\n /* Update the share rate if necessary */\n _shareRateUpdate(g, st, stakeReturn);\n }\n g._lockedHeartsTotal -= st._stakedHearts;\n\n _stakeRemove(stakeListRef, stakeIndex);\n\n _globalsSync(g, gSnapshot);\n }",
        "comments": [
            "/**",
            " * @dev PUBLIC FACING: Closes a stake. The order of the stake list can change so",
            " * a stake id is used to reject stale indexes.",
            " * @param stakeIndex Index of stake within stake list",
            " * @param stakeIdParam The stake's id",
            " */",
            ""
        ],
        "comt": "/**\n * @dev PUBLIC FACING: Closes a stake. The order of the stake list can change so\n * a stake id is used to reject stale indexes.\n * @param stakeIndex Index of stake within stake list\n * @param stakeIdParam The stake's id\n */\n",
        "@dev": "PUBLIC FACING: Closes a stake. The order of the stake list can change so * a stake id is used to reject stale indexes.",
        "@param1": "stakeIndex Index of stake within stake list",
        "@param2": "stakeIdParam The stake's id",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "stakeCount",
        "visibility": "external",
        "args": [
            {
                "name": "stakerAddr",
                "type": "address"
            }
        ],
        "func": "function stakeCount(address stakerAddr)\n external\n view\n returns (uint256)\n {\n return stakeLists[stakerAddr].length;\n }",
        "comments": [
            "/**",
            " * @dev PUBLIC FACING: Return the current stake count for a staker address",
            " * @param stakerAddr Address of staker",
            " */",
            ""
        ],
        "comt": "/**\n * @dev PUBLIC FACING: Return the current stake count for a staker address\n * @param stakerAddr Address of staker\n */\n",
        "@dev": "PUBLIC FACING: Return the current stake count for a staker address",
        "@param1": "stakerAddr Address of staker",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "btcAddressIsClaimable",
        "visibility": "external",
        "args": [
            {
                "name": "btcAddr",
                "type": "bytes20"
            },
            {
                "name": "rawSatoshis",
                "type": "uint256"
            },
            {
                "name": "proof",
                "type": "bytes32[] calldata"
            }
        ],
        "func": "function btcAddressIsClaimable(bytes20 btcAddr, uint256 rawSatoshis, bytes32[] calldata proof)\n external\n view\n returns (bool)\n {\n uint256 day = _currentDay();\n\n require(day >= CLAIM_PHASE_START_DAY, \"HEX: Claim phase has not yet started\");\n require(day < CLAIM_PHASE_END_DAY, \"HEX: Claim phase has ended\");\n\n /* Don't need to check Merkle proof if UTXO BTC address has already been claimed */\n if (btcAddressClaims[btcAddr]) {\n return false;\n }\n\n /* Verify the Merkle tree proof */\n return _btcAddressIsValid(btcAddr, rawSatoshis, proof);\n }",
        "comments": [
            "/**",
            " * @dev PUBLIC FACING: Verify a BTC address and balance are unclaimed and part of the Merkle tree",
            " * @param btcAddr Bitcoin address (binary; no base58-check encoding)",
            " * @param rawSatoshis Raw BTC address balance in Satoshis",
            " * @param proof Merkle tree proof",
            " * @return True if can be claimed",
            " */",
            ""
        ],
        "comt": "/**\n * @dev PUBLIC FACING: Verify a BTC address and balance are unclaimed and part of the Merkle tree\n * @param btcAddr Bitcoin address (binary; no base58-check encoding)\n * @param rawSatoshis Raw BTC address balance in Satoshis\n * @param proof Merkle tree proof\n * @return True if can be claimed\n */\n",
        "@dev": "PUBLIC FACING: Verify a BTC address and balance are unclaimed and part of the Merkle tree",
        "@param1": "btcAddr Bitcoin address (binary; no base58-check encoding)",
        "@param2": "rawSatoshis Raw BTC address balance in Satoshis",
        "@param3": "proof Merkle tree proof",
        "@return1": "True if can be claimed",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "btcAddressIsValid",
        "visibility": "external",
        "args": [
            {
                "name": "btcAddr",
                "type": "bytes20"
            },
            {
                "name": "rawSatoshis",
                "type": "uint256"
            },
            {
                "name": "proof",
                "type": "bytes32[] calldata"
            }
        ],
        "func": "function btcAddressIsValid(bytes20 btcAddr, uint256 rawSatoshis, bytes32[] calldata proof)\n external\n pure\n returns (bool)\n {\n return _btcAddressIsValid(btcAddr, rawSatoshis, proof);\n }",
        "comments": [
            "/**",
            " * @dev PUBLIC FACING: Verify a BTC address and balance are part of the Merkle tree",
            " * @param btcAddr Bitcoin address (binary; no base58-check encoding)",
            " * @param rawSatoshis Raw BTC address balance in Satoshis",
            " * @param proof Merkle tree proof",
            " * @return True if valid",
            " */",
            ""
        ],
        "comt": "/**\n * @dev PUBLIC FACING: Verify a BTC address and balance are part of the Merkle tree\n * @param btcAddr Bitcoin address (binary; no base58-check encoding)\n * @param rawSatoshis Raw BTC address balance in Satoshis\n * @param proof Merkle tree proof\n * @return True if valid\n */\n",
        "@dev": "PUBLIC FACING: Verify a BTC address and balance are part of the Merkle tree",
        "@param1": "btcAddr Bitcoin address (binary; no base58-check encoding)",
        "@param2": "rawSatoshis Raw BTC address balance in Satoshis",
        "@param3": "proof Merkle tree proof",
        "@return1": "True if valid",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "merkleProofIsValid",
        "visibility": "external",
        "args": [
            {
                "name": "merkleLeaf",
                "type": "bytes32"
            },
            {
                "name": "proof",
                "type": "bytes32[] calldata"
            }
        ],
        "func": "function merkleProofIsValid(bytes32 merkleLeaf, bytes32[] calldata proof)\n external\n pure\n returns (bool)\n {\n return _merkleProofIsValid(merkleLeaf, proof);\n }",
        "comments": [
            "/**",
            " * @dev PUBLIC FACING: Verify a Merkle proof using the UTXO Merkle tree",
            " * @param merkleLeaf Leaf asserted to be present in the Merkle tree",
            " * @param proof Generated Merkle tree proof",
            " * @return True if valid",
            " */",
            ""
        ],
        "comt": "/**\n * @dev PUBLIC FACING: Verify a Merkle proof using the UTXO Merkle tree\n * @param merkleLeaf Leaf asserted to be present in the Merkle tree\n * @param proof Generated Merkle tree proof\n * @return True if valid\n */\n",
        "@dev": "PUBLIC FACING: Verify a Merkle proof using the UTXO Merkle tree",
        "@param1": "merkleLeaf Leaf asserted to be present in the Merkle tree",
        "@param2": "proof Generated Merkle tree proof",
        "@return1": "True if valid",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "claimMessageMatchesSignature",
        "visibility": "public",
        "args": [
            {
                "name": "claimToAddr",
                "type": "address"
            },
            {
                "name": "claimParamHash",
                "type": "bytes32"
            },
            {
                "name": "pubKeyX",
                "type": "bytes32"
            },
            {
                "name": "pubKeyY",
                "type": "bytes32"
            },
            {
                "name": "claimFlags",
                "type": "uint8"
            },
            {
                "name": "v",
                "type": "uint8"
            },
            {
                "name": "r",
                "type": "bytes32"
            },
            {
                "name": "s",
                "type": "bytes32"
            }
        ],
        "func": "function claimMessageMatchesSignature(\n address claimToAddr,\n bytes32 claimParamHash,\n bytes32 pubKeyX,\n bytes32 pubKeyY,\n uint8 claimFlags,\n uint8 v,\n bytes32 r,\n bytes32 s\n )\n public\n pure\n returns (bool)\n {\n require(v >= 27 && v <= 30, \"HEX: v invalid\");\n\n /*\n ecrecover() returns an Eth address rather than a public key, so\n we must do the same to compare.\n */\n address pubKeyEthAddr = pubKeyToEthAddress(pubKeyX, pubKeyY);\n\n /* Create and hash the claim message text */\n bytes32 messageHash = _hash256(\n _claimMessageCreate(claimToAddr, claimParamHash, claimFlags)\n );\n\n /* Verify the public key */\n return ecrecover(messageHash, v, r, s) == pubKeyEthAddr;\n }",
        "comments": [
            "/**",
            " * @dev PUBLIC FACING: Verify that a Bitcoin signature matches the claim message containing",
            " * the Ethereum address and claim param hash",
            " * @param claimToAddr Eth address within the signed claim message",
            " * @param claimParamHash Param hash within the signed claim message",
            " * @param pubKeyX First half of uncompressed ECDSA public key",
            " * @param pubKeyY Second half of uncompressed ECDSA public key",
            " * @param claimFlags Claim flags specifying address and message formats",
            " * @param v v parameter of ECDSA signature",
            " * @param r r parameter of ECDSA signature",
            " * @param s s parameter of ECDSA signature",
            " * @return True if matching",
            " */",
            ""
        ],
        "comt": "/**\n * @dev PUBLIC FACING: Verify that a Bitcoin signature matches the claim message containing\n * the Ethereum address and claim param hash\n * @param claimToAddr Eth address within the signed claim message\n * @param claimParamHash Param hash within the signed claim message\n * @param pubKeyX First half of uncompressed ECDSA public key\n * @param pubKeyY Second half of uncompressed ECDSA public key\n * @param claimFlags Claim flags specifying address and message formats\n * @param v v parameter of ECDSA signature\n * @param r r parameter of ECDSA signature\n * @param s s parameter of ECDSA signature\n * @return True if matching\n */\n",
        "@dev": "PUBLIC FACING: Verify that a Bitcoin signature matches the claim message containing * the Ethereum address and claim param hash",
        "@param1": "claimToAddr Eth address within the signed claim message",
        "@param2": "claimParamHash Param hash within the signed claim message",
        "@param3": "pubKeyX First half of uncompressed ECDSA public key",
        "@param4": "pubKeyY Second half of uncompressed ECDSA public key",
        "@param5": "claimFlags Claim flags specifying address and message formats",
        "@param6": "v v parameter of ECDSA signature",
        "@param7": "r r parameter of ECDSA signature",
        "@param8": "s s parameter of ECDSA signature",
        "@return1": "True if matching",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "pubKeyToEthAddress",
        "visibility": "public",
        "args": [
            {
                "name": "pubKeyX",
                "type": "bytes32"
            },
            {
                "name": "pubKeyY",
                "type": "bytes32"
            }
        ],
        "func": "function pubKeyToEthAddress(bytes32 pubKeyX, bytes32 pubKeyY)\n public\n pure\n returns (address)\n {\n return address(uint160(uint256(keccak256(abi.encodePacked(pubKeyX, pubKeyY)))));\n }",
        "comments": [
            "/**",
            " * @dev PUBLIC FACING: Derive an Ethereum address from an ECDSA public key",
            " * @param pubKeyX First half of uncompressed ECDSA public key",
            " * @param pubKeyY Second half of uncompressed ECDSA public key",
            " * @return Derived Eth address",
            " */",
            ""
        ],
        "comt": "/**\n * @dev PUBLIC FACING: Derive an Ethereum address from an ECDSA public key\n * @param pubKeyX First half of uncompressed ECDSA public key\n * @param pubKeyY Second half of uncompressed ECDSA public key\n * @return Derived Eth address\n */\n",
        "@dev": "PUBLIC FACING: Derive an Ethereum address from an ECDSA public key",
        "@param1": "pubKeyX First half of uncompressed ECDSA public key",
        "@param2": "pubKeyY Second half of uncompressed ECDSA public key",
        "@return1": "Derived Eth address",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "pubKeyToBtcAddress",
        "visibility": "public",
        "args": [
            {
                "name": "pubKeyX",
                "type": "bytes32"
            },
            {
                "name": "pubKeyY",
                "type": "bytes32"
            },
            {
                "name": "claimFlags",
                "type": "uint8"
            }
        ],
        "func": "function pubKeyToBtcAddress(bytes32 pubKeyX, bytes32 pubKeyY, uint8 claimFlags)\n  public\n pure\n returns (bytes20)\n {\n /*\n Helpful references:\n - https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses\n - https://github.com/cryptocoinjs/ecurve/blob/master/lib/point.js\n */\n uint8 startingByte;\n bytes memory pubKey;\n bool compressed = (claimFlags & CLAIM_FLAG_BTC_ADDR_COMPRESSED) != 0;\n bool nested = (claimFlags & CLAIM_FLAG_BTC_ADDR_P2WPKH_IN_P2SH) != 0;\n bool bech32 = (claimFlags & CLAIM_FLAG_BTC_ADDR_BECH32) != 0;\n\n if (compressed) {\n /* Compressed public key format */\n require(!(nested && bech32), \"HEX: claimFlags invalid\");\n\n startingByte = (pubKeyY[31] & 0x01) == 0 ? 0x02 : 0x03;\n pubKey = abi.encodePacked(startingByte, pubKeyX);\n } else {\n /* Uncompressed public key format */\n require(!nested && !bech32, \"HEX: claimFlags invalid\");\n\n startingByte = 0x04;\n pubKey = abi.encodePacked(startingByte, pubKeyX, pubKeyY);\n }\n\n bytes20 pubKeyHash = _hash160(pubKey);\n if (nested) {\n return _hash160(abi.encodePacked(hex\"0014\", pubKeyHash));\n }\n return pubKeyHash;\n }",
        "comments": [
            "/**",
            " * @dev PUBLIC FACING: Derive a Bitcoin address from an ECDSA public key",
            " * @param pubKeyX First half of uncompressed ECDSA public key",
            " * @param pubKeyY Second half of uncompressed ECDSA public key",
            " * @param claimFlags Claim flags specifying address and message formats",
            " * @return Derived Bitcoin address (binary; no base58-check encoding)",
            " */",
            ""
        ],
        "comt": "/**\n * @dev PUBLIC FACING: Derive a Bitcoin address from an ECDSA public key\n * @param pubKeyX First half of uncompressed ECDSA public key\n * @param pubKeyY Second half of uncompressed ECDSA public key\n * @param claimFlags Claim flags specifying address and message formats\n * @return Derived Bitcoin address (binary; no base58-check encoding)\n */\n",
        "@dev": "PUBLIC FACING: Derive a Bitcoin address from an ECDSA public key",
        "@param1": "pubKeyX First half of uncompressed ECDSA public key",
        "@param2": "pubKeyY Second half of uncompressed ECDSA public key",
        "@param3": "claimFlags Claim flags specifying address and message formats",
        "@return1": "Derived Bitcoin address (binary; no base58-check encoding)",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "btcAddressClaim",
        "visibility": "external",
        "args": [
            {
                "name": "rawSatoshis",
                "type": "uint256"
            },
            {
                "name": "proof",
                "type": "bytes32[] calldata"
            },
            {
                "name": "claimToAddr",
                "type": "address"
            },
            {
                "name": "pubKeyX",
                "type": "bytes32"
            },
            {
                "name": "pubKeyY",
                "type": "bytes32"
            },
            {
                "name": "claimFlags",
                "type": "uint8"
            },
            {
                "name": "v",
                "type": "uint8"
            },
            {
                "name": "r",
                "type": "bytes32"
            },
            {
                "name": "s",
                "type": "bytes32"
            },
            {
                "name": "autoStakeDays",
                "type": "uint256"
            },
            {
                "name": "referrerAddr",
                "type": "address"
            }
        ],
        "func": "function btcAddressClaim(\n uint256 rawSatoshis,\n bytes32[] calldata proof,\n address claimToAddr,\n bytes32 pubKeyX,\n bytes32 pubKeyY,\n uint8 claimFlags,\n uint8 v,\n bytes32 r,\n bytes32 s,\n uint256 autoStakeDays,\n address referrerAddr\n )\n external\n returns (uint256)\n {\n /* Sanity check */\n require(rawSatoshis <= MAX_BTC_ADDR_BALANCE_SATOSHIS, \"HEX: CHK: rawSatoshis\");\n\n /* Enforce the minimum stake time for the auto-stake from this claim */\n require(autoStakeDays >= MIN_AUTO_STAKE_DAYS, \"HEX: autoStakeDays lower than minimum\");\n\n /* Ensure signature matches the claim message containing the Eth address and claimParamHash */\n {\n bytes32 claimParamHash = 0;\n\n if (claimToAddr != msg.sender) {\n /* Claimer did not send this, so claim params must be signed */\n claimParamHash = keccak256(\n abi.encodePacked(MERKLE_TREE_ROOT, autoStakeDays, referrerAddr)\n );\n }\n\n require(\n claimMessageMatchesSignature(\n claimToAddr,\n claimParamHash,\n pubKeyX,\n pubKeyY,\n claimFlags,\n v,\n r,\n s\n ),\n \"HEX: Signature mismatch\"\n );\n }\n\n /* Derive BTC address from public key */\n bytes20 btcAddr = pubKeyToBtcAddress(pubKeyX, pubKeyY, claimFlags);\n\n /* Ensure BTC address has not yet been claimed */\n require(!btcAddressClaims[btcAddr], \"HEX: BTC address balance already claimed\");\n\n /* Ensure BTC address is part of the Merkle tree */\n require(\n _btcAddressIsValid(btcAddr, rawSatoshis, proof),\n \"HEX: BTC address or balance unknown\"\n );\n\n /* Mark BTC address as claimed */\n btcAddressClaims[btcAddr] = true;\n\n return _satoshisClaimSync(\n rawSatoshis,\n claimToAddr,\n btcAddr,\n claimFlags,\n autoStakeDays,\n referrerAddr\n );\n }",
        "comments": [
            "/**",
            " * @dev PUBLIC FACING: Claim a BTC address and its Satoshi balance in Hearts",
            " * crediting the appropriate amount to a specified Eth address. Bitcoin ECDSA",
            " * signature must be from that BTC address and must match the claim message",
            " * for the Eth address.",
            " * @param rawSatoshis Raw BTC address balance in Satoshis",
            " * @param proof Merkle tree proof",
            " * @param claimToAddr Destination Eth address to credit Hearts to",
            " * @param pubKeyX First half of uncompressed ECDSA public key for the BTC address",
            " * @param pubKeyY Second half of uncompressed ECDSA public key for the BTC address",
            " * @param claimFlags Claim flags specifying address and message formats",
            " * @param v v parameter of ECDSA signature",
            " * @param r r parameter of ECDSA signature",
            " * @param s s parameter of ECDSA signature",
            " * @param autoStakeDays Number of days to auto-stake, subject to minimum auto-stake days",
            " * @param referrerAddr Eth address of referring user (optional; 0x0 for no referrer)",
            " * @return Total number of Hearts credited, if successful",
            " */",
            ""
        ],
        "comt": "/**\n * @dev PUBLIC FACING: Claim a BTC address and its Satoshi balance in Hearts\n * crediting the appropriate amount to a specified Eth address. Bitcoin ECDSA\n * signature must be from that BTC address and must match the claim message\n * for the Eth address.\n * @param rawSatoshis Raw BTC address balance in Satoshis\n * @param proof Merkle tree proof\n * @param claimToAddr Destination Eth address to credit Hearts to\n * @param pubKeyX First half of uncompressed ECDSA public key for the BTC address\n * @param pubKeyY Second half of uncompressed ECDSA public key for the BTC address\n * @param claimFlags Claim flags specifying address and message formats\n * @param v v parameter of ECDSA signature\n * @param r r parameter of ECDSA signature\n * @param s s parameter of ECDSA signature\n * @param autoStakeDays Number of days to auto-stake, subject to minimum auto-stake days\n * @param referrerAddr Eth address of referring user (optional; 0x0 for no referrer)\n * @return Total number of Hearts credited, if successful\n */\n",
        "@dev": "PUBLIC FACING: Claim a BTC address and its Satoshi balance in Hearts * crediting the appropriate amount to a specified Eth address. Bitcoin ECDSA * signature must be from that BTC address and must match the claim message * for the Eth address.",
        "@param1": "rawSatoshis Raw BTC address balance in Satoshis",
        "@param2": "proof Merkle tree proof",
        "@param3": "claimToAddr Destination Eth address to credit Hearts to",
        "@param4": "pubKeyX First half of uncompressed ECDSA public key for the BTC address",
        "@param5": "pubKeyY Second half of uncompressed ECDSA public key for the BTC address",
        "@param6": "claimFlags Claim flags specifying address and message formats",
        "@param7": "v v parameter of ECDSA signature",
        "@param8": "r r parameter of ECDSA signature",
        "@param9": "s s parameter of ECDSA signature",
        "@param10": "autoStakeDays Number of days to auto-stake, subject to minimum auto-stake days",
        "@param11": "referrerAddr Eth address of referring user (optional; 0x0 for no referrer)",
        "@return1": "Total number of Hearts credited, if successful",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "xfLobbyEnter",
        "visibility": "external",
        "args": [
            {
                "name": "referrerAddr",
                "type": "address"
            }
        ],
        "func": "function xfLobbyEnter(address referrerAddr)\n external\n payable\n {\n uint256 enterDay = _currentDay();\n require(enterDay < CLAIM_PHASE_END_DAY, \"HEX: Lobbies have ended\");\n\n uint256 rawAmount = msg.value;\n require(rawAmount != 0, \"HEX: Amount required\");\n\n XfLobbyQueueStore storage qRef = xfLobbyMembers[enterDay][msg.sender];\n\n uint256 entryIndex = qRef.tailIndex++;\n\n qRef.entries[entryIndex] = XfLobbyEntryStore(uint96(rawAmount), referrerAddr);\n\n xfLobby[enterDay] += rawAmount;\n\n _emitXfLobbyEnter(enterDay, entryIndex, rawAmount, referrerAddr);\n }",
        "comments": [
            "/**",
            " * @dev PUBLIC FACING: Enter the tranform lobby for the current round",
            " * @param referrerAddr Eth address of referring user (optional; 0x0 for no referrer)",
            " */",
            ""
        ],
        "comt": "/**\n * @dev PUBLIC FACING: Enter the tranform lobby for the current round\n * @param referrerAddr Eth address of referring user (optional; 0x0 for no referrer)\n */\n",
        "@dev": "PUBLIC FACING: Enter the tranform lobby for the current round",
        "@param1": "referrerAddr Eth address of referring user (optional; 0x0 for no referrer)",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "xfLobbyExit",
        "visibility": "external",
        "args": [
            {
                "name": "enterDay",
                "type": "uint256"
            },
            {
                "name": "count",
                "type": "uint256"
            }
        ],
        "func": "function xfLobbyExit(uint256 enterDay, uint256 count)\n external\n {\n require(enterDay < _currentDay(), \"HEX: Round is not complete\");\n\n XfLobbyQueueStore storage qRef = xfLobbyMembers[enterDay][msg.sender];\n\n uint256 headIndex = qRef.headIndex;\n uint256 endIndex;\n\n if (count != 0) {\n require(count <= qRef.tailIndex - headIndex, \"HEX: count invalid\");\n endIndex = headIndex + count;\n } else {\n endIndex = qRef.tailIndex;\n require(headIndex < endIndex, \"HEX: count invalid\");\n }\n\n uint256 waasLobby = _waasLobby(enterDay);\n uint256 _xfLobby = xfLobby[enterDay];\n uint256 totalXfAmount = 0;\n uint256 originBonusHearts = 0;\n\n do {\n uint256 rawAmount = qRef.entries[headIndex].rawAmount;\n address referrerAddr = qRef.entries[headIndex].referrerAddr;\n\n delete qRef.entries[headIndex];\n\n uint256 xfAmount = waasLobby * rawAmount / _xfLobby;\n\n if (referrerAddr == address(0)) {\n /* No referrer */\n _emitXfLobbyExit(enterDay, headIndex, xfAmount, referrerAddr);\n } else {\n /* Referral bonus of 10% of xfAmount to member */\n uint256 referralBonusHearts = xfAmount / 10;\n\n xfAmount += referralBonusHearts;\n\n /* Then a cumulative referrer bonus of 20% to referrer */\n uint256 referrerBonusHearts = xfAmount / 5;\n\n if (referrerAddr == msg.sender) {\n /* Self-referred */\n xfAmount += referrerBonusHearts;\n _emitXfLobbyExit(enterDay, headIndex, xfAmount, referrerAddr);\n } else {\n /* Referred by different address */\n _emitXfLobbyExit(enterDay, headIndex, xfAmount, referrerAddr);\n _mint(referrerAddr, referrerBonusHearts);\n }\n originBonusHearts += referralBonusHearts + referrerBonusHearts;\n }\n\n totalXfAmount += xfAmount;\n } while (++headIndex < endIndex);\n\n qRef.headIndex = uint40(headIndex);\n\n if (originBonusHearts != 0) {\n _mint(ORIGIN_ADDR, originBonusHearts);\n }\n if (totalXfAmount != 0) {\n _mint(msg.sender, totalXfAmount);\n }\n }",
        "comments": [
            "/**",
            " * @dev PUBLIC FACING: Leave the transform lobby after the round is complete",
            " * @param enterDay Day number when the member entered",
            " * @param count Number of queued-enters to exit (optional; 0 for all)",
            " */",
            ""
        ],
        "comt": "/**\n * @dev PUBLIC FACING: Leave the transform lobby after the round is complete\n * @param enterDay Day number when the member entered\n * @param count Number of queued-enters to exit (optional; 0 for all)\n */\n",
        "@dev": "PUBLIC FACING: Leave the transform lobby after the round is complete",
        "@param1": "enterDay Day number when the member entered",
        "@param2": "count Number of queued-enters to exit (optional; 0 for all)",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "xfLobbyFlush",
        "visibility": "external",
        "args": [],
        "func": "function xfLobbyFlush()\n external\n {\n require(address(this).balance != 0, \"HEX: No value\");\n\n FLUSH_ADDR.transfer(address(this).balance);\n }",
        "comments": [
            "/**",
            " * @dev PUBLIC FACING: Release any value that has been sent to the contract",
            " */",
            ""
        ],
        "comt": "/**\n * @dev PUBLIC FACING: Release any value that has been sent to the contract\n */\n",
        "@dev": "PUBLIC FACING: Release any value that has been sent to the contract",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "xfLobbyRange",
        "visibility": "external",
        "args": [
            {
                "name": "beginDay",
                "type": "uint256"
            },
            {
                "name": "endDay",
                "type": "uint256"
            }
        ],
        "func": "function xfLobbyRange(uint256 beginDay, uint256 endDay)\n external\n view\n returns (uint256[] memory list)\n {\n require(\n beginDay < endDay && endDay <= CLAIM_PHASE_END_DAY && endDay <= _currentDay(),\n \"HEX: invalid range\"\n );\n\n list = new uint256[](endDay - beginDay);\n\n uint256 src = beginDay;\n uint256 dst = 0;\n do {\n list[dst++] = uint256(xfLobby[src++]);\n } while (src < endDay);\n\n return list;\n }",
        "comments": [
            "/**",
            " * @dev PUBLIC FACING: External helper to return multiple values of xfLobby[] with",
            " * a single call",
            " * @param beginDay First day of data range",
            " * @param endDay Last day (non-inclusive) of data range",
            " * @return Fixed array of values",
            " */",
            ""
        ],
        "comt": "/**\n * @dev PUBLIC FACING: External helper to return multiple values of xfLobby[] with\n * a single call\n * @param beginDay First day of data range\n * @param endDay Last day (non-inclusive) of data range\n * @return Fixed array of values\n */\n",
        "@dev": "PUBLIC FACING: External helper to return multiple values of xfLobby[] with * a single call",
        "@param1": "beginDay First day of data range",
        "@param2": "endDay Last day (non-inclusive) of data range",
        "@return1": "Fixed array of values",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "xfLobbyEntry",
        "visibility": "external",
        "args": [
            {
                "name": "memberAddr",
                "type": "address"
            },
            {
                "name": "entryId",
                "type": "uint256"
            }
        ],
        "func": "function xfLobbyEntry(address memberAddr, uint256 entryId)\n external\n view\n returns (uint256 rawAmount, address referrerAddr)\n {\n uint256 enterDay = entryId >> XF_LOBBY_ENTRY_INDEX_SIZE;\n uint256 entryIndex = entryId & XF_LOBBY_ENTRY_INDEX_MASK;\n\n XfLobbyEntryStore storage entry = xfLobbyMembers[enterDay][memberAddr].entries[entryIndex];\n\n require(entry.rawAmount != 0, \"HEX: Param invalid\");\n\n return (entry.rawAmount, entry.referrerAddr);\n }",
        "comments": [
            "/**",
            " * @dev PUBLIC FACING: Return a current lobby member queue entry.",
            " * Only needed due to limitations of the standard ABI encoder.",
            " * @param memberAddr Eth address of the lobby member",
            " * @param entryId 49 bit compound value. Top 9 bits: enterDay, Bottom 40 bits: entryIndex",
            " * @return 1: Raw amount that was entered with; 2: Referring Eth addr (optional; 0x0 for no referrer)",
            " */",
            ""
        ],
        "comt": "/**\n * @dev PUBLIC FACING: Return a current lobby member queue entry.\n * Only needed due to limitations of the standard ABI encoder.\n * @param memberAddr Eth address of the lobby member\n * @param entryId 49 bit compound value. Top 9 bits: enterDay, Bottom 40 bits: entryIndex\n * @return 1: Raw amount that was entered with; 2: Referring Eth addr (optional; 0x0 for no referrer)\n */\n",
        "@dev": "PUBLIC FACING: Return a current lobby member queue entry. * Only needed due to limitations of the standard ABI encoder.",
        "@param1": "memberAddr Eth address of the lobby member",
        "@param2": "entryId 49 bit compound value. Top 9 bits: enterDay, Bottom 40 bits: entryIndex",
        "@return1": "1: Raw amount that was entered with; 2: Referring Eth addr (optional; 0x0 for no referrer)",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 1,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    },
    {
        "name": "xfLobbyPendingDays",
        "visibility": "external",
        "args": [
            {
                "name": "memberAddr",
                "type": "address"
            }
        ],
        "func": "function xfLobbyPendingDays(address memberAddr)\n external\n view\n returns (uint256[XF_LOBBY_DAY_WORDS] memory words)\n {\n uint256 day = _currentDay() + 1;\n\n if (day > CLAIM_PHASE_END_DAY) {\n day = CLAIM_PHASE_END_DAY;\n }\n\n while (day-- != 0) {\n if (xfLobbyMembers[day][memberAddr].tailIndex > xfLobbyMembers[day][memberAddr].headIndex) {\n words[day >> 8] |= 1 << (day & 255);\n }\n }\n\n return words;\n }",
        "comments": [
            "/**",
            " * @dev PUBLIC FACING: Return the lobby days that a user is in with a single call",
            " * @param memberAddr Eth address of the user",
            " * @return Bit vector of lobby day numbers",
            " */",
            ""
        ],
        "comt": "/**\n * @dev PUBLIC FACING: Return the lobby days that a user is in with a single call\n * @param memberAddr Eth address of the user\n * @return Bit vector of lobby day numbers\n */\n",
        "@dev": "PUBLIC FACING: Return the lobby days that a user is in with a single call",
        "@param1": "memberAddr Eth address of the user",
        "@return1": "Bit vector of lobby day numbers",
        "notice_missing": 1,
        "param_missing": 0,
        "return_missing": 0,
        "no_comment": 0,
        "inconsistent_dxn": 1,
        "inconsistent_others": 0,
        "low_quality": 0
    }
]